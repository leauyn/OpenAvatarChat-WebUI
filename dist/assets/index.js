var yI = Object.defineProperty
var b2 = (n) => {
  throw TypeError(n)
}
var vI = (n, e, t) =>
  e in n ? yI(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (n[e] = t)
var xe = (n, e, t) => vI(n, typeof e != 'symbol' ? e + '' : e, t),
  Q0 = (n, e, t) => e.has(n) || b2('Cannot ' + t)
var dt = (n, e, t) => (Q0(n, e, 'read from private field'), t ? t.call(n) : e.get(n)),
  oi = (n, e, t) =>
    e.has(n)
      ? b2('Cannot add the same private member more than once')
      : e instanceof WeakSet
        ? e.add(n)
        : e.set(n, t),
  En = (n, e, t, i) => (Q0(n, e, 'write to private field'), i ? i.call(n, t) : e.set(n, t), t),
  hi = (n, e, t) => (Q0(n, e, 'access private method'), t)
var Yu = (n, e, t, i) => ({
  set _(r) {
    En(n, e, r, t)
  },
  get _() {
    return dt(n, e, i)
  },
})
function mre() {
  ;(import.meta.url, import('_').catch(() => 1), (async function* () {})().next())
}
;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r)
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && i(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function t(r) {
    const s = {}
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : r.crossOrigin === 'anonymous'
          ? (s.credentials = 'omit')
          : (s.credentials = 'same-origin'),
      s
    )
  }
  function i(r) {
    if (r.ep) return
    r.ep = !0
    const s = t(r)
    fetch(r.href, s)
  }
})()
/**
 * @vue/shared v3.5.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Gv(n) {
  const e = Object.create(null)
  for (const t of n.split(',')) e[t] = 1
  return (t) => t in e
}
const un = {},
  Vc = [],
  qs = () => {},
  OT = () => !1,
  Qm = (n) =>
    n.charCodeAt(0) === 111 &&
    n.charCodeAt(1) === 110 &&
    (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97),
  Wv = (n) => n.startsWith('onUpdate:'),
  ti = Object.assign,
  Qv = (n, e) => {
    const t = n.indexOf(e)
    t > -1 && n.splice(t, 1)
  },
  _I = Object.prototype.hasOwnProperty,
  tn = (n, e) => _I.call(n, e),
  vt = Array.isArray,
  Hc = (n) => jm(n) === '[object Map]',
  BT = (n) => jm(n) === '[object Set]',
  wt = (n) => typeof n == 'function',
  wn = (n) => typeof n == 'string',
  za = (n) => typeof n == 'symbol',
  gn = (n) => n !== null && typeof n == 'object',
  UT = (n) => (gn(n) || wt(n)) && wt(n.then) && wt(n.catch),
  kT = Object.prototype.toString,
  jm = (n) => kT.call(n),
  xI = (n) => jm(n).slice(8, -1),
  zT = (n) => jm(n) === '[object Object]',
  jv = (n) => wn(n) && n !== 'NaN' && n[0] !== '-' && '' + parseInt(n, 10) === n,
  Md = Gv(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  qm = (n) => {
    const e = Object.create(null)
    return (t) => e[t] || (e[t] = n(t))
  },
  SI = /-\w/g,
  ns = qm((n) => n.replace(SI, (e) => e.slice(1).toUpperCase())),
  AI = /\B([A-Z])/g,
  Ql = qm((n) => n.replace(AI, '-$1').toLowerCase()),
  Xm = qm((n) => n.charAt(0).toUpperCase() + n.slice(1)),
  j0 = qm((n) => (n ? 'on'.concat(Xm(n)) : '')),
  Pa = (n, e) => !Object.is(n, e),
  q0 = (n, ...e) => {
    for (let t = 0; t < n.length; t++) n[t](...e)
  },
  VT = (n, e, t, i = !1) => {
    Object.defineProperty(n, e, { configurable: !0, enumerable: !1, writable: i, value: t })
  },
  bI = (n) => {
    const e = parseFloat(n)
    return isNaN(e) ? n : e
  },
  TI = (n) => {
    const e = wn(n) ? Number(n) : NaN
    return isNaN(e) ? n : e
  }
let T2
const Km = () =>
  T2 ||
  (T2 =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : {})
function Go(n) {
  if (vt(n)) {
    const e = {}
    for (let t = 0; t < n.length; t++) {
      const i = n[t],
        r = wn(i) ? MI(i) : Go(i)
      if (r) for (const s in r) e[s] = r[s]
    }
    return e
  } else if (wn(n) || gn(n)) return n
}
const wI = /;(?![^(]*\))/g,
  CI = /:([^]+)/,
  EI = /\/\*[^]*?\*\//g
function MI(n) {
  const e = {}
  return (
    n
      .replace(EI, '')
      .split(wI)
      .forEach((t) => {
        if (t) {
          const i = t.split(CI)
          i.length > 1 && (e[i[0].trim()] = i[1].trim())
        }
      }),
    e
  )
}
function Wo(n) {
  let e = ''
  if (wn(n)) e = n
  else if (vt(n))
    for (let t = 0; t < n.length; t++) {
      const i = Wo(n[t])
      i && (e += i + ' ')
    }
  else if (gn(n)) for (const t in n) n[t] && (e += t + ' ')
  return e.trim()
}
const RI = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  II = Gv(RI)
function HT(n) {
  return !!n || n === ''
}
const $T = (n) => !!(n && n.__v_isRef === !0),
  su = (n) =>
    wn(n)
      ? n
      : n == null
        ? ''
        : vt(n) || (gn(n) && (n.toString === kT || !wt(n.toString)))
          ? $T(n)
            ? su(n.value)
            : JSON.stringify(n, GT, 2)
          : String(n),
  GT = (n, e) =>
    $T(e)
      ? GT(n, e.value)
      : Hc(e)
        ? {
            ['Map('.concat(e.size, ')')]: [...e.entries()].reduce(
              (t, [i, r], s) => ((t[X0(i, s) + ' =>'] = r), t),
              {}
            ),
          }
        : BT(e)
          ? { ['Set('.concat(e.size, ')')]: [...e.values()].map((t) => X0(t)) }
          : za(e)
            ? X0(e)
            : gn(e) && !vt(e) && !zT(e)
              ? String(e)
              : e,
  X0 = (n, e = '') => {
    var t
    return za(n) ? 'Symbol('.concat((t = n.description) != null ? t : e, ')') : n
  }
/**
 * @vue/reactivity v3.5.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let Ri
class WT {
  constructor(e = !1) {
    ;((this.detached = e),
      (this._active = !0),
      (this._on = 0),
      (this.effects = []),
      (this.cleanups = []),
      (this._isPaused = !1),
      (this.parent = Ri),
      !e && Ri && (this.index = (Ri.scopes || (Ri.scopes = [])).push(this) - 1))
  }
  get active() {
    return this._active
  }
  pause() {
    if (this._active) {
      this._isPaused = !0
      let e, t
      if (this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause()
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause()
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1
      let e, t
      if (this.scopes) for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume()
      for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume()
    }
  }
  run(e) {
    if (this._active) {
      const t = Ri
      try {
        return ((Ri = this), e())
      } finally {
        Ri = t
      }
    }
  }
  on() {
    ++this._on === 1 && ((this.prevScope = Ri), (Ri = this))
  }
  off() {
    this._on > 0 && --this._on === 0 && ((Ri = this.prevScope), (this.prevScope = void 0))
  }
  stop(e) {
    if (this._active) {
      this._active = !1
      let t, i
      for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop()
      for (this.effects.length = 0, t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]()
      if (((this.cleanups.length = 0), this.scopes)) {
        for (t = 0, i = this.scopes.length; t < i; t++) this.scopes[t].stop(!0)
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !e) {
        const r = this.parent.scopes.pop()
        r && r !== this && ((this.parent.scopes[this.index] = r), (r.index = this.index))
      }
      this.parent = void 0
    }
  }
}
function qv(n) {
  return new WT(n)
}
function QT() {
  return Ri
}
function NI(n, e = !1) {
  Ri && Ri.cleanups.push(n)
}
let fn
const K0 = new WeakSet()
class jT {
  constructor(e) {
    ;((this.fn = e),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 5),
      (this.next = void 0),
      (this.cleanup = void 0),
      (this.scheduler = void 0),
      Ri && Ri.active && Ri.effects.push(this))
  }
  pause() {
    this.flags |= 64
  }
  resume() {
    this.flags & 64 && ((this.flags &= -65), K0.has(this) && (K0.delete(this), this.trigger()))
  }
  notify() {
    ;(this.flags & 2 && !(this.flags & 32)) || this.flags & 8 || XT(this)
  }
  run() {
    if (!(this.flags & 1)) return this.fn()
    ;((this.flags |= 2), w2(this), KT(this))
    const e = fn,
      t = vs
    ;((fn = this), (vs = !0))
    try {
      return this.fn()
    } finally {
      ;(YT(this), (fn = e), (vs = t), (this.flags &= -3))
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep) Yv(e)
      ;((this.deps = this.depsTail = void 0),
        w2(this),
        this.onStop && this.onStop(),
        (this.flags &= -2))
    }
  }
  trigger() {
    this.flags & 64 ? K0.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }
  runIfDirty() {
    z1(this) && this.run()
  }
  get dirty() {
    return z1(this)
  }
}
let qT = 0,
  Rd,
  Id
function XT(n, e = !1) {
  if (((n.flags |= 8), e)) {
    ;((n.next = Id), (Id = n))
    return
  }
  ;((n.next = Rd), (Rd = n))
}
function Xv() {
  qT++
}
function Kv() {
  if (--qT > 0) return
  if (Id) {
    let e = Id
    for (Id = void 0; e; ) {
      const t = e.next
      ;((e.next = void 0), (e.flags &= -9), (e = t))
    }
  }
  let n
  for (; Rd; ) {
    let e = Rd
    for (Rd = void 0; e; ) {
      const t = e.next
      if (((e.next = void 0), (e.flags &= -9), e.flags & 1))
        try {
          e.trigger()
        } catch (i) {
          n || (n = i)
        }
      e = t
    }
  }
  if (n) throw n
}
function KT(n) {
  for (let e = n.deps; e; e = e.nextDep)
    ((e.version = -1), (e.prevActiveLink = e.dep.activeLink), (e.dep.activeLink = e))
}
function YT(n) {
  let e,
    t = n.depsTail,
    i = t
  for (; i; ) {
    const r = i.prevDep
    ;(i.version === -1 ? (i === t && (t = r), Yv(i), PI(i)) : (e = i),
      (i.dep.activeLink = i.prevActiveLink),
      (i.prevActiveLink = void 0),
      (i = r))
  }
  ;((n.deps = e), (n.depsTail = t))
}
function z1(n) {
  for (let e = n.deps; e; e = e.nextDep)
    if (
      e.dep.version !== e.version ||
      (e.dep.computed && (ZT(e.dep.computed) || e.dep.version !== e.version))
    )
      return !0
  return !!n._dirty
}
function ZT(n) {
  if (
    (n.flags & 4 && !(n.flags & 16)) ||
    ((n.flags &= -17), n.globalVersion === Yd) ||
    ((n.globalVersion = Yd), !n.isSSR && n.flags & 128 && ((!n.deps && !n._dirty) || !z1(n)))
  )
    return
  n.flags |= 2
  const e = n.dep,
    t = fn,
    i = vs
  ;((fn = n), (vs = !0))
  try {
    KT(n)
    const r = n.fn(n._value)
    ;(e.version === 0 || Pa(r, n._value)) && ((n.flags |= 128), (n._value = r), e.version++)
  } catch (r) {
    throw (e.version++, r)
  } finally {
    ;((fn = t), (vs = i), YT(n), (n.flags &= -3))
  }
}
function Yv(n, e = !1) {
  const { dep: t, prevSub: i, nextSub: r } = n
  if (
    (i && ((i.nextSub = r), (n.prevSub = void 0)),
    r && ((r.prevSub = i), (n.nextSub = void 0)),
    t.subs === n && ((t.subs = i), !i && t.computed))
  ) {
    t.computed.flags &= -5
    for (let s = t.computed.deps; s; s = s.nextDep) Yv(s, !0)
  }
  !e && !--t.sc && t.map && t.map.delete(t.key)
}
function PI(n) {
  const { prevDep: e, nextDep: t } = n
  ;(e && ((e.nextDep = t), (n.prevDep = void 0)), t && ((t.prevDep = e), (n.nextDep = void 0)))
}
let vs = !0
const JT = []
function Qo() {
  ;(JT.push(vs), (vs = !1))
}
function jo() {
  const n = JT.pop()
  vs = n === void 0 ? !0 : n
}
function w2(n) {
  const { cleanup: e } = n
  if (((n.cleanup = void 0), e)) {
    const t = fn
    fn = void 0
    try {
      e()
    } finally {
      fn = t
    }
  }
}
let Yd = 0
class LI {
  constructor(e, t) {
    ;((this.sub = e),
      (this.dep = t),
      (this.version = t.version),
      (this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0))
  }
}
class Zv {
  constructor(e) {
    ;((this.computed = e),
      (this.version = 0),
      (this.activeLink = void 0),
      (this.subs = void 0),
      (this.map = void 0),
      (this.key = void 0),
      (this.sc = 0),
      (this.__v_skip = !0))
  }
  track(e) {
    if (!fn || !vs || fn === this.computed) return
    let t = this.activeLink
    if (t === void 0 || t.sub !== fn)
      ((t = this.activeLink = new LI(fn, this)),
        fn.deps
          ? ((t.prevDep = fn.depsTail), (fn.depsTail.nextDep = t), (fn.depsTail = t))
          : (fn.deps = fn.depsTail = t),
        ew(t))
    else if (t.version === -1 && ((t.version = this.version), t.nextDep)) {
      const i = t.nextDep
      ;((i.prevDep = t.prevDep),
        t.prevDep && (t.prevDep.nextDep = i),
        (t.prevDep = fn.depsTail),
        (t.nextDep = void 0),
        (fn.depsTail.nextDep = t),
        (fn.depsTail = t),
        fn.deps === t && (fn.deps = i))
    }
    return t
  }
  trigger(e) {
    ;(this.version++, Yd++, this.notify(e))
  }
  notify(e) {
    Xv()
    try {
      for (let t = this.subs; t; t = t.prevSub) t.sub.notify() && t.sub.dep.notify()
    } finally {
      Kv()
    }
  }
}
function ew(n) {
  if ((n.dep.sc++, n.sub.flags & 4)) {
    const e = n.dep.computed
    if (e && !n.dep.subs) {
      e.flags |= 20
      for (let i = e.deps; i; i = i.nextDep) ew(i)
    }
    const t = n.dep.subs
    ;(t !== n && ((n.prevSub = t), t && (t.nextSub = n)), (n.dep.subs = n))
  }
}
const Yp = new WeakMap(),
  Rl = Symbol(''),
  V1 = Symbol(''),
  Zd = Symbol('')
function Pi(n, e, t) {
  if (vs && fn) {
    let i = Yp.get(n)
    i || Yp.set(n, (i = new Map()))
    let r = i.get(t)
    ;(r || (i.set(t, (r = new Zv())), (r.map = i), (r.key = t)), r.track())
  }
}
function Po(n, e, t, i, r, s) {
  const o = Yp.get(n)
  if (!o) {
    Yd++
    return
  }
  const a = (l) => {
    l && l.trigger()
  }
  if ((Xv(), e === 'clear')) o.forEach(a)
  else {
    const l = vt(n),
      c = l && jv(t)
    if (l && t === 'length') {
      const u = Number(i)
      o.forEach((d, h) => {
        ;(h === 'length' || h === Zd || (!za(h) && h >= u)) && a(d)
      })
    } else
      switch (((t !== void 0 || o.has(void 0)) && a(o.get(t)), c && a(o.get(Zd)), e)) {
        case 'add':
          l ? c && a(o.get('length')) : (a(o.get(Rl)), Hc(n) && a(o.get(V1)))
          break
        case 'delete':
          l || (a(o.get(Rl)), Hc(n) && a(o.get(V1)))
          break
        case 'set':
          Hc(n) && a(o.get(Rl))
          break
      }
  }
  Kv()
}
function DI(n, e) {
  const t = Yp.get(n)
  return t && t.get(e)
}
function Zl(n) {
  const e = Ot(n)
  return e === n ? e : (Pi(e, 'iterate', Zd), Zr(n) ? e : e.map(mi))
}
function Ym(n) {
  return (Pi((n = Ot(n)), 'iterate', Zd), n)
}
const FI = {
  __proto__: null,
  [Symbol.iterator]() {
    return Y0(this, Symbol.iterator, mi)
  },
  concat(...n) {
    return Zl(this).concat(...n.map((e) => (vt(e) ? Zl(e) : e)))
  },
  entries() {
    return Y0(this, 'entries', (n) => ((n[1] = mi(n[1])), n))
  },
  every(n, e) {
    return fo(this, 'every', n, e, void 0, arguments)
  },
  filter(n, e) {
    return fo(this, 'filter', n, e, (t) => t.map(mi), arguments)
  },
  find(n, e) {
    return fo(this, 'find', n, e, mi, arguments)
  },
  findIndex(n, e) {
    return fo(this, 'findIndex', n, e, void 0, arguments)
  },
  findLast(n, e) {
    return fo(this, 'findLast', n, e, mi, arguments)
  },
  findLastIndex(n, e) {
    return fo(this, 'findLastIndex', n, e, void 0, arguments)
  },
  forEach(n, e) {
    return fo(this, 'forEach', n, e, void 0, arguments)
  },
  includes(...n) {
    return Z0(this, 'includes', n)
  },
  indexOf(...n) {
    return Z0(this, 'indexOf', n)
  },
  join(n) {
    return Zl(this).join(n)
  },
  lastIndexOf(...n) {
    return Z0(this, 'lastIndexOf', n)
  },
  map(n, e) {
    return fo(this, 'map', n, e, void 0, arguments)
  },
  pop() {
    return Zu(this, 'pop')
  },
  push(...n) {
    return Zu(this, 'push', n)
  },
  reduce(n, ...e) {
    return C2(this, 'reduce', n, e)
  },
  reduceRight(n, ...e) {
    return C2(this, 'reduceRight', n, e)
  },
  shift() {
    return Zu(this, 'shift')
  },
  some(n, e) {
    return fo(this, 'some', n, e, void 0, arguments)
  },
  splice(...n) {
    return Zu(this, 'splice', n)
  },
  toReversed() {
    return Zl(this).toReversed()
  },
  toSorted(n) {
    return Zl(this).toSorted(n)
  },
  toSpliced(...n) {
    return Zl(this).toSpliced(...n)
  },
  unshift(...n) {
    return Zu(this, 'unshift', n)
  },
  values() {
    return Y0(this, 'values', mi)
  },
}
function Y0(n, e, t) {
  const i = Ym(n),
    r = i[e]()
  return (
    i !== n &&
      !Zr(n) &&
      ((r._next = r.next),
      (r.next = () => {
        const s = r._next()
        return (s.value && (s.value = t(s.value)), s)
      })),
    r
  )
}
const OI = Array.prototype
function fo(n, e, t, i, r, s) {
  const o = Ym(n),
    a = o !== n && !Zr(n),
    l = o[e]
  if (l !== OI[e]) {
    const d = l.apply(n, s)
    return a ? mi(d) : d
  }
  let c = t
  o !== n &&
    (a
      ? (c = function (d, h) {
          return t.call(this, mi(d), h, n)
        })
      : t.length > 2 &&
        (c = function (d, h) {
          return t.call(this, d, h, n)
        }))
  const u = l.call(o, c, i)
  return a && r ? r(u) : u
}
function C2(n, e, t, i) {
  const r = Ym(n)
  let s = t
  return (
    r !== n &&
      (Zr(n)
        ? t.length > 3 &&
          (s = function (o, a, l) {
            return t.call(this, o, a, l, n)
          })
        : (s = function (o, a, l) {
            return t.call(this, o, mi(a), l, n)
          })),
    r[e](s, ...i)
  )
}
function Z0(n, e, t) {
  const i = Ot(n)
  Pi(i, 'iterate', Zd)
  const r = i[e](...t)
  return (r === -1 || r === !1) && t_(t[0]) ? ((t[0] = Ot(t[0])), i[e](...t)) : r
}
function Zu(n, e, t = []) {
  ;(Qo(), Xv())
  const i = Ot(n)[e].apply(n, t)
  return (Kv(), jo(), i)
}
const BI = Gv('__proto__,__v_isRef,__isVue'),
  tw = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((n) => n !== 'arguments' && n !== 'caller')
      .map((n) => Symbol[n])
      .filter(za)
  )
function UI(n) {
  za(n) || (n = String(n))
  const e = Ot(this)
  return (Pi(e, 'has', n), e.hasOwnProperty(n))
}
class nw {
  constructor(e = !1, t = !1) {
    ;((this._isReadonly = e), (this._isShallow = t))
  }
  get(e, t, i) {
    if (t === '__v_skip') return e.__v_skip
    const r = this._isReadonly,
      s = this._isShallow
    if (t === '__v_isReactive') return !r
    if (t === '__v_isReadonly') return r
    if (t === '__v_isShallow') return s
    if (t === '__v_raw')
      return i === (r ? (s ? qI : ow) : s ? sw : rw).get(e) ||
        Object.getPrototypeOf(e) === Object.getPrototypeOf(i)
        ? e
        : void 0
    const o = vt(e)
    if (!r) {
      let l
      if (o && (l = FI[t])) return l
      if (t === 'hasOwnProperty') return UI
    }
    const a = Reflect.get(e, t, bn(e) ? e : i)
    return (za(t) ? tw.has(t) : BI(t)) || (r || Pi(e, 'get', t), s)
      ? a
      : bn(a)
        ? o && jv(t)
          ? a
          : a.value
        : gn(a)
          ? r
            ? aw(a)
            : Zs(a)
          : a
  }
}
class iw extends nw {
  constructor(e = !1) {
    super(!1, e)
  }
  set(e, t, i, r) {
    let s = e[t]
    if (!this._isShallow) {
      const l = Oa(s)
      if ((!Zr(i) && !Oa(i) && ((s = Ot(s)), (i = Ot(i))), !vt(e) && bn(s) && !bn(i)))
        return (l || (s.value = i), !0)
    }
    const o = vt(e) && jv(t) ? Number(t) < e.length : tn(e, t),
      a = Reflect.set(e, t, i, bn(e) ? e : r)
    return (e === Ot(r) && (o ? Pa(i, s) && Po(e, 'set', t, i) : Po(e, 'add', t, i)), a)
  }
  deleteProperty(e, t) {
    const i = tn(e, t)
    e[t]
    const r = Reflect.deleteProperty(e, t)
    return (r && i && Po(e, 'delete', t, void 0), r)
  }
  has(e, t) {
    const i = Reflect.has(e, t)
    return ((!za(t) || !tw.has(t)) && Pi(e, 'has', t), i)
  }
  ownKeys(e) {
    return (Pi(e, 'iterate', vt(e) ? 'length' : Rl), Reflect.ownKeys(e))
  }
}
class kI extends nw {
  constructor(e = !1) {
    super(!0, e)
  }
  set(e, t) {
    return !0
  }
  deleteProperty(e, t) {
    return !0
  }
}
const zI = new iw(),
  VI = new kI(),
  HI = new iw(!0)
const H1 = (n) => n,
  ff = (n) => Reflect.getPrototypeOf(n)
function $I(n, e, t) {
  return function (...i) {
    const r = this.__v_raw,
      s = Ot(r),
      o = Hc(s),
      a = n === 'entries' || (n === Symbol.iterator && o),
      l = n === 'keys' && o,
      c = r[n](...i),
      u = t ? H1 : e ? Zp : mi
    return (
      !e && Pi(s, 'iterate', l ? V1 : Rl),
      {
        next() {
          const { value: d, done: h } = c.next()
          return h ? { value: d, done: h } : { value: a ? [u(d[0]), u(d[1])] : u(d), done: h }
        },
        [Symbol.iterator]() {
          return this
        },
      }
    )
  }
}
function pf(n) {
  return function (...e) {
    return n === 'delete' ? !1 : n === 'clear' ? void 0 : this
  }
}
function GI(n, e) {
  const t = {
    get(r) {
      const s = this.__v_raw,
        o = Ot(s),
        a = Ot(r)
      n || (Pa(r, a) && Pi(o, 'get', r), Pi(o, 'get', a))
      const { has: l } = ff(o),
        c = e ? H1 : n ? Zp : mi
      if (l.call(o, r)) return c(s.get(r))
      if (l.call(o, a)) return c(s.get(a))
      s !== o && s.get(r)
    },
    get size() {
      const r = this.__v_raw
      return (!n && Pi(Ot(r), 'iterate', Rl), r.size)
    },
    has(r) {
      const s = this.__v_raw,
        o = Ot(s),
        a = Ot(r)
      return (
        n || (Pa(r, a) && Pi(o, 'has', r), Pi(o, 'has', a)),
        r === a ? s.has(r) : s.has(r) || s.has(a)
      )
    },
    forEach(r, s) {
      const o = this,
        a = o.__v_raw,
        l = Ot(a),
        c = e ? H1 : n ? Zp : mi
      return (!n && Pi(l, 'iterate', Rl), a.forEach((u, d) => r.call(s, c(u), c(d), o)))
    },
  }
  return (
    ti(
      t,
      n
        ? { add: pf('add'), set: pf('set'), delete: pf('delete'), clear: pf('clear') }
        : {
            add(r) {
              !e && !Zr(r) && !Oa(r) && (r = Ot(r))
              const s = Ot(this)
              return (ff(s).has.call(s, r) || (s.add(r), Po(s, 'add', r, r)), this)
            },
            set(r, s) {
              !e && !Zr(s) && !Oa(s) && (s = Ot(s))
              const o = Ot(this),
                { has: a, get: l } = ff(o)
              let c = a.call(o, r)
              c || ((r = Ot(r)), (c = a.call(o, r)))
              const u = l.call(o, r)
              return (o.set(r, s), c ? Pa(s, u) && Po(o, 'set', r, s) : Po(o, 'add', r, s), this)
            },
            delete(r) {
              const s = Ot(this),
                { has: o, get: a } = ff(s)
              let l = o.call(s, r)
              ;(l || ((r = Ot(r)), (l = o.call(s, r))), a && a.call(s, r))
              const c = s.delete(r)
              return (l && Po(s, 'delete', r, void 0), c)
            },
            clear() {
              const r = Ot(this),
                s = r.size !== 0,
                o = r.clear()
              return (s && Po(r, 'clear', void 0, void 0), o)
            },
          }
    ),
    ['keys', 'values', 'entries', Symbol.iterator].forEach((r) => {
      t[r] = $I(r, n, e)
    }),
    t
  )
}
function Jv(n, e) {
  const t = GI(n, e)
  return (i, r, s) =>
    r === '__v_isReactive'
      ? !n
      : r === '__v_isReadonly'
        ? n
        : r === '__v_raw'
          ? i
          : Reflect.get(tn(t, r) && r in i ? t : i, r, s)
}
const WI = { get: Jv(!1, !1) },
  QI = { get: Jv(!1, !0) },
  jI = { get: Jv(!0, !1) }
const rw = new WeakMap(),
  sw = new WeakMap(),
  ow = new WeakMap(),
  qI = new WeakMap()
function XI(n) {
  switch (n) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function KI(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : XI(xI(n))
}
function Zs(n) {
  return Oa(n) ? n : e_(n, !1, zI, WI, rw)
}
function YI(n) {
  return e_(n, !1, HI, QI, sw)
}
function aw(n) {
  return e_(n, !0, VI, jI, ow)
}
function e_(n, e, t, i, r) {
  if (!gn(n) || (n.__v_raw && !(e && n.__v_isReactive))) return n
  const s = KI(n)
  if (s === 0) return n
  const o = r.get(n)
  if (o) return o
  const a = new Proxy(n, s === 2 ? i : t)
  return (r.set(n, a), a)
}
function ko(n) {
  return Oa(n) ? ko(n.__v_raw) : !!(n && n.__v_isReactive)
}
function Oa(n) {
  return !!(n && n.__v_isReadonly)
}
function Zr(n) {
  return !!(n && n.__v_isShallow)
}
function t_(n) {
  return n ? !!n.__v_raw : !1
}
function Ot(n) {
  const e = n && n.__v_raw
  return e ? Ot(e) : n
}
function n_(n) {
  return (!tn(n, '__v_skip') && Object.isExtensible(n) && VT(n, '__v_skip', !0), n)
}
const mi = (n) => (gn(n) ? Zs(n) : n),
  Zp = (n) => (gn(n) ? aw(n) : n)
function bn(n) {
  return n ? n.__v_isRef === !0 : !1
}
function Dn(n) {
  return lw(n, !1)
}
function ar(n) {
  return lw(n, !0)
}
function lw(n, e) {
  return bn(n) ? n : new ZI(n, e)
}
class ZI {
  constructor(e, t) {
    ;((this.dep = new Zv()),
      (this.__v_isRef = !0),
      (this.__v_isShallow = !1),
      (this._rawValue = t ? e : Ot(e)),
      (this._value = t ? e : mi(e)),
      (this.__v_isShallow = t))
  }
  get value() {
    return (this.dep.track(), this._value)
  }
  set value(e) {
    const t = this._rawValue,
      i = this.__v_isShallow || Zr(e) || Oa(e)
    ;((e = i ? e : Ot(e)),
      Pa(e, t) && ((this._rawValue = e), (this._value = i ? e : mi(e)), this.dep.trigger()))
  }
}
function JI(n) {
  n.dep && n.dep.trigger()
}
function Ke(n) {
  return bn(n) ? n.value : n
}
const e8 = {
  get: (n, e, t) => (e === '__v_raw' ? n : Ke(Reflect.get(n, e, t))),
  set: (n, e, t, i) => {
    const r = n[e]
    return bn(r) && !bn(t) ? ((r.value = t), !0) : Reflect.set(n, e, t, i)
  },
}
function cw(n) {
  return ko(n) ? n : new Proxy(n, e8)
}
function t8(n) {
  const e = vt(n) ? new Array(n.length) : {}
  for (const t in n) e[t] = uw(n, t)
  return e
}
class n8 {
  constructor(e, t, i) {
    ;((this._object = e),
      (this._key = t),
      (this._defaultValue = i),
      (this.__v_isRef = !0),
      (this._value = void 0))
  }
  get value() {
    const e = this._object[this._key]
    return (this._value = e === void 0 ? this._defaultValue : e)
  }
  set value(e) {
    this._object[this._key] = e
  }
  get dep() {
    return DI(Ot(this._object), this._key)
  }
}
class i8 {
  constructor(e) {
    ;((this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0), (this._value = void 0))
  }
  get value() {
    return (this._value = this._getter())
  }
}
function r8(n, e, t) {
  return bn(n) ? n : wt(n) ? new i8(n) : gn(n) && arguments.length > 1 ? uw(n, e, t) : Dn(n)
}
function uw(n, e, t) {
  const i = n[e]
  return bn(i) ? i : new n8(n, e, t)
}
class s8 {
  constructor(e, t, i) {
    ;((this.fn = e),
      (this.setter = t),
      (this._value = void 0),
      (this.dep = new Zv(this)),
      (this.__v_isRef = !0),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 16),
      (this.globalVersion = Yd - 1),
      (this.next = void 0),
      (this.effect = this),
      (this.__v_isReadonly = !t),
      (this.isSSR = i))
  }
  notify() {
    if (((this.flags |= 16), !(this.flags & 8) && fn !== this)) return (XT(this, !0), !0)
  }
  get value() {
    const e = this.dep.track()
    return (ZT(this), e && (e.version = this.dep.version), this._value)
  }
  set value(e) {
    this.setter && this.setter(e)
  }
}
function o8(n, e, t = !1) {
  let i, r
  return (wt(n) ? (i = n) : ((i = n.get), (r = n.set)), new s8(i, r, t))
}
const mf = {},
  Jp = new WeakMap()
let fl
function a8(n, e = !1, t = fl) {
  if (t) {
    let i = Jp.get(t)
    ;(i || Jp.set(t, (i = [])), i.push(n))
  }
}
function l8(n, e, t = un) {
  const { immediate: i, deep: r, once: s, scheduler: o, augmentJob: a, call: l } = t,
    c = (_) => (r ? _ : Zr(_) || r === !1 || r === 0 ? Lo(_, 1) : Lo(_))
  let u,
    d,
    h,
    f,
    p = !1,
    g = !1
  if (
    (bn(n)
      ? ((d = () => n.value), (p = Zr(n)))
      : ko(n)
        ? ((d = () => c(n)), (p = !0))
        : vt(n)
          ? ((g = !0),
            (p = n.some((_) => ko(_) || Zr(_))),
            (d = () =>
              n.map((_) => {
                if (bn(_)) return _.value
                if (ko(_)) return c(_)
                if (wt(_)) return l ? l(_, 2) : _()
              })))
          : wt(n)
            ? e
              ? (d = l ? () => l(n, 2) : n)
              : (d = () => {
                  if (h) {
                    Qo()
                    try {
                      h()
                    } finally {
                      jo()
                    }
                  }
                  const _ = fl
                  fl = u
                  try {
                    return l ? l(n, 3, [f]) : n(f)
                  } finally {
                    fl = _
                  }
                })
            : (d = qs),
    e && r)
  ) {
    const _ = d,
      S = r === !0 ? 1 / 0 : r
    d = () => Lo(_(), S)
  }
  const y = QT(),
    m = () => {
      ;(u.stop(), y && y.active && Qv(y.effects, u))
    }
  if (s && e) {
    const _ = e
    e = (...S) => {
      ;(_(...S), m())
    }
  }
  let v = g ? new Array(n.length).fill(mf) : mf
  const x = (_) => {
    if (!(!(u.flags & 1) || (!u.dirty && !_)))
      if (e) {
        const S = u.run()
        if (r || p || (g ? S.some((C, A) => Pa(C, v[A])) : Pa(S, v))) {
          h && h()
          const C = fl
          fl = u
          try {
            const A = [S, v === mf ? void 0 : g && v[0] === mf ? [] : v, f]
            ;((v = S), l ? l(e, 3, A) : e(...A))
          } finally {
            fl = C
          }
        }
      } else u.run()
  }
  return (
    a && a(x),
    (u = new jT(d)),
    (u.scheduler = o ? () => o(x, !1) : x),
    (f = (_) => a8(_, !1, u)),
    (h = u.onStop =
      () => {
        const _ = Jp.get(u)
        if (_) {
          if (l) l(_, 4)
          else for (const S of _) S()
          Jp.delete(u)
        }
      }),
    e ? (i ? x(!0) : (v = u.run())) : o ? o(x.bind(null, !0), !0) : u.run(),
    (m.pause = u.pause.bind(u)),
    (m.resume = u.resume.bind(u)),
    (m.stop = m),
    m
  )
}
function Lo(n, e = 1 / 0, t) {
  if (e <= 0 || !gn(n) || n.__v_skip || ((t = t || new Map()), (t.get(n) || 0) >= e)) return n
  if ((t.set(n, e), e--, bn(n))) Lo(n.value, e, t)
  else if (vt(n)) for (let i = 0; i < n.length; i++) Lo(n[i], e, t)
  else if (BT(n) || Hc(n))
    n.forEach((i) => {
      Lo(i, e, t)
    })
  else if (zT(n)) {
    for (const i in n) Lo(n[i], e, t)
    for (const i of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, i) && Lo(n[i], e, t)
  }
  return n
}
/**
 * @vue/runtime-core v3.5.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Lh(n, e, t, i) {
  try {
    return i ? n(...i) : n()
  } catch (r) {
    Zm(r, e, t)
  }
}
function As(n, e, t, i) {
  if (wt(n)) {
    const r = Lh(n, e, t, i)
    return (
      r &&
        UT(r) &&
        r.catch((s) => {
          Zm(s, e, t)
        }),
      r
    )
  }
  if (vt(n)) {
    const r = []
    for (let s = 0; s < n.length; s++) r.push(As(n[s], e, t, i))
    return r
  }
}
function Zm(n, e, t, i = !0) {
  const r = e ? e.vnode : null,
    { errorHandler: s, throwUnhandledErrorInProduction: o } = (e && e.appContext.config) || un
  if (e) {
    let a = e.parent
    const l = e.proxy,
      c = 'https://vuejs.org/error-reference/#runtime-'.concat(t)
    for (; a; ) {
      const u = a.ec
      if (u) {
        for (let d = 0; d < u.length; d++) if (u[d](n, l, c) === !1) return
      }
      a = a.parent
    }
    if (s) {
      ;(Qo(), Lh(s, null, 10, [n, l, c]), jo())
      return
    }
  }
  c8(n, t, r, i, o)
}
function c8(n, e, t, i = !0, r = !1) {
  if (r) throw n
  console.error(n)
}
const Xi = []
let Bs = -1
const $c = []
let va = null,
  Tc = 0
const dw = Promise.resolve()
let em = null
function Dh(n) {
  const e = em || dw
  return n ? e.then(this ? n.bind(this) : n) : e
}
function u8(n) {
  let e = Bs + 1,
    t = Xi.length
  for (; e < t; ) {
    const i = (e + t) >>> 1,
      r = Xi[i],
      s = Jd(r)
    s < n || (s === n && r.flags & 2) ? (e = i + 1) : (t = i)
  }
  return e
}
function i_(n) {
  if (!(n.flags & 1)) {
    const e = Jd(n),
      t = Xi[Xi.length - 1]
    ;(!t || (!(n.flags & 2) && e >= Jd(t)) ? Xi.push(n) : Xi.splice(u8(e), 0, n),
      (n.flags |= 1),
      hw())
  }
}
function hw() {
  em || (em = dw.then(pw))
}
function d8(n) {
  ;(vt(n)
    ? $c.push(...n)
    : va && n.id === -1
      ? va.splice(Tc + 1, 0, n)
      : n.flags & 1 || ($c.push(n), (n.flags |= 1)),
    hw())
}
function E2(n, e, t = Bs + 1) {
  for (; t < Xi.length; t++) {
    const i = Xi[t]
    if (i && i.flags & 2) {
      if (n && i.id !== n.uid) continue
      ;(Xi.splice(t, 1), t--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2))
    }
  }
}
function fw(n) {
  if ($c.length) {
    const e = [...new Set($c)].sort((t, i) => Jd(t) - Jd(i))
    if ((($c.length = 0), va)) {
      va.push(...e)
      return
    }
    for (va = e, Tc = 0; Tc < va.length; Tc++) {
      const t = va[Tc]
      ;(t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), (t.flags &= -2))
    }
    ;((va = null), (Tc = 0))
  }
}
const Jd = (n) => (n.id == null ? (n.flags & 2 ? -1 : 1 / 0) : n.id)
function pw(n) {
  try {
    for (Bs = 0; Bs < Xi.length; Bs++) {
      const e = Xi[Bs]
      e &&
        !(e.flags & 8) &&
        (e.flags & 4 && (e.flags &= -2), Lh(e, e.i, e.i ? 15 : 14), e.flags & 4 || (e.flags &= -2))
    }
  } finally {
    for (; Bs < Xi.length; Bs++) {
      const e = Xi[Bs]
      e && (e.flags &= -2)
    }
    ;((Bs = -1), (Xi.length = 0), fw(), (em = null), (Xi.length || $c.length) && pw())
  }
}
let Er = null,
  mw = null
function tm(n) {
  const e = Er
  return ((Er = n), (mw = (n && n.type.__scopeId) || null), e)
}
function gw(n, e = Er, t) {
  if (!e || n._n) return n
  const i = (...r) => {
    i._d && sm(-1)
    const s = tm(e)
    let o
    try {
      o = n(...r)
    } finally {
      ;(tm(s), i._d && sm(1))
    }
    return o
  }
  return ((i._n = !0), (i._c = !0), (i._d = !0), i)
}
function Pc(n, e) {
  if (Er === null) return n
  const t = i0(Er),
    i = n.dirs || (n.dirs = [])
  for (let r = 0; r < e.length; r++) {
    let [s, o, a, l = un] = e[r]
    s &&
      (wt(s) && (s = { mounted: s, updated: s }),
      s.deep && Lo(o),
      i.push({ dir: s, instance: t, value: o, oldValue: void 0, arg: a, modifiers: l }))
  }
  return n
}
function Ya(n, e, t, i) {
  const r = n.dirs,
    s = e && e.dirs
  for (let o = 0; o < r.length; o++) {
    const a = r[o]
    s && (a.oldValue = s[o].value)
    let l = a.dir[i]
    l && (Qo(), As(l, t, 8, [n.el, a, n, e]), jo())
  }
}
const yw = Symbol('_vte'),
  h8 = (n) => n.__isTeleport,
  Nd = (n) => n && (n.disabled || n.disabled === ''),
  M2 = (n) => n && (n.defer || n.defer === ''),
  R2 = (n) => typeof SVGElement < 'u' && n instanceof SVGElement,
  I2 = (n) => typeof MathMLElement == 'function' && n instanceof MathMLElement,
  $1 = (n, e) => {
    const t = n && n.to
    return wn(t) ? (e ? e(t) : null) : t
  },
  vw = {
    name: 'Teleport',
    __isTeleport: !0,
    process(n, e, t, i, r, s, o, a, l, c) {
      const {
          mc: u,
          pc: d,
          pbc: h,
          o: { insert: f, querySelector: p, createText: g, createComment: y },
        } = c,
        m = Nd(e.props)
      let { shapeFlag: v, children: x, dynamicChildren: _ } = e
      if (n == null) {
        const S = (e.el = g('')),
          C = (e.anchor = g(''))
        ;(f(S, t, i), f(C, t, i))
        const A = (w, M) => {
            v & 16 && (r && r.isCE && (r.ce._teleportTarget = w), u(x, w, M, r, s, o, a, l))
          },
          R = () => {
            const w = (e.target = $1(e.props, p)),
              M = xw(w, e, g, f)
            w &&
              (o !== 'svg' && R2(w) ? (o = 'svg') : o !== 'mathml' && I2(w) && (o = 'mathml'),
              m || (A(w, M), _p(e, !1)))
          }
        ;(m && (A(t, C), _p(e, !0)),
          M2(e.props)
            ? ((e.el.__isMounted = !1),
              ji(() => {
                ;(R(), delete e.el.__isMounted)
              }, s))
            : R())
      } else {
        if (M2(e.props) && n.el.__isMounted === !1) {
          ji(() => {
            vw.process(n, e, t, i, r, s, o, a, l, c)
          }, s)
          return
        }
        ;((e.el = n.el), (e.targetStart = n.targetStart))
        const S = (e.anchor = n.anchor),
          C = (e.target = n.target),
          A = (e.targetAnchor = n.targetAnchor),
          R = Nd(n.props),
          w = R ? t : C,
          M = R ? S : A
        if (
          (o === 'svg' || R2(C) ? (o = 'svg') : (o === 'mathml' || I2(C)) && (o = 'mathml'),
          _
            ? (h(n.dynamicChildren, _, w, r, s, o, a), a_(n, e, !0))
            : l || d(n, e, w, M, r, s, o, a, !1),
          m)
        )
          R
            ? e.props && n.props && e.props.to !== n.props.to && (e.props.to = n.props.to)
            : gf(e, t, S, c, 1)
        else if ((e.props && e.props.to) !== (n.props && n.props.to)) {
          const I = (e.target = $1(e.props, p))
          I && gf(e, I, null, c, 0)
        } else R && gf(e, C, A, c, 1)
        _p(e, m)
      }
    },
    remove(n, e, t, { um: i, o: { remove: r } }, s) {
      const {
        shapeFlag: o,
        children: a,
        anchor: l,
        targetStart: c,
        targetAnchor: u,
        target: d,
        props: h,
      } = n
      if ((d && (r(c), r(u)), s && r(l), o & 16)) {
        const f = s || !Nd(h)
        for (let p = 0; p < a.length; p++) {
          const g = a[p]
          i(g, e, t, f, !!g.dynamicChildren)
        }
      }
    },
    move: gf,
    hydrate: f8,
  }
function gf(n, e, t, { o: { insert: i }, m: r }, s = 2) {
  s === 0 && i(n.targetAnchor, e, t)
  const { el: o, anchor: a, shapeFlag: l, children: c, props: u } = n,
    d = s === 2
  if ((d && i(o, e, t), (!d || Nd(u)) && l & 16))
    for (let h = 0; h < c.length; h++) r(c[h], e, t, 2)
  d && i(a, e, t)
}
function f8(
  n,
  e,
  t,
  i,
  r,
  s,
  { o: { nextSibling: o, parentNode: a, querySelector: l, insert: c, createText: u } },
  d
) {
  function h(g, y, m, v) {
    ;((y.anchor = d(o(g), y, a(g), t, i, r, s)), (y.targetStart = m), (y.targetAnchor = v))
  }
  const f = (e.target = $1(e.props, l)),
    p = Nd(e.props)
  if (f) {
    const g = f._lpa || f.firstChild
    if (e.shapeFlag & 16)
      if (p) h(n, e, g, g && o(g))
      else {
        e.anchor = o(n)
        let y = g
        for (; y; ) {
          if (y && y.nodeType === 8) {
            if (y.data === 'teleport start anchor') e.targetStart = y
            else if (y.data === 'teleport anchor') {
              ;((e.targetAnchor = y), (f._lpa = e.targetAnchor && o(e.targetAnchor)))
              break
            }
          }
          y = o(y)
        }
        ;(e.targetAnchor || xw(f, e, u, c), d(g && o(g), e, f, t, i, r, s))
      }
    _p(e, p)
  } else p && e.shapeFlag & 16 && h(n, e, n, o(n))
  return e.anchor && o(e.anchor)
}
const _w = vw
function _p(n, e) {
  const t = n.ctx
  if (t && t.ut) {
    let i, r
    for (
      e ? ((i = n.el), (r = n.anchor)) : ((i = n.targetStart), (r = n.targetAnchor));
      i && i !== r;

    )
      (i.nodeType === 1 && i.setAttribute('data-v-owner', t.uid), (i = i.nextSibling))
    t.ut()
  }
}
function xw(n, e, t, i) {
  const r = (e.targetStart = t('')),
    s = (e.targetAnchor = t(''))
  return ((r[yw] = s), n && (i(r, n), i(s, n)), s)
}
const pl = Symbol('_leaveCb'),
  yf = Symbol('_enterCb')
function p8() {
  const n = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
  return (
    Va(() => {
      n.isMounted = !0
    }),
    e0(() => {
      n.isUnmounting = !0
    }),
    n
  )
}
const zr = [Function, Array],
  m8 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: zr,
    onEnter: zr,
    onAfterEnter: zr,
    onEnterCancelled: zr,
    onBeforeLeave: zr,
    onLeave: zr,
    onAfterLeave: zr,
    onLeaveCancelled: zr,
    onBeforeAppear: zr,
    onAppear: zr,
    onAfterAppear: zr,
    onAppearCancelled: zr,
  }
function g8(n, e) {
  const { leavingVNodes: t } = n
  let i = t.get(e.type)
  return (i || ((i = Object.create(null)), t.set(e.type, i)), i)
}
function G1(n, e, t, i, r) {
  const {
      appear: s,
      mode: o,
      persisted: a = !1,
      onBeforeEnter: l,
      onEnter: c,
      onAfterEnter: u,
      onEnterCancelled: d,
      onBeforeLeave: h,
      onLeave: f,
      onAfterLeave: p,
      onLeaveCancelled: g,
      onBeforeAppear: y,
      onAppear: m,
      onAfterAppear: v,
      onAppearCancelled: x,
    } = e,
    _ = String(n.key),
    S = g8(t, n),
    C = (w, M) => {
      w && As(w, i, 9, M)
    },
    A = (w, M) => {
      const I = M[1]
      ;(C(w, M), vt(w) ? w.every((L) => L.length <= 1) && I() : w.length <= 1 && I())
    },
    R = {
      mode: o,
      persisted: a,
      beforeEnter(w) {
        let M = l
        if (!t.isMounted)
          if (s) M = y || l
          else return
        w[pl] && w[pl](!0)
        const I = S[_]
        ;(I && wc(n, I) && I.el[pl] && I.el[pl](), C(M, [w]))
      },
      enter(w) {
        let M = c,
          I = u,
          L = d
        if (!t.isMounted)
          if (s) ((M = m || c), (I = v || u), (L = x || d))
          else return
        let U = !1
        const T = (w[yf] = (F) => {
          U ||
            ((U = !0),
            F ? C(L, [w]) : C(I, [w]),
            R.delayedLeave && R.delayedLeave(),
            (w[yf] = void 0))
        })
        M ? A(M, [w, T]) : T()
      },
      leave(w, M) {
        const I = String(n.key)
        if ((w[yf] && w[yf](!0), t.isUnmounting)) return M()
        C(h, [w])
        let L = !1
        const U = (w[pl] = (T) => {
          L ||
            ((L = !0), M(), T ? C(g, [w]) : C(p, [w]), (w[pl] = void 0), S[I] === n && delete S[I])
        })
        ;((S[I] = n), f ? A(f, [w, U]) : U())
      },
      clone(w) {
        return G1(w, e, t, i)
      },
    }
  return R
}
function eh(n, e) {
  n.shapeFlag & 6 && n.component
    ? ((n.transition = e), eh(n.component.subTree, e))
    : n.shapeFlag & 128
      ? ((n.ssContent.transition = e.clone(n.ssContent)),
        (n.ssFallback.transition = e.clone(n.ssFallback)))
      : (n.transition = e)
}
function Sw(n, e = !1, t) {
  let i = [],
    r = 0
  for (let s = 0; s < n.length; s++) {
    let o = n[s]
    const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : s)
    o.type === Hn
      ? (o.patchFlag & 128 && r++, (i = i.concat(Sw(o.children, e, a))))
      : (e || o.type !== Js) && i.push(a != null ? qo(o, { key: a }) : o)
  }
  if (r > 1) for (let s = 0; s < i.length; s++) i[s].patchFlag = -2
  return i
}
function qt(n, e) {
  return wt(n) ? ti({ name: n.name }, e, { setup: n }) : n
}
function Aw(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + '-', 0, 0]
}
function nm(n) {
  const e = bs(),
    t = ar(null)
  if (e) {
    const r = e.refs === un ? (e.refs = {}) : e.refs
    Object.defineProperty(r, n, { enumerable: !0, get: () => t.value, set: (s) => (t.value = s) })
  }
  return t
}
const im = new WeakMap()
function Pd(n, e, t, i, r = !1) {
  if (vt(n)) {
    n.forEach((p, g) => Pd(p, e && (vt(e) ? e[g] : e), t, i, r))
    return
  }
  if (Ld(i) && !r) {
    i.shapeFlag & 512 &&
      i.type.__asyncResolved &&
      i.component.subTree.component &&
      Pd(n, e, t, i.component.subTree)
    return
  }
  const s = i.shapeFlag & 4 ? i0(i.component) : i.el,
    o = r ? null : s,
    { i: a, r: l } = n,
    c = e && e.r,
    u = a.refs === un ? (a.refs = {}) : a.refs,
    d = a.setupState,
    h = Ot(d),
    f = d === un ? OT : (p) => tn(h, p)
  if (c != null && c !== l) {
    if ((N2(e), wn(c))) ((u[c] = null), f(c) && (d[c] = null))
    else if (bn(c)) {
      c.value = null
      const p = e
      p.k && (u[p.k] = null)
    }
  }
  if (wt(l)) Lh(l, a, 12, [o, u])
  else {
    const p = wn(l),
      g = bn(l)
    if (p || g) {
      const y = () => {
        if (n.f) {
          const m = p ? (f(l) ? d[l] : u[l]) : l.value
          if (r) vt(m) && Qv(m, s)
          else if (vt(m)) m.includes(s) || m.push(s)
          else if (p) ((u[l] = [s]), f(l) && (d[l] = u[l]))
          else {
            const v = [s]
            ;((l.value = v), n.k && (u[n.k] = v))
          }
        } else p ? ((u[l] = o), f(l) && (d[l] = o)) : g && ((l.value = o), n.k && (u[n.k] = o))
      }
      if (o) {
        const m = () => {
          ;(y(), im.delete(n))
        }
        ;((m.id = -1), im.set(n, m), ji(m, t))
      } else (N2(n), y())
    }
  }
}
function N2(n) {
  const e = im.get(n)
  e && ((e.flags |= 8), im.delete(n))
}
Km().requestIdleCallback
Km().cancelIdleCallback
const Ld = (n) => !!n.type.__asyncLoader,
  bw = (n) => n.type.__isKeepAlive
function y8(n, e) {
  Tw(n, 'a', e)
}
function v8(n, e) {
  Tw(n, 'da', e)
}
function Tw(n, e, t = Li) {
  const i =
    n.__wdc ||
    (n.__wdc = () => {
      let r = t
      for (; r; ) {
        if (r.isDeactivated) return
        r = r.parent
      }
      return n()
    })
  if ((Jm(e, i, t), t)) {
    let r = t.parent
    for (; r && r.parent; ) (bw(r.parent.vnode) && _8(i, e, t, r), (r = r.parent))
  }
}
function _8(n, e, t, i) {
  const r = Jm(e, n, i, !0)
  Fh(() => {
    Qv(i[e], r)
  }, t)
}
function Jm(n, e, t = Li, i = !1) {
  if (t) {
    const r = t[n] || (t[n] = []),
      s =
        e.__weh ||
        (e.__weh = (...o) => {
          Qo()
          const a = Oh(t),
            l = As(e, t, n, o)
          return (a(), jo(), l)
        })
    return (i ? r.unshift(s) : r.push(s), s)
  }
}
const ia =
    (n) =>
    (e, t = Li) => {
      ;(!ih || n === 'sp') && Jm(n, (...i) => e(...i), t)
    },
  ww = ia('bm'),
  Va = ia('m'),
  x8 = ia('bu'),
  r_ = ia('u'),
  e0 = ia('bum'),
  Fh = ia('um'),
  S8 = ia('sp'),
  A8 = ia('rtg'),
  b8 = ia('rtc')
function T8(n, e = Li) {
  Jm('ec', n, e)
}
const Cw = 'components',
  w8 = 'directives',
  Ew = Symbol.for('v-ndc')
function C8(n) {
  return wn(n) ? Mw(Cw, n, !1) || n : n || Ew
}
function E8(n) {
  return Mw(w8, n)
}
function Mw(n, e, t = !0, i = !1) {
  const r = Er || Li
  if (r) {
    const s = r.type
    if (n === Cw) {
      const a = m9(s, !1)
      if (a && (a === e || a === ns(e) || a === Xm(ns(e)))) return s
    }
    const o = P2(r[n] || s[n], e) || P2(r.appContext[n], e)
    return !o && i ? s : o
  }
}
function P2(n, e) {
  return n && (n[e] || n[ns(e)] || n[Xm(ns(e))])
}
function th(n, e, t, i) {
  let r
  const s = t,
    o = vt(n)
  if (o || wn(n)) {
    const a = o && ko(n)
    let l = !1,
      c = !1
    ;(a && ((l = !Zr(n)), (c = Oa(n)), (n = Ym(n))), (r = new Array(n.length)))
    for (let u = 0, d = n.length; u < d; u++)
      r[u] = e(l ? (c ? Zp(mi(n[u])) : mi(n[u])) : n[u], u, void 0, s)
  } else if (typeof n == 'number') {
    r = new Array(n)
    for (let a = 0; a < n; a++) r[a] = e(a + 1, a, void 0, s)
  } else if (gn(n))
    if (n[Symbol.iterator]) r = Array.from(n, (a, l) => e(a, l, void 0, s))
    else {
      const a = Object.keys(n)
      r = new Array(a.length)
      for (let l = 0, c = a.length; l < c; l++) {
        const u = a[l]
        r[l] = e(n[u], u, l, s)
      }
    }
  else r = []
  return r
}
const W1 = (n) => (n ? (Qw(n) ? i0(n) : W1(n.parent)) : null),
  Dd = ti(Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => W1(n.parent),
    $root: (n) => W1(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => Iw(n),
    $forceUpdate: (n) =>
      n.f ||
      (n.f = () => {
        i_(n.update)
      }),
    $nextTick: (n) => n.n || (n.n = Dh.bind(n.proxy)),
    $watch: (n) => X8.bind(n),
  }),
  J0 = (n, e) => n !== un && !n.__isScriptSetup && tn(n, e),
  M8 = {
    get({ _: n }, e) {
      if (e === '__v_skip') return !0
      const { ctx: t, setupState: i, data: r, props: s, accessCache: o, type: a, appContext: l } = n
      let c
      if (e[0] !== '$') {
        const f = o[e]
        if (f !== void 0)
          switch (f) {
            case 1:
              return i[e]
            case 2:
              return r[e]
            case 4:
              return t[e]
            case 3:
              return s[e]
          }
        else {
          if (J0(i, e)) return ((o[e] = 1), i[e])
          if (r !== un && tn(r, e)) return ((o[e] = 2), r[e])
          if ((c = n.propsOptions[0]) && tn(c, e)) return ((o[e] = 3), s[e])
          if (t !== un && tn(t, e)) return ((o[e] = 4), t[e])
          Q1 && (o[e] = 0)
        }
      }
      const u = Dd[e]
      let d, h
      if (u) return (e === '$attrs' && Pi(n.attrs, 'get', ''), u(n))
      if ((d = a.__cssModules) && (d = d[e])) return d
      if (t !== un && tn(t, e)) return ((o[e] = 4), t[e])
      if (((h = l.config.globalProperties), tn(h, e))) return h[e]
    },
    set({ _: n }, e, t) {
      const { data: i, setupState: r, ctx: s } = n
      return J0(r, e)
        ? ((r[e] = t), !0)
        : i !== un && tn(i, e)
          ? ((i[e] = t), !0)
          : tn(n.props, e) || (e[0] === '$' && e.slice(1) in n)
            ? !1
            : ((s[e] = t), !0)
    },
    has(
      {
        _: {
          data: n,
          setupState: e,
          accessCache: t,
          ctx: i,
          appContext: r,
          propsOptions: s,
          type: o,
        },
      },
      a
    ) {
      let l, c
      return !!(
        t[a] ||
        (n !== un && a[0] !== '$' && tn(n, a)) ||
        J0(e, a) ||
        ((l = s[0]) && tn(l, a)) ||
        tn(i, a) ||
        tn(Dd, a) ||
        tn(r.config.globalProperties, a) ||
        ((c = o.__cssModules) && c[a])
      )
    },
    defineProperty(n, e, t) {
      return (
        t.get != null ? (n._.accessCache[e] = 0) : tn(t, 'value') && this.set(n, e, t.value, null),
        Reflect.defineProperty(n, e, t)
      )
    },
  }
function L2(n) {
  return vt(n) ? n.reduce((e, t) => ((e[t] = null), e), {}) : n
}
let Q1 = !0
function R8(n) {
  const e = Iw(n),
    t = n.proxy,
    i = n.ctx
  ;((Q1 = !1), e.beforeCreate && D2(e.beforeCreate, n, 'bc'))
  const {
    data: r,
    computed: s,
    methods: o,
    watch: a,
    provide: l,
    inject: c,
    created: u,
    beforeMount: d,
    mounted: h,
    beforeUpdate: f,
    updated: p,
    activated: g,
    deactivated: y,
    beforeDestroy: m,
    beforeUnmount: v,
    destroyed: x,
    unmounted: _,
    render: S,
    renderTracked: C,
    renderTriggered: A,
    errorCaptured: R,
    serverPrefetch: w,
    expose: M,
    inheritAttrs: I,
    components: L,
    directives: U,
    filters: T,
  } = e
  if ((c && I8(c, i, null), o))
    for (const W in o) {
      const ee = o[W]
      wt(ee) && (i[W] = ee.bind(t))
    }
  if (r) {
    const W = r.call(t, t)
    gn(W) && (n.data = Zs(W))
  }
  if (((Q1 = !0), s))
    for (const W in s) {
      const ee = s[W],
        se = wt(ee) ? ee.bind(t, t) : wt(ee.get) ? ee.get.bind(t, t) : qs,
        he = !wt(ee) && wt(ee.set) ? ee.set.bind(t) : qs,
        ne = Ge({ get: se, set: he })
      Object.defineProperty(i, W, {
        enumerable: !0,
        configurable: !0,
        get: () => ne.value,
        set: (ie) => (ne.value = ie),
      })
    }
  if (a) for (const W in a) Rw(a[W], i, t, W)
  if (l) {
    const W = wt(l) ? l.call(t) : l
    Reflect.ownKeys(W).forEach((ee) => {
      ra(ee, W[ee])
    })
  }
  u && D2(u, n, 'c')
  function V(W, ee) {
    vt(ee) ? ee.forEach((se) => W(se.bind(t))) : ee && W(ee.bind(t))
  }
  if (
    (V(ww, d),
    V(Va, h),
    V(x8, f),
    V(r_, p),
    V(y8, g),
    V(v8, y),
    V(T8, R),
    V(b8, C),
    V(A8, A),
    V(e0, v),
    V(Fh, _),
    V(S8, w),
    vt(M))
  )
    if (M.length) {
      const W = n.exposed || (n.exposed = {})
      M.forEach((ee) => {
        Object.defineProperty(W, ee, {
          get: () => t[ee],
          set: (se) => (t[ee] = se),
          enumerable: !0,
        })
      })
    } else n.exposed || (n.exposed = {})
  ;(S && n.render === qs && (n.render = S),
    I != null && (n.inheritAttrs = I),
    L && (n.components = L),
    U && (n.directives = U),
    w && Aw(n))
}
function I8(n, e, t = qs) {
  vt(n) && (n = j1(n))
  for (const i in n) {
    const r = n[i]
    let s
    ;(gn(r)
      ? 'default' in r
        ? (s = Zi(r.from || i, r.default, !0))
        : (s = Zi(r.from || i))
      : (s = Zi(r)),
      bn(s)
        ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: (o) => (s.value = o),
          })
        : (e[i] = s))
  }
}
function D2(n, e, t) {
  As(vt(n) ? n.map((i) => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}
function Rw(n, e, t, i) {
  let r = i.includes('.') ? Vw(t, i) : () => t[i]
  if (wn(n)) {
    const s = e[n]
    wt(s) && Jn(r, s)
  } else if (wt(n)) Jn(r, n.bind(t))
  else if (gn(n))
    if (vt(n)) n.forEach((s) => Rw(s, e, t, i))
    else {
      const s = wt(n.handler) ? n.handler.bind(t) : e[n.handler]
      wt(s) && Jn(r, s, n)
    }
}
function Iw(n) {
  const e = n.type,
    { mixins: t, extends: i } = e,
    {
      mixins: r,
      optionsCache: s,
      config: { optionMergeStrategies: o },
    } = n.appContext,
    a = s.get(e)
  let l
  return (
    a
      ? (l = a)
      : !r.length && !t && !i
        ? (l = e)
        : ((l = {}), r.length && r.forEach((c) => rm(l, c, o, !0)), rm(l, e, o)),
    gn(e) && s.set(e, l),
    l
  )
}
function rm(n, e, t, i = !1) {
  const { mixins: r, extends: s } = e
  ;(s && rm(n, s, t, !0), r && r.forEach((o) => rm(n, o, t, !0)))
  for (const o in e)
    if (!(i && o === 'expose')) {
      const a = N8[o] || (t && t[o])
      n[o] = a ? a(n[o], e[o]) : e[o]
    }
  return n
}
const N8 = {
  data: F2,
  props: O2,
  emits: O2,
  methods: bd,
  computed: bd,
  beforeCreate: Gi,
  created: Gi,
  beforeMount: Gi,
  mounted: Gi,
  beforeUpdate: Gi,
  updated: Gi,
  beforeDestroy: Gi,
  beforeUnmount: Gi,
  destroyed: Gi,
  unmounted: Gi,
  activated: Gi,
  deactivated: Gi,
  errorCaptured: Gi,
  serverPrefetch: Gi,
  components: bd,
  directives: bd,
  watch: L8,
  provide: F2,
  inject: P8,
}
function F2(n, e) {
  return e
    ? n
      ? function () {
          return ti(wt(n) ? n.call(this, this) : n, wt(e) ? e.call(this, this) : e)
        }
      : e
    : n
}
function P8(n, e) {
  return bd(j1(n), j1(e))
}
function j1(n) {
  if (vt(n)) {
    const e = {}
    for (let t = 0; t < n.length; t++) e[n[t]] = n[t]
    return e
  }
  return n
}
function Gi(n, e) {
  return n ? [...new Set([].concat(n, e))] : e
}
function bd(n, e) {
  return n ? ti(Object.create(null), n, e) : e
}
function O2(n, e) {
  return n
    ? vt(n) && vt(e)
      ? [...new Set([...n, ...e])]
      : ti(Object.create(null), L2(n), L2(e != null ? e : {}))
    : e
}
function L8(n, e) {
  if (!n) return e
  if (!e) return n
  const t = ti(Object.create(null), n)
  for (const i in e) t[i] = Gi(n[i], e[i])
  return t
}
function Nw() {
  return {
    app: null,
    config: {
      isNativeTag: OT,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  }
}
let D8 = 0
function F8(n, e) {
  return function (i, r = null) {
    ;(wt(i) || (i = ti({}, i)), r != null && !gn(r) && (r = null))
    const s = Nw(),
      o = new WeakSet(),
      a = []
    let l = !1
    const c = (s.app = {
      _uid: D8++,
      _component: i,
      _props: r,
      _container: null,
      _context: s,
      _instance: null,
      version: y9,
      get config() {
        return s.config
      },
      set config(u) {},
      use(u, ...d) {
        return (
          o.has(u) ||
            (u && wt(u.install) ? (o.add(u), u.install(c, ...d)) : wt(u) && (o.add(u), u(c, ...d))),
          c
        )
      },
      mixin(u) {
        return (s.mixins.includes(u) || s.mixins.push(u), c)
      },
      component(u, d) {
        return d ? ((s.components[u] = d), c) : s.components[u]
      },
      directive(u, d) {
        return d ? ((s.directives[u] = d), c) : s.directives[u]
      },
      mount(u, d, h) {
        if (!l) {
          const f = c._ceVNode || Te(i, r)
          return (
            (f.appContext = s),
            h === !0 ? (h = 'svg') : h === !1 && (h = void 0),
            n(f, u, h),
            (l = !0),
            (c._container = u),
            (u.__vue_app__ = c),
            i0(f.component)
          )
        }
      },
      onUnmount(u) {
        a.push(u)
      },
      unmount() {
        l && (As(a, c._instance, 16), n(null, c._container), delete c._container.__vue_app__)
      },
      provide(u, d) {
        return ((s.provides[u] = d), c)
      },
      runWithContext(u) {
        const d = Il
        Il = c
        try {
          return u()
        } finally {
          Il = d
        }
      },
    })
    return c
  }
}
let Il = null
function ra(n, e) {
  if (Li) {
    let t = Li.provides
    const i = Li.parent && Li.parent.provides
    ;(i === t && (t = Li.provides = Object.create(i)), (t[n] = e))
  }
}
function Zi(n, e, t = !1) {
  const i = bs()
  if (i || Il) {
    let r = Il
      ? Il._context.provides
      : i
        ? i.parent == null || i.ce
          ? i.vnode.appContext && i.vnode.appContext.provides
          : i.parent.provides
        : void 0
    if (r && n in r) return r[n]
    if (arguments.length > 1) return t && wt(e) ? e.call(i && i.proxy) : e
  }
}
function O8() {
  return !!(bs() || Il)
}
const Pw = {},
  Lw = () => Object.create(Pw),
  Dw = (n) => Object.getPrototypeOf(n) === Pw
function B8(n, e, t, i = !1) {
  const r = {},
    s = Lw()
  ;((n.propsDefaults = Object.create(null)), Fw(n, e, r, s))
  for (const o in n.propsOptions[0]) o in r || (r[o] = void 0)
  ;(t ? (n.props = i ? r : YI(r)) : n.type.props ? (n.props = r) : (n.props = s), (n.attrs = s))
}
function U8(n, e, t, i) {
  const {
      props: r,
      attrs: s,
      vnode: { patchFlag: o },
    } = n,
    a = Ot(r),
    [l] = n.propsOptions
  let c = !1
  if ((i || o > 0) && !(o & 16)) {
    if (o & 8) {
      const u = n.vnode.dynamicProps
      for (let d = 0; d < u.length; d++) {
        let h = u[d]
        if (n0(n.emitsOptions, h)) continue
        const f = e[h]
        if (l)
          if (tn(s, h)) f !== s[h] && ((s[h] = f), (c = !0))
          else {
            const p = ns(h)
            r[p] = q1(l, a, p, f, n, !1)
          }
        else f !== s[h] && ((s[h] = f), (c = !0))
      }
    }
  } else {
    Fw(n, e, r, s) && (c = !0)
    let u
    for (const d in a)
      (!e || (!tn(e, d) && ((u = Ql(d)) === d || !tn(e, u)))) &&
        (l
          ? t && (t[d] !== void 0 || t[u] !== void 0) && (r[d] = q1(l, a, d, void 0, n, !0))
          : delete r[d])
    if (s !== a) for (const d in s) (!e || !tn(e, d)) && (delete s[d], (c = !0))
  }
  c && Po(n.attrs, 'set', '')
}
function Fw(n, e, t, i) {
  const [r, s] = n.propsOptions
  let o = !1,
    a
  if (e)
    for (let l in e) {
      if (Md(l)) continue
      const c = e[l]
      let u
      r && tn(r, (u = ns(l)))
        ? !s || !s.includes(u)
          ? (t[u] = c)
          : ((a || (a = {}))[u] = c)
        : n0(n.emitsOptions, l) || ((!(l in i) || c !== i[l]) && ((i[l] = c), (o = !0)))
    }
  if (s) {
    const l = Ot(t),
      c = a || un
    for (let u = 0; u < s.length; u++) {
      const d = s[u]
      t[d] = q1(r, l, d, c[d], n, !tn(c, d))
    }
  }
  return o
}
function q1(n, e, t, i, r, s) {
  const o = n[t]
  if (o != null) {
    const a = tn(o, 'default')
    if (a && i === void 0) {
      const l = o.default
      if (o.type !== Function && !o.skipFactory && wt(l)) {
        const { propsDefaults: c } = r
        if (t in c) i = c[t]
        else {
          const u = Oh(r)
          ;((i = c[t] = l.call(null, e)), u())
        }
      } else i = l
      r.ce && r.ce._setProp(t, i)
    }
    o[0] && (s && !a ? (i = !1) : o[1] && (i === '' || i === Ql(t)) && (i = !0))
  }
  return i
}
const k8 = new WeakMap()
function Ow(n, e, t = !1) {
  const i = t ? k8 : e.propsCache,
    r = i.get(n)
  if (r) return r
  const s = n.props,
    o = {},
    a = []
  let l = !1
  if (!wt(n)) {
    const u = (d) => {
      l = !0
      const [h, f] = Ow(d, e, !0)
      ;(ti(o, h), f && a.push(...f))
    }
    ;(!t && e.mixins.length && e.mixins.forEach(u),
      n.extends && u(n.extends),
      n.mixins && n.mixins.forEach(u))
  }
  if (!s && !l) return (gn(n) && i.set(n, Vc), Vc)
  if (vt(s))
    for (let u = 0; u < s.length; u++) {
      const d = ns(s[u])
      B2(d) && (o[d] = un)
    }
  else if (s)
    for (const u in s) {
      const d = ns(u)
      if (B2(d)) {
        const h = s[u],
          f = (o[d] = vt(h) || wt(h) ? { type: h } : ti({}, h)),
          p = f.type
        let g = !1,
          y = !0
        if (vt(p))
          for (let m = 0; m < p.length; ++m) {
            const v = p[m],
              x = wt(v) && v.name
            if (x === 'Boolean') {
              g = !0
              break
            } else x === 'String' && (y = !1)
          }
        else g = wt(p) && p.name === 'Boolean'
        ;((f[0] = g), (f[1] = y), (g || tn(f, 'default')) && a.push(d))
      }
    }
  const c = [o, a]
  return (gn(n) && i.set(n, c), c)
}
function B2(n) {
  return n[0] !== '$' && !Md(n)
}
const s_ = (n) => n === '_' || n === '_ctx' || n === '$stable',
  o_ = (n) => (vt(n) ? n.map(zs) : [zs(n)]),
  z8 = (n, e, t) => {
    if (e._n) return e
    const i = gw((...r) => o_(e(...r)), t)
    return ((i._c = !1), i)
  },
  Bw = (n, e, t) => {
    const i = n._ctx
    for (const r in n) {
      if (s_(r)) continue
      const s = n[r]
      if (wt(s)) e[r] = z8(r, s, i)
      else if (s != null) {
        const o = o_(s)
        e[r] = () => o
      }
    }
  },
  Uw = (n, e) => {
    const t = o_(e)
    n.slots.default = () => t
  },
  kw = (n, e, t) => {
    for (const i in e) (t || !s_(i)) && (n[i] = e[i])
  },
  V8 = (n, e, t) => {
    const i = (n.slots = Lw())
    if (n.vnode.shapeFlag & 32) {
      const r = e._
      r ? (kw(i, e, t), t && VT(i, '_', r, !0)) : Bw(e, i)
    } else e && Uw(n, e)
  },
  H8 = (n, e, t) => {
    const { vnode: i, slots: r } = n
    let s = !0,
      o = un
    if (i.shapeFlag & 32) {
      const a = e._
      ;(a ? (t && a === 1 ? (s = !1) : kw(r, e, t)) : ((s = !e.$stable), Bw(e, r)), (o = e))
    } else e && (Uw(n, e), (o = { default: 1 }))
    if (s) for (const a in r) !s_(a) && o[a] == null && delete r[a]
  },
  ji = i9
function $8(n) {
  return G8(n)
}
function G8(n, e) {
  const t = Km()
  t.__VUE__ = !0
  const {
      insert: i,
      remove: r,
      patchProp: s,
      createElement: o,
      createText: a,
      createComment: l,
      setText: c,
      setElementText: u,
      parentNode: d,
      nextSibling: h,
      setScopeId: f = qs,
      insertStaticContent: p,
    } = n,
    g = (
      te,
      re,
      b,
      oe = null,
      J = null,
      H = null,
      P = void 0,
      k = null,
      j = !!re.dynamicChildren
    ) => {
      if (te === re) return
      ;(te && !wc(te, re) && ((oe = Ee(te)), ie(te, J, H, !0), (te = null)),
        re.patchFlag === -2 && ((j = !1), (re.dynamicChildren = null)))
      const { type: B, ref: D, shapeFlag: Q } = re
      switch (B) {
        case Nu:
          y(te, re, b, oe)
          break
        case Js:
          m(te, re, b, oe)
          break
        case xp:
          te == null && v(re, b, oe, P)
          break
        case Hn:
          L(te, re, b, oe, J, H, P, k, j)
          break
        default:
          Q & 1
            ? S(te, re, b, oe, J, H, P, k, j)
            : Q & 6
              ? U(te, re, b, oe, J, H, P, k, j)
              : (Q & 64 || Q & 128) && B.process(te, re, b, oe, J, H, P, k, j, Be)
      }
      D != null && J
        ? Pd(D, te && te.ref, H, re || te, !re)
        : D == null && te && te.ref != null && Pd(te.ref, null, H, te, !0)
    },
    y = (te, re, b, oe) => {
      if (te == null) i((re.el = a(re.children)), b, oe)
      else {
        const J = (re.el = te.el)
        re.children !== te.children && c(J, re.children)
      }
    },
    m = (te, re, b, oe) => {
      te == null ? i((re.el = l(re.children || '')), b, oe) : (re.el = te.el)
    },
    v = (te, re, b, oe) => {
      ;[te.el, te.anchor] = p(te.children, re, b, oe, te.el, te.anchor)
    },
    x = ({ el: te, anchor: re }, b, oe) => {
      let J
      for (; te && te !== re; ) ((J = h(te)), i(te, b, oe), (te = J))
      i(re, b, oe)
    },
    _ = ({ el: te, anchor: re }) => {
      let b
      for (; te && te !== re; ) ((b = h(te)), r(te), (te = b))
      r(re)
    },
    S = (te, re, b, oe, J, H, P, k, j) => {
      ;(re.type === 'svg' ? (P = 'svg') : re.type === 'math' && (P = 'mathml'),
        te == null ? C(re, b, oe, J, H, P, k, j) : w(te, re, J, H, P, k, j))
    },
    C = (te, re, b, oe, J, H, P, k) => {
      let j, B
      const { props: D, shapeFlag: Q, transition: G, dirs: X } = te
      if (
        ((j = te.el = o(te.type, H, D && D.is, D)),
        Q & 8 ? u(j, te.children) : Q & 16 && R(te.children, j, null, oe, J, eg(te, H), P, k),
        X && Ya(te, null, oe, 'created'),
        A(j, te, te.scopeId, P, oe),
        D)
      ) {
        for (const z in D) z !== 'value' && !Md(z) && s(j, z, null, D[z], H, oe)
        ;('value' in D && s(j, 'value', null, D.value, H),
          (B = D.onVnodeBeforeMount) && Rs(B, oe, te))
      }
      X && Ya(te, null, oe, 'beforeMount')
      const ue = W8(J, G)
      ;(ue && G.beforeEnter(j),
        i(j, re, b),
        ((B = D && D.onVnodeMounted) || ue || X) &&
          ji(() => {
            ;(B && Rs(B, oe, te), ue && G.enter(j), X && Ya(te, null, oe, 'mounted'))
          }, J))
    },
    A = (te, re, b, oe, J) => {
      if ((b && f(te, b), oe)) for (let H = 0; H < oe.length; H++) f(te, oe[H])
      if (J) {
        let H = J.subTree
        if (re === H || ($w(H.type) && (H.ssContent === re || H.ssFallback === re))) {
          const P = J.vnode
          A(te, P, P.scopeId, P.slotScopeIds, J.parent)
        }
      }
    },
    R = (te, re, b, oe, J, H, P, k, j = 0) => {
      for (let B = j; B < te.length; B++) {
        const D = (te[B] = k ? _a(te[B]) : zs(te[B]))
        g(null, D, re, b, oe, J, H, P, k)
      }
    },
    w = (te, re, b, oe, J, H, P) => {
      const k = (re.el = te.el)
      let { patchFlag: j, dynamicChildren: B, dirs: D } = re
      j |= te.patchFlag & 16
      const Q = te.props || un,
        G = re.props || un
      let X
      if (
        (b && Za(b, !1),
        (X = G.onVnodeBeforeUpdate) && Rs(X, b, re, te),
        D && Ya(re, te, b, 'beforeUpdate'),
        b && Za(b, !0),
        ((Q.innerHTML && G.innerHTML == null) || (Q.textContent && G.textContent == null)) &&
          u(k, ''),
        B
          ? M(te.dynamicChildren, B, k, b, oe, eg(re, J), H)
          : P || ee(te, re, k, null, b, oe, eg(re, J), H, !1),
        j > 0)
      ) {
        if (j & 16) I(k, Q, G, b, J)
        else if (
          (j & 2 && Q.class !== G.class && s(k, 'class', null, G.class, J),
          j & 4 && s(k, 'style', Q.style, G.style, J),
          j & 8)
        ) {
          const ue = re.dynamicProps
          for (let z = 0; z < ue.length; z++) {
            const E = ue[z],
              N = Q[E],
              q = G[E]
            ;(q !== N || E === 'value') && s(k, E, N, q, J, b)
          }
        }
        j & 1 && te.children !== re.children && u(k, re.children)
      } else !P && B == null && I(k, Q, G, b, J)
      ;((X = G.onVnodeUpdated) || D) &&
        ji(() => {
          ;(X && Rs(X, b, re, te), D && Ya(re, te, b, 'updated'))
        }, oe)
    },
    M = (te, re, b, oe, J, H, P) => {
      for (let k = 0; k < re.length; k++) {
        const j = te[k],
          B = re[k],
          D = j.el && (j.type === Hn || !wc(j, B) || j.shapeFlag & 198) ? d(j.el) : b
        g(j, B, D, null, oe, J, H, P, !0)
      }
    },
    I = (te, re, b, oe, J) => {
      if (re !== b) {
        if (re !== un) for (const H in re) !Md(H) && !(H in b) && s(te, H, re[H], null, J, oe)
        for (const H in b) {
          if (Md(H)) continue
          const P = b[H],
            k = re[H]
          P !== k && H !== 'value' && s(te, H, k, P, J, oe)
        }
        'value' in b && s(te, 'value', re.value, b.value, J)
      }
    },
    L = (te, re, b, oe, J, H, P, k, j) => {
      const B = (re.el = te ? te.el : a('')),
        D = (re.anchor = te ? te.anchor : a(''))
      let { patchFlag: Q, dynamicChildren: G, slotScopeIds: X } = re
      ;(X && (k = k ? k.concat(X) : X),
        te == null
          ? (i(B, b, oe), i(D, b, oe), R(re.children || [], b, D, J, H, P, k, j))
          : Q > 0 && Q & 64 && G && te.dynamicChildren
            ? (M(te.dynamicChildren, G, b, J, H, P, k),
              (re.key != null || (J && re === J.subTree)) && a_(te, re, !0))
            : ee(te, re, b, D, J, H, P, k, j))
    },
    U = (te, re, b, oe, J, H, P, k, j) => {
      ;((re.slotScopeIds = k),
        te == null
          ? re.shapeFlag & 512
            ? J.ctx.activate(re, b, oe, P, j)
            : T(re, b, oe, J, H, P, j)
          : F(te, re, j))
    },
    T = (te, re, b, oe, J, H, P) => {
      const k = (te.component = u9(te, oe, J))
      if ((bw(te) && (k.ctx.renderer = Be), d9(k, !1, P), k.asyncDep)) {
        if ((J && J.registerDep(k, V, P), !te.el)) {
          const j = (k.subTree = Te(Js))
          ;(m(null, j, re, b), (te.placeholder = j.el))
        }
      } else V(k, te, re, b, J, H, P)
    },
    F = (te, re, b) => {
      const oe = (re.component = te.component)
      if (t9(te, re, b))
        if (oe.asyncDep && !oe.asyncResolved) {
          W(oe, re, b)
          return
        } else ((oe.next = re), oe.update())
      else ((re.el = te.el), (oe.vnode = re))
    },
    V = (te, re, b, oe, J, H, P) => {
      const k = () => {
        if (te.isMounted) {
          let { next: Q, bu: G, u: X, parent: ue, vnode: z } = te
          {
            const $ = zw(te)
            if ($) {
              ;(Q && ((Q.el = z.el), W(te, Q, P)),
                $.asyncDep.then(() => {
                  te.isUnmounted || k()
                }))
              return
            }
          }
          let E = Q,
            N
          ;(Za(te, !1),
            Q ? ((Q.el = z.el), W(te, Q, P)) : (Q = z),
            G && q0(G),
            (N = Q.props && Q.props.onVnodeBeforeUpdate) && Rs(N, ue, Q, z),
            Za(te, !0))
          const q = k2(te),
            Z = te.subTree
          ;((te.subTree = q),
            g(Z, q, d(Z.el), Ee(Z), te, J, H),
            (Q.el = q.el),
            E === null && n9(te, q.el),
            X && ji(X, J),
            (N = Q.props && Q.props.onVnodeUpdated) && ji(() => Rs(N, ue, Q, z), J))
        } else {
          let Q
          const { el: G, props: X } = re,
            { bm: ue, m: z, parent: E, root: N, type: q } = te,
            Z = Ld(re)
          ;(Za(te, !1),
            ue && q0(ue),
            !Z && (Q = X && X.onVnodeBeforeMount) && Rs(Q, E, re),
            Za(te, !0))
          {
            N.ce && N.ce._def.shadowRoot !== !1 && N.ce._injectChildStyle(q)
            const $ = (te.subTree = k2(te))
            ;(g(null, $, b, oe, te, J, H), (re.el = $.el))
          }
          if ((z && ji(z, J), !Z && (Q = X && X.onVnodeMounted))) {
            const $ = re
            ji(() => Rs(Q, E, $), J)
          }
          ;((re.shapeFlag & 256 || (E && Ld(E.vnode) && E.vnode.shapeFlag & 256)) &&
            te.a &&
            ji(te.a, J),
            (te.isMounted = !0),
            (re = b = oe = null))
        }
      }
      te.scope.on()
      const j = (te.effect = new jT(k))
      te.scope.off()
      const B = (te.update = j.run.bind(j)),
        D = (te.job = j.runIfDirty.bind(j))
      ;((D.i = te), (D.id = te.uid), (j.scheduler = () => i_(D)), Za(te, !0), B())
    },
    W = (te, re, b) => {
      re.component = te
      const oe = te.vnode.props
      ;((te.vnode = re),
        (te.next = null),
        U8(te, re.props, oe, b),
        H8(te, re.children, b),
        Qo(),
        E2(te),
        jo())
    },
    ee = (te, re, b, oe, J, H, P, k, j = !1) => {
      const B = te && te.children,
        D = te ? te.shapeFlag : 0,
        Q = re.children,
        { patchFlag: G, shapeFlag: X } = re
      if (G > 0) {
        if (G & 128) {
          he(B, Q, b, oe, J, H, P, k, j)
          return
        } else if (G & 256) {
          se(B, Q, b, oe, J, H, P, k, j)
          return
        }
      }
      X & 8
        ? (D & 16 && we(B, J, H), Q !== B && u(b, Q))
        : D & 16
          ? X & 16
            ? he(B, Q, b, oe, J, H, P, k, j)
            : we(B, J, H, !0)
          : (D & 8 && u(b, ''), X & 16 && R(Q, b, oe, J, H, P, k, j))
    },
    se = (te, re, b, oe, J, H, P, k, j) => {
      ;((te = te || Vc), (re = re || Vc))
      const B = te.length,
        D = re.length,
        Q = Math.min(B, D)
      let G
      for (G = 0; G < Q; G++) {
        const X = (re[G] = j ? _a(re[G]) : zs(re[G]))
        g(te[G], X, b, null, J, H, P, k, j)
      }
      B > D ? we(te, J, H, !0, !1, Q) : R(re, b, oe, J, H, P, k, j, Q)
    },
    he = (te, re, b, oe, J, H, P, k, j) => {
      let B = 0
      const D = re.length
      let Q = te.length - 1,
        G = D - 1
      for (; B <= Q && B <= G; ) {
        const X = te[B],
          ue = (re[B] = j ? _a(re[B]) : zs(re[B]))
        if (wc(X, ue)) g(X, ue, b, null, J, H, P, k, j)
        else break
        B++
      }
      for (; B <= Q && B <= G; ) {
        const X = te[Q],
          ue = (re[G] = j ? _a(re[G]) : zs(re[G]))
        if (wc(X, ue)) g(X, ue, b, null, J, H, P, k, j)
        else break
        ;(Q--, G--)
      }
      if (B > Q) {
        if (B <= G) {
          const X = G + 1,
            ue = X < D ? re[X].el : oe
          for (; B <= G; ) (g(null, (re[B] = j ? _a(re[B]) : zs(re[B])), b, ue, J, H, P, k, j), B++)
        }
      } else if (B > G) for (; B <= Q; ) (ie(te[B], J, H, !0), B++)
      else {
        const X = B,
          ue = B,
          z = new Map()
        for (B = ue; B <= G; B++) {
          const Le = (re[B] = j ? _a(re[B]) : zs(re[B]))
          Le.key != null && z.set(Le.key, B)
        }
        let E,
          N = 0
        const q = G - ue + 1
        let Z = !1,
          $ = 0
        const ae = new Array(q)
        for (B = 0; B < q; B++) ae[B] = 0
        for (B = X; B <= Q; B++) {
          const Le = te[B]
          if (N >= q) {
            ie(Le, J, H, !0)
            continue
          }
          let Ve
          if (Le.key != null) Ve = z.get(Le.key)
          else
            for (E = ue; E <= G; E++)
              if (ae[E - ue] === 0 && wc(Le, re[E])) {
                Ve = E
                break
              }
          Ve === void 0
            ? ie(Le, J, H, !0)
            : ((ae[Ve - ue] = B + 1),
              Ve >= $ ? ($ = Ve) : (Z = !0),
              g(Le, re[Ve], b, null, J, H, P, k, j),
              N++)
        }
        const Ue = Z ? Q8(ae) : Vc
        for (E = Ue.length - 1, B = q - 1; B >= 0; B--) {
          const Le = ue + B,
            Ve = re[Le],
            Je = re[Le + 1],
            rt = Le + 1 < D ? Je.el || Je.placeholder : oe
          ae[B] === 0
            ? g(null, Ve, b, rt, J, H, P, k, j)
            : Z && (E < 0 || B !== Ue[E] ? ne(Ve, b, rt, 2) : E--)
        }
      }
    },
    ne = (te, re, b, oe, J = null) => {
      const { el: H, type: P, transition: k, children: j, shapeFlag: B } = te
      if (B & 6) {
        ne(te.component.subTree, re, b, oe)
        return
      }
      if (B & 128) {
        te.suspense.move(re, b, oe)
        return
      }
      if (B & 64) {
        P.move(te, re, b, Be)
        return
      }
      if (P === Hn) {
        i(H, re, b)
        for (let Q = 0; Q < j.length; Q++) ne(j[Q], re, b, oe)
        i(te.anchor, re, b)
        return
      }
      if (P === xp) {
        x(te, re, b)
        return
      }
      if (oe !== 2 && B & 1 && k)
        if (oe === 0) (k.beforeEnter(H), i(H, re, b), ji(() => k.enter(H), J))
        else {
          const { leave: Q, delayLeave: G, afterLeave: X } = k,
            ue = () => {
              te.ctx.isUnmounted ? r(H) : i(H, re, b)
            },
            z = () => {
              ;(H._isLeaving && H[pl](!0),
                Q(H, () => {
                  ;(ue(), X && X())
                }))
            }
          G ? G(H, ue, z) : z()
        }
      else i(H, re, b)
    },
    ie = (te, re, b, oe = !1, J = !1) => {
      const {
        type: H,
        props: P,
        ref: k,
        children: j,
        dynamicChildren: B,
        shapeFlag: D,
        patchFlag: Q,
        dirs: G,
        cacheIndex: X,
      } = te
      if (
        (Q === -2 && (J = !1),
        k != null && (Qo(), Pd(k, null, b, te, !0), jo()),
        X != null && (re.renderCache[X] = void 0),
        D & 256)
      ) {
        re.ctx.deactivate(te)
        return
      }
      const ue = D & 1 && G,
        z = !Ld(te)
      let E
      if ((z && (E = P && P.onVnodeBeforeUnmount) && Rs(E, re, te), D & 6)) fe(te.component, b, oe)
      else {
        if (D & 128) {
          te.suspense.unmount(b, oe)
          return
        }
        ;(ue && Ya(te, null, re, 'beforeUnmount'),
          D & 64
            ? te.type.remove(te, re, b, Be, oe)
            : B && !B.hasOnce && (H !== Hn || (Q > 0 && Q & 64))
              ? we(B, re, b, !1, !0)
              : ((H === Hn && Q & 384) || (!J && D & 16)) && we(j, re, b),
          oe && be(te))
      }
      ;((z && (E = P && P.onVnodeUnmounted)) || ue) &&
        ji(() => {
          ;(E && Rs(E, re, te), ue && Ya(te, null, re, 'unmounted'))
        }, b)
    },
    be = (te) => {
      const { type: re, el: b, anchor: oe, transition: J } = te
      if (re === Hn) {
        le(b, oe)
        return
      }
      if (re === xp) {
        _(te)
        return
      }
      const H = () => {
        ;(r(b), J && !J.persisted && J.afterLeave && J.afterLeave())
      }
      if (te.shapeFlag & 1 && J && !J.persisted) {
        const { leave: P, delayLeave: k } = J,
          j = () => P(b, H)
        k ? k(te.el, H, j) : j()
      } else H()
    },
    le = (te, re) => {
      let b
      for (; te !== re; ) ((b = h(te)), r(te), (te = b))
      r(re)
    },
    fe = (te, re, b) => {
      const { bum: oe, scope: J, job: H, subTree: P, um: k, m: j, a: B } = te
      ;(U2(j),
        U2(B),
        oe && q0(oe),
        J.stop(),
        H && ((H.flags |= 8), ie(P, te, re, b)),
        k && ji(k, re),
        ji(() => {
          te.isUnmounted = !0
        }, re))
    },
    we = (te, re, b, oe = !1, J = !1, H = 0) => {
      for (let P = H; P < te.length; P++) ie(te[P], re, b, oe, J)
    },
    Ee = (te) => {
      if (te.shapeFlag & 6) return Ee(te.component.subTree)
      if (te.shapeFlag & 128) return te.suspense.next()
      const re = h(te.anchor || te.el),
        b = re && re[yw]
      return b ? h(b) : re
    }
  let Ie = !1
  const ze = (te, re, b) => {
      ;(te == null
        ? re._vnode && ie(re._vnode, null, null, !0)
        : g(re._vnode || null, te, re, null, null, null, b),
        (re._vnode = te),
        Ie || ((Ie = !0), E2(), fw(), (Ie = !1)))
    },
    Be = { p: g, um: ie, m: ne, r: be, mt: T, mc: R, pc: ee, pbc: M, n: Ee, o: n }
  return { render: ze, hydrate: void 0, createApp: F8(ze) }
}
function eg({ type: n, props: e }, t) {
  return (t === 'svg' && n === 'foreignObject') ||
    (t === 'mathml' && n === 'annotation-xml' && e && e.encoding && e.encoding.includes('html'))
    ? void 0
    : t
}
function Za({ effect: n, job: e }, t) {
  t ? ((n.flags |= 32), (e.flags |= 4)) : ((n.flags &= -33), (e.flags &= -5))
}
function W8(n, e) {
  return (!n || (n && !n.pendingBranch)) && e && !e.persisted
}
function a_(n, e, t = !1) {
  const i = n.children,
    r = e.children
  if (vt(i) && vt(r))
    for (let s = 0; s < i.length; s++) {
      const o = i[s]
      let a = r[s]
      ;(a.shapeFlag & 1 &&
        !a.dynamicChildren &&
        ((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = r[s] = _a(r[s])), (a.el = o.el)),
        !t && a.patchFlag !== -2 && a_(o, a)),
        a.type === Nu && a.patchFlag !== -1 && (a.el = o.el),
        a.type === Js && !a.el && (a.el = o.el))
    }
}
function Q8(n) {
  const e = n.slice(),
    t = [0]
  let i, r, s, o, a
  const l = n.length
  for (i = 0; i < l; i++) {
    const c = n[i]
    if (c !== 0) {
      if (((r = t[t.length - 1]), n[r] < c)) {
        ;((e[i] = r), t.push(i))
        continue
      }
      for (s = 0, o = t.length - 1; s < o; )
        ((a = (s + o) >> 1), n[t[a]] < c ? (s = a + 1) : (o = a))
      c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]), (t[s] = i))
    }
  }
  for (s = t.length, o = t[s - 1]; s-- > 0; ) ((t[s] = o), (o = e[o]))
  return t
}
function zw(n) {
  const e = n.subTree.component
  if (e) return e.asyncDep && !e.asyncResolved ? e : zw(e)
}
function U2(n) {
  if (n) for (let e = 0; e < n.length; e++) n[e].flags |= 8
}
const j8 = Symbol.for('v-scx'),
  q8 = () => Zi(j8)
function t0(n, e) {
  return l_(n, null, e)
}
function Jn(n, e, t) {
  return l_(n, e, t)
}
function l_(n, e, t = un) {
  const { immediate: i, deep: r, flush: s, once: o } = t,
    a = ti({}, t),
    l = (e && i) || (!e && s !== 'post')
  let c
  if (ih) {
    if (s === 'sync') {
      const f = q8()
      c = f.__watcherHandles || (f.__watcherHandles = [])
    } else if (!l) {
      const f = () => {}
      return ((f.stop = qs), (f.resume = qs), (f.pause = qs), f)
    }
  }
  const u = Li
  a.call = (f, p, g) => As(f, u, p, g)
  let d = !1
  ;(s === 'post'
    ? (a.scheduler = (f) => {
        ji(f, u && u.suspense)
      })
    : s !== 'sync' &&
      ((d = !0),
      (a.scheduler = (f, p) => {
        p ? f() : i_(f)
      })),
    (a.augmentJob = (f) => {
      ;(e && (f.flags |= 4), d && ((f.flags |= 2), u && ((f.id = u.uid), (f.i = u))))
    }))
  const h = l8(n, e, a)
  return (ih && (c ? c.push(h) : l && h()), h)
}
function X8(n, e, t) {
  const i = this.proxy,
    r = wn(n) ? (n.includes('.') ? Vw(i, n) : () => i[n]) : n.bind(i, i)
  let s
  wt(e) ? (s = e) : ((s = e.handler), (t = e))
  const o = Oh(this),
    a = l_(r, s.bind(i), t)
  return (o(), a)
}
function Vw(n, e) {
  const t = e.split('.')
  return () => {
    let i = n
    for (let r = 0; r < t.length && i; r++) i = i[t[r]]
    return i
  }
}
const K8 = (n, e) =>
  e === 'modelValue' || e === 'model-value'
    ? n.modelModifiers
    : n[''.concat(e, 'Modifiers')] ||
      n[''.concat(ns(e), 'Modifiers')] ||
      n[''.concat(Ql(e), 'Modifiers')]
function Y8(n, e, ...t) {
  if (n.isUnmounted) return
  const i = n.vnode.props || un
  let r = t
  const s = e.startsWith('update:'),
    o = s && K8(i, e.slice(7))
  o && (o.trim && (r = t.map((u) => (wn(u) ? u.trim() : u))), o.number && (r = t.map(bI)))
  let a,
    l = i[(a = j0(e))] || i[(a = j0(ns(e)))]
  ;(!l && s && (l = i[(a = j0(Ql(e)))]), l && As(l, n, 6, r))
  const c = i[a + 'Once']
  if (c) {
    if (!n.emitted) n.emitted = {}
    else if (n.emitted[a]) return
    ;((n.emitted[a] = !0), As(c, n, 6, r))
  }
}
const Z8 = new WeakMap()
function Hw(n, e, t = !1) {
  const i = t ? Z8 : e.emitsCache,
    r = i.get(n)
  if (r !== void 0) return r
  const s = n.emits
  let o = {},
    a = !1
  if (!wt(n)) {
    const l = (c) => {
      const u = Hw(c, e, !0)
      u && ((a = !0), ti(o, u))
    }
    ;(!t && e.mixins.length && e.mixins.forEach(l),
      n.extends && l(n.extends),
      n.mixins && n.mixins.forEach(l))
  }
  return !s && !a
    ? (gn(n) && i.set(n, null), null)
    : (vt(s) ? s.forEach((l) => (o[l] = null)) : ti(o, s), gn(n) && i.set(n, o), o)
}
function n0(n, e) {
  return !n || !Qm(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, '')),
      tn(n, e[0].toLowerCase() + e.slice(1)) || tn(n, Ql(e)) || tn(n, e))
}
function k2(n) {
  const {
      type: e,
      vnode: t,
      proxy: i,
      withProxy: r,
      propsOptions: [s],
      slots: o,
      attrs: a,
      emit: l,
      render: c,
      renderCache: u,
      props: d,
      data: h,
      setupState: f,
      ctx: p,
      inheritAttrs: g,
    } = n,
    y = tm(n)
  let m, v
  try {
    if (t.shapeFlag & 4) {
      const _ = r || i,
        S = _
      ;((m = zs(c.call(S, _, u, d, f, h, p))), (v = a))
    } else {
      const _ = e
      ;((m = zs(_.length > 1 ? _(d, { attrs: a, slots: o, emit: l }) : _(d, null))),
        (v = e.props ? a : J8(a)))
    }
  } catch (_) {
    ;((Fd.length = 0), Zm(_, n, 1), (m = Te(Js)))
  }
  let x = m
  if (v && g !== !1) {
    const _ = Object.keys(v),
      { shapeFlag: S } = x
    _.length && S & 7 && (s && _.some(Wv) && (v = e9(v, s)), (x = qo(x, v, !1, !0)))
  }
  return (
    t.dirs && ((x = qo(x, null, !1, !0)), (x.dirs = x.dirs ? x.dirs.concat(t.dirs) : t.dirs)),
    t.transition && eh(x, t.transition),
    (m = x),
    tm(y),
    m
  )
}
const J8 = (n) => {
    let e
    for (const t in n) (t === 'class' || t === 'style' || Qm(t)) && ((e || (e = {}))[t] = n[t])
    return e
  },
  e9 = (n, e) => {
    const t = {}
    for (const i in n) (!Wv(i) || !(i.slice(9) in e)) && (t[i] = n[i])
    return t
  }
function t9(n, e, t) {
  const { props: i, children: r, component: s } = n,
    { props: o, children: a, patchFlag: l } = e,
    c = s.emitsOptions
  if (e.dirs || e.transition) return !0
  if (t && l >= 0) {
    if (l & 1024) return !0
    if (l & 16) return i ? z2(i, o, c) : !!o
    if (l & 8) {
      const u = e.dynamicProps
      for (let d = 0; d < u.length; d++) {
        const h = u[d]
        if (o[h] !== i[h] && !n0(c, h)) return !0
      }
    }
  } else
    return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? (o ? z2(i, o, c) : !0) : !!o
  return !1
}
function z2(n, e, t) {
  const i = Object.keys(e)
  if (i.length !== Object.keys(n).length) return !0
  for (let r = 0; r < i.length; r++) {
    const s = i[r]
    if (e[s] !== n[s] && !n0(t, s)) return !0
  }
  return !1
}
function n9({ vnode: n, parent: e }, t) {
  for (; e; ) {
    const i = e.subTree
    if ((i.suspense && i.suspense.activeBranch === n && (i.el = n.el), i === n))
      (((n = e.vnode).el = t), (e = e.parent))
    else break
  }
}
const $w = (n) => n.__isSuspense
function i9(n, e) {
  e && e.pendingBranch ? (vt(n) ? e.effects.push(...n) : e.effects.push(n)) : d8(n)
}
const Hn = Symbol.for('v-fgt'),
  Nu = Symbol.for('v-txt'),
  Js = Symbol.for('v-cmt'),
  xp = Symbol.for('v-stc'),
  Fd = []
let Mr = null
function mt(n = !1) {
  Fd.push((Mr = n ? null : []))
}
function r9() {
  ;(Fd.pop(), (Mr = Fd[Fd.length - 1] || null))
}
let nh = 1
function sm(n, e = !1) {
  ;((nh += n), n < 0 && Mr && e && (Mr.hasOnce = !0))
}
function Gw(n) {
  return ((n.dynamicChildren = nh > 0 ? Mr || Vc : null), r9(), nh > 0 && Mr && Mr.push(n), n)
}
function Ct(n, e, t, i, r, s) {
  return Gw(kt(n, e, t, i, r, s, !0))
}
function ou(n, e, t, i, r) {
  return Gw(Te(n, e, t, i, r, !0))
}
function au(n) {
  return n ? n.__v_isVNode === !0 : !1
}
function wc(n, e) {
  return n.type === e.type && n.key === e.key
}
const Ww = ({ key: n }) => (n != null ? n : null),
  Sp = ({ ref: n, ref_key: e, ref_for: t }) => (
    typeof n == 'number' && (n = '' + n),
    n != null ? (wn(n) || bn(n) || wt(n) ? { i: Er, r: n, k: e, f: !!t } : n) : null
  )
function kt(n, e = null, t = null, i = 0, r = null, s = n === Hn ? 0 : 1, o = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && Ww(e),
    ref: e && Sp(e),
    scopeId: mw,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Er,
  }
  return (
    a ? (c_(l, t), s & 128 && n.normalize(l)) : t && (l.shapeFlag |= wn(t) ? 8 : 16),
    nh > 0 && !o && Mr && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Mr.push(l),
    l
  )
}
const Te = s9
function s9(n, e = null, t = null, i = 0, r = null, s = !1) {
  if (((!n || n === Ew) && (n = Js), au(n))) {
    const a = qo(n, e, !0)
    return (
      t && c_(a, t),
      nh > 0 && !s && Mr && (a.shapeFlag & 6 ? (Mr[Mr.indexOf(n)] = a) : Mr.push(a)),
      (a.patchFlag = -2),
      a
    )
  }
  if ((g9(n) && (n = n.__vccOpts), e)) {
    e = o9(e)
    let { class: a, style: l } = e
    ;(a && !wn(a) && (e.class = Wo(a)),
      gn(l) && (t_(l) && !vt(l) && (l = ti({}, l)), (e.style = Go(l))))
  }
  const o = wn(n) ? 1 : $w(n) ? 128 : h8(n) ? 64 : gn(n) ? 4 : wt(n) ? 2 : 0
  return kt(n, e, t, i, r, o, s, !0)
}
function o9(n) {
  return n ? (t_(n) || Dw(n) ? ti({}, n) : n) : null
}
function qo(n, e, t = !1, i = !1) {
  const { props: r, ref: s, patchFlag: o, children: a, transition: l } = n,
    c = e ? a9(r || {}, e) : r,
    u = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: n.type,
      props: c,
      key: c && Ww(c),
      ref: e && e.ref ? (t && s ? (vt(s) ? s.concat(Sp(e)) : [s, Sp(e)]) : Sp(e)) : s,
      scopeId: n.scopeId,
      slotScopeIds: n.slotScopeIds,
      children: a,
      target: n.target,
      targetStart: n.targetStart,
      targetAnchor: n.targetAnchor,
      staticCount: n.staticCount,
      shapeFlag: n.shapeFlag,
      patchFlag: e && n.type !== Hn ? (o === -1 ? 16 : o | 16) : o,
      dynamicProps: n.dynamicProps,
      dynamicChildren: n.dynamicChildren,
      appContext: n.appContext,
      dirs: n.dirs,
      transition: l,
      component: n.component,
      suspense: n.suspense,
      ssContent: n.ssContent && qo(n.ssContent),
      ssFallback: n.ssFallback && qo(n.ssFallback),
      placeholder: n.placeholder,
      el: n.el,
      anchor: n.anchor,
      ctx: n.ctx,
      ce: n.ce,
    }
  return (l && i && eh(u, l.clone(u)), u)
}
function om(n = ' ', e = 0) {
  return Te(Nu, null, n, e)
}
function Pu(n, e) {
  const t = Te(xp, null, n)
  return ((t.staticCount = e), t)
}
function qr(n = '', e = !1) {
  return e ? (mt(), ou(Js, null, n)) : Te(Js, null, n)
}
function zs(n) {
  return n == null || typeof n == 'boolean'
    ? Te(Js)
    : vt(n)
      ? Te(Hn, null, n.slice())
      : au(n)
        ? _a(n)
        : Te(Nu, null, String(n))
}
function _a(n) {
  return (n.el === null && n.patchFlag !== -1) || n.memo ? n : qo(n)
}
function c_(n, e) {
  let t = 0
  const { shapeFlag: i } = n
  if (e == null) e = null
  else if (vt(e)) t = 16
  else if (typeof e == 'object')
    if (i & 65) {
      const r = e.default
      r && (r._c && (r._d = !1), c_(n, r()), r._c && (r._d = !0))
      return
    } else {
      t = 32
      const r = e._
      !r && !Dw(e)
        ? (e._ctx = Er)
        : r === 3 && Er && (Er.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (n.patchFlag |= 1024)))
    }
  else
    wt(e)
      ? ((e = { default: e, _ctx: Er }), (t = 32))
      : ((e = String(e)), i & 64 ? ((t = 16), (e = [om(e)])) : (t = 8))
  ;((n.children = e), (n.shapeFlag |= t))
}
function a9(...n) {
  const e = {}
  for (let t = 0; t < n.length; t++) {
    const i = n[t]
    for (const r in i)
      if (r === 'class') e.class !== i.class && (e.class = Wo([e.class, i.class]))
      else if (r === 'style') e.style = Go([e.style, i.style])
      else if (Qm(r)) {
        const s = e[r],
          o = i[r]
        o && s !== o && !(vt(s) && s.includes(o)) && (e[r] = s ? [].concat(s, o) : o)
      } else r !== '' && (e[r] = i[r])
  }
  return e
}
function Rs(n, e, t, i = null) {
  As(n, e, 7, [t, i])
}
const l9 = Nw()
let c9 = 0
function u9(n, e, t) {
  const i = n.type,
    r = (e ? e.appContext : n.appContext) || l9,
    s = {
      uid: c9++,
      vnode: n,
      type: i,
      parent: e,
      appContext: r,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new WT(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(r.provides),
      ids: e ? e.ids : ['', 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: Ow(i, r),
      emitsOptions: Hw(i, r),
      emit: null,
      emitted: null,
      propsDefaults: un,
      inheritAttrs: i.inheritAttrs,
      ctx: un,
      data: un,
      props: un,
      attrs: un,
      slots: un,
      refs: un,
      setupState: un,
      setupContext: null,
      suspense: t,
      suspenseId: t ? t.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    }
  return (
    (s.ctx = { _: s }),
    (s.root = e ? e.root : s),
    (s.emit = Y8.bind(null, s)),
    n.ce && n.ce(s),
    s
  )
}
let Li = null
const bs = () => Li || Er
let am, X1
{
  const n = Km(),
    e = (t, i) => {
      let r
      return (
        (r = n[t]) || (r = n[t] = []),
        r.push(i),
        (s) => {
          r.length > 1 ? r.forEach((o) => o(s)) : r[0](s)
        }
      )
    }
  ;((am = e('__VUE_INSTANCE_SETTERS__', (t) => (Li = t))),
    (X1 = e('__VUE_SSR_SETTERS__', (t) => (ih = t))))
}
const Oh = (n) => {
    const e = Li
    return (
      am(n),
      n.scope.on(),
      () => {
        ;(n.scope.off(), am(e))
      }
    )
  },
  V2 = () => {
    ;(Li && Li.scope.off(), am(null))
  }
function Qw(n) {
  return n.vnode.shapeFlag & 4
}
let ih = !1
function d9(n, e = !1, t = !1) {
  e && X1(e)
  const { props: i, children: r } = n.vnode,
    s = Qw(n)
  ;(B8(n, i, s, e), V8(n, r, t || e))
  const o = s ? h9(n, e) : void 0
  return (e && X1(!1), o)
}
function h9(n, e) {
  const t = n.type
  ;((n.accessCache = Object.create(null)), (n.proxy = new Proxy(n.ctx, M8)))
  const { setup: i } = t
  if (i) {
    Qo()
    const r = (n.setupContext = i.length > 1 ? p9(n) : null),
      s = Oh(n),
      o = Lh(i, n, 0, [n.props, r]),
      a = UT(o)
    if ((jo(), s(), (a || n.sp) && !Ld(n) && Aw(n), a)) {
      if ((o.then(V2, V2), e))
        return o
          .then((l) => {
            H2(n, l)
          })
          .catch((l) => {
            Zm(l, n, 0)
          })
      n.asyncDep = o
    } else H2(n, o)
  } else jw(n)
}
function H2(n, e, t) {
  ;(wt(e)
    ? n.type.__ssrInlineRender
      ? (n.ssrRender = e)
      : (n.render = e)
    : gn(e) && (n.setupState = cw(e)),
    jw(n))
}
function jw(n, e, t) {
  const i = n.type
  n.render || (n.render = i.render || qs)
  {
    const r = Oh(n)
    Qo()
    try {
      R8(n)
    } finally {
      ;(jo(), r())
    }
  }
}
const f9 = {
  get(n, e) {
    return (Pi(n, 'get', ''), n[e])
  },
}
function p9(n) {
  const e = (t) => {
    n.exposed = t || {}
  }
  return { attrs: new Proxy(n.attrs, f9), slots: n.slots, emit: n.emit, expose: e }
}
function i0(n) {
  return n.exposed
    ? n.exposeProxy ||
        (n.exposeProxy = new Proxy(cw(n_(n.exposed)), {
          get(e, t) {
            if (t in e) return e[t]
            if (t in Dd) return Dd[t](n)
          },
          has(e, t) {
            return t in e || t in Dd
          },
        }))
    : n.proxy
}
function m9(n, e = !0) {
  return wt(n) ? n.displayName || n.name : n.name || (e && n.__name)
}
function g9(n) {
  return wt(n) && '__vccOpts' in n
}
const Ge = (n, e) => o8(n, e, ih)
function Ba(n, e, t) {
  const i = (s, o, a) => {
      sm(-1)
      try {
        return Te(s, o, a)
      } finally {
        sm(1)
      }
    },
    r = arguments.length
  return r === 2
    ? gn(e) && !vt(e)
      ? au(e)
        ? i(n, null, [e])
        : i(n, e)
      : i(n, null, e)
    : (r > 3 ? (t = Array.prototype.slice.call(arguments, 2)) : r === 3 && au(t) && (t = [t]),
      i(n, e, t))
}
const y9 = '3.5.21'
/**
 * @vue/runtime-dom v3.5.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let K1
const $2 = typeof window < 'u' && window.trustedTypes
if ($2)
  try {
    K1 = $2.createPolicy('vue', { createHTML: (n) => n })
  } catch (n) {}
const qw = K1 ? (n) => K1.createHTML(n) : (n) => n,
  v9 = 'http://www.w3.org/2000/svg',
  _9 = 'http://www.w3.org/1998/Math/MathML',
  To = typeof document < 'u' ? document : null,
  G2 = To && To.createElement('template'),
  x9 = {
    insert: (n, e, t) => {
      e.insertBefore(n, t || null)
    },
    remove: (n) => {
      const e = n.parentNode
      e && e.removeChild(n)
    },
    createElement: (n, e, t, i) => {
      const r =
        e === 'svg'
          ? To.createElementNS(v9, n)
          : e === 'mathml'
            ? To.createElementNS(_9, n)
            : t
              ? To.createElement(n, { is: t })
              : To.createElement(n)
      return (
        n === 'select' && i && i.multiple != null && r.setAttribute('multiple', i.multiple),
        r
      )
    },
    createText: (n) => To.createTextNode(n),
    createComment: (n) => To.createComment(n),
    setText: (n, e) => {
      n.nodeValue = e
    },
    setElementText: (n, e) => {
      n.textContent = e
    },
    parentNode: (n) => n.parentNode,
    nextSibling: (n) => n.nextSibling,
    querySelector: (n) => To.querySelector(n),
    setScopeId(n, e) {
      n.setAttribute(e, '')
    },
    insertStaticContent(n, e, t, i, r, s) {
      const o = t ? t.previousSibling : e.lastChild
      if (r && (r === s || r.nextSibling))
        for (; e.insertBefore(r.cloneNode(!0), t), !(r === s || !(r = r.nextSibling)); );
      else {
        G2.innerHTML = qw(
          i === 'svg'
            ? '<svg>'.concat(n, '</svg>')
            : i === 'mathml'
              ? '<math>'.concat(n, '</math>')
              : n
        )
        const a = G2.content
        if (i === 'svg' || i === 'mathml') {
          const l = a.firstChild
          for (; l.firstChild; ) a.appendChild(l.firstChild)
          a.removeChild(l)
        }
        e.insertBefore(a, t)
      }
      return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
    },
  },
  oa = 'transition',
  Ju = 'animation',
  lu = Symbol('_vtc'),
  Xw = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String,
  },
  S9 = ti({}, m8, Xw),
  Ja = (n, e = []) => {
    vt(n) ? n.forEach((t) => t(...e)) : n && n(...e)
  },
  W2 = (n) => (n ? (vt(n) ? n.some((e) => e.length > 1) : n.length > 1) : !1)
function A9(n) {
  const e = {}
  for (const L in n) L in Xw || (e[L] = n[L])
  if (n.css === !1) return e
  const {
      name: t = 'v',
      type: i,
      duration: r,
      enterFromClass: s = ''.concat(t, '-enter-from'),
      enterActiveClass: o = ''.concat(t, '-enter-active'),
      enterToClass: a = ''.concat(t, '-enter-to'),
      appearFromClass: l = s,
      appearActiveClass: c = o,
      appearToClass: u = a,
      leaveFromClass: d = ''.concat(t, '-leave-from'),
      leaveActiveClass: h = ''.concat(t, '-leave-active'),
      leaveToClass: f = ''.concat(t, '-leave-to'),
    } = n,
    p = b9(r),
    g = p && p[0],
    y = p && p[1],
    {
      onBeforeEnter: m,
      onEnter: v,
      onEnterCancelled: x,
      onLeave: _,
      onLeaveCancelled: S,
      onBeforeAppear: C = m,
      onAppear: A = v,
      onAppearCancelled: R = x,
    } = e,
    w = (L, U, T, F) => {
      ;((L._enterCancelled = F), ma(L, U ? u : a), ma(L, U ? c : o), T && T())
    },
    M = (L, U) => {
      ;((L._isLeaving = !1), ma(L, d), ma(L, f), ma(L, h), U && U())
    },
    I = (L) => (U, T) => {
      const F = L ? A : v,
        V = () => w(U, L, T)
      ;(Ja(F, [U, V]),
        Q2(() => {
          ;(ma(U, L ? l : s), Fs(U, L ? u : a), W2(F) || j2(U, i, g, V))
        }))
    }
  return ti(e, {
    onBeforeEnter(L) {
      ;(Ja(m, [L]), Fs(L, s), Fs(L, o))
    },
    onBeforeAppear(L) {
      ;(Ja(C, [L]), Fs(L, l), Fs(L, c))
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(L, U) {
      L._isLeaving = !0
      const T = () => M(L, U)
      ;(Fs(L, d),
        L._enterCancelled ? (Fs(L, h), Y1()) : (Y1(), Fs(L, h)),
        Q2(() => {
          L._isLeaving && (ma(L, d), Fs(L, f), W2(_) || j2(L, i, y, T))
        }),
        Ja(_, [L, T]))
    },
    onEnterCancelled(L) {
      ;(w(L, !1, void 0, !0), Ja(x, [L]))
    },
    onAppearCancelled(L) {
      ;(w(L, !0, void 0, !0), Ja(R, [L]))
    },
    onLeaveCancelled(L) {
      ;(M(L), Ja(S, [L]))
    },
  })
}
function b9(n) {
  if (n == null) return null
  if (gn(n)) return [tg(n.enter), tg(n.leave)]
  {
    const e = tg(n)
    return [e, e]
  }
}
function tg(n) {
  return TI(n)
}
function Fs(n, e) {
  ;(e.split(/\s+/).forEach((t) => t && n.classList.add(t)), (n[lu] || (n[lu] = new Set())).add(e))
}
function ma(n, e) {
  e.split(/\s+/).forEach((i) => i && n.classList.remove(i))
  const t = n[lu]
  t && (t.delete(e), t.size || (n[lu] = void 0))
}
function Q2(n) {
  requestAnimationFrame(() => {
    requestAnimationFrame(n)
  })
}
let T9 = 0
function j2(n, e, t, i) {
  const r = (n._endId = ++T9),
    s = () => {
      r === n._endId && i()
    }
  if (t != null) return setTimeout(s, t)
  const { type: o, timeout: a, propCount: l } = Kw(n, e)
  if (!o) return i()
  const c = o + 'end'
  let u = 0
  const d = () => {
      ;(n.removeEventListener(c, h), s())
    },
    h = (f) => {
      f.target === n && ++u >= l && d()
    }
  ;(setTimeout(() => {
    u < l && d()
  }, a + 1),
    n.addEventListener(c, h))
}
function Kw(n, e) {
  const t = window.getComputedStyle(n),
    i = (p) => (t[p] || '').split(', '),
    r = i(''.concat(oa, 'Delay')),
    s = i(''.concat(oa, 'Duration')),
    o = q2(r, s),
    a = i(''.concat(Ju, 'Delay')),
    l = i(''.concat(Ju, 'Duration')),
    c = q2(a, l)
  let u = null,
    d = 0,
    h = 0
  e === oa
    ? o > 0 && ((u = oa), (d = o), (h = s.length))
    : e === Ju
      ? c > 0 && ((u = Ju), (d = c), (h = l.length))
      : ((d = Math.max(o, c)),
        (u = d > 0 ? (o > c ? oa : Ju) : null),
        (h = u ? (u === oa ? s.length : l.length) : 0))
  const f = u === oa && /\b(?:transform|all)(?:,|$)/.test(i(''.concat(oa, 'Property')).toString())
  return { type: u, timeout: d, propCount: h, hasTransform: f }
}
function q2(n, e) {
  for (; n.length < e.length; ) n = n.concat(n)
  return Math.max(...e.map((t, i) => X2(t) + X2(n[i])))
}
function X2(n) {
  return n === 'auto' ? 0 : Number(n.slice(0, -1).replace(',', '.')) * 1e3
}
function Y1() {
  return document.body.offsetHeight
}
function w9(n, e, t) {
  const i = n[lu]
  ;(i && (e = (e ? [e, ...i] : [...i]).join(' ')),
    e == null ? n.removeAttribute('class') : t ? n.setAttribute('class', e) : (n.className = e))
}
const lm = Symbol('_vod'),
  Yw = Symbol('_vsh'),
  cm = {
    name: 'show',
    beforeMount(n, { value: e }, { transition: t }) {
      ;((n[lm] = n.style.display === 'none' ? '' : n.style.display),
        t && e ? t.beforeEnter(n) : ed(n, e))
    },
    mounted(n, { value: e }, { transition: t }) {
      t && e && t.enter(n)
    },
    updated(n, { value: e, oldValue: t }, { transition: i }) {
      !e != !t &&
        (i
          ? e
            ? (i.beforeEnter(n), ed(n, !0), i.enter(n))
            : i.leave(n, () => {
                ed(n, !1)
              })
          : ed(n, e))
    },
    beforeUnmount(n, { value: e }) {
      ed(n, e)
    },
  }
function ed(n, e) {
  ;((n.style.display = e ? n[lm] : 'none'), (n[Yw] = !e))
}
const C9 = Symbol(''),
  E9 = /(?:^|;)\s*display\s*:/
function M9(n, e, t) {
  const i = n.style,
    r = wn(t)
  let s = !1
  if (t && !r) {
    if (e)
      if (wn(e))
        for (const o of e.split(';')) {
          const a = o.slice(0, o.indexOf(':')).trim()
          t[a] == null && Ap(i, a, '')
        }
      else for (const o in e) t[o] == null && Ap(i, o, '')
    for (const o in t) (o === 'display' && (s = !0), Ap(i, o, t[o]))
  } else if (r) {
    if (e !== t) {
      const o = i[C9]
      ;(o && (t += ';' + o), (i.cssText = t), (s = E9.test(t)))
    }
  } else e && n.removeAttribute('style')
  lm in n && ((n[lm] = s ? i.display : ''), n[Yw] && (i.display = 'none'))
}
const K2 = /\s*!important$/
function Ap(n, e, t) {
  if (vt(t)) t.forEach((i) => Ap(n, e, i))
  else if ((t == null && (t = ''), e.startsWith('--'))) n.setProperty(e, t)
  else {
    const i = R9(n, e)
    K2.test(t) ? n.setProperty(Ql(i), t.replace(K2, ''), 'important') : (n[i] = t)
  }
}
const Y2 = ['Webkit', 'Moz', 'ms'],
  ng = {}
function R9(n, e) {
  const t = ng[e]
  if (t) return t
  let i = ns(e)
  if (i !== 'filter' && i in n) return (ng[e] = i)
  i = Xm(i)
  for (let r = 0; r < Y2.length; r++) {
    const s = Y2[r] + i
    if (s in n) return (ng[e] = s)
  }
  return e
}
const Z2 = 'http://www.w3.org/1999/xlink'
function J2(n, e, t, i, r, s = II(e)) {
  i && e.startsWith('xlink:')
    ? t == null
      ? n.removeAttributeNS(Z2, e.slice(6, e.length))
      : n.setAttributeNS(Z2, e, t)
    : t == null || (s && !HT(t))
      ? n.removeAttribute(e)
      : n.setAttribute(e, s ? '' : za(t) ? String(t) : t)
}
function eS(n, e, t, i, r) {
  if (e === 'innerHTML' || e === 'textContent') {
    t != null && (n[e] = e === 'innerHTML' ? qw(t) : t)
    return
  }
  const s = n.tagName
  if (e === 'value' && s !== 'PROGRESS' && !s.includes('-')) {
    const a = s === 'OPTION' ? n.getAttribute('value') || '' : n.value,
      l = t == null ? (n.type === 'checkbox' ? 'on' : '') : String(t)
    ;((a !== l || !('_value' in n)) && (n.value = l),
      t == null && n.removeAttribute(e),
      (n._value = t))
    return
  }
  let o = !1
  if (t === '' || t == null) {
    const a = typeof n[e]
    a === 'boolean'
      ? (t = HT(t))
      : t == null && a === 'string'
        ? ((t = ''), (o = !0))
        : a === 'number' && ((t = 0), (o = !0))
  }
  try {
    n[e] = t
  } catch (a) {}
  o && n.removeAttribute(r || e)
}
function I9(n, e, t, i) {
  n.addEventListener(e, t, i)
}
function N9(n, e, t, i) {
  n.removeEventListener(e, t, i)
}
const tS = Symbol('_vei')
function P9(n, e, t, i, r = null) {
  const s = n[tS] || (n[tS] = {}),
    o = s[e]
  if (i && o) o.value = i
  else {
    const [a, l] = L9(e)
    if (i) {
      const c = (s[e] = O9(i, r))
      I9(n, a, c, l)
    } else o && (N9(n, a, o, l), (s[e] = void 0))
  }
}
const nS = /(?:Once|Passive|Capture)$/
function L9(n) {
  let e
  if (nS.test(n)) {
    e = {}
    let i
    for (; (i = n.match(nS)); )
      ((n = n.slice(0, n.length - i[0].length)), (e[i[0].toLowerCase()] = !0))
  }
  return [n[2] === ':' ? n.slice(3) : Ql(n.slice(2)), e]
}
let ig = 0
const D9 = Promise.resolve(),
  F9 = () => ig || (D9.then(() => (ig = 0)), (ig = Date.now()))
function O9(n, e) {
  const t = (i) => {
    if (!i._vts) i._vts = Date.now()
    else if (i._vts <= t.attached) return
    As(B9(i, t.value), e, 5, [i])
  }
  return ((t.value = n), (t.attached = F9()), t)
}
function B9(n, e) {
  if (vt(e)) {
    const t = n.stopImmediatePropagation
    return (
      (n.stopImmediatePropagation = () => {
        ;(t.call(n), (n._stopped = !0))
      }),
      e.map((i) => (r) => !r._stopped && i && i(r))
    )
  } else return e
}
const iS = (n) =>
    n.charCodeAt(0) === 111 &&
    n.charCodeAt(1) === 110 &&
    n.charCodeAt(2) > 96 &&
    n.charCodeAt(2) < 123,
  U9 = (n, e, t, i, r, s) => {
    const o = r === 'svg'
    e === 'class'
      ? w9(n, i, o)
      : e === 'style'
        ? M9(n, t, i)
        : Qm(e)
          ? Wv(e) || P9(n, e, t, i, s)
          : (
                e[0] === '.'
                  ? ((e = e.slice(1)), !0)
                  : e[0] === '^'
                    ? ((e = e.slice(1)), !1)
                    : k9(n, e, i, o)
              )
            ? (eS(n, e, i),
              !n.tagName.includes('-') &&
                (e === 'value' || e === 'checked' || e === 'selected') &&
                J2(n, e, i, o, s, e !== 'value'))
            : n._isVueCE && (/[A-Z]/.test(e) || !wn(i))
              ? eS(n, ns(e), i, s, e)
              : (e === 'true-value'
                  ? (n._trueValue = i)
                  : e === 'false-value' && (n._falseValue = i),
                J2(n, e, i, o))
  }
function k9(n, e, t, i) {
  if (i) return !!(e === 'innerHTML' || e === 'textContent' || (e in n && iS(e) && wt(t)))
  if (
    e === 'spellcheck' ||
    e === 'draggable' ||
    e === 'translate' ||
    e === 'autocorrect' ||
    e === 'form' ||
    (e === 'list' && n.tagName === 'INPUT') ||
    (e === 'type' && n.tagName === 'TEXTAREA')
  )
    return !1
  if (e === 'width' || e === 'height') {
    const r = n.tagName
    if (r === 'IMG' || r === 'VIDEO' || r === 'CANVAS' || r === 'SOURCE') return !1
  }
  return iS(e) && wn(t) ? !1 : e in n
}
const Zw = new WeakMap(),
  Jw = new WeakMap(),
  um = Symbol('_moveCb'),
  rS = Symbol('_enterCb'),
  z9 = (n) => (delete n.props.mode, n),
  V9 = z9({
    name: 'TransitionGroup',
    props: ti({}, S9, { tag: String, moveClass: String }),
    setup(n, { slots: e }) {
      const t = bs(),
        i = p8()
      let r, s
      return (
        r_(() => {
          if (!r.length) return
          const o = n.moveClass || ''.concat(n.name || 'v', '-move')
          if (!W9(r[0].el, t.vnode.el, o)) {
            r = []
            return
          }
          ;(r.forEach(H9), r.forEach($9))
          const a = r.filter(G9)
          ;(Y1(),
            a.forEach((l) => {
              const c = l.el,
                u = c.style
              ;(Fs(c, o), (u.transform = u.webkitTransform = u.transitionDuration = ''))
              const d = (c[um] = (h) => {
                ;(h && h.target !== c) ||
                  ((!h || h.propertyName.endsWith('transform')) &&
                    (c.removeEventListener('transitionend', d), (c[um] = null), ma(c, o)))
              })
              c.addEventListener('transitionend', d)
            }),
            (r = []))
        }),
        () => {
          const o = Ot(n),
            a = A9(o)
          let l = o.tag || Hn
          if (((r = []), s))
            for (let c = 0; c < s.length; c++) {
              const u = s[c]
              u.el &&
                u.el instanceof Element &&
                (r.push(u), eh(u, G1(u, a, i, t)), Zw.set(u, u.el.getBoundingClientRect()))
            }
          s = e.default ? Sw(e.default()) : []
          for (let c = 0; c < s.length; c++) {
            const u = s[c]
            u.key != null && eh(u, G1(u, a, i, t))
          }
          return Te(l, null, s)
        }
      )
    },
  }),
  e5 = V9
function H9(n) {
  const e = n.el
  ;(e[um] && e[um](), e[rS] && e[rS]())
}
function $9(n) {
  Jw.set(n, n.el.getBoundingClientRect())
}
function G9(n) {
  const e = Zw.get(n),
    t = Jw.get(n),
    i = e.left - t.left,
    r = e.top - t.top
  if (i || r) {
    const s = n.el.style
    return (
      (s.transform = s.webkitTransform = 'translate('.concat(i, 'px,').concat(r, 'px)')),
      (s.transitionDuration = '0s'),
      n
    )
  }
}
function W9(n, e, t) {
  const i = n.cloneNode(),
    r = n[lu]
  ;(r &&
    r.forEach((a) => {
      a.split(/\s+/).forEach((l) => l && i.classList.remove(l))
    }),
    t.split(/\s+/).forEach((a) => a && i.classList.add(a)),
    (i.style.display = 'none'))
  const s = e.nodeType === 1 ? e : e.parentNode
  s.appendChild(i)
  const { hasTransform: o } = Kw(i)
  return (s.removeChild(i), o)
}
const Q9 = ['ctrl', 'shift', 'alt', 'meta'],
  j9 = {
    stop: (n) => n.stopPropagation(),
    prevent: (n) => n.preventDefault(),
    self: (n) => n.target !== n.currentTarget,
    ctrl: (n) => !n.ctrlKey,
    shift: (n) => !n.shiftKey,
    alt: (n) => !n.altKey,
    meta: (n) => !n.metaKey,
    left: (n) => 'button' in n && n.button !== 0,
    middle: (n) => 'button' in n && n.button !== 1,
    right: (n) => 'button' in n && n.button !== 2,
    exact: (n, e) => Q9.some((t) => n[''.concat(t, 'Key')] && !e.includes(t)),
  },
  vf = (n, e) => {
    const t = n._withMods || (n._withMods = {}),
      i = e.join('.')
    return (
      t[i] ||
      (t[i] = (r, ...s) => {
        for (let o = 0; o < e.length; o++) {
          const a = j9[e[o]]
          if (a && a(r, e)) return
        }
        return n(r, ...s)
      })
    )
  },
  q9 = ti({ patchProp: U9 }, x9)
let sS
function t5() {
  return sS || (sS = $8(q9))
}
const oS = (...n) => {
    t5().render(...n)
  },
  X9 = (...n) => {
    const e = t5().createApp(...n),
      { mount: t } = e
    return (
      (e.mount = (i) => {
        const r = Y9(i)
        if (!r) return
        const s = e._component
        ;(!wt(s) && !s.render && !s.template && (s.template = r.innerHTML),
          r.nodeType === 1 && (r.textContent = ''))
        const o = t(r, !1, K9(r))
        return (
          r instanceof Element && (r.removeAttribute('v-cloak'), r.setAttribute('data-v-app', '')),
          o
        )
      }),
      e
    )
  }
function K9(n) {
  if (n instanceof SVGElement) return 'svg'
  if (typeof MathMLElement == 'function' && n instanceof MathMLElement) return 'mathml'
}
function Y9(n) {
  return wn(n) ? document.querySelector(n) : n
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */ let n5
const r0 = (n) => (n5 = n),
  i5 = Symbol()
function Z1(n) {
  return (
    n &&
    typeof n == 'object' &&
    Object.prototype.toString.call(n) === '[object Object]' &&
    typeof n.toJSON != 'function'
  )
}
var Od
;(function (n) {
  ;((n.direct = 'direct'), (n.patchObject = 'patch object'), (n.patchFunction = 'patch function'))
})(Od || (Od = {}))
function Z9() {
  const n = qv(!0),
    e = n.run(() => Dn({}))
  let t = [],
    i = []
  const r = n_({
    install(s) {
      ;(r0(r),
        (r._a = s),
        s.provide(i5, r),
        (s.config.globalProperties.$pinia = r),
        i.forEach((o) => t.push(o)),
        (i = []))
    },
    use(s) {
      return (this._a ? t.push(s) : i.push(s), this)
    },
    _p: t,
    _a: null,
    _e: n,
    _s: new Map(),
    state: e,
  })
  return r
}
const r5 = () => {}
function aS(n, e, t, i = r5) {
  n.push(e)
  const r = () => {
    const s = n.indexOf(e)
    s > -1 && (n.splice(s, 1), i())
  }
  return (!t && QT() && NI(r), r)
}
function Jl(n, ...e) {
  n.slice().forEach((t) => {
    t(...e)
  })
}
const J9 = (n) => n(),
  lS = Symbol(),
  rg = Symbol()
function J1(n, e) {
  n instanceof Map && e instanceof Map
    ? e.forEach((t, i) => n.set(i, t))
    : n instanceof Set && e instanceof Set && e.forEach(n.add, n)
  for (const t in e) {
    if (!e.hasOwnProperty(t)) continue
    const i = e[t],
      r = n[t]
    Z1(r) && Z1(i) && n.hasOwnProperty(t) && !bn(i) && !ko(i) ? (n[t] = J1(r, i)) : (n[t] = i)
  }
  return n
}
const eN = Symbol()
function tN(n) {
  return !Z1(n) || !Object.prototype.hasOwnProperty.call(n, eN)
}
const { assign: ga } = Object
function nN(n) {
  return !!(bn(n) && n.effect)
}
function iN(n, e, t, i) {
  const { state: r, actions: s, getters: o } = e,
    a = t.state.value[n]
  let l
  function c() {
    a || (t.state.value[n] = r ? r() : {})
    const u = t8(t.state.value[n])
    return ga(
      u,
      s,
      Object.keys(o || {}).reduce(
        (d, h) => (
          (d[h] = n_(
            Ge(() => {
              r0(t)
              const f = t._s.get(n)
              return o[h].call(f, f)
            })
          )),
          d
        ),
        {}
      )
    )
  }
  return ((l = s5(n, c, e, t, i, !0)), l)
}
function s5(n, e, t = {}, i, r, s) {
  let o
  const a = ga({ actions: {} }, t),
    l = { deep: !0 }
  let c,
    u,
    d = [],
    h = [],
    f
  const p = i.state.value[n]
  ;(!s && !p && (i.state.value[n] = {}), Dn({}))
  let g
  function y(R) {
    let w
    ;((c = u = !1),
      typeof R == 'function'
        ? (R(i.state.value[n]), (w = { type: Od.patchFunction, storeId: n, events: f }))
        : (J1(i.state.value[n], R),
          (w = { type: Od.patchObject, payload: R, storeId: n, events: f })))
    const M = (g = Symbol())
    ;(Dh().then(() => {
      g === M && (c = !0)
    }),
      (u = !0),
      Jl(d, w, i.state.value[n]))
  }
  const m = s
    ? function () {
        const { state: w } = t,
          M = w ? w() : {}
        this.$patch((I) => {
          ga(I, M)
        })
      }
    : r5
  function v() {
    ;(o.stop(), (d = []), (h = []), i._s.delete(n))
  }
  const x = (R, w = '') => {
      if (lS in R) return ((R[rg] = w), R)
      const M = function () {
        r0(i)
        const I = Array.from(arguments),
          L = [],
          U = []
        function T(W) {
          L.push(W)
        }
        function F(W) {
          U.push(W)
        }
        Jl(h, { args: I, name: M[rg], store: S, after: T, onError: F })
        let V
        try {
          V = R.apply(this && this.$id === n ? this : S, I)
        } catch (W) {
          throw (Jl(U, W), W)
        }
        return V instanceof Promise
          ? V.then((W) => (Jl(L, W), W)).catch((W) => (Jl(U, W), Promise.reject(W)))
          : (Jl(L, V), V)
      }
      return ((M[lS] = !0), (M[rg] = w), M)
    },
    _ = {
      _p: i,
      $id: n,
      $onAction: aS.bind(null, h),
      $patch: y,
      $reset: m,
      $subscribe(R, w = {}) {
        const M = aS(d, R, w.detached, () => I()),
          I = o.run(() =>
            Jn(
              () => i.state.value[n],
              (L) => {
                ;(w.flush === 'sync' ? u : c) && R({ storeId: n, type: Od.direct, events: f }, L)
              },
              ga({}, l, w)
            )
          )
        return M
      },
      $dispose: v,
    },
    S = Zs(_)
  i._s.set(n, S)
  const A = ((i._a && i._a.runWithContext) || J9)(() =>
    i._e.run(() => (o = qv()).run(() => e({ action: x })))
  )
  for (const R in A) {
    const w = A[R]
    if ((bn(w) && !nN(w)) || ko(w))
      s || (p && tN(w) && (bn(w) ? (w.value = p[R]) : J1(w, p[R])), (i.state.value[n][R] = w))
    else if (typeof w == 'function') {
      const M = x(w, R)
      ;((A[R] = M), (a.actions[R] = w))
    }
  }
  return (
    ga(S, A),
    ga(Ot(S), A),
    Object.defineProperty(S, '$state', {
      get: () => i.state.value[n],
      set: (R) => {
        y((w) => {
          ga(w, R)
        })
      },
    }),
    i._p.forEach((R) => {
      ga(
        S,
        o.run(() => R({ store: S, app: i._a, pinia: i, options: a }))
      )
    }),
    p && s && t.hydrate && t.hydrate(S.$state, p),
    (c = !0),
    (u = !0),
    S
  )
}
/*! #__NO_SIDE_EFFECTS__ */ function o5(n, e, t) {
  let i
  const r = typeof e == 'function'
  i = r ? t : e
  function s(o, a) {
    const l = O8()
    return (
      (o = o || (l ? Zi(i5, null) : null)),
      o && r0(o),
      (o = n5),
      o._s.has(n) || (r ? s5(n, e, i, o) : iN(n, i, o)),
      o._s.get(n)
    )
  }
  return ((s.$id = n), s)
}
function dm(n) {
  const e = Ot(n),
    t = {}
  for (const i in e) {
    const r = e[i]
    r.effect
      ? (t[i] = Ge({
          get: () => n[i],
          set(s) {
            n[i] = s
          },
        }))
      : (bn(r) || ko(r)) && (t[i] = r8(n, i))
  }
  return t
}
function u_(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n
}
var sg = { exports: {} },
  cS
function rN() {
  return (
    cS ||
      ((cS = 1),
      (function (n) {
        var e = Object.prototype.hasOwnProperty,
          t = '~'
        function i() {}
        Object.create && ((i.prototype = Object.create(null)), new i().__proto__ || (t = !1))
        function r(l, c, u) {
          ;((this.fn = l), (this.context = c), (this.once = u || !1))
        }
        function s(l, c, u, d, h) {
          if (typeof u != 'function') throw new TypeError('The listener must be a function')
          var f = new r(u, d || l, h),
            p = t ? t + c : c
          return (
            l._events[p]
              ? l._events[p].fn
                ? (l._events[p] = [l._events[p], f])
                : l._events[p].push(f)
              : ((l._events[p] = f), l._eventsCount++),
            l
          )
        }
        function o(l, c) {
          --l._eventsCount === 0 ? (l._events = new i()) : delete l._events[c]
        }
        function a() {
          ;((this._events = new i()), (this._eventsCount = 0))
        }
        ;((a.prototype.eventNames = function () {
          var c = [],
            u,
            d
          if (this._eventsCount === 0) return c
          for (d in (u = this._events)) e.call(u, d) && c.push(t ? d.slice(1) : d)
          return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
        }),
          (a.prototype.listeners = function (c) {
            var u = t ? t + c : c,
              d = this._events[u]
            if (!d) return []
            if (d.fn) return [d.fn]
            for (var h = 0, f = d.length, p = new Array(f); h < f; h++) p[h] = d[h].fn
            return p
          }),
          (a.prototype.listenerCount = function (c) {
            var u = t ? t + c : c,
              d = this._events[u]
            return d ? (d.fn ? 1 : d.length) : 0
          }),
          (a.prototype.emit = function (c, u, d, h, f, p) {
            var g = t ? t + c : c
            if (!this._events[g]) return !1
            var y = this._events[g],
              m = arguments.length,
              v,
              x
            if (y.fn) {
              switch ((y.once && this.removeListener(c, y.fn, void 0, !0), m)) {
                case 1:
                  return (y.fn.call(y.context), !0)
                case 2:
                  return (y.fn.call(y.context, u), !0)
                case 3:
                  return (y.fn.call(y.context, u, d), !0)
                case 4:
                  return (y.fn.call(y.context, u, d, h), !0)
                case 5:
                  return (y.fn.call(y.context, u, d, h, f), !0)
                case 6:
                  return (y.fn.call(y.context, u, d, h, f, p), !0)
              }
              for (x = 1, v = new Array(m - 1); x < m; x++) v[x - 1] = arguments[x]
              y.fn.apply(y.context, v)
            } else {
              var _ = y.length,
                S
              for (x = 0; x < _; x++)
                switch ((y[x].once && this.removeListener(c, y[x].fn, void 0, !0), m)) {
                  case 1:
                    y[x].fn.call(y[x].context)
                    break
                  case 2:
                    y[x].fn.call(y[x].context, u)
                    break
                  case 3:
                    y[x].fn.call(y[x].context, u, d)
                    break
                  case 4:
                    y[x].fn.call(y[x].context, u, d, h)
                    break
                  default:
                    if (!v) for (S = 1, v = new Array(m - 1); S < m; S++) v[S - 1] = arguments[S]
                    y[x].fn.apply(y[x].context, v)
                }
            }
            return !0
          }),
          (a.prototype.on = function (c, u, d) {
            return s(this, c, u, d, !1)
          }),
          (a.prototype.once = function (c, u, d) {
            return s(this, c, u, d, !0)
          }),
          (a.prototype.removeListener = function (c, u, d, h) {
            var f = t ? t + c : c
            if (!this._events[f]) return this
            if (!u) return (o(this, f), this)
            var p = this._events[f]
            if (p.fn) p.fn === u && (!h || p.once) && (!d || p.context === d) && o(this, f)
            else {
              for (var g = 0, y = [], m = p.length; g < m; g++)
                (p[g].fn !== u || (h && !p[g].once) || (d && p[g].context !== d)) && y.push(p[g])
              y.length ? (this._events[f] = y.length === 1 ? y[0] : y) : o(this, f)
            }
            return this
          }),
          (a.prototype.removeAllListeners = function (c) {
            var u
            return (
              c
                ? ((u = t ? t + c : c), this._events[u] && o(this, u))
                : ((this._events = new i()), (this._eventsCount = 0)),
              this
            )
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = t),
          (a.EventEmitter = a),
          (n.exports = a))
      })(sg)),
    sg.exports
  )
}
var sN = rN()
const d_ = u_(sN)
var xr = ((n) => (
    (n.ErrorReceived = 'ErrorReceived'),
    (n.MessageReceived = 'MessageReceived'),
    (n.StartSpeech = 'StartSpeech'),
    (n.EndSpeech = 'EndSpeech'),
    (n.StateChanged = 'StateChanged'),
    n
  ))(xr || {}),
  Kr = ((n) => (
    (n.WS_CLOSE = 'WS_CLOSE'),
    (n.WS_ERROR = 'WS_ERROR'),
    (n.WS_MESSAGE = 'WS_MESSAGE'),
    (n.WS_OPEN = 'WS_OPEN'),
    n
  ))(Kr || {}),
  Ul = ((n) => (
    (n.Player_EndSpeaking = 'Player_EndSpeaking'),
    (n.Player_NoLegacy = 'Player_NoLegacy'),
    (n.Player_StartSpeaking = 'Player_StartSpeaking'),
    (n.Player_WaitNextAudioClip = 'Player_WaitNextAudioClip'),
    n
  ))(Ul || {}),
  ey = ((n) => (
    (n.Change_Status = 'Change_Status'),
    (n.Chat_BinsizeError = 'Chat_BinsizeError'),
    n
  ))(ey || {})
class oN extends d_ {
  constructor(t) {
    super()
    xe(this, 'engine')
    xe(this, '_inited', !1)
    this._init(t)
  }
  _init(t) {
    this._inited ||
      ((this._inited = !0),
      (this.engine = new WebSocket(t)),
      this.engine.addEventListener('error', (i) => {
        this.emit(Kr.WS_ERROR, i)
      }),
      this.engine.addEventListener('open', () => {
        this.emit(Kr.WS_OPEN)
      }),
      this.engine.addEventListener('message', (i) => {
        this.emit(Kr.WS_MESSAGE, i.data)
      }),
      this.engine.addEventListener('close', () => {
        this.emit(Kr.WS_CLOSE)
      }))
  }
  send(t) {
    var i
    ;(i = this.engine) == null || i.send(t)
  }
  stop() {
    var t
    ;(this.emit(Kr.WS_CLOSE), (this._inited = !1), (t = this.engine) == null || t.close())
  }
}
var ya = ((n) => (
    (n.Idle = 'Idle'),
    (n.Listening = 'Listening'),
    (n.Responding = 'Responding'),
    (n.Thinking = 'Thinking'),
    n
  ))(ya || {}),
  qi = ((n) => ((n.closed = 'closed'), (n.open = 'open'), (n.waiting = 'waiting'), n))(qi || {})
class a5 extends Error {
  constructor(e) {
    ;(super(e), (this.name = 'TimeoutError'))
  }
}
class aN extends Error {
  constructor(e) {
    ;(super(), (this.name = 'AbortError'), (this.message = e))
  }
}
const uS = (n) => (globalThis.DOMException === void 0 ? new aN(n) : new DOMException(n)),
  dS = (n) => {
    const e = n.reason === void 0 ? uS('This operation was aborted.') : n.reason
    return e instanceof Error ? e : uS(e)
  }
function lN(n, e) {
  const {
    milliseconds: t,
    fallback: i,
    message: r,
    customTimers: s = { setTimeout, clearTimeout },
  } = e
  let o, a
  const c = new Promise((u, d) => {
    if (typeof t != 'number' || Math.sign(t) !== 1)
      throw new TypeError('Expected `milliseconds` to be a positive number, got `'.concat(t, '`'))
    if (e.signal) {
      const { signal: f } = e
      ;(f.aborted && d(dS(f)),
        (a = () => {
          d(dS(f))
        }),
        f.addEventListener('abort', a, { once: !0 }))
    }
    if (t === Number.POSITIVE_INFINITY) {
      n.then(u, d)
      return
    }
    const h = new a5()
    ;((o = s.setTimeout.call(
      void 0,
      () => {
        if (i) {
          try {
            u(i())
          } catch (f) {
            d(f)
          }
          return
        }
        ;(typeof n.cancel == 'function' && n.cancel(),
          r === !1
            ? u()
            : r instanceof Error
              ? d(r)
              : ((h.message =
                  r != null ? r : 'Promise timed out after '.concat(t, ' milliseconds')),
                d(h)))
      },
      t
    )),
      (async () => {
        try {
          u(await n)
        } catch (f) {
          d(f)
        }
      })())
  }).finally(() => {
    ;(c.clear(), a && e.signal && e.signal.removeEventListener('abort', a))
  })
  return (
    (c.clear = () => {
      ;(s.clearTimeout.call(void 0, o), (o = void 0))
    }),
    c
  )
}
function cN(n, e, t) {
  let i = 0,
    r = n.length
  for (; r > 0; ) {
    const s = Math.trunc(r / 2)
    let o = i + s
    t(n[o], e) <= 0 ? ((i = ++o), (r -= s + 1)) : (r = s)
  }
  return i
}
var $r
class uN {
  constructor() {
    oi(this, $r, [])
  }
  enqueue(e, t) {
    t = { priority: 0, ...t }
    const i = { priority: t.priority, id: t.id, run: e }
    if (this.size === 0 || dt(this, $r)[this.size - 1].priority >= t.priority) {
      dt(this, $r).push(i)
      return
    }
    const r = cN(dt(this, $r), i, (s, o) => o.priority - s.priority)
    dt(this, $r).splice(r, 0, i)
  }
  setPriority(e, t) {
    const i = dt(this, $r).findIndex((s) => s.id === e)
    if (i === -1)
      throw new ReferenceError(
        'No promise function with the id "'.concat(e, '" exists in the queue.')
      )
    const [r] = dt(this, $r).splice(i, 1)
    this.enqueue(r.run, { priority: t, id: e })
  }
  dequeue() {
    const e = dt(this, $r).shift()
    return e == null ? void 0 : e.run
  }
  filter(e) {
    return dt(this, $r)
      .filter((t) => t.priority === e.priority)
      .map((t) => t.run)
  }
  get size() {
    return dt(this, $r).length
  }
}
$r = new WeakMap()
var eu,
  tu,
  Ta,
  Rh,
  nu,
  Ih,
  Gr,
  iu,
  Qi,
  Nh,
  Wr,
  ru,
  No,
  Ph,
  $m,
  Gt,
  l5,
  c5,
  u5,
  d5,
  h5,
  bp,
  ty,
  ny,
  Tp,
  f5,
  wp
class dN extends d_ {
  constructor(t) {
    var i, r, s, o
    super()
    oi(this, Gt)
    oi(this, eu)
    oi(this, tu)
    oi(this, Ta, 0)
    oi(this, Rh)
    oi(this, nu)
    oi(this, Ih, 0)
    oi(this, Gr)
    oi(this, iu)
    oi(this, Qi)
    oi(this, Nh)
    oi(this, Wr, 0)
    oi(this, ru)
    oi(this, No)
    oi(this, Ph)
    oi(this, $m, BigInt(1))
    xe(this, 'timeout')
    if (
      ((t = {
        carryoverConcurrencyCount: !1,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: !0,
        queueClass: uN,
        ...t,
      }),
      !(typeof t.intervalCap == 'number' && t.intervalCap >= 1))
    )
      throw new TypeError(
        'Expected `intervalCap` to be a number from 1 and up, got `'
          .concat((r = (i = t.intervalCap) == null ? void 0 : i.toString()) != null ? r : '', '` (')
          .concat(typeof t.intervalCap, ')')
      )
    if (t.interval === void 0 || !(Number.isFinite(t.interval) && t.interval >= 0))
      throw new TypeError(
        'Expected `interval` to be a finite number >= 0, got `'
          .concat((o = (s = t.interval) == null ? void 0 : s.toString()) != null ? o : '', '` (')
          .concat(typeof t.interval, ')')
      )
    ;(En(this, eu, t.carryoverConcurrencyCount),
      En(this, tu, t.intervalCap === Number.POSITIVE_INFINITY || t.interval === 0),
      En(this, Rh, t.intervalCap),
      En(this, nu, t.interval),
      En(this, Qi, new t.queueClass()),
      En(this, Nh, t.queueClass),
      (this.concurrency = t.concurrency),
      (this.timeout = t.timeout),
      En(this, Ph, t.throwOnTimeout === !0),
      En(this, No, t.autoStart === !1))
  }
  get concurrency() {
    return dt(this, ru)
  }
  set concurrency(t) {
    if (!(typeof t == 'number' && t >= 1))
      throw new TypeError(
        'Expected `concurrency` to be a number from 1 and up, got `'
          .concat(t, '` (')
          .concat(typeof t, ')')
      )
    ;(En(this, ru, t), hi(this, Gt, Tp).call(this))
  }
  setPriority(t, i) {
    dt(this, Qi).setPriority(t, i)
  }
  async add(t, i = {}) {
    var r
    return (
      (r = i.id) != null || (i.id = (Yu(this, $m)._++).toString()),
      (i = { timeout: this.timeout, throwOnTimeout: dt(this, Ph), ...i }),
      new Promise((s, o) => {
        ;(dt(this, Qi).enqueue(async () => {
          var a
          Yu(this, Wr)._++
          try {
            ;((a = i.signal) == null || a.throwIfAborted(), Yu(this, Ta)._++)
            let l = t({ signal: i.signal })
            ;(i.timeout && (l = lN(Promise.resolve(l), { milliseconds: i.timeout })),
              i.signal && (l = Promise.race([l, hi(this, Gt, f5).call(this, i.signal)])))
            const c = await l
            ;(s(c), this.emit('completed', c))
          } catch (l) {
            if (l instanceof a5 && !i.throwOnTimeout) {
              s()
              return
            }
            ;(o(l), this.emit('error', l))
          } finally {
            hi(this, Gt, u5).call(this)
          }
        }, i),
          this.emit('add'),
          hi(this, Gt, bp).call(this))
      })
    )
  }
  async addAll(t, i) {
    return Promise.all(t.map(async (r) => this.add(r, i)))
  }
  start() {
    return dt(this, No) ? (En(this, No, !1), hi(this, Gt, Tp).call(this), this) : this
  }
  pause() {
    En(this, No, !0)
  }
  clear() {
    En(this, Qi, new (dt(this, Nh))())
  }
  async onEmpty() {
    dt(this, Qi).size !== 0 && (await hi(this, Gt, wp).call(this, 'empty'))
  }
  async onSizeLessThan(t) {
    dt(this, Qi).size < t ||
      (await hi(this, Gt, wp).call(this, 'next', () => dt(this, Qi).size < t))
  }
  async onIdle() {
    ;(dt(this, Wr) === 0 && dt(this, Qi).size === 0) || (await hi(this, Gt, wp).call(this, 'idle'))
  }
  get size() {
    return dt(this, Qi).size
  }
  sizeBy(t) {
    return dt(this, Qi).filter(t).length
  }
  get pending() {
    return dt(this, Wr)
  }
  get isPaused() {
    return dt(this, No)
  }
}
;((eu = new WeakMap()),
  (tu = new WeakMap()),
  (Ta = new WeakMap()),
  (Rh = new WeakMap()),
  (nu = new WeakMap()),
  (Ih = new WeakMap()),
  (Gr = new WeakMap()),
  (iu = new WeakMap()),
  (Qi = new WeakMap()),
  (Nh = new WeakMap()),
  (Wr = new WeakMap()),
  (ru = new WeakMap()),
  (No = new WeakMap()),
  (Ph = new WeakMap()),
  ($m = new WeakMap()),
  (Gt = new WeakSet()),
  (l5 = function () {
    return dt(this, tu) || dt(this, Ta) < dt(this, Rh)
  }),
  (c5 = function () {
    return dt(this, Wr) < dt(this, ru)
  }),
  (u5 = function () {
    ;(Yu(this, Wr)._--, hi(this, Gt, bp).call(this), this.emit('next'))
  }),
  (d5 = function () {
    ;(hi(this, Gt, ny).call(this), hi(this, Gt, ty).call(this), En(this, iu, void 0))
  }),
  (h5 = function () {
    const t = Date.now()
    if (dt(this, Gr) === void 0) {
      const i = dt(this, Ih) - t
      if (i < 0) En(this, Ta, dt(this, eu) ? dt(this, Wr) : 0)
      else
        return (
          dt(this, iu) === void 0 &&
            En(
              this,
              iu,
              setTimeout(() => {
                hi(this, Gt, d5).call(this)
              }, i)
            ),
          !0
        )
    }
    return !1
  }),
  (bp = function () {
    if (dt(this, Qi).size === 0)
      return (
        dt(this, Gr) && clearInterval(dt(this, Gr)),
        En(this, Gr, void 0),
        this.emit('empty'),
        dt(this, Wr) === 0 && this.emit('idle'),
        !1
      )
    if (!dt(this, No)) {
      const t = !dt(this, Gt, h5)
      if (dt(this, Gt, l5) && dt(this, Gt, c5)) {
        const i = dt(this, Qi).dequeue()
        return i ? (this.emit('active'), i(), t && hi(this, Gt, ty).call(this), !0) : !1
      }
    }
    return !1
  }),
  (ty = function () {
    dt(this, tu) ||
      dt(this, Gr) !== void 0 ||
      (En(
        this,
        Gr,
        setInterval(
          () => {
            hi(this, Gt, ny).call(this)
          },
          dt(this, nu)
        )
      ),
      En(this, Ih, Date.now() + dt(this, nu)))
  }),
  (ny = function () {
    ;(dt(this, Ta) === 0 &&
      dt(this, Wr) === 0 &&
      dt(this, Gr) &&
      (clearInterval(dt(this, Gr)), En(this, Gr, void 0)),
      En(this, Ta, dt(this, eu) ? dt(this, Wr) : 0),
      hi(this, Gt, Tp).call(this))
  }),
  (Tp = function () {
    for (; hi(this, Gt, bp).call(this); );
  }),
  (f5 = async function (t) {
    return new Promise((i, r) => {
      t.addEventListener(
        'abort',
        () => {
          r(t.reason)
        },
        { once: !0 }
      )
    })
  }),
  (wp = async function (t, i) {
    return new Promise((r) => {
      const s = () => {
        ;(i && !i()) || (this.off(t, s), r())
      }
      this.on(t, s)
    })
  }))
var td = {},
  hS
function p5() {
  if (hS) return td
  ;((hS = 1), (td.byteLength = a), (td.toByteArray = c), (td.fromByteArray = h))
  for (
    var n = [],
      e = [],
      t = typeof Uint8Array < 'u' ? Uint8Array : Array,
      i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      r = 0,
      s = i.length;
    r < s;
    ++r
  )
    ((n[r] = i[r]), (e[i.charCodeAt(r)] = r))
  ;((e[45] = 62), (e[95] = 63))
  function o(f) {
    var p = f.length
    if (p % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
    var g = f.indexOf('=')
    g === -1 && (g = p)
    var y = g === p ? 0 : 4 - (g % 4)
    return [g, y]
  }
  function a(f) {
    var p = o(f),
      g = p[0],
      y = p[1]
    return ((g + y) * 3) / 4 - y
  }
  function l(f, p, g) {
    return ((p + g) * 3) / 4 - g
  }
  function c(f) {
    var p,
      g = o(f),
      y = g[0],
      m = g[1],
      v = new t(l(f, y, m)),
      x = 0,
      _ = m > 0 ? y - 4 : y,
      S
    for (S = 0; S < _; S += 4)
      ((p =
        (e[f.charCodeAt(S)] << 18) |
        (e[f.charCodeAt(S + 1)] << 12) |
        (e[f.charCodeAt(S + 2)] << 6) |
        e[f.charCodeAt(S + 3)]),
        (v[x++] = (p >> 16) & 255),
        (v[x++] = (p >> 8) & 255),
        (v[x++] = p & 255))
    return (
      m === 2 &&
        ((p = (e[f.charCodeAt(S)] << 2) | (e[f.charCodeAt(S + 1)] >> 4)), (v[x++] = p & 255)),
      m === 1 &&
        ((p =
          (e[f.charCodeAt(S)] << 10) |
          (e[f.charCodeAt(S + 1)] << 4) |
          (e[f.charCodeAt(S + 2)] >> 2)),
        (v[x++] = (p >> 8) & 255),
        (v[x++] = p & 255)),
      v
    )
  }
  function u(f) {
    return n[(f >> 18) & 63] + n[(f >> 12) & 63] + n[(f >> 6) & 63] + n[f & 63]
  }
  function d(f, p, g) {
    for (var y, m = [], v = p; v < g; v += 3)
      ((y = ((f[v] << 16) & 16711680) + ((f[v + 1] << 8) & 65280) + (f[v + 2] & 255)), m.push(u(y)))
    return m.join('')
  }
  function h(f) {
    for (var p, g = f.length, y = g % 3, m = [], v = 16383, x = 0, _ = g - y; x < _; x += v)
      m.push(d(f, x, x + v > _ ? _ : x + v))
    return (
      y === 1
        ? ((p = f[g - 1]), m.push(n[p >> 2] + n[(p << 4) & 63] + '=='))
        : y === 2 &&
          ((p = (f[g - 2] << 8) + f[g - 1]),
          m.push(n[p >> 10] + n[(p >> 4) & 63] + n[(p << 2) & 63] + '=')),
      m.join('')
    )
  }
  return td
}
p5()
var og = {},
  _f = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var fS
function hN() {
  return (
    fS ||
      ((fS = 1),
      (_f.read = function (n, e, t, i, r) {
        var s,
          o,
          a = r * 8 - i - 1,
          l = (1 << a) - 1,
          c = l >> 1,
          u = -7,
          d = t ? r - 1 : 0,
          h = t ? -1 : 1,
          f = n[e + d]
        for (
          d += h, s = f & ((1 << -u) - 1), f >>= -u, u += a;
          u > 0;
          s = s * 256 + n[e + d], d += h, u -= 8
        );
        for (
          o = s & ((1 << -u) - 1), s >>= -u, u += i;
          u > 0;
          o = o * 256 + n[e + d], d += h, u -= 8
        );
        if (s === 0) s = 1 - c
        else {
          if (s === l) return o ? NaN : (f ? -1 : 1) * (1 / 0)
          ;((o = o + Math.pow(2, i)), (s = s - c))
        }
        return (f ? -1 : 1) * o * Math.pow(2, s - i)
      }),
      (_f.write = function (n, e, t, i, r, s) {
        var o,
          a,
          l,
          c = s * 8 - r - 1,
          u = (1 << c) - 1,
          d = u >> 1,
          h = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          f = i ? 0 : s - 1,
          p = i ? 1 : -1,
          g = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0
        for (
          e = Math.abs(e),
            isNaN(e) || e === 1 / 0
              ? ((a = isNaN(e) ? 1 : 0), (o = u))
              : ((o = Math.floor(Math.log(e) / Math.LN2)),
                e * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
                o + d >= 1 ? (e += h / l) : (e += h * Math.pow(2, 1 - d)),
                e * l >= 2 && (o++, (l /= 2)),
                o + d >= u
                  ? ((a = 0), (o = u))
                  : o + d >= 1
                    ? ((a = (e * l - 1) * Math.pow(2, r)), (o = o + d))
                    : ((a = e * Math.pow(2, d - 1) * Math.pow(2, r)), (o = 0)));
          r >= 8;
          n[t + f] = a & 255, f += p, a /= 256, r -= 8
        );
        for (o = (o << r) | a, c += r; c > 0; n[t + f] = o & 255, f += p, o /= 256, c -= 8);
        n[t + f - p] |= g * 128
      })),
    _f
  )
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var pS
function m5() {
  return (
    pS ||
      ((pS = 1),
      (function (n) {
        const e = p5(),
          t = hN(),
          i =
            typeof Symbol == 'function' && typeof Symbol.for == 'function'
              ? Symbol.for('nodejs.util.inspect.custom')
              : null
        ;((n.Buffer = a), (n.SlowBuffer = v), (n.INSPECT_MAX_BYTES = 50))
        const r = 2147483647
        ;((n.kMaxLength = r),
          (a.TYPED_ARRAY_SUPPORT = s()),
          !a.TYPED_ARRAY_SUPPORT &&
            typeof console < 'u' &&
            typeof console.error == 'function' &&
            console.error(
              'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
            ))
        function s() {
          try {
            const z = new Uint8Array(1),
              E = {
                foo: function () {
                  return 42
                },
              }
            return (
              Object.setPrototypeOf(E, Uint8Array.prototype),
              Object.setPrototypeOf(z, E),
              z.foo() === 42
            )
          } catch (z) {
            return !1
          }
        }
        ;(Object.defineProperty(a.prototype, 'parent', {
          enumerable: !0,
          get: function () {
            if (a.isBuffer(this)) return this.buffer
          },
        }),
          Object.defineProperty(a.prototype, 'offset', {
            enumerable: !0,
            get: function () {
              if (a.isBuffer(this)) return this.byteOffset
            },
          }))
        function o(z) {
          if (z > r) throw new RangeError('The value "' + z + '" is invalid for option "size"')
          const E = new Uint8Array(z)
          return (Object.setPrototypeOf(E, a.prototype), E)
        }
        function a(z, E, N) {
          if (typeof z == 'number') {
            if (typeof E == 'string')
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              )
            return d(z)
          }
          return l(z, E, N)
        }
        a.poolSize = 8192
        function l(z, E, N) {
          if (typeof z == 'string') return h(z, E)
          if (ArrayBuffer.isView(z)) return p(z)
          if (z == null)
            throw new TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                typeof z
            )
          if (
            D(z, ArrayBuffer) ||
            (z && D(z.buffer, ArrayBuffer)) ||
            (typeof SharedArrayBuffer < 'u' &&
              (D(z, SharedArrayBuffer) || (z && D(z.buffer, SharedArrayBuffer))))
          )
            return g(z, E, N)
          if (typeof z == 'number')
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            )
          const q = z.valueOf && z.valueOf()
          if (q != null && q !== z) return a.from(q, E, N)
          const Z = y(z)
          if (Z) return Z
          if (
            typeof Symbol < 'u' &&
            Symbol.toPrimitive != null &&
            typeof z[Symbol.toPrimitive] == 'function'
          )
            return a.from(z[Symbol.toPrimitive]('string'), E, N)
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof z
          )
        }
        ;((a.from = function (z, E, N) {
          return l(z, E, N)
        }),
          Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
          Object.setPrototypeOf(a, Uint8Array))
        function c(z) {
          if (typeof z != 'number') throw new TypeError('"size" argument must be of type number')
          if (z < 0) throw new RangeError('The value "' + z + '" is invalid for option "size"')
        }
        function u(z, E, N) {
          return (
            c(z),
            z <= 0
              ? o(z)
              : E !== void 0
                ? typeof N == 'string'
                  ? o(z).fill(E, N)
                  : o(z).fill(E)
                : o(z)
          )
        }
        a.alloc = function (z, E, N) {
          return u(z, E, N)
        }
        function d(z) {
          return (c(z), o(z < 0 ? 0 : m(z) | 0))
        }
        ;((a.allocUnsafe = function (z) {
          return d(z)
        }),
          (a.allocUnsafeSlow = function (z) {
            return d(z)
          }))
        function h(z, E) {
          if (((typeof E != 'string' || E === '') && (E = 'utf8'), !a.isEncoding(E)))
            throw new TypeError('Unknown encoding: ' + E)
          const N = x(z, E) | 0
          let q = o(N)
          const Z = q.write(z, E)
          return (Z !== N && (q = q.slice(0, Z)), q)
        }
        function f(z) {
          const E = z.length < 0 ? 0 : m(z.length) | 0,
            N = o(E)
          for (let q = 0; q < E; q += 1) N[q] = z[q] & 255
          return N
        }
        function p(z) {
          if (D(z, Uint8Array)) {
            const E = new Uint8Array(z)
            return g(E.buffer, E.byteOffset, E.byteLength)
          }
          return f(z)
        }
        function g(z, E, N) {
          if (E < 0 || z.byteLength < E)
            throw new RangeError('"offset" is outside of buffer bounds')
          if (z.byteLength < E + (N || 0))
            throw new RangeError('"length" is outside of buffer bounds')
          let q
          return (
            E === void 0 && N === void 0
              ? (q = new Uint8Array(z))
              : N === void 0
                ? (q = new Uint8Array(z, E))
                : (q = new Uint8Array(z, E, N)),
            Object.setPrototypeOf(q, a.prototype),
            q
          )
        }
        function y(z) {
          if (a.isBuffer(z)) {
            const E = m(z.length) | 0,
              N = o(E)
            return (N.length === 0 || z.copy(N, 0, 0, E), N)
          }
          if (z.length !== void 0) return typeof z.length != 'number' || Q(z.length) ? o(0) : f(z)
          if (z.type === 'Buffer' && Array.isArray(z.data)) return f(z.data)
        }
        function m(z) {
          if (z >= r)
            throw new RangeError(
              'Attempt to allocate Buffer larger than maximum size: 0x' + r.toString(16) + ' bytes'
            )
          return z | 0
        }
        function v(z) {
          return (+z != z && (z = 0), a.alloc(+z))
        }
        ;((a.isBuffer = function (E) {
          return E != null && E._isBuffer === !0 && E !== a.prototype
        }),
          (a.compare = function (E, N) {
            if (
              (D(E, Uint8Array) && (E = a.from(E, E.offset, E.byteLength)),
              D(N, Uint8Array) && (N = a.from(N, N.offset, N.byteLength)),
              !a.isBuffer(E) || !a.isBuffer(N))
            )
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              )
            if (E === N) return 0
            let q = E.length,
              Z = N.length
            for (let $ = 0, ae = Math.min(q, Z); $ < ae; ++$)
              if (E[$] !== N[$]) {
                ;((q = E[$]), (Z = N[$]))
                break
              }
            return q < Z ? -1 : Z < q ? 1 : 0
          }),
          (a.isEncoding = function (E) {
            switch (String(E).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return !0
              default:
                return !1
            }
          }),
          (a.concat = function (E, N) {
            if (!Array.isArray(E))
              throw new TypeError('"list" argument must be an Array of Buffers')
            if (E.length === 0) return a.alloc(0)
            let q
            if (N === void 0) for (N = 0, q = 0; q < E.length; ++q) N += E[q].length
            const Z = a.allocUnsafe(N)
            let $ = 0
            for (q = 0; q < E.length; ++q) {
              let ae = E[q]
              if (D(ae, Uint8Array))
                $ + ae.length > Z.length
                  ? (a.isBuffer(ae) || (ae = a.from(ae)), ae.copy(Z, $))
                  : Uint8Array.prototype.set.call(Z, ae, $)
              else if (a.isBuffer(ae)) ae.copy(Z, $)
              else throw new TypeError('"list" argument must be an Array of Buffers')
              $ += ae.length
            }
            return Z
          }))
        function x(z, E) {
          if (a.isBuffer(z)) return z.length
          if (ArrayBuffer.isView(z) || D(z, ArrayBuffer)) return z.byteLength
          if (typeof z != 'string')
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                typeof z
            )
          const N = z.length,
            q = arguments.length > 2 && arguments[2] === !0
          if (!q && N === 0) return 0
          let Z = !1
          for (;;)
            switch (E) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return N
              case 'utf8':
              case 'utf-8':
                return H(z).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return N * 2
              case 'hex':
                return N >>> 1
              case 'base64':
                return j(z).length
              default:
                if (Z) return q ? -1 : H(z).length
                ;((E = ('' + E).toLowerCase()), (Z = !0))
            }
        }
        a.byteLength = x
        function _(z, E, N) {
          let q = !1
          if (
            ((E === void 0 || E < 0) && (E = 0),
            E > this.length ||
              ((N === void 0 || N > this.length) && (N = this.length), N <= 0) ||
              ((N >>>= 0), (E >>>= 0), N <= E))
          )
            return ''
          for (z || (z = 'utf8'); ; )
            switch (z) {
              case 'hex':
                return se(this, E, N)
              case 'utf8':
              case 'utf-8':
                return T(this, E, N)
              case 'ascii':
                return W(this, E, N)
              case 'latin1':
              case 'binary':
                return ee(this, E, N)
              case 'base64':
                return U(this, E, N)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return he(this, E, N)
              default:
                if (q) throw new TypeError('Unknown encoding: ' + z)
                ;((z = (z + '').toLowerCase()), (q = !0))
            }
        }
        a.prototype._isBuffer = !0
        function S(z, E, N) {
          const q = z[E]
          ;((z[E] = z[N]), (z[N] = q))
        }
        ;((a.prototype.swap16 = function () {
          const E = this.length
          if (E % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
          for (let N = 0; N < E; N += 2) S(this, N, N + 1)
          return this
        }),
          (a.prototype.swap32 = function () {
            const E = this.length
            if (E % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
            for (let N = 0; N < E; N += 4) (S(this, N, N + 3), S(this, N + 1, N + 2))
            return this
          }),
          (a.prototype.swap64 = function () {
            const E = this.length
            if (E % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
            for (let N = 0; N < E; N += 8)
              (S(this, N, N + 7),
                S(this, N + 1, N + 6),
                S(this, N + 2, N + 5),
                S(this, N + 3, N + 4))
            return this
          }),
          (a.prototype.toString = function () {
            const E = this.length
            return E === 0 ? '' : arguments.length === 0 ? T(this, 0, E) : _.apply(this, arguments)
          }),
          (a.prototype.toLocaleString = a.prototype.toString),
          (a.prototype.equals = function (E) {
            if (!a.isBuffer(E)) throw new TypeError('Argument must be a Buffer')
            return this === E ? !0 : a.compare(this, E) === 0
          }),
          (a.prototype.inspect = function () {
            let E = ''
            const N = n.INSPECT_MAX_BYTES
            return (
              (E = this.toString('hex', 0, N)
                .replace(/(.{2})/g, '$1 ')
                .trim()),
              this.length > N && (E += ' ... '),
              '<Buffer ' + E + '>'
            )
          }),
          i && (a.prototype[i] = a.prototype.inspect),
          (a.prototype.compare = function (E, N, q, Z, $) {
            if ((D(E, Uint8Array) && (E = a.from(E, E.offset, E.byteLength)), !a.isBuffer(E)))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                  typeof E
              )
            if (
              (N === void 0 && (N = 0),
              q === void 0 && (q = E ? E.length : 0),
              Z === void 0 && (Z = 0),
              $ === void 0 && ($ = this.length),
              N < 0 || q > E.length || Z < 0 || $ > this.length)
            )
              throw new RangeError('out of range index')
            if (Z >= $ && N >= q) return 0
            if (Z >= $) return -1
            if (N >= q) return 1
            if (((N >>>= 0), (q >>>= 0), (Z >>>= 0), ($ >>>= 0), this === E)) return 0
            let ae = $ - Z,
              Ue = q - N
            const Le = Math.min(ae, Ue),
              Ve = this.slice(Z, $),
              Je = E.slice(N, q)
            for (let rt = 0; rt < Le; ++rt)
              if (Ve[rt] !== Je[rt]) {
                ;((ae = Ve[rt]), (Ue = Je[rt]))
                break
              }
            return ae < Ue ? -1 : Ue < ae ? 1 : 0
          }))
        function C(z, E, N, q, Z) {
          if (z.length === 0) return -1
          if (
            (typeof N == 'string'
              ? ((q = N), (N = 0))
              : N > 2147483647
                ? (N = 2147483647)
                : N < -2147483648 && (N = -2147483648),
            (N = +N),
            Q(N) && (N = Z ? 0 : z.length - 1),
            N < 0 && (N = z.length + N),
            N >= z.length)
          ) {
            if (Z) return -1
            N = z.length - 1
          } else if (N < 0)
            if (Z) N = 0
            else return -1
          if ((typeof E == 'string' && (E = a.from(E, q)), a.isBuffer(E)))
            return E.length === 0 ? -1 : A(z, E, N, q, Z)
          if (typeof E == 'number')
            return (
              (E = E & 255),
              typeof Uint8Array.prototype.indexOf == 'function'
                ? Z
                  ? Uint8Array.prototype.indexOf.call(z, E, N)
                  : Uint8Array.prototype.lastIndexOf.call(z, E, N)
                : A(z, [E], N, q, Z)
            )
          throw new TypeError('val must be string, number or Buffer')
        }
        function A(z, E, N, q, Z) {
          let $ = 1,
            ae = z.length,
            Ue = E.length
          if (
            q !== void 0 &&
            ((q = String(q).toLowerCase()),
            q === 'ucs2' || q === 'ucs-2' || q === 'utf16le' || q === 'utf-16le')
          ) {
            if (z.length < 2 || E.length < 2) return -1
            ;(($ = 2), (ae /= 2), (Ue /= 2), (N /= 2))
          }
          function Le(Je, rt) {
            return $ === 1 ? Je[rt] : Je.readUInt16BE(rt * $)
          }
          let Ve
          if (Z) {
            let Je = -1
            for (Ve = N; Ve < ae; Ve++)
              if (Le(z, Ve) === Le(E, Je === -1 ? 0 : Ve - Je)) {
                if ((Je === -1 && (Je = Ve), Ve - Je + 1 === Ue)) return Je * $
              } else (Je !== -1 && (Ve -= Ve - Je), (Je = -1))
          } else
            for (N + Ue > ae && (N = ae - Ue), Ve = N; Ve >= 0; Ve--) {
              let Je = !0
              for (let rt = 0; rt < Ue; rt++)
                if (Le(z, Ve + rt) !== Le(E, rt)) {
                  Je = !1
                  break
                }
              if (Je) return Ve
            }
          return -1
        }
        ;((a.prototype.includes = function (E, N, q) {
          return this.indexOf(E, N, q) !== -1
        }),
          (a.prototype.indexOf = function (E, N, q) {
            return C(this, E, N, q, !0)
          }),
          (a.prototype.lastIndexOf = function (E, N, q) {
            return C(this, E, N, q, !1)
          }))
        function R(z, E, N, q) {
          N = Number(N) || 0
          const Z = z.length - N
          q ? ((q = Number(q)), q > Z && (q = Z)) : (q = Z)
          const $ = E.length
          q > $ / 2 && (q = $ / 2)
          let ae
          for (ae = 0; ae < q; ++ae) {
            const Ue = parseInt(E.substr(ae * 2, 2), 16)
            if (Q(Ue)) return ae
            z[N + ae] = Ue
          }
          return ae
        }
        function w(z, E, N, q) {
          return B(H(E, z.length - N), z, N, q)
        }
        function M(z, E, N, q) {
          return B(P(E), z, N, q)
        }
        function I(z, E, N, q) {
          return B(j(E), z, N, q)
        }
        function L(z, E, N, q) {
          return B(k(E, z.length - N), z, N, q)
        }
        ;((a.prototype.write = function (E, N, q, Z) {
          if (N === void 0) ((Z = 'utf8'), (q = this.length), (N = 0))
          else if (q === void 0 && typeof N == 'string') ((Z = N), (q = this.length), (N = 0))
          else if (isFinite(N))
            ((N = N >>> 0),
              isFinite(q) ? ((q = q >>> 0), Z === void 0 && (Z = 'utf8')) : ((Z = q), (q = void 0)))
          else
            throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported'
            )
          const $ = this.length - N
          if (
            ((q === void 0 || q > $) && (q = $),
            (E.length > 0 && (q < 0 || N < 0)) || N > this.length)
          )
            throw new RangeError('Attempt to write outside buffer bounds')
          Z || (Z = 'utf8')
          let ae = !1
          for (;;)
            switch (Z) {
              case 'hex':
                return R(this, E, N, q)
              case 'utf8':
              case 'utf-8':
                return w(this, E, N, q)
              case 'ascii':
              case 'latin1':
              case 'binary':
                return M(this, E, N, q)
              case 'base64':
                return I(this, E, N, q)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return L(this, E, N, q)
              default:
                if (ae) throw new TypeError('Unknown encoding: ' + Z)
                ;((Z = ('' + Z).toLowerCase()), (ae = !0))
            }
        }),
          (a.prototype.toJSON = function () {
            return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
          }))
        function U(z, E, N) {
          return E === 0 && N === z.length ? e.fromByteArray(z) : e.fromByteArray(z.slice(E, N))
        }
        function T(z, E, N) {
          N = Math.min(z.length, N)
          const q = []
          let Z = E
          for (; Z < N; ) {
            const $ = z[Z]
            let ae = null,
              Ue = $ > 239 ? 4 : $ > 223 ? 3 : $ > 191 ? 2 : 1
            if (Z + Ue <= N) {
              let Le, Ve, Je, rt
              switch (Ue) {
                case 1:
                  $ < 128 && (ae = $)
                  break
                case 2:
                  ;((Le = z[Z + 1]),
                    (Le & 192) === 128 &&
                      ((rt = (($ & 31) << 6) | (Le & 63)), rt > 127 && (ae = rt)))
                  break
                case 3:
                  ;((Le = z[Z + 1]),
                    (Ve = z[Z + 2]),
                    (Le & 192) === 128 &&
                      (Ve & 192) === 128 &&
                      ((rt = (($ & 15) << 12) | ((Le & 63) << 6) | (Ve & 63)),
                      rt > 2047 && (rt < 55296 || rt > 57343) && (ae = rt)))
                  break
                case 4:
                  ;((Le = z[Z + 1]),
                    (Ve = z[Z + 2]),
                    (Je = z[Z + 3]),
                    (Le & 192) === 128 &&
                      (Ve & 192) === 128 &&
                      (Je & 192) === 128 &&
                      ((rt = (($ & 15) << 18) | ((Le & 63) << 12) | ((Ve & 63) << 6) | (Je & 63)),
                      rt > 65535 && rt < 1114112 && (ae = rt)))
              }
            }
            ;(ae === null
              ? ((ae = 65533), (Ue = 1))
              : ae > 65535 &&
                ((ae -= 65536), q.push(((ae >>> 10) & 1023) | 55296), (ae = 56320 | (ae & 1023))),
              q.push(ae),
              (Z += Ue))
          }
          return V(q)
        }
        const F = 4096
        function V(z) {
          const E = z.length
          if (E <= F) return String.fromCharCode.apply(String, z)
          let N = '',
            q = 0
          for (; q < E; ) N += String.fromCharCode.apply(String, z.slice(q, (q += F)))
          return N
        }
        function W(z, E, N) {
          let q = ''
          N = Math.min(z.length, N)
          for (let Z = E; Z < N; ++Z) q += String.fromCharCode(z[Z] & 127)
          return q
        }
        function ee(z, E, N) {
          let q = ''
          N = Math.min(z.length, N)
          for (let Z = E; Z < N; ++Z) q += String.fromCharCode(z[Z])
          return q
        }
        function se(z, E, N) {
          const q = z.length
          ;((!E || E < 0) && (E = 0), (!N || N < 0 || N > q) && (N = q))
          let Z = ''
          for (let $ = E; $ < N; ++$) Z += G[z[$]]
          return Z
        }
        function he(z, E, N) {
          const q = z.slice(E, N)
          let Z = ''
          for (let $ = 0; $ < q.length - 1; $ += 2) Z += String.fromCharCode(q[$] + q[$ + 1] * 256)
          return Z
        }
        a.prototype.slice = function (E, N) {
          const q = this.length
          ;((E = ~~E),
            (N = N === void 0 ? q : ~~N),
            E < 0 ? ((E += q), E < 0 && (E = 0)) : E > q && (E = q),
            N < 0 ? ((N += q), N < 0 && (N = 0)) : N > q && (N = q),
            N < E && (N = E))
          const Z = this.subarray(E, N)
          return (Object.setPrototypeOf(Z, a.prototype), Z)
        }
        function ne(z, E, N) {
          if (z % 1 !== 0 || z < 0) throw new RangeError('offset is not uint')
          if (z + E > N) throw new RangeError('Trying to access beyond buffer length')
        }
        ;((a.prototype.readUintLE = a.prototype.readUIntLE =
          function (E, N, q) {
            ;((E = E >>> 0), (N = N >>> 0), q || ne(E, N, this.length))
            let Z = this[E],
              $ = 1,
              ae = 0
            for (; ++ae < N && ($ *= 256); ) Z += this[E + ae] * $
            return Z
          }),
          (a.prototype.readUintBE = a.prototype.readUIntBE =
            function (E, N, q) {
              ;((E = E >>> 0), (N = N >>> 0), q || ne(E, N, this.length))
              let Z = this[E + --N],
                $ = 1
              for (; N > 0 && ($ *= 256); ) Z += this[E + --N] * $
              return Z
            }),
          (a.prototype.readUint8 = a.prototype.readUInt8 =
            function (E, N) {
              return ((E = E >>> 0), N || ne(E, 1, this.length), this[E])
            }),
          (a.prototype.readUint16LE = a.prototype.readUInt16LE =
            function (E, N) {
              return ((E = E >>> 0), N || ne(E, 2, this.length), this[E] | (this[E + 1] << 8))
            }),
          (a.prototype.readUint16BE = a.prototype.readUInt16BE =
            function (E, N) {
              return ((E = E >>> 0), N || ne(E, 2, this.length), (this[E] << 8) | this[E + 1])
            }),
          (a.prototype.readUint32LE = a.prototype.readUInt32LE =
            function (E, N) {
              return (
                (E = E >>> 0),
                N || ne(E, 4, this.length),
                (this[E] | (this[E + 1] << 8) | (this[E + 2] << 16)) + this[E + 3] * 16777216
              )
            }),
          (a.prototype.readUint32BE = a.prototype.readUInt32BE =
            function (E, N) {
              return (
                (E = E >>> 0),
                N || ne(E, 4, this.length),
                this[E] * 16777216 + ((this[E + 1] << 16) | (this[E + 2] << 8) | this[E + 3])
              )
            }),
          (a.prototype.readBigUInt64LE = X(function (E) {
            ;((E = E >>> 0), re(E, 'offset'))
            const N = this[E],
              q = this[E + 7]
            ;(N === void 0 || q === void 0) && b(E, this.length - 8)
            const Z = N + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24,
              $ = this[++E] + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + q * 2 ** 24
            return BigInt(Z) + (BigInt($) << BigInt(32))
          })),
          (a.prototype.readBigUInt64BE = X(function (E) {
            ;((E = E >>> 0), re(E, 'offset'))
            const N = this[E],
              q = this[E + 7]
            ;(N === void 0 || q === void 0) && b(E, this.length - 8)
            const Z = N * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E],
              $ = this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + q
            return (BigInt(Z) << BigInt(32)) + BigInt($)
          })),
          (a.prototype.readIntLE = function (E, N, q) {
            ;((E = E >>> 0), (N = N >>> 0), q || ne(E, N, this.length))
            let Z = this[E],
              $ = 1,
              ae = 0
            for (; ++ae < N && ($ *= 256); ) Z += this[E + ae] * $
            return (($ *= 128), Z >= $ && (Z -= Math.pow(2, 8 * N)), Z)
          }),
          (a.prototype.readIntBE = function (E, N, q) {
            ;((E = E >>> 0), (N = N >>> 0), q || ne(E, N, this.length))
            let Z = N,
              $ = 1,
              ae = this[E + --Z]
            for (; Z > 0 && ($ *= 256); ) ae += this[E + --Z] * $
            return (($ *= 128), ae >= $ && (ae -= Math.pow(2, 8 * N)), ae)
          }),
          (a.prototype.readInt8 = function (E, N) {
            return (
              (E = E >>> 0),
              N || ne(E, 1, this.length),
              this[E] & 128 ? (255 - this[E] + 1) * -1 : this[E]
            )
          }),
          (a.prototype.readInt16LE = function (E, N) {
            ;((E = E >>> 0), N || ne(E, 2, this.length))
            const q = this[E] | (this[E + 1] << 8)
            return q & 32768 ? q | 4294901760 : q
          }),
          (a.prototype.readInt16BE = function (E, N) {
            ;((E = E >>> 0), N || ne(E, 2, this.length))
            const q = this[E + 1] | (this[E] << 8)
            return q & 32768 ? q | 4294901760 : q
          }),
          (a.prototype.readInt32LE = function (E, N) {
            return (
              (E = E >>> 0),
              N || ne(E, 4, this.length),
              this[E] | (this[E + 1] << 8) | (this[E + 2] << 16) | (this[E + 3] << 24)
            )
          }),
          (a.prototype.readInt32BE = function (E, N) {
            return (
              (E = E >>> 0),
              N || ne(E, 4, this.length),
              (this[E] << 24) | (this[E + 1] << 16) | (this[E + 2] << 8) | this[E + 3]
            )
          }),
          (a.prototype.readBigInt64LE = X(function (E) {
            ;((E = E >>> 0), re(E, 'offset'))
            const N = this[E],
              q = this[E + 7]
            ;(N === void 0 || q === void 0) && b(E, this.length - 8)
            const Z = this[E + 4] + this[E + 5] * 2 ** 8 + this[E + 6] * 2 ** 16 + (q << 24)
            return (
              (BigInt(Z) << BigInt(32)) +
              BigInt(N + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24)
            )
          })),
          (a.prototype.readBigInt64BE = X(function (E) {
            ;((E = E >>> 0), re(E, 'offset'))
            const N = this[E],
              q = this[E + 7]
            ;(N === void 0 || q === void 0) && b(E, this.length - 8)
            const Z = (N << 24) + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E]
            return (
              (BigInt(Z) << BigInt(32)) +
              BigInt(this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + q)
            )
          })),
          (a.prototype.readFloatLE = function (E, N) {
            return ((E = E >>> 0), N || ne(E, 4, this.length), t.read(this, E, !0, 23, 4))
          }),
          (a.prototype.readFloatBE = function (E, N) {
            return ((E = E >>> 0), N || ne(E, 4, this.length), t.read(this, E, !1, 23, 4))
          }),
          (a.prototype.readDoubleLE = function (E, N) {
            return ((E = E >>> 0), N || ne(E, 8, this.length), t.read(this, E, !0, 52, 8))
          }),
          (a.prototype.readDoubleBE = function (E, N) {
            return ((E = E >>> 0), N || ne(E, 8, this.length), t.read(this, E, !1, 52, 8))
          }))
        function ie(z, E, N, q, Z, $) {
          if (!a.isBuffer(z)) throw new TypeError('"buffer" argument must be a Buffer instance')
          if (E > Z || E < $) throw new RangeError('"value" argument is out of bounds')
          if (N + q > z.length) throw new RangeError('Index out of range')
        }
        ;((a.prototype.writeUintLE = a.prototype.writeUIntLE =
          function (E, N, q, Z) {
            if (((E = +E), (N = N >>> 0), (q = q >>> 0), !Z)) {
              const Ue = Math.pow(2, 8 * q) - 1
              ie(this, E, N, q, Ue, 0)
            }
            let $ = 1,
              ae = 0
            for (this[N] = E & 255; ++ae < q && ($ *= 256); ) this[N + ae] = (E / $) & 255
            return N + q
          }),
          (a.prototype.writeUintBE = a.prototype.writeUIntBE =
            function (E, N, q, Z) {
              if (((E = +E), (N = N >>> 0), (q = q >>> 0), !Z)) {
                const Ue = Math.pow(2, 8 * q) - 1
                ie(this, E, N, q, Ue, 0)
              }
              let $ = q - 1,
                ae = 1
              for (this[N + $] = E & 255; --$ >= 0 && (ae *= 256); ) this[N + $] = (E / ae) & 255
              return N + q
            }),
          (a.prototype.writeUint8 = a.prototype.writeUInt8 =
            function (E, N, q) {
              return (
                (E = +E),
                (N = N >>> 0),
                q || ie(this, E, N, 1, 255, 0),
                (this[N] = E & 255),
                N + 1
              )
            }),
          (a.prototype.writeUint16LE = a.prototype.writeUInt16LE =
            function (E, N, q) {
              return (
                (E = +E),
                (N = N >>> 0),
                q || ie(this, E, N, 2, 65535, 0),
                (this[N] = E & 255),
                (this[N + 1] = E >>> 8),
                N + 2
              )
            }),
          (a.prototype.writeUint16BE = a.prototype.writeUInt16BE =
            function (E, N, q) {
              return (
                (E = +E),
                (N = N >>> 0),
                q || ie(this, E, N, 2, 65535, 0),
                (this[N] = E >>> 8),
                (this[N + 1] = E & 255),
                N + 2
              )
            }),
          (a.prototype.writeUint32LE = a.prototype.writeUInt32LE =
            function (E, N, q) {
              return (
                (E = +E),
                (N = N >>> 0),
                q || ie(this, E, N, 4, 4294967295, 0),
                (this[N + 3] = E >>> 24),
                (this[N + 2] = E >>> 16),
                (this[N + 1] = E >>> 8),
                (this[N] = E & 255),
                N + 4
              )
            }),
          (a.prototype.writeUint32BE = a.prototype.writeUInt32BE =
            function (E, N, q) {
              return (
                (E = +E),
                (N = N >>> 0),
                q || ie(this, E, N, 4, 4294967295, 0),
                (this[N] = E >>> 24),
                (this[N + 1] = E >>> 16),
                (this[N + 2] = E >>> 8),
                (this[N + 3] = E & 255),
                N + 4
              )
            }))
        function be(z, E, N, q, Z) {
          te(E, q, Z, z, N, 7)
          let $ = Number(E & BigInt(4294967295))
          ;((z[N++] = $),
            ($ = $ >> 8),
            (z[N++] = $),
            ($ = $ >> 8),
            (z[N++] = $),
            ($ = $ >> 8),
            (z[N++] = $))
          let ae = Number((E >> BigInt(32)) & BigInt(4294967295))
          return (
            (z[N++] = ae),
            (ae = ae >> 8),
            (z[N++] = ae),
            (ae = ae >> 8),
            (z[N++] = ae),
            (ae = ae >> 8),
            (z[N++] = ae),
            N
          )
        }
        function le(z, E, N, q, Z) {
          te(E, q, Z, z, N, 7)
          let $ = Number(E & BigInt(4294967295))
          ;((z[N + 7] = $),
            ($ = $ >> 8),
            (z[N + 6] = $),
            ($ = $ >> 8),
            (z[N + 5] = $),
            ($ = $ >> 8),
            (z[N + 4] = $))
          let ae = Number((E >> BigInt(32)) & BigInt(4294967295))
          return (
            (z[N + 3] = ae),
            (ae = ae >> 8),
            (z[N + 2] = ae),
            (ae = ae >> 8),
            (z[N + 1] = ae),
            (ae = ae >> 8),
            (z[N] = ae),
            N + 8
          )
        }
        ;((a.prototype.writeBigUInt64LE = X(function (E, N = 0) {
          return be(this, E, N, BigInt(0), BigInt('0xffffffffffffffff'))
        })),
          (a.prototype.writeBigUInt64BE = X(function (E, N = 0) {
            return le(this, E, N, BigInt(0), BigInt('0xffffffffffffffff'))
          })),
          (a.prototype.writeIntLE = function (E, N, q, Z) {
            if (((E = +E), (N = N >>> 0), !Z)) {
              const Le = Math.pow(2, 8 * q - 1)
              ie(this, E, N, q, Le - 1, -Le)
            }
            let $ = 0,
              ae = 1,
              Ue = 0
            for (this[N] = E & 255; ++$ < q && (ae *= 256); )
              (E < 0 && Ue === 0 && this[N + $ - 1] !== 0 && (Ue = 1),
                (this[N + $] = (((E / ae) >> 0) - Ue) & 255))
            return N + q
          }),
          (a.prototype.writeIntBE = function (E, N, q, Z) {
            if (((E = +E), (N = N >>> 0), !Z)) {
              const Le = Math.pow(2, 8 * q - 1)
              ie(this, E, N, q, Le - 1, -Le)
            }
            let $ = q - 1,
              ae = 1,
              Ue = 0
            for (this[N + $] = E & 255; --$ >= 0 && (ae *= 256); )
              (E < 0 && Ue === 0 && this[N + $ + 1] !== 0 && (Ue = 1),
                (this[N + $] = (((E / ae) >> 0) - Ue) & 255))
            return N + q
          }),
          (a.prototype.writeInt8 = function (E, N, q) {
            return (
              (E = +E),
              (N = N >>> 0),
              q || ie(this, E, N, 1, 127, -128),
              E < 0 && (E = 255 + E + 1),
              (this[N] = E & 255),
              N + 1
            )
          }),
          (a.prototype.writeInt16LE = function (E, N, q) {
            return (
              (E = +E),
              (N = N >>> 0),
              q || ie(this, E, N, 2, 32767, -32768),
              (this[N] = E & 255),
              (this[N + 1] = E >>> 8),
              N + 2
            )
          }),
          (a.prototype.writeInt16BE = function (E, N, q) {
            return (
              (E = +E),
              (N = N >>> 0),
              q || ie(this, E, N, 2, 32767, -32768),
              (this[N] = E >>> 8),
              (this[N + 1] = E & 255),
              N + 2
            )
          }),
          (a.prototype.writeInt32LE = function (E, N, q) {
            return (
              (E = +E),
              (N = N >>> 0),
              q || ie(this, E, N, 4, 2147483647, -2147483648),
              (this[N] = E & 255),
              (this[N + 1] = E >>> 8),
              (this[N + 2] = E >>> 16),
              (this[N + 3] = E >>> 24),
              N + 4
            )
          }),
          (a.prototype.writeInt32BE = function (E, N, q) {
            return (
              (E = +E),
              (N = N >>> 0),
              q || ie(this, E, N, 4, 2147483647, -2147483648),
              E < 0 && (E = 4294967295 + E + 1),
              (this[N] = E >>> 24),
              (this[N + 1] = E >>> 16),
              (this[N + 2] = E >>> 8),
              (this[N + 3] = E & 255),
              N + 4
            )
          }),
          (a.prototype.writeBigInt64LE = X(function (E, N = 0) {
            return be(this, E, N, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          })),
          (a.prototype.writeBigInt64BE = X(function (E, N = 0) {
            return le(this, E, N, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
          })))
        function fe(z, E, N, q, Z, $) {
          if (N + q > z.length) throw new RangeError('Index out of range')
          if (N < 0) throw new RangeError('Index out of range')
        }
        function we(z, E, N, q, Z) {
          return ((E = +E), (N = N >>> 0), Z || fe(z, E, N, 4), t.write(z, E, N, q, 23, 4), N + 4)
        }
        ;((a.prototype.writeFloatLE = function (E, N, q) {
          return we(this, E, N, !0, q)
        }),
          (a.prototype.writeFloatBE = function (E, N, q) {
            return we(this, E, N, !1, q)
          }))
        function Ee(z, E, N, q, Z) {
          return ((E = +E), (N = N >>> 0), Z || fe(z, E, N, 8), t.write(z, E, N, q, 52, 8), N + 8)
        }
        ;((a.prototype.writeDoubleLE = function (E, N, q) {
          return Ee(this, E, N, !0, q)
        }),
          (a.prototype.writeDoubleBE = function (E, N, q) {
            return Ee(this, E, N, !1, q)
          }),
          (a.prototype.copy = function (E, N, q, Z) {
            if (!a.isBuffer(E)) throw new TypeError('argument should be a Buffer')
            if (
              (q || (q = 0),
              !Z && Z !== 0 && (Z = this.length),
              N >= E.length && (N = E.length),
              N || (N = 0),
              Z > 0 && Z < q && (Z = q),
              Z === q || E.length === 0 || this.length === 0)
            )
              return 0
            if (N < 0) throw new RangeError('targetStart out of bounds')
            if (q < 0 || q >= this.length) throw new RangeError('Index out of range')
            if (Z < 0) throw new RangeError('sourceEnd out of bounds')
            ;(Z > this.length && (Z = this.length), E.length - N < Z - q && (Z = E.length - N + q))
            const $ = Z - q
            return (
              this === E && typeof Uint8Array.prototype.copyWithin == 'function'
                ? this.copyWithin(N, q, Z)
                : Uint8Array.prototype.set.call(E, this.subarray(q, Z), N),
              $
            )
          }),
          (a.prototype.fill = function (E, N, q, Z) {
            if (typeof E == 'string') {
              if (
                (typeof N == 'string'
                  ? ((Z = N), (N = 0), (q = this.length))
                  : typeof q == 'string' && ((Z = q), (q = this.length)),
                Z !== void 0 && typeof Z != 'string')
              )
                throw new TypeError('encoding must be a string')
              if (typeof Z == 'string' && !a.isEncoding(Z))
                throw new TypeError('Unknown encoding: ' + Z)
              if (E.length === 1) {
                const ae = E.charCodeAt(0)
                ;((Z === 'utf8' && ae < 128) || Z === 'latin1') && (E = ae)
              }
            } else typeof E == 'number' ? (E = E & 255) : typeof E == 'boolean' && (E = Number(E))
            if (N < 0 || this.length < N || this.length < q)
              throw new RangeError('Out of range index')
            if (q <= N) return this
            ;((N = N >>> 0), (q = q === void 0 ? this.length : q >>> 0), E || (E = 0))
            let $
            if (typeof E == 'number') for ($ = N; $ < q; ++$) this[$] = E
            else {
              const ae = a.isBuffer(E) ? E : a.from(E, Z),
                Ue = ae.length
              if (Ue === 0)
                throw new TypeError('The value "' + E + '" is invalid for argument "value"')
              for ($ = 0; $ < q - N; ++$) this[$ + N] = ae[$ % Ue]
            }
            return this
          }))
        const Ie = {}
        function ze(z, E, N) {
          Ie[z] = class extends N {
            constructor() {
              ;(super(),
                Object.defineProperty(this, 'message', {
                  value: E.apply(this, arguments),
                  writable: !0,
                  configurable: !0,
                }),
                (this.name = ''.concat(this.name, ' [').concat(z, ']')),
                this.stack,
                delete this.name)
            }
            get code() {
              return z
            }
            set code(Z) {
              Object.defineProperty(this, 'code', {
                configurable: !0,
                enumerable: !0,
                value: Z,
                writable: !0,
              })
            }
            toString() {
              return ''.concat(this.name, ' [').concat(z, ']: ').concat(this.message)
            }
          }
        }
        ;(ze(
          'ERR_BUFFER_OUT_OF_BOUNDS',
          function (z) {
            return z
              ? ''.concat(z, ' is outside of buffer bounds')
              : 'Attempt to access memory outside buffer bounds'
          },
          RangeError
        ),
          ze(
            'ERR_INVALID_ARG_TYPE',
            function (z, E) {
              return 'The "'
                .concat(z, '" argument must be of type number. Received type ')
                .concat(typeof E)
            },
            TypeError
          ),
          ze(
            'ERR_OUT_OF_RANGE',
            function (z, E, N) {
              let q = 'The value of "'.concat(z, '" is out of range.'),
                Z = N
              return (
                Number.isInteger(N) && Math.abs(N) > 2 ** 32
                  ? (Z = Be(String(N)))
                  : typeof N == 'bigint' &&
                    ((Z = String(N)),
                    (N > BigInt(2) ** BigInt(32) || N < -(BigInt(2) ** BigInt(32))) && (Z = Be(Z)),
                    (Z += 'n')),
                (q += ' It must be '.concat(E, '. Received ').concat(Z)),
                q
              )
            },
            RangeError
          ))
        function Be(z) {
          let E = '',
            N = z.length
          const q = z[0] === '-' ? 1 : 0
          for (; N >= q + 4; N -= 3) E = '_'.concat(z.slice(N - 3, N)).concat(E)
          return ''.concat(z.slice(0, N)).concat(E)
        }
        function it(z, E, N) {
          ;(re(E, 'offset'), (z[E] === void 0 || z[E + N] === void 0) && b(E, z.length - (N + 1)))
        }
        function te(z, E, N, q, Z, $) {
          if (z > N || z < E) {
            const ae = typeof E == 'bigint' ? 'n' : ''
            let Ue
            throw (
              E === 0 || E === BigInt(0)
                ? (Ue = '>= 0'
                    .concat(ae, ' and < 2')
                    .concat(ae, ' ** ')
                    .concat(($ + 1) * 8)
                    .concat(ae))
                : (Ue =
                    '>= -(2'
                      .concat(ae, ' ** ')
                      .concat(($ + 1) * 8 - 1)
                      .concat(ae, ') and < 2 ** ') + ''.concat(($ + 1) * 8 - 1).concat(ae)),
              new Ie.ERR_OUT_OF_RANGE('value', Ue, z)
            )
          }
          it(q, Z, $)
        }
        function re(z, E) {
          if (typeof z != 'number') throw new Ie.ERR_INVALID_ARG_TYPE(E, 'number', z)
        }
        function b(z, E, N) {
          throw Math.floor(z) !== z
            ? (re(z, N), new Ie.ERR_OUT_OF_RANGE('offset', 'an integer', z))
            : E < 0
              ? new Ie.ERR_BUFFER_OUT_OF_BOUNDS()
              : new Ie.ERR_OUT_OF_RANGE('offset', '>= 0 and <= '.concat(E), z)
        }
        const oe = /[^+/0-9A-Za-z-_]/g
        function J(z) {
          if (((z = z.split('=')[0]), (z = z.trim().replace(oe, '')), z.length < 2)) return ''
          for (; z.length % 4 !== 0; ) z = z + '='
          return z
        }
        function H(z, E) {
          E = E || 1 / 0
          let N
          const q = z.length
          let Z = null
          const $ = []
          for (let ae = 0; ae < q; ++ae) {
            if (((N = z.charCodeAt(ae)), N > 55295 && N < 57344)) {
              if (!Z) {
                if (N > 56319) {
                  ;(E -= 3) > -1 && $.push(239, 191, 189)
                  continue
                } else if (ae + 1 === q) {
                  ;(E -= 3) > -1 && $.push(239, 191, 189)
                  continue
                }
                Z = N
                continue
              }
              if (N < 56320) {
                ;((E -= 3) > -1 && $.push(239, 191, 189), (Z = N))
                continue
              }
              N = (((Z - 55296) << 10) | (N - 56320)) + 65536
            } else Z && (E -= 3) > -1 && $.push(239, 191, 189)
            if (((Z = null), N < 128)) {
              if ((E -= 1) < 0) break
              $.push(N)
            } else if (N < 2048) {
              if ((E -= 2) < 0) break
              $.push((N >> 6) | 192, (N & 63) | 128)
            } else if (N < 65536) {
              if ((E -= 3) < 0) break
              $.push((N >> 12) | 224, ((N >> 6) & 63) | 128, (N & 63) | 128)
            } else if (N < 1114112) {
              if ((E -= 4) < 0) break
              $.push((N >> 18) | 240, ((N >> 12) & 63) | 128, ((N >> 6) & 63) | 128, (N & 63) | 128)
            } else throw new Error('Invalid code point')
          }
          return $
        }
        function P(z) {
          const E = []
          for (let N = 0; N < z.length; ++N) E.push(z.charCodeAt(N) & 255)
          return E
        }
        function k(z, E) {
          let N, q, Z
          const $ = []
          for (let ae = 0; ae < z.length && !((E -= 2) < 0); ++ae)
            ((N = z.charCodeAt(ae)), (q = N >> 8), (Z = N % 256), $.push(Z), $.push(q))
          return $
        }
        function j(z) {
          return e.toByteArray(J(z))
        }
        function B(z, E, N, q) {
          let Z
          for (Z = 0; Z < q && !(Z + N >= E.length || Z >= z.length); ++Z) E[Z + N] = z[Z]
          return Z
        }
        function D(z, E) {
          return (
            z instanceof E ||
            (z != null &&
              z.constructor != null &&
              z.constructor.name != null &&
              z.constructor.name === E.name)
          )
        }
        function Q(z) {
          return z !== z
        }
        const G = (function () {
          const z = '0123456789abcdef',
            E = new Array(256)
          for (let N = 0; N < 16; ++N) {
            const q = N * 16
            for (let Z = 0; Z < 16; ++Z) E[q + Z] = z[N] + z[Z]
          }
          return E
        })()
        function X(z) {
          return typeof BigInt > 'u' ? ue : z
        }
        function ue() {
          throw new Error('BigInt not supported')
        }
      })(og)),
    og
  )
}
var fN = m5(),
  ag,
  mS
function pN() {
  if (mS) return ag
  mS = 1
  const n = (f, p, g) => {
      const y = f.indexOf(0, p),
        m = Math.min(p + g, y === -1 ? f.length : y)
      return f.slice(p, m).toString('utf8')
    },
    e = (f, p, g, y) => {
      const m = p.write(f, g, y, 'utf8')
      m < y && p.fill(0, g + m, g + y)
    },
    t = (f, p, g) => {
      let y = f[0]
      return (y >= g && (y = g - 1), p++, f.slice(p, p + y).toString('utf8'))
    },
    i = (f, p, g, y) => {
      let m = Buffer.alloc(f, 'utf8'),
        v = m.length
      ;(v >= y && (v = y - 1),
        v > 255 && (v = 255),
        (m[g] = v),
        m.copy(p, g + 1, 0, v),
        p.fill(0, g + 1 + v, g + y))
    },
    r = (f, p) => f.readUInt32LE(p, !0),
    s = (f, p) => f.readUInt32BE(p, !0),
    o = (f, p) => f.readInt32LE(p, !0),
    a = (f, p) => f.readInt32BE(p, !0),
    l = (f, p, g) => {
      p.writeUInt32LE(f, g, !0)
    },
    c = (f, p, g) => {
      p.writeUInt32BE(f, g, !0)
    },
    u = (f, p, g) => {
      p.writeInt32LE(f, g, !0)
    },
    d = (f, p, g) => {
      p.writeInt32BE(f, g, !0)
    }
  function h(f) {
    const p = f.Buffer,
      g = f.isLittleEndian === void 0 ? !0 : !!f.isLittleEndian,
      y = f.is64bit === void 0 ? !0 : !!f.is64bit,
      m = f.unpackUInt64LE,
      v = f.unpackUInt64BE,
      x = f.unpackInt64LE,
      _ = f.unpackInt64BE,
      S = f.packUInt64LE,
      C = f.packUInt64BE,
      A = f.packInt64LE,
      R = f.packInt64BE,
      w = {
        x: [1, 1, null, null],
        c: [
          1,
          1,
          (T, F) => String.fromCharCode(T[F]),
          (T, F, V) => {
            F[V] = T.charCodeAt(0)
          },
        ],
        b: [
          1,
          1,
          (T, F) => T.readInt8(F),
          (T, F, V) => {
            F.writeInt8(T, V, !0)
          },
        ],
        B: [
          1,
          1,
          (T, F) => T[F],
          (T, F, V) => {
            F[V] = T
          },
        ],
        h: [
          2,
          2,
          g ? (T, F) => T.readInt16LE(F) : (T, F) => T.readInt16BE(F),
          g ? (T, F, V) => F.writeInt16LE(T, V, !0) : (T, F, V) => F.writeInt16BE(T, V, !0),
        ],
        H: [
          2,
          2,
          g ? (T, F) => T.readUInt16LE(F) : (T, F) => T.readUInt16BE(F),
          g ? (T, F, V) => F.writeUInt16LE(T, V, !0) : (T, F, V) => F.writeUInt16BE(T, V, !0),
        ],
        i: [4, 4, g ? o : a, g ? u : d],
        I: [4, 4, g ? r : s, g ? l : c],
        l: [4, 4, g ? o : a, g ? u : d],
        L: [4, 4, g ? r : s, g ? l : c],
        f: [
          4,
          4,
          g ? (T, F) => T.readFloatLE(F) : (T, F) => T.readFloatBE(F),
          g ? (T, F, V) => F.writeFloatLE(T, V, !0) : (T, F, V) => F.writeFloatBE(T, V, !0),
        ],
        d: [
          8,
          8,
          g ? (T, F) => T.readDoubleLE(F) : (T, F) => T.readDoubleBE(F),
          g ? (T, F, V) => F.writeDoubleLE(T, V, !0) : (T, F, V) => F.writeDoubleBE(T, V, !0),
        ],
        s: [1, 1, n, e],
        p: [1, 1, t, i],
        P: [y ? 8 : 4, y ? 8 : 4, g ? (y ? m : r) : y ? v : s, g ? (y ? S : l) : y ? C : c],
        q: [8, 8, g ? x : _, g ? A : R],
        Q: [8, 8, g ? m : v, g ? S : C],
        '?': [
          1,
          1,
          (T, F) => T[F] !== 0,
          (T, F, V) => {
            F[V] = T ? 1 : 0
          },
        ],
      },
      M = {
        x: [1, 1, null, null],
        c: [
          1,
          1,
          (T, F) => String.fromCharCode(T[F]),
          (T, F, V) => {
            F[V] = T.charCodeAt(0)
          },
        ],
        b: [
          1,
          1,
          (T, F) => T.readInt8(F),
          (T, F, V) => {
            F.writeInt8(T, V, !0)
          },
        ],
        B: [
          1,
          1,
          (T, F) => T[F],
          (T, F, V) => {
            F[V] = T
          },
        ],
        h: [2, 1, (T, F) => T.readInt16LE(F), (T, F, V) => F.writeInt16LE(T, V, !0)],
        H: [2, 1, (T, F) => T.readUInt16LE(F), (T, F, V) => F.writeUInt16LE(T, V, !0)],
        i: [4, 1, o, u],
        I: [4, 1, r, l],
        l: [4, 1, o, u],
        L: [4, 1, r, l],
        f: [4, 1, (T, F) => T.readFloatLE(F), (T, F, V) => F.writeFloatLE(T, V, !0)],
        d: [8, 1, (T, F) => T.readDoubleLE(F), (T, F, V) => F.writeDoubleLE(T, V, !0)],
        s: [1, 1, n, e],
        p: [1, 1, t, i],
        P: [y ? 8 : 4, 1, y ? m : r, y ? S : l],
        q: [8, 1, x, A],
        Q: [8, 1, m, S],
        '?': [
          1,
          1,
          (T, F) => T[F] !== 0,
          (T, F, V) => {
            F[V] = T ? 1 : 0
          },
        ],
      },
      I = {
        x: [1, 1, null, null],
        c: [
          1,
          1,
          (T, F) => String.fromCharCode(T[F]),
          (T, F, V) => {
            F[V] = T.charCodeAt(0)
          },
        ],
        b: [
          1,
          1,
          (T, F) => T.readInt8(F),
          (T, F, V) => {
            F.writeInt8(T, V, !0)
          },
        ],
        B: [
          1,
          1,
          (T, F) => T[F],
          (T, F, V) => {
            F[V] = T
          },
        ],
        h: [2, 1, (T, F) => T.readInt16BE(F), (T, F, V) => F.writeInt16BE(T, V, !0)],
        H: [2, 1, (T, F) => T.readUInt16BE(F), (T, F, V) => F.writeUInt16BE(T, V, !0)],
        i: [4, 1, a, d],
        I: [4, 1, s, c],
        l: [4, 1, a, d],
        L: [4, 1, s, c],
        f: [4, 1, (T, F) => T.readFloatBE(F), (T, F, V) => F.writeFloatBE(T, V, !0)],
        d: [8, 1, (T, F) => T.readDoubleBE(F), (T, F, V) => F.writeDoubleBE(T, V, !0)],
        s: [1, 1, n, e],
        p: [1, 1, t, i],
        P: [y ? 8 : 4, 1, y ? v : s, y ? C : c],
        q: [8, 1, _, R],
        Q: [8, 1, v, C],
        '?': [
          1,
          1,
          (T, F) => T[F] !== 0,
          (T, F, V) => {
            F[V] = T ? 1 : 0
          },
        ],
      }
    let L = (T) => {
      let F = T[0],
        V = !0,
        W = w
      switch (F) {
        case '<':
          W = M
          break
        case '>':
        case '!':
          W = I
          break
        case '=':
          W = g ? M : I
          break
        default:
          V = !1
        case '@':
          W = w
          break
      }
      return { map: W, skipFirst: V }
    }
    class U {
      static sizeOf(F) {
        let V = 0,
          W = null,
          ee = 0,
          se,
          he,
          ne,
          ie,
          be = L(F),
          le = be.map
        for (be.skipFirst && ee++, he = F.length; ee < he; ee++) {
          if (((se = F[ee]), se >= '0' && se <= '9')) {
            W = W === null ? se : W + se
            continue
          }
          ;((ne = le[se]),
            ne &&
              ((ie = ne[1]),
              ie > 1 && (V = Math.ceil(V / ie) * ie),
              (W = W ? parseInt(W, 10) : 0),
              se === 's' ? (V += W || 0) : se === 'p' ? (V += W || 1) : (V += ne[0] * (W || 1)),
              (W = null)))
        }
        return V
      }
      static unpack(F, V, W) {
        return U.unpackFrom(F, V, W, 0)
      }
      static unpackFrom(F, V, W, ee) {
        let se = [],
          he = null,
          ne = 0,
          ie = L(F),
          be = ie.map
        ie.skipFirst && ne++
        for (const le = F.length; ne < le; ne++) {
          let fe = F[ne]
          if (fe >= '0' && fe <= '9') {
            he = he === null ? fe : he + fe
            continue
          }
          const we = be[fe]
          if (!we) continue
          let Ee = we[0]
          const Ie = we[1]
          ;(Ie > 1 && (ee = Math.ceil(ee / Ie) * Ie), (he = he ? parseInt(he, 10) : 0))
          let ze
          fe === 's'
            ? ((ze = 1), (Ee = he))
            : fe === 'p'
              ? ((ze = 1), (Ee = he || 1))
              : (ze = he || 1)
          let Be = we[2]
          for (; ze > 0; ) {
            if (Be) {
              if (W && ee + Ee >= V.length)
                throw new Error("Reached end of buffer, can't unpack anymore data.")
              se.push(Be(V, ee, he))
            }
            ;((ee += Ee), ze--)
          }
          he = null
        }
        return se
      }
      static pack(F, V, W) {
        Array.isArray(V) || ((V = Array.prototype.slice.call(arguments, 1)), (W = !0))
        let ee = p.alloc(U.sizeOf(F)),
          se = 0,
          he = null,
          ne = 0,
          ie = 0,
          be = L(F),
          le = be.map
        be.skipFirst && ne++
        for (const fe = F.length; ne < fe; ne++) {
          let we = F[ne]
          if (we >= '0' && we <= '9') {
            he = he === null ? we : he + we
            continue
          }
          const Ee = le[we]
          if (!Ee) continue
          let Ie = Ee[0]
          const ze = Ee[1]
          ;(ze > 1 && (se = Math.ceil(se / ze) * ze), (he = he ? parseInt(he, 10) : 0))
          let Be
          we === 's'
            ? ((Be = 1), (Ie = he))
            : we === 'p'
              ? ((Be = 1), (Ie = he || 1))
              : (Be = he || 1)
          let it = Ee[3]
          for (; Be > 0; ) {
            if (it) {
              if (W && ie >= V.length)
                throw new Error('Reached end of data, no more elements to pack.')
              ;(it(V[ie], ee, se, he), ie++)
            }
            ;((se += Ie), Be--)
          }
          he = null
        }
        return ee
      }
    }
    return U
  }
  return ((ag = h), ag)
}
var lg, gS
function mN() {
  if (gS) return lg
  ;((gS = 1), (lg = e))
  var n = null
  try {
    n = new WebAssembly.Instance(
      new WebAssembly.Module(
        new Uint8Array([
          0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127,
          3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1,
          5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95,
          115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0,
          0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134,
          132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
          167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173,
          66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32,
          0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34,
          4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32,
          134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0,
          32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,
          3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
        ])
      ),
      {}
    ).exports
  } catch (M) {}
  function e(M, I, L) {
    ;((this.low = M | 0), (this.high = I | 0), (this.unsigned = !!L))
  }
  ;(e.prototype.__isLong__, Object.defineProperty(e.prototype, '__isLong__', { value: !0 }))
  function t(M) {
    return (M && M.__isLong__) === !0
  }
  e.isLong = t
  var i = {},
    r = {}
  function s(M, I) {
    var L, U, T
    return I
      ? ((M >>>= 0),
        (T = 0 <= M && M < 256) && ((U = r[M]), U)
          ? U
          : ((L = a(M, (M | 0) < 0 ? -1 : 0, !0)), T && (r[M] = L), L))
      : ((M |= 0),
        (T = -128 <= M && M < 128) && ((U = i[M]), U)
          ? U
          : ((L = a(M, M < 0 ? -1 : 0, !1)), T && (i[M] = L), L))
  }
  e.fromInt = s
  function o(M, I) {
    if (isNaN(M)) return I ? v : m
    if (I) {
      if (M < 0) return v
      if (M >= p) return A
    } else {
      if (M <= -g) return R
      if (M + 1 >= g) return C
    }
    return M < 0 ? o(-M, I).neg() : a(M % f | 0, (M / f) | 0, I)
  }
  e.fromNumber = o
  function a(M, I, L) {
    return new e(M, I, L)
  }
  e.fromBits = a
  var l = Math.pow
  function c(M, I, L) {
    if (M.length === 0) throw Error('empty string')
    if (M === 'NaN' || M === 'Infinity' || M === '+Infinity' || M === '-Infinity') return m
    if ((typeof I == 'number' ? ((L = I), (I = !1)) : (I = !!I), (L = L || 10), L < 2 || 36 < L))
      throw RangeError('radix')
    var U
    if ((U = M.indexOf('-')) > 0) throw Error('interior hyphen')
    if (U === 0) return c(M.substring(1), I, L).neg()
    for (var T = o(l(L, 8)), F = m, V = 0; V < M.length; V += 8) {
      var W = Math.min(8, M.length - V),
        ee = parseInt(M.substring(V, V + W), L)
      if (W < 8) {
        var se = o(l(L, W))
        F = F.mul(se).add(o(ee))
      } else ((F = F.mul(T)), (F = F.add(o(ee))))
    }
    return ((F.unsigned = I), F)
  }
  e.fromString = c
  function u(M, I) {
    return typeof M == 'number'
      ? o(M, I)
      : typeof M == 'string'
        ? c(M, I)
        : a(M.low, M.high, typeof I == 'boolean' ? I : M.unsigned)
  }
  e.fromValue = u
  var d = 65536,
    h = 1 << 24,
    f = d * d,
    p = f * f,
    g = p / 2,
    y = s(h),
    m = s(0)
  e.ZERO = m
  var v = s(0, !0)
  e.UZERO = v
  var x = s(1)
  e.ONE = x
  var _ = s(1, !0)
  e.UONE = _
  var S = s(-1)
  e.NEG_ONE = S
  var C = a(-1, 2147483647, !1)
  e.MAX_VALUE = C
  var A = a(-1, -1, !0)
  e.MAX_UNSIGNED_VALUE = A
  var R = a(0, -2147483648, !1)
  e.MIN_VALUE = R
  var w = e.prototype
  return (
    (w.toInt = function () {
      return this.unsigned ? this.low >>> 0 : this.low
    }),
    (w.toNumber = function () {
      return this.unsigned
        ? (this.high >>> 0) * f + (this.low >>> 0)
        : this.high * f + (this.low >>> 0)
    }),
    (w.toString = function (I) {
      if (((I = I || 10), I < 2 || 36 < I)) throw RangeError('radix')
      if (this.isZero()) return '0'
      if (this.isNegative())
        if (this.eq(R)) {
          var L = o(I),
            U = this.div(L),
            T = U.mul(L).sub(this)
          return U.toString(I) + T.toInt().toString(I)
        } else return '-' + this.neg().toString(I)
      for (var F = o(l(I, 6), this.unsigned), V = this, W = ''; ; ) {
        var ee = V.div(F),
          se = V.sub(ee.mul(F)).toInt() >>> 0,
          he = se.toString(I)
        if (((V = ee), V.isZero())) return he + W
        for (; he.length < 6; ) he = '0' + he
        W = '' + he + W
      }
    }),
    (w.getHighBits = function () {
      return this.high
    }),
    (w.getHighBitsUnsigned = function () {
      return this.high >>> 0
    }),
    (w.getLowBits = function () {
      return this.low
    }),
    (w.getLowBitsUnsigned = function () {
      return this.low >>> 0
    }),
    (w.getNumBitsAbs = function () {
      if (this.isNegative()) return this.eq(R) ? 64 : this.neg().getNumBitsAbs()
      for (
        var I = this.high != 0 ? this.high : this.low, L = 31;
        L > 0 && (I & (1 << L)) == 0;
        L--
      );
      return this.high != 0 ? L + 33 : L + 1
    }),
    (w.isZero = function () {
      return this.high === 0 && this.low === 0
    }),
    (w.eqz = w.isZero),
    (w.isNegative = function () {
      return !this.unsigned && this.high < 0
    }),
    (w.isPositive = function () {
      return this.unsigned || this.high >= 0
    }),
    (w.isOdd = function () {
      return (this.low & 1) === 1
    }),
    (w.isEven = function () {
      return (this.low & 1) === 0
    }),
    (w.equals = function (I) {
      return (
        t(I) || (I = u(I)),
        this.unsigned !== I.unsigned && this.high >>> 31 === 1 && I.high >>> 31 === 1
          ? !1
          : this.high === I.high && this.low === I.low
      )
    }),
    (w.eq = w.equals),
    (w.notEquals = function (I) {
      return !this.eq(I)
    }),
    (w.neq = w.notEquals),
    (w.ne = w.notEquals),
    (w.lessThan = function (I) {
      return this.comp(I) < 0
    }),
    (w.lt = w.lessThan),
    (w.lessThanOrEqual = function (I) {
      return this.comp(I) <= 0
    }),
    (w.lte = w.lessThanOrEqual),
    (w.le = w.lessThanOrEqual),
    (w.greaterThan = function (I) {
      return this.comp(I) > 0
    }),
    (w.gt = w.greaterThan),
    (w.greaterThanOrEqual = function (I) {
      return this.comp(I) >= 0
    }),
    (w.gte = w.greaterThanOrEqual),
    (w.ge = w.greaterThanOrEqual),
    (w.compare = function (I) {
      if ((t(I) || (I = u(I)), this.eq(I))) return 0
      var L = this.isNegative(),
        U = I.isNegative()
      return L && !U
        ? -1
        : !L && U
          ? 1
          : this.unsigned
            ? I.high >>> 0 > this.high >>> 0 ||
              (I.high === this.high && I.low >>> 0 > this.low >>> 0)
              ? -1
              : 1
            : this.sub(I).isNegative()
              ? -1
              : 1
    }),
    (w.comp = w.compare),
    (w.negate = function () {
      return !this.unsigned && this.eq(R) ? R : this.not().add(x)
    }),
    (w.neg = w.negate),
    (w.add = function (I) {
      t(I) || (I = u(I))
      var L = this.high >>> 16,
        U = this.high & 65535,
        T = this.low >>> 16,
        F = this.low & 65535,
        V = I.high >>> 16,
        W = I.high & 65535,
        ee = I.low >>> 16,
        se = I.low & 65535,
        he = 0,
        ne = 0,
        ie = 0,
        be = 0
      return (
        (be += F + se),
        (ie += be >>> 16),
        (be &= 65535),
        (ie += T + ee),
        (ne += ie >>> 16),
        (ie &= 65535),
        (ne += U + W),
        (he += ne >>> 16),
        (ne &= 65535),
        (he += L + V),
        (he &= 65535),
        a((ie << 16) | be, (he << 16) | ne, this.unsigned)
      )
    }),
    (w.subtract = function (I) {
      return (t(I) || (I = u(I)), this.add(I.neg()))
    }),
    (w.sub = w.subtract),
    (w.multiply = function (I) {
      if (this.isZero()) return m
      if ((t(I) || (I = u(I)), n)) {
        var L = n.mul(this.low, this.high, I.low, I.high)
        return a(L, n.get_high(), this.unsigned)
      }
      if (I.isZero()) return m
      if (this.eq(R)) return I.isOdd() ? R : m
      if (I.eq(R)) return this.isOdd() ? R : m
      if (this.isNegative())
        return I.isNegative() ? this.neg().mul(I.neg()) : this.neg().mul(I).neg()
      if (I.isNegative()) return this.mul(I.neg()).neg()
      if (this.lt(y) && I.lt(y)) return o(this.toNumber() * I.toNumber(), this.unsigned)
      var U = this.high >>> 16,
        T = this.high & 65535,
        F = this.low >>> 16,
        V = this.low & 65535,
        W = I.high >>> 16,
        ee = I.high & 65535,
        se = I.low >>> 16,
        he = I.low & 65535,
        ne = 0,
        ie = 0,
        be = 0,
        le = 0
      return (
        (le += V * he),
        (be += le >>> 16),
        (le &= 65535),
        (be += F * he),
        (ie += be >>> 16),
        (be &= 65535),
        (be += V * se),
        (ie += be >>> 16),
        (be &= 65535),
        (ie += T * he),
        (ne += ie >>> 16),
        (ie &= 65535),
        (ie += F * se),
        (ne += ie >>> 16),
        (ie &= 65535),
        (ie += V * ee),
        (ne += ie >>> 16),
        (ie &= 65535),
        (ne += U * he + T * se + F * ee + V * W),
        (ne &= 65535),
        a((be << 16) | le, (ne << 16) | ie, this.unsigned)
      )
    }),
    (w.mul = w.multiply),
    (w.divide = function (I) {
      if ((t(I) || (I = u(I)), I.isZero())) throw Error('division by zero')
      if (n) {
        if (!this.unsigned && this.high === -2147483648 && I.low === -1 && I.high === -1)
          return this
        var L = (this.unsigned ? n.div_u : n.div_s)(this.low, this.high, I.low, I.high)
        return a(L, n.get_high(), this.unsigned)
      }
      if (this.isZero()) return this.unsigned ? v : m
      var U, T, F
      if (this.unsigned) {
        if ((I.unsigned || (I = I.toUnsigned()), I.gt(this))) return v
        if (I.gt(this.shru(1))) return _
        F = v
      } else {
        if (this.eq(R)) {
          if (I.eq(x) || I.eq(S)) return R
          if (I.eq(R)) return x
          var V = this.shr(1)
          return (
            (U = V.div(I).shl(1)),
            U.eq(m)
              ? I.isNegative()
                ? x
                : S
              : ((T = this.sub(I.mul(U))), (F = U.add(T.div(I))), F)
          )
        } else if (I.eq(R)) return this.unsigned ? v : m
        if (this.isNegative())
          return I.isNegative() ? this.neg().div(I.neg()) : this.neg().div(I).neg()
        if (I.isNegative()) return this.div(I.neg()).neg()
        F = m
      }
      for (T = this; T.gte(I); ) {
        U = Math.max(1, Math.floor(T.toNumber() / I.toNumber()))
        for (
          var W = Math.ceil(Math.log(U) / Math.LN2),
            ee = W <= 48 ? 1 : l(2, W - 48),
            se = o(U),
            he = se.mul(I);
          he.isNegative() || he.gt(T);

        )
          ((U -= ee), (se = o(U, this.unsigned)), (he = se.mul(I)))
        ;(se.isZero() && (se = x), (F = F.add(se)), (T = T.sub(he)))
      }
      return F
    }),
    (w.div = w.divide),
    (w.modulo = function (I) {
      if ((t(I) || (I = u(I)), n)) {
        var L = (this.unsigned ? n.rem_u : n.rem_s)(this.low, this.high, I.low, I.high)
        return a(L, n.get_high(), this.unsigned)
      }
      return this.sub(this.div(I).mul(I))
    }),
    (w.mod = w.modulo),
    (w.rem = w.modulo),
    (w.not = function () {
      return a(~this.low, ~this.high, this.unsigned)
    }),
    (w.and = function (I) {
      return (t(I) || (I = u(I)), a(this.low & I.low, this.high & I.high, this.unsigned))
    }),
    (w.or = function (I) {
      return (t(I) || (I = u(I)), a(this.low | I.low, this.high | I.high, this.unsigned))
    }),
    (w.xor = function (I) {
      return (t(I) || (I = u(I)), a(this.low ^ I.low, this.high ^ I.high, this.unsigned))
    }),
    (w.shiftLeft = function (I) {
      return (
        t(I) && (I = I.toInt()),
        (I &= 63) === 0
          ? this
          : I < 32
            ? a(this.low << I, (this.high << I) | (this.low >>> (32 - I)), this.unsigned)
            : a(0, this.low << (I - 32), this.unsigned)
      )
    }),
    (w.shl = w.shiftLeft),
    (w.shiftRight = function (I) {
      return (
        t(I) && (I = I.toInt()),
        (I &= 63) === 0
          ? this
          : I < 32
            ? a((this.low >>> I) | (this.high << (32 - I)), this.high >> I, this.unsigned)
            : a(this.high >> (I - 32), this.high >= 0 ? 0 : -1, this.unsigned)
      )
    }),
    (w.shr = w.shiftRight),
    (w.shiftRightUnsigned = function (I) {
      if ((t(I) && (I = I.toInt()), (I &= 63), I === 0)) return this
      var L = this.high
      if (I < 32) {
        var U = this.low
        return a((U >>> I) | (L << (32 - I)), L >>> I, this.unsigned)
      } else return I === 32 ? a(L, 0, this.unsigned) : a(L >>> (I - 32), 0, this.unsigned)
    }),
    (w.shru = w.shiftRightUnsigned),
    (w.shr_u = w.shiftRightUnsigned),
    (w.toSigned = function () {
      return this.unsigned ? a(this.low, this.high, !1) : this
    }),
    (w.toUnsigned = function () {
      return this.unsigned ? this : a(this.low, this.high, !0)
    }),
    (w.toBytes = function (I) {
      return I ? this.toBytesLE() : this.toBytesBE()
    }),
    (w.toBytesLE = function () {
      var I = this.high,
        L = this.low
      return [
        L & 255,
        (L >>> 8) & 255,
        (L >>> 16) & 255,
        L >>> 24,
        I & 255,
        (I >>> 8) & 255,
        (I >>> 16) & 255,
        I >>> 24,
      ]
    }),
    (w.toBytesBE = function () {
      var I = this.high,
        L = this.low
      return [
        I >>> 24,
        (I >>> 16) & 255,
        (I >>> 8) & 255,
        I & 255,
        L >>> 24,
        (L >>> 16) & 255,
        (L >>> 8) & 255,
        L & 255,
      ]
    }),
    (e.fromBytes = function (I, L, U) {
      return U ? e.fromBytesLE(I, L) : e.fromBytesBE(I, L)
    }),
    (e.fromBytesLE = function (I, L) {
      return new e(
        I[0] | (I[1] << 8) | (I[2] << 16) | (I[3] << 24),
        I[4] | (I[5] << 8) | (I[6] << 16) | (I[7] << 24),
        L
      )
    }),
    (e.fromBytesBE = function (I, L) {
      return new e(
        (I[4] << 24) | (I[5] << 16) | (I[6] << 8) | I[7],
        (I[0] << 24) | (I[1] << 16) | (I[2] << 8) | I[3],
        L
      )
    }),
    lg
  )
}
var cg, yS
function gN() {
  if (yS) return cg
  yS = 1
  const n = mN(),
    e = (a, l) => n.fromBits(a.readInt32LE(l), a.readInt32LE(l + 4), !0),
    t = (a, l) => n.fromBits(a.readInt32BE(l + 4), a.readInt32BE(l), !0),
    i = (a, l) => n.fromBits(a.readInt32LE(l), a.readInt32LE(l + 4), !1),
    r = (a, l) => n.fromBits(a.readInt32BE(l + 4), a.readInt32BE(l), !1),
    s = (a, l, c) => {
      ;(a instanceof n ||
        (typeof a == 'number' ? (a = n.fromNumber(a)) : (a = n.fromString(a || ''))),
        l.writeInt32LE(a.getLowBits(), c, !0),
        l.writeInt32LE(a.getHighBits(), c + 4, !0))
    },
    o = (a, l, c) => {
      ;(a instanceof n ||
        (typeof a == 'number' ? (a = n.fromNumber(a)) : (a = n.fromString(a || ''))),
        l.writeInt32BE(a.getHighBits(), c, !0),
        l.writeInt32BE(a.getLowBits(), c + 4, !0))
    }
  return (
    (cg = {
      unpackUInt64LE: e,
      unpackUInt64BE: t,
      unpackInt64LE: i,
      unpackInt64BE: r,
      packUInt64LE: s,
      packUInt64BE: o,
      packInt64LE: s,
      packInt64BE: o,
    }),
    cg
  )
}
var ug, vS
function yN() {
  return (
    vS ||
      ((vS = 1),
      (ug = pN()(
        Object.assign(
          {
            Buffer: m5().Buffer,
            isLittleEndian:
              typeof Uint8Array !== void 0
                ? new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 120
                : !0,
            is64bit:
              typeof navigator !== void 0
                ? /WOW64|Win64|arm64|ia64|x64;|Mac OS X/i.test(navigator.userAgent)
                : !0,
          },
          gN()
        )
      ))),
    ug
  )
}
var vN = yN()
const _N = u_(vN),
  xN = async function (n, e = '<II') {
    const t = await n.slice(4, 12).arrayBuffer(),
      [i, r] = _N.unpack(e, fN.Buffer.from(t)),
      s = await n.slice(12, 12 + i).text()
    return { parsedData: JSON.parse(s), jsonSize: i, binSize: r }
  },
  SN = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let AN = (n = 21) => {
  let e = '',
    t = crypto.getRandomValues(new Uint8Array((n |= 0)))
  for (; n--; ) e += SN[t[n] & 63]
  return e
}
class h_ {
  constructor(e, t) {
    xe(this, 'id', AN())
    xe(this, 'analyserNode')
    xe(this, 'audioCtx')
    xe(this, 'autoPlay', !0)
    xe(this, 'bufferSource')
    xe(this, 'convertValue', 32768)
    xe(this, 'ee')
    xe(this, 'gainNode')
    xe(this, 'option', {
      inputCodec: 'Int16',
      channels: 1,
      sampleRate: 8e3,
      fftSize: 2048,
      onended: () => {},
      isMute: !1,
    })
    xe(this, 'samplesList', [])
    xe(this, 'startTime')
    xe(this, 'typedArray')
    xe(this, '_firstStartRelativeTime')
    xe(this, '_firstStartAbsoluteTime')
    ;((this.ee = t), this.init(e))
  }
  static isTypedArray(e) {
    return (
      (e.byteLength && e.buffer && e.buffer.constructor === ArrayBuffer) ||
      e.constructor === ArrayBuffer
    )
  }
  async continue() {
    await this.audioCtx.resume()
  }
  destroy() {
    var e
    ;((this.samplesList = []), (e = this.audioCtx) == null || e.close(), (this.audioCtx = void 0))
  }
  feed(e) {
    let { audio: t } = e
    const { end_of_batch: i } = e
    if (!t) return
    ;(this._isSupported(t), (t = this._getFormattedValue(t)))
    const r = new Float32Array(t.length)
    r.set(t, 0)
    const s = { data: r, end_of_batch: i }
    ;(this.samplesList.push(s), this.flush(s, this.samplesList.length - 1))
  }
  flush(e, t) {
    if (!(e && this.autoPlay && this.audioCtx)) return
    const { data: i, end_of_batch: r } = e
    ;(this.bufferSource && (this.bufferSource.onended = () => {}),
      (this.bufferSource = this.audioCtx.createBufferSource()),
      typeof this.option.onended == 'function' &&
        (this.bufferSource.onended = () => {
          ;(!r && t === this.samplesList.length - 1 && this.ee.emit(Ul.Player_WaitNextAudioClip),
            this.option.onended())
        }))
    const s = i.length / this.option.channels,
      o = this.audioCtx.createBuffer(this.option.channels, s, this.option.sampleRate)
    for (let a = 0; a < this.option.channels; a++) {
      const l = o.getChannelData(a)
      let c = a,
        u = 50
      for (let d = 0; d < s; d++)
        ((l[d] = i[c]),
          d < 50 && (l[d] = (l[d] * d) / 50),
          d >= s - 51 && (l[d] = (l[d] * u--) / 50),
          (c += this.option.channels))
    }
    ;(this.startTime < this.audioCtx.currentTime && (this.startTime = this.audioCtx.currentTime),
      (this.bufferSource.buffer = o),
      this.bufferSource.connect(this.gainNode),
      this.bufferSource.connect(this.analyserNode),
      this.bufferSource.start(this.startTime),
      (e.startTime = this.startTime),
      this._firstStartAbsoluteTime === void 0 && (this._firstStartAbsoluteTime = Date.now()),
      this._firstStartRelativeTime === void 0 &&
        ((this._firstStartRelativeTime = this.startTime),
        this.ee.emit(Ul.Player_StartSpeaking, this)),
      (this.startTime += o.duration))
  }
  init(e) {
    ;((this.option = Object.assign(this.option, e)),
      (this.convertValue = this._getConvertValue()),
      (this.typedArray = this._getTypedArray()),
      this.initAudioContext())
  }
  initAudioContext() {
    ;((this.audioCtx = new (window.AudioContext || window.webkitAudioContext)()),
      (this.gainNode = this.audioCtx.createGain()),
      (this.gainNode.gain.value = this.option.isMute ? 0 : 1),
      this.gainNode.connect(this.audioCtx.destination),
      (this.startTime = this.audioCtx.currentTime),
      (this.analyserNode = this.audioCtx.createAnalyser()),
      (this.analyserNode.fftSize = this.option.fftSize))
  }
  setMute(e) {
    this.gainNode.gain.value = e ? 0 : 1
  }
  async pause() {
    await this.audioCtx.suspend()
  }
  async updateAutoPlay(e) {
    this.autoPlay !== e && e
      ? ((this.autoPlay = e),
        this.samplesList.forEach((t, i) => {
          this.flush(t, i)
        }))
      : (this.autoPlay = e)
  }
  volume(e) {
    this.gainNode.gain.value = e
  }
  _getFormattedValue(e) {
    const t = this.typedArray
    e.constructor === ArrayBuffer ? (e = new t(e)) : (e = new t(e.buffer))
    const i = new Float32Array(e.length)
    for (let r = 0; r < e.length; r++) i[r] = e[r] / this.convertValue
    return i
  }
  _isSupported(e) {
    if (!h_.isTypedArray(e)) throw new Error('请传入ArrayBuffer或者任意TypedArray')
    return !0
  }
  _getConvertValue() {
    const e = { Int8: 128, Int16: 32768, Int32: 2147483648, Float32: 1 }
    if (!e[this.option.inputCodec])
      throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')
    return e[this.option.inputCodec]
  }
  _getTypedArray() {
    const e = { Int8: Int8Array, Int16: Int16Array, Int32: Int32Array, Float32: Float32Array }
    if (!e[this.option.inputCodec])
      throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')
    return e[this.option.inputCodec]
  }
}
const bN = { int16: 'Int16', int32: 'Int32', float32: 'Float32' },
  TN = { int16: Int16Array, int32: Int32Array, float32: Float32Array }
class wN {
  constructor(e) {
    xe(this, 'ee')
    xe(this, '_motionDataGroupHandlerQueue', new dN({ concurrency: 1 }))
    xe(this, '_motionDataGroups', [])
    xe(this, '_arkit_face_sample_rate')
    xe(this, '_arkit_face_channel_names')
    xe(this, '_tts2face_sample_rate')
    xe(this, '_tts2face_channel_names')
    xe(this, '_maxBatchId')
    xe(this, '_arkitFaceShape')
    xe(this, '_tts2FaceShape')
    this.ee = e
  }
  add(e) {
    const { avatar_motion_data: t } = e
    this._motionDataGroupHandlerQueue.add(async () => await this._motionDataGroupHandler(t))
  }
  clear() {
    ;(this._motionDataGroups.forEach((e) => {
      var t
      ;(t = e.player) == null || t.destroy()
    }),
      (this._motionDataGroups = []))
  }
  setMute(e) {
    this._motionDataGroups.forEach((t) => {
      var i
      ;(i = t.player) == null || i.setMute(e)
    })
  }
  getArkitFaceFrame() {
    return { arkitFace: this._getArkitFaceFrame() }
  }
  getLastBatchId() {
    let e
    return (
      this._motionDataGroups.forEach((t) => {
        t.batch_id && (e = t.batch_id)
      }),
      e
    )
  }
  getTtt2FaceFrame() {
    return { tts2Face: this._getTts2FaceFrame() }
  }
  interrupt() {
    ;(this._motionDataGroups.forEach((e) => {
      var t
      ;(e.batch_id && (this._maxBatchId = e.batch_id), (t = e.player) == null || t.destroy())
    }),
      (this._motionDataGroups = []))
  }
  _getArkitFaceFrame() {
    if (!this._motionDataGroups.length) return null
    const e = this._motionDataGroups.find((r) => r.player)
    if (!e) return null
    const { arkitFaceArrayBufferArray: t, player: i } = e
    if (
      i &&
      i._firstStartAbsoluteTime &&
      t &&
      t.length > 0 &&
      this._arkitFaceShape &&
      this._arkit_face_sample_rate
    ) {
      const r = Date.now() - i._firstStartAbsoluteTime
      let s = 0,
        o
      i.samplesList.forEach((h, f) => {
        ;(o === void 0 && h.startTime !== void 0 && (o = h.startTime),
          h.startTime !== void 0 && h.startTime - o <= r / 1e3 && (s = f))
      })
      const a = i.samplesList[s],
        l = r - a.startTime * 1e3,
        c = Math.floor((l / 1e3) * this._arkit_face_sample_rate),
        u = new Float32Array(t[s]),
        d =
          u == null
            ? void 0
            : u.slice(c * this._arkitFaceShape, c * this._arkitFaceShape + this._arkitFaceShape)
      if (d != null && d.length) {
        const h = {}
        return (
          (this._arkit_face_channel_names || []).forEach((p, g) => {
            Object.assign(h, { [p]: d[g] })
          }),
          h
        )
      }
      return null
    }
    return null
  }
  _getTts2FaceFrame() {
    if (!this._motionDataGroups.length) return null
    const e = this._motionDataGroups.find((r) => r.player)
    if (!e) return null
    const { tts2faceArrayBufferArray: t, player: i } = e
    if (
      i &&
      i._firstStartAbsoluteTime &&
      t &&
      t.length > 0 &&
      this._tts2FaceShape &&
      this._tts2face_sample_rate
    ) {
      const r = Date.now() - i._firstStartAbsoluteTime
      let s = 0,
        o
      i.samplesList.forEach((h, f) => {
        ;(o === void 0 && h.startTime !== void 0 && (o = h.startTime),
          h.startTime !== void 0 && h.startTime - o <= r / 1e3 && (s = f))
      })
      const a = i.samplesList[s],
        l = r - a.startTime * 1e3,
        c = Math.floor((l / 1e3) * this._tts2face_sample_rate),
        u = new Float32Array(t[s]),
        d =
          u == null
            ? void 0
            : u.slice(c * this._tts2FaceShape, c * this._tts2FaceShape + this._tts2FaceShape)
      return d != null && d.length ? d : null
    }
    return null
  }
  async _motionDataGroupHandler(e) {
    try {
      const {
        first_package: t,
        motion_data_slice: i,
        segment_num: r,
        binary_size: s,
        use_binary_frame: o,
        is_audio_mute: a,
      } = e
      if (t) {
        const l = this._motionDataGroups[this._motionDataGroups.length - 1]
        ;(l &&
          l.segment_num !== l.motion_data_slices.length &&
          this.ee.emit(xr.ErrorReceived, 'lost data packets'),
          this._motionDataGroups.push({
            first_package: t,
            binary_size: s,
            segment_num: r,
            use_binary_frame: o,
            motion_data_slices: [],
            merged_motion_data: new Uint8Array(s),
          }))
      } else {
        if (this._motionDataGroups.length === 0 || !i) return
        const l = this._motionDataGroups[this._motionDataGroups.length - 1],
          c = this._motionDataGroups[this._motionDataGroups.length - 2]
        if ((l.motion_data_slices.push(i), l.motion_data_slices.length === l.segment_num)) {
          const u = l.motion_data_slices[0],
            { parsedData: d, jsonSize: h, binSize: f } = await xN(u)
          ;((l.jsonSize = h), (l.binSize = f))
          const p = u.slice(12 + l.jsonSize)
          if (
            (p.size !== l.binSize && this.ee.emit(ey.Chat_BinsizeError),
            !this._connectBatch(d, l, c))
          )
            return
          ;(await this._handleArkitFaceConfig(d, l, c, p),
            await this._handleAudioConfig(d, l, c, p, a || !1),
            this._handleEvents(d))
        }
      }
    } catch (t) {
      ;(console.error('err', t), this.ee.emit(xr.ErrorReceived, t.message))
    }
  }
  async _handleAudioConfig(e, t, i, r, s) {
    const { data_records: o = {}, end_of_batch: a } = e,
      { audio: l } = o
    if (l) {
      const { sample_rate: c, shape: u, data_offset: d, data_type: h } = l,
        f = bN[h],
        p = TN[h]
      if (
        t.player === void 0 &&
        (i && i.player && i.batch_id === t.batch_id
          ? (t.player = i.player)
          : c &&
            (t.player = new h_(
              {
                inputCodec: f,
                channels: 1,
                sampleRate: c,
                fftSize: 1024,
                isMute: s,
                onended: (S) => {
                  if (!S) return
                  const { end_of_batch: C, lastMotionGroup: A } = S
                  if (C) {
                    const { batch_id: R, player: w } = A
                    ;(this.ee.emit(Ul.Player_EndSpeaking, w),
                      (this._motionDataGroups = this._motionDataGroups.filter(
                        (M) => M.batch_id > R
                      )),
                      this._motionDataGroups.length && this._motionDataGroups[0].player
                        ? this._motionDataGroups[0].player.updateAutoPlay(!0)
                        : this.ee.emit(Ul.Player_NoLegacy))
                  }
                },
              },
              this.ee
            )),
        a)
      ) {
        const S = t.player.option.onended
        t.player.option.onended = () => {
          S({ end_of_batch: a, lastMotionGroup: t })
        }
      }
      const g = u.reduce((S, C) => S * C, f === 'Int16' ? 2 : 4),
        y = d,
        m = d + g,
        x = await r.slice(y, m).arrayBuffer(),
        _ = this._motionDataGroups.find((S) => S.player)
      ;(this._motionDataGroups.length &&
        t.player &&
        _ &&
        _.player !== t.player &&
        (t.player.autoPlay = !1),
        t.player && t.player.feed({ audio: new p(x), end_of_batch: a }))
    } else i && i.player && t.batch_id === i.batch_id && (t.player = i.player)
  }
  async _handleArkitFaceConfig(e, t, i, r) {
    const { data_records: s = {} } = e,
      { arkit_face: o } = s
    if (o) {
      const { channel_names: a, shape: l, data_offset: c, sample_rate: u } = o
      if (
        (a &&
          !this._arkit_face_channel_names &&
          ((this._arkit_face_channel_names = a), (this._arkit_face_sample_rate = u)),
        t.arkitFaceArrayBufferArray === void 0)
      ) {
        i && i.arkitFaceArrayBufferArray && i.batch_id === t.batch_id
          ? (t.arkitFaceArrayBufferArray = i.arkitFaceArrayBufferArray)
          : (t.arkitFaceArrayBufferArray = [])
        const d = l.reduce((p, g) => p * g, 4)
        this._arkitFaceShape = l[1]
        const f = await r.slice(c, c + d).arrayBuffer()
        t.arkitFaceArrayBufferArray.push(f)
      }
    } else
      i &&
        i.arkitFaceArrayBufferArray &&
        t.batch_id === i.batch_id &&
        (t.arkitFaceArrayBufferArray = i.arkitFaceArrayBufferArray)
  }
  async _handletts2faceConfig(e, t, i, r) {
    const { data_records: s = {} } = e,
      { tts2face: o } = s
    if (o) {
      const { channel_names: a, shape: l, data_offset: c, sample_rate: u } = o
      if (
        (a &&
          !this._tts2face_channel_names &&
          ((this._tts2face_channel_names = a), (this._tts2face_sample_rate = u)),
        t.tts2faceArrayBufferArray === void 0)
      ) {
        i && i.tts2faceArrayBufferArray && i.batch_id === t.batch_id
          ? (t.tts2faceArrayBufferArray = i.tts2faceArrayBufferArray)
          : (t.tts2faceArrayBufferArray = [])
        const d = l.reduce((p, g) => p * g, 4)
        this._tts2FaceShape = l[1]
        const f = await r.slice(c, c + d).arrayBuffer()
        t.tts2faceArrayBufferArray.push(f)
      }
    } else
      i &&
        i.tts2faceArrayBufferArray &&
        t.batch_id === i.batch_id &&
        (t.tts2faceArrayBufferArray = i.tts2faceArrayBufferArray)
  }
  _handleEvents(e) {
    const { events: t } = e
    t &&
      t.length &&
      t.forEach((i) => {
        switch (i.event_type) {
          case 'interrupt_speech':
            break
          case 'change_status':
            this.ee.emit(ey.Change_Status, i)
            break
        }
      })
  }
  _connectBatch(e, t, i) {
    let r = !0
    return (
      e.batch_id && t.batch_id === void 0 && (t.batch_id = e.batch_id),
      !t.batch_id && i && i.batch_id && (t.batch_id = i.batch_id),
      e.batch_name && t.batch_name === void 0 && (t.batch_name = e.batch_name),
      this._maxBatchId && t.batch_id && t.batch_id <= this._maxBatchId && (this.clear(), (r = !1)),
      r
    )
  }
}
const Al = class Al {
  constructor(e, t) {
    let i, r
    this.promise = new Promise((c, u) => {
      ;((i = c), (r = u))
    })
    const s = i.bind(this),
      o = r.bind(this),
      a = (...c) => {
        s(...c)
      },
      l = (c) => {
        o(c)
      }
    ;(e(a.bind(this), l.bind(this)), (this.abortHandler = t), (this.id = Al.idGen++))
  }
  then(e) {
    return new Al((t, i) => {
      this.promise = this.promise
        .then((...r) => {
          const s = e(...r)
          s instanceof Promise || s instanceof Al
            ? s.then((...o) => {
                t(...o)
              })
            : t(s)
        })
        .catch((r) => {
          i(r)
        })
    }, this.abortHandler)
  }
  catch(e) {
    return new Al((t) => {
      this.promise = this.promise
        .then((...i) => {
          t(...i)
        })
        .catch(e)
    }, this.abortHandler)
  }
  abort(e) {
    this.abortHandler && this.abortHandler(e)
  }
}
xe(Al, 'idGen', 0)
let rh = Al
class Cp extends Error {
  constructor(e) {
    super(e)
  }
}
;(function () {
  const n = new Float32Array(1),
    e = new Int32Array(n.buffer)
  return function (t) {
    n[0] = t
    const i = e[0]
    let r = (i >> 16) & 32768,
      s = (i >> 12) & 2047
    const o = (i >> 23) & 255
    return o < 103
      ? r
      : o > 142
        ? ((r |= 31744), (r |= (o == 255 ? 0 : 1) && i & 8388607), r)
        : o < 113
          ? ((s |= 2048), (r |= (s >> (114 - o)) + ((s >> (113 - o)) & 1)), r)
          : ((r |= ((o - 112) << 10) | (s >> 1)), (r += s & 1), r)
  }
})()
const Hi = (function () {
    const n = new Float32Array(1),
      e = new Int32Array(n.buffer)
    return function (t) {
      return ((n[0] = t), e[0])
    }
  })(),
  CN = function (n, e) {
    return n[e] + (n[e + 1] << 8) + (n[e + 2] << 16) + (n[e + 3] << 24)
  },
  f_ = function (n, e, t = !0, i) {
    const r = new AbortController(),
      s = r.signal
    let o = !1
    const a = (l) => {
      ;(r.abort(l), (o = !0))
    }
    return new rh((l, c) => {
      const u = { signal: s }
      ;(i && (u.headers = i),
        fetch(n, u)
          .then(async (d) => {
            if (!d.ok) {
              const m = await d.text()
              c(
                new Error(
                  'Fetch failed: '.concat(d.status, ' ').concat(d.statusText, ' ').concat(m)
                )
              )
              return
            }
            const h = d.body.getReader()
            let f = 0,
              p = d.headers.get('Content-Length'),
              g = p ? parseInt(p) : void 0
            const y = []
            for (; !o; )
              try {
                const { value: m, done: v } = await h.read()
                if (v) {
                  if ((e && e(100, '100%', m, g), t)) {
                    const S = new Blob(y).arrayBuffer()
                    l(S)
                  } else l()
                  break
                }
                f += m.length
                let x, _
                ;(g !== void 0 && ((x = (f / g) * 100), (_ = ''.concat(x.toFixed(2), '%'))),
                  t && y.push(m),
                  e && e(x, _, m, g))
              } catch (m) {
                c(m)
                return
              }
          })
          .catch((d) => {
            c(new Cp(d))
          }))
    }, a)
  },
  gi = function (n, e, t) {
    return Math.max(Math.min(n, t), e)
  },
  ec = function () {
    return performance.now() / 1e3
  },
  Cc = (n) => {
    if (
      (n.geometry && (n.geometry.dispose(), (n.geometry = null)),
      n.material && (n.material.dispose(), (n.material = null)),
      n.children)
    )
      for (let e of n.children) Cc(e)
  },
  ms = (n, e) =>
    new Promise((t) => {
      window.setTimeout(
        () => {
          t(n())
        },
        e ? 1 : 50
      )
    }),
  Gc = (n = 0) => {
    switch (n) {
      case 1:
        return 9
      case 2:
        return 24
    }
    return 0
  },
  p_ = () => {
    let n, e
    return {
      promise: new Promise((i, r) => {
        ;((n = i), (e = r))
      }),
      resolve: n,
      reject: e,
    }
  },
  dg = (n) => {
    let e, t
    return (
      n || (n = () => {}),
      {
        promise: new rh((r, s) => {
          ;((e = r), (t = s))
        }, n),
        resolve: e,
        reject: t,
      }
    )
  }
class EN {
  constructor(e, t, i) {
    ;((this.major = e), (this.minor = t), (this.patch = i))
  }
  toString() {
    return ''.concat(this.major, '_').concat(this.minor, '_').concat(this.patch)
  }
}
function m_() {
  const n = navigator.userAgent
  return n.indexOf('iPhone') > 0 || n.indexOf('iPad') > 0
}
function g5() {
  if (m_()) {
    const n = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/)
    return new EN(parseInt(n[1] || 0, 10), parseInt(n[2] || 0, 10), parseInt(n[3] || 0, 10))
  } else return null
}
const MN = 14,
  Xd = class Xd {
    constructor(e = 0) {
      ;((this.sphericalHarmonicsDegree = e),
        (this.sphericalHarmonicsCount = Gc(this.sphericalHarmonicsDegree)),
        (this.componentCount = this.sphericalHarmonicsCount + MN),
        (this.defaultSphericalHarmonics = new Array(this.sphericalHarmonicsCount).fill(0)),
        (this.splats = []),
        (this.splatCount = 0))
    }
    static createSplat(e = 0) {
      const t = [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]
      let i = Gc(e)
      for (let r = 0; r < i; r++) t.push(0)
      return t
    }
    addSplat(e) {
      ;(this.splats.push(e), this.splatCount++)
    }
    getSplat(e) {
      return this.splats[e]
    }
    addDefaultSplat() {
      const e = Xd.createSplat(this.sphericalHarmonicsDegree)
      return (this.addSplat(e), e)
    }
    addSplatFromComonents(e, t, i, r, s, o, a, l, c, u, d, h, f, p, ...g) {
      const y = [e, t, i, r, s, o, a, l, c, u, d, h, f, p, ...this.defaultSphericalHarmonics]
      for (let m = 0; m < g.length && m < this.sphericalHarmonicsCount; m++) y[m] = g[m]
      return (this.addSplat(y), y)
    }
    addSplatFromArray(e, t) {
      const i = e.splats[t],
        r = Xd.createSplat(this.sphericalHarmonicsDegree)
      for (let s = 0; s < this.componentCount && s < i.length; s++) r[s] = i[s]
      this.addSplat(r)
    }
  }
xe(Xd, 'OFFSET', {
  X: 0,
  Y: 1,
  Z: 2,
  SCALE0: 3,
  SCALE1: 4,
  SCALE2: 5,
  ROTATION0: 6,
  ROTATION1: 7,
  ROTATION2: 8,
  ROTATION3: 9,
  FDC0: 10,
  FDC1: 11,
  FDC2: 12,
  OPACITY: 13,
  FRC0: 14,
  FRC1: 15,
  FRC2: 16,
  FRC3: 17,
  FRC4: 18,
  FRC5: 19,
  FRC6: 20,
  FRC7: 21,
  FRC8: 22,
  FRC9: 23,
  FRC10: 24,
  FRC11: 25,
  FRC12: 26,
  FRC13: 27,
  FRC14: 28,
  FRC15: 29,
  FRC16: 30,
  FRC17: 31,
  FRC18: 32,
  FRC19: 33,
  FRC20: 34,
  FRC21: 35,
  FRC22: 36,
  FRC23: 37,
})
let lt = Xd
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const g_ = '173',
  tc = { ROTATE: 0, DOLLY: 1, PAN: 2 },
  nc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  RN = 0,
  _S = 1,
  IN = 2,
  y5 = 1,
  NN = 2,
  Ar = 3,
  Ts = 0,
  Oi = 1,
  wr = 2,
  La = 0,
  zo = 1,
  xS = 2,
  SS = 3,
  AS = 4,
  v5 = 5,
  gl = 100,
  PN = 101,
  LN = 102,
  DN = 103,
  FN = 104,
  ON = 200,
  BN = 201,
  UN = 202,
  kN = 203,
  sh = 204,
  oh = 205,
  zN = 206,
  VN = 207,
  HN = 208,
  $N = 209,
  GN = 210,
  WN = 211,
  QN = 212,
  jN = 213,
  qN = 214,
  iy = 0,
  ry = 1,
  sy = 2,
  cu = 3,
  oy = 4,
  ay = 5,
  ly = 6,
  cy = 7,
  _5 = 0,
  XN = 1,
  KN = 2,
  _s = 0,
  YN = 1,
  ZN = 2,
  JN = 3,
  eP = 4,
  tP = 5,
  nP = 6,
  iP = 7,
  bS = 'attached',
  rP = 'detached',
  y_ = 300,
  kl = 301,
  zl = 302,
  uy = 303,
  dy = 304,
  s0 = 306,
  uu = 1e3,
  wa = 1001,
  hm = 1002,
  vi = 1003,
  x5 = 1004,
  Td = 1005,
  Rr = 1006,
  Ep = 1007,
  Ws = 1008,
  sP = 1008,
  eo = 1009,
  S5 = 1010,
  A5 = 1011,
  ah = 1012,
  o0 = 1013,
  Ni = 1014,
  nr = 1015,
  ws = 1016,
  v_ = 1017,
  __ = 1018,
  du = 1020,
  b5 = 35902,
  T5 = 1021,
  w5 = 1022,
  Fi = 1023,
  C5 = 1024,
  E5 = 1025,
  Nl = 1026,
  hu = 1027,
  x_ = 1028,
  a0 = 1029,
  lh = 1030,
  S_ = 1031,
  Co = 1033,
  Mp = 33776,
  Rp = 33777,
  Ip = 33778,
  Np = 33779,
  hy = 35840,
  fy = 35841,
  py = 35842,
  my = 35843,
  gy = 36196,
  yy = 37492,
  vy = 37496,
  _y = 37808,
  xy = 37809,
  Sy = 37810,
  Ay = 37811,
  by = 37812,
  Ty = 37813,
  wy = 37814,
  Cy = 37815,
  Ey = 37816,
  My = 37817,
  Ry = 37818,
  Iy = 37819,
  Ny = 37820,
  Py = 37821,
  Pp = 36492,
  Ly = 36494,
  Dy = 36495,
  M5 = 36283,
  Fy = 36284,
  Oy = 36285,
  By = 36286,
  Jr = 2200,
  Vl = 2201,
  oP = 2202,
  ch = 2300,
  uh = 2301,
  hg = 2302,
  Lc = 2400,
  Dc = 2401,
  fm = 2402,
  A_ = 2500,
  aP = 2501,
  lP = 0,
  R5 = 1,
  Uy = 2,
  cP = 3200,
  uP = 3201,
  pm = 0,
  I5 = 1,
  $s = '',
  fi = 'srgb',
  Ui = 'srgb-linear',
  mm = 'linear',
  Jt = 'srgb',
  ic = 7680,
  TS = 519,
  dP = 512,
  N5 = 513,
  hP = 514,
  P5 = 515,
  fP = 516,
  pP = 517,
  mP = 518,
  gP = 519,
  gm = 35044,
  Ca = 35048,
  wS = '300 es',
  Ir = 2e3,
  Xo = 2001
class so {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {})
    const i = this._listeners
    ;(i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t))
  }
  hasEventListener(e, t) {
    const i = this._listeners
    return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1
  }
  removeEventListener(e, t) {
    const i = this._listeners
    if (i === void 0) return
    const r = i[e]
    if (r !== void 0) {
      const s = r.indexOf(t)
      s !== -1 && r.splice(s, 1)
    }
  }
  dispatchEvent(e) {
    const t = this._listeners
    if (t === void 0) return
    const i = t[e.type]
    if (i !== void 0) {
      e.target = this
      const r = i.slice(0)
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e)
      e.target = null
    }
  }
}
const Ti = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
]
let CS = 1234567
const Bd = Math.PI / 180,
  fu = 180 / Math.PI
function xs() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0
  return (
    Ti[n & 255] +
    Ti[(n >> 8) & 255] +
    Ti[(n >> 16) & 255] +
    Ti[(n >> 24) & 255] +
    '-' +
    Ti[e & 255] +
    Ti[(e >> 8) & 255] +
    '-' +
    Ti[((e >> 16) & 15) | 64] +
    Ti[(e >> 24) & 255] +
    '-' +
    Ti[(t & 63) | 128] +
    Ti[(t >> 8) & 255] +
    '-' +
    Ti[(t >> 16) & 255] +
    Ti[(t >> 24) & 255] +
    Ti[i & 255] +
    Ti[(i >> 8) & 255] +
    Ti[(i >> 16) & 255] +
    Ti[(i >> 24) & 255]
  ).toLowerCase()
}
function Nt(n, e, t) {
  return Math.max(e, Math.min(t, n))
}
function b_(n, e) {
  return ((n % e) + e) % e
}
function yP(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e)
}
function vP(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0
}
function Ud(n, e, t) {
  return (1 - t) * n + t * e
}
function _P(n, e, t, i) {
  return Ud(n, e, 1 - Math.exp(-t * i))
}
function xP(n, e = 1) {
  return e - Math.abs(b_(n, e * 2) - e)
}
function SP(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n))
}
function AP(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10))
}
function bP(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1))
}
function TP(n, e) {
  return n + Math.random() * (e - n)
}
function wP(n) {
  return n * (0.5 - Math.random())
}
function CP(n) {
  n !== void 0 && (CS = n)
  let e = (CS += 1831565813)
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  )
}
function EP(n) {
  return n * Bd
}
function MP(n) {
  return n * fu
}
function RP(n) {
  return (n & (n - 1)) === 0 && n !== 0
}
function IP(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function NP(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function PP(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + i) / 2),
    u = o((e + i) / 2),
    d = s((e - i) / 2),
    h = o((e - i) / 2),
    f = s((i - e) / 2),
    p = o((i - e) / 2)
  switch (r) {
    case 'XYX':
      n.set(a * u, l * d, l * h, a * c)
      break
    case 'YZY':
      n.set(l * h, a * u, l * d, a * c)
      break
    case 'ZXZ':
      n.set(l * d, l * h, a * u, a * c)
      break
    case 'XZX':
      n.set(a * u, l * p, l * f, a * c)
      break
    case 'YXY':
      n.set(l * f, a * u, l * p, a * c)
      break
    case 'ZYZ':
      n.set(l * p, l * f, a * u, a * c)
      break
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + r
      )
  }
}
function fs(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n
    case Uint32Array:
      return n / 4294967295
    case Uint16Array:
      return n / 65535
    case Uint8Array:
      return n / 255
    case Int32Array:
      return Math.max(n / 2147483647, -1)
    case Int16Array:
      return Math.max(n / 32767, -1)
    case Int8Array:
      return Math.max(n / 127, -1)
    default:
      throw new Error('Invalid component type.')
  }
}
function ln(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n
    case Uint32Array:
      return Math.round(n * 4294967295)
    case Uint16Array:
      return Math.round(n * 65535)
    case Uint8Array:
      return Math.round(n * 255)
    case Int32Array:
      return Math.round(n * 2147483647)
    case Int16Array:
      return Math.round(n * 32767)
    case Int8Array:
      return Math.round(n * 127)
    default:
      throw new Error('Invalid component type.')
  }
}
const Ea = {
  DEG2RAD: Bd,
  RAD2DEG: fu,
  generateUUID: xs,
  clamp: Nt,
  euclideanModulo: b_,
  mapLinear: yP,
  inverseLerp: vP,
  lerp: Ud,
  damp: _P,
  pingpong: xP,
  smoothstep: SP,
  smootherstep: AP,
  randInt: bP,
  randFloat: TP,
  randFloatSpread: wP,
  seededRandom: CP,
  degToRad: EP,
  radToDeg: MP,
  isPowerOfTwo: RP,
  ceilPowerOfTwo: IP,
  floorPowerOfTwo: NP,
  setQuaternionFromProperEuler: PP,
  normalize: ln,
  denormalize: fs,
}
class je {
  constructor(e = 0, t = 0) {
    ;((je.prototype.isVector2 = !0), (this.x = e), (this.y = t))
  }
  get width() {
    return this.x
  }
  set width(e) {
    this.x = e
  }
  get height() {
    return this.y
  }
  set height(e) {
    this.y = e
  }
  set(e, t) {
    return ((this.x = e), (this.y = t), this)
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), this)
  }
  setX(e) {
    return ((this.x = e), this)
  }
  setY(e) {
    return ((this.y = e), this)
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), this)
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), this)
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), this)
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), this)
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), this)
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), this)
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), this)
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), this)
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), this)
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), this)
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), this)
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements
    return ((this.x = r[0] * t + r[3] * i + r[6]), (this.y = r[1] * t + r[4] * i + r[7]), this)
  }
  min(e) {
    return ((this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this)
  }
  max(e) {
    return ((this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this)
  }
  clamp(e, t) {
    return ((this.x = Nt(this.x, e.x, t.x)), (this.y = Nt(this.y, e.y, t.y)), this)
  }
  clampScalar(e, t) {
    return ((this.x = Nt(this.x, e, t)), (this.y = Nt(this.y, e, t)), this)
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Nt(i, e, t))
  }
  floor() {
    return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this)
  }
  ceil() {
    return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this)
  }
  round() {
    return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this)
  }
  roundToZero() {
    return ((this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this)
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), this)
  }
  dot(e) {
    return this.x * e.x + this.y * e.y
  }
  cross(e) {
    return this.x * e.y - this.y * e.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (t === 0) return Math.PI / 2
    const i = this.dot(e) / t
    return Math.acos(Nt(i, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y
    return t * t + i * i
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return ((this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this)
  }
  lerpVectors(e, t, i) {
    return ((this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this)
  }
  equals(e) {
    return e.x === this.x && e.y === this.y
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), this)
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), e)
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), this)
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y
    return ((this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this)
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), this)
  }
  *[Symbol.iterator]() {
    ;(yield this.x, yield this.y)
  }
}
class pt {
  constructor(e, t, i, r, s, o, a, l, c) {
    ;((pt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c))
  }
  set(e, t, i, r, s, o, a, l, c) {
    const u = this.elements
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = a),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = o),
      (u[8] = c),
      this
    )
  }
  identity() {
    return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this)
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(e) {
    const t = e.elements
    return (this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this)
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      d = i[7],
      h = i[2],
      f = i[5],
      p = i[8],
      g = r[0],
      y = r[3],
      m = r[6],
      v = r[1],
      x = r[4],
      _ = r[7],
      S = r[2],
      C = r[5],
      A = r[8]
    return (
      (s[0] = o * g + a * v + l * S),
      (s[3] = o * y + a * x + l * C),
      (s[6] = o * m + a * _ + l * A),
      (s[1] = c * g + u * v + d * S),
      (s[4] = c * y + u * x + d * C),
      (s[7] = c * m + u * _ + d * A),
      (s[2] = h * g + f * v + p * S),
      (s[5] = h * y + f * x + p * C),
      (s[8] = h * m + f * _ + p * A),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8]
    return t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * o - a * c,
      h = a * l - u * s,
      f = c * s - o * l,
      p = t * d + i * h + r * f
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const g = 1 / p
    return (
      (e[0] = d * g),
      (e[1] = (r * c - u * i) * g),
      (e[2] = (a * i - r * o) * g),
      (e[3] = h * g),
      (e[4] = (u * t - r * l) * g),
      (e[5] = (r * s - a * t) * g),
      (e[6] = f * g),
      (e[7] = (i * l - c * t) * g),
      (e[8] = (o * t - i * s) * g),
      this
    )
  }
  transpose() {
    let e
    const t = this.elements
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    )
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose()
  }
  transposeIntoArray(e) {
    const t = this.elements
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    )
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s)
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * o + c * a) + o + e,
        -r * c,
        r * l,
        -r * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    )
  }
  scale(e, t) {
    return (this.premultiply(fg.makeScale(e, t)), this)
  }
  rotate(e) {
    return (this.premultiply(fg.makeRotation(-e)), this)
  }
  translate(e, t) {
    return (this.premultiply(fg.makeTranslation(e, t)), this)
  }
  makeTranslation(e, t) {
    return (
      e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    )
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return (this.set(t, -i, 0, i, t, 0, 0, 0, 1), this)
  }
  makeScale(e, t) {
    return (this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this)
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
const fg = new pt()
function L5(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0
  return !1
}
function dh(n) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', n)
}
function LP() {
  const n = dh('canvas')
  return ((n.style.display = 'block'), n)
}
const ES = {}
function Ec(n) {
  n in ES || ((ES[n] = !0), console.warn(n))
}
function DP(n, e, t) {
  return new Promise(function (i, r) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          r()
          break
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t)
          break
        default:
          i()
      }
    }
    setTimeout(s, t)
  })
}
function FP(n) {
  const e = n.elements
  ;((e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]))
}
function OP(n) {
  const e = n.elements
  e[11] === -1 ? ((e[10] = -e[10] - 1), (e[14] = -e[14])) : ((e[10] = -e[10]), (e[14] = -e[14] + 1))
}
const MS = new pt().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  RS = new pt().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  )
function BP() {
  const n = {
      enabled: !0,
      workingColorSpace: Ui,
      spaces: {},
      convert: function (r, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === Jt && ((r.r = Vo(r.r)), (r.g = Vo(r.g)), (r.b = Vo(r.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ), r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === Jt && ((r.r = Wc(r.r)), (r.g = Wc(r.g)), (r.b = Wc(r.b)))),
          r
        )
      },
      fromWorkingColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s)
      },
      toWorkingColorSpace: function (r, s) {
        return this.convert(r, s, this.workingColorSpace)
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries
      },
      getTransfer: function (r) {
        return r === $s ? mm : this.spaces[r].transfer
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients)
      },
      define: function (r) {
        Object.assign(this.spaces, r)
      },
      _getMatrix: function (r, s, o) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    i = [0.3127, 0.329]
  return (
    n.define({
      [Ui]: {
        primaries: e,
        whitePoint: i,
        transfer: mm,
        toXYZ: MS,
        fromXYZ: RS,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: fi },
        outputColorSpaceConfig: { drawingBufferColorSpace: fi },
      },
      [fi]: {
        primaries: e,
        whitePoint: i,
        transfer: Jt,
        toXYZ: MS,
        fromXYZ: RS,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: fi },
      },
    }),
    n
  )
}
const Tt = BP()
function Vo(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4)
}
function Wc(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055
}
let rc
class UP {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src
    let t
    if (e instanceof HTMLCanvasElement) t = e
    else {
      ;(rc === void 0 && (rc = dh('canvas')), (rc.width = e.width), (rc.height = e.height))
      const i = rc.getContext('2d')
      ;(e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
        (t = rc))
    }
    return t.toDataURL('image/png')
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
    ) {
      const t = dh('canvas')
      ;((t.width = e.width), (t.height = e.height))
      const i = t.getContext('2d')
      i.drawImage(e, 0, 0, e.width, e.height)
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data
      for (let o = 0; o < s.length; o++) s[o] = Vo(s[o] / 255) * 255
      return (i.putImageData(r, 0, 0), t)
    } else if (e.data) {
      const t = e.data.slice(0)
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Vo(t[i] / 255) * 255))
          : (t[i] = Vo(t[i]))
      return { data: t, width: e.width, height: e.height }
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
        ),
        e
      )
  }
}
let kP = 0
class D5 {
  constructor(e = null) {
    ;((this.isSource = !0),
      Object.defineProperty(this, 'id', { value: kP++ }),
      (this.uuid = xs()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0))
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]
    const i = { uuid: this.uuid, url: '' },
      r = this.data
    if (r !== null) {
      let s
      if (Array.isArray(r)) {
        s = []
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(pg(r[o].image)) : s.push(pg(r[o]))
      } else s = pg(r)
      i.url = s
    }
    return (t || (e.images[this.uuid] = i), i)
  }
}
function pg(n) {
  return (typeof HTMLImageElement < 'u' && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && n instanceof ImageBitmap)
    ? UP.getDataURL(n)
    : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
}
let zP = 0
class Wn extends so {
  constructor(
    e = Wn.DEFAULT_IMAGE,
    t = Wn.DEFAULT_MAPPING,
    i = wa,
    r = wa,
    s = Rr,
    o = Ws,
    a = Fi,
    l = eo,
    c = Wn.DEFAULT_ANISOTROPY,
    u = $s
  ) {
    ;(super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: zP++ }),
      (this.uuid = xs()),
      (this.name = ''),
      (this.source = new D5(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new je(0, 0)),
      (this.repeat = new je(1, 1)),
      (this.center = new je(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new pt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0))
  }
  get image() {
    return this.source.data
  }
  set image(e = null) {
    this.source.data = e
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]
    const i = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  transformUv(e) {
    if (this.mapping !== y_) return e
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case uu:
          e.x = e.x - Math.floor(e.x)
          break
        case wa:
          e.x = e.x < 0 ? 0 : 1
          break
        case hm:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x))
          break
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case uu:
          e.y = e.y - Math.floor(e.y)
          break
        case wa:
          e.y = e.y < 0 ? 0 : 1
          break
        case hm:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y))
          break
      }
    return (this.flipY && (e.y = 1 - e.y), e)
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0))
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++
  }
}
Wn.DEFAULT_IMAGE = null
Wn.DEFAULT_MAPPING = y_
Wn.DEFAULT_ANISOTROPY = 1
class Mt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;((Mt.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = i), (this.w = r))
  }
  get width() {
    return this.z
  }
  set width(e) {
    this.z = e
  }
  get height() {
    return this.w
  }
  set height(e) {
    this.w = e
  }
  set(e, t, i, r) {
    return ((this.x = e), (this.y = t), (this.z = i), (this.w = r), this)
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), (this.w = e), this)
  }
  setX(e) {
    return ((this.x = e), this)
  }
  setY(e) {
    return ((this.y = e), this)
  }
  setZ(e) {
    return ((this.z = e), this)
  }
  setW(e) {
    return ((this.w = e), this)
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      case 3:
        this.w = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    )
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this)
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), (this.w += e), this)
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    )
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    )
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this)
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this)
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    )
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this)
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this)
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    )
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this)
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w)
    const t = Math.sqrt(1 - e.w * e.w)
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      h = l[1],
      f = l[5],
      p = l[9],
      g = l[2],
      y = l[6],
      m = l[10]
    if (Math.abs(u - h) < 0.01 && Math.abs(d - g) < 0.01 && Math.abs(p - y) < 0.01) {
      if (
        Math.abs(u + h) < 0.1 &&
        Math.abs(d + g) < 0.1 &&
        Math.abs(p + y) < 0.1 &&
        Math.abs(c + f + m - 3) < 0.1
      )
        return (this.set(1, 0, 0, 0), this)
      t = Math.PI
      const x = (c + 1) / 2,
        _ = (f + 1) / 2,
        S = (m + 1) / 2,
        C = (u + h) / 4,
        A = (d + g) / 4,
        R = (p + y) / 4
      return (
        x > _ && x > S
          ? x < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(x)), (r = C / i), (s = A / i))
          : _ > S
            ? _ < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(_)), (i = C / r), (s = R / r))
            : S < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(S)), (i = A / s), (r = R / s)),
        this.set(i, r, s, t),
        this
      )
    }
    let v = Math.sqrt((y - p) * (y - p) + (d - g) * (d - g) + (h - u) * (h - u))
    return (
      Math.abs(v) < 0.001 && (v = 1),
      (this.x = (y - p) / v),
      (this.y = (d - g) / v),
      (this.z = (h - u) / v),
      (this.w = Math.acos((c + f + m - 1) / 2)),
      this
    )
  }
  setFromMatrixPosition(e) {
    const t = e.elements
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), (this.w = t[15]), this)
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = Nt(this.x, e.x, t.x)),
      (this.y = Nt(this.y, e.y, t.y)),
      (this.z = Nt(this.z, e.z, t.z)),
      (this.w = Nt(this.w, e.w, t.w)),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = Nt(this.x, e, t)),
      (this.y = Nt(this.y, e, t)),
      (this.z = Nt(this.z, e, t)),
      (this.w = Nt(this.w, e, t)),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Nt(i, e, t))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    )
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this)
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this)
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e)
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    ;(yield this.x, yield this.y, yield this.z, yield this.w)
  }
}
class Bh extends so {
  constructor(e = 1, t = 1, i = {}) {
    ;(super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Mt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Mt(0, 0, e, t)))
    const r = { width: e, height: t, depth: 1 }
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Rr,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      i
    )
    const s = new Wn(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace
    )
    ;((s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = []))
    const o = i.count
    for (let a = 0; a < o; a++)
      ((this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0),
        (this.textures[a].renderTarget = this))
    ;((this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples))
  }
  get texture() {
    return this.textures[0]
  }
  set texture(e) {
    this.textures[0] = e
  }
  set depthTexture(e) {
    ;(this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e))
  }
  get depthTexture() {
    return this._depthTexture
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ;((this.width = e), (this.height = t), (this.depth = i))
      for (let r = 0, s = this.textures.length; r < s; r++)
        ((this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = i))
      this.dispose()
    }
    ;(this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t))
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;((this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0))
    for (let i = 0, r = e.textures.length; i < r; i++)
      ((this.textures[i] = e.textures[i].clone()),
        (this.textures[i].isRenderTargetTexture = !0),
        (this.textures[i].renderTarget = this))
    const t = Object.assign({}, e.texture.image)
    return (
      (this.texture.source = new D5(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
class Ua extends Bh {
  constructor(e = 1, t = 1, i = {}) {
    ;(super(e, t, i), (this.isWebGLRenderTarget = !0))
  }
}
class T_ extends Wn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    ;(super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = vi),
      (this.minFilter = vi),
      (this.wrapR = wa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set()))
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class VP extends Wn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    ;(super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = vi),
      (this.minFilter = vi),
      (this.wrapR = wa),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1))
  }
}
class Qt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;((this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = i), (this._w = r))
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      d = i[r + 3]
    const h = s[o + 0],
      f = s[o + 1],
      p = s[o + 2],
      g = s[o + 3]
    if (a === 0) {
      ;((e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d))
      return
    }
    if (a === 1) {
      ;((e[t + 0] = h), (e[t + 1] = f), (e[t + 2] = p), (e[t + 3] = g))
      return
    }
    if (d !== g || l !== h || c !== f || u !== p) {
      let y = 1 - a
      const m = l * h + c * f + u * p + d * g,
        v = m >= 0 ? 1 : -1,
        x = 1 - m * m
      if (x > Number.EPSILON) {
        const S = Math.sqrt(x),
          C = Math.atan2(S, m * v)
        ;((y = Math.sin(y * C) / S), (a = Math.sin(a * C) / S))
      }
      const _ = a * v
      if (
        ((l = l * y + h * _),
        (c = c * y + f * _),
        (u = u * y + p * _),
        (d = d * y + g * _),
        y === 1 - a)
      ) {
        const S = 1 / Math.sqrt(l * l + c * c + u * u + d * d)
        ;((l *= S), (c *= S), (u *= S), (d *= S))
      }
    }
    ;((e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d))
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      d = s[o],
      h = s[o + 1],
      f = s[o + 2],
      p = s[o + 3]
    return (
      (e[t] = a * p + u * d + l * f - c * h),
      (e[t + 1] = l * p + u * h + c * d - a * f),
      (e[t + 2] = c * p + u * f + a * h - l * d),
      (e[t + 3] = u * p - a * d - l * h - c * f),
      e
    )
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;((this._x = e), this._onChangeCallback())
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;((this._y = e), this._onChangeCallback())
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;((this._z = e), this._onChangeCallback())
  }
  get w() {
    return this._w
  }
  set w(e) {
    ;((this._w = e), this._onChangeCallback())
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(i / 2),
      u = a(r / 2),
      d = a(s / 2),
      h = l(i / 2),
      f = l(r / 2),
      p = l(s / 2)
    switch (o) {
      case 'XYZ':
        ;((this._x = h * u * d + c * f * p),
          (this._y = c * f * d - h * u * p),
          (this._z = c * u * p + h * f * d),
          (this._w = c * u * d - h * f * p))
        break
      case 'YXZ':
        ;((this._x = h * u * d + c * f * p),
          (this._y = c * f * d - h * u * p),
          (this._z = c * u * p - h * f * d),
          (this._w = c * u * d + h * f * p))
        break
      case 'ZXY':
        ;((this._x = h * u * d - c * f * p),
          (this._y = c * f * d + h * u * p),
          (this._z = c * u * p + h * f * d),
          (this._w = c * u * d - h * f * p))
        break
      case 'ZYX':
        ;((this._x = h * u * d - c * f * p),
          (this._y = c * f * d + h * u * p),
          (this._z = c * u * p - h * f * d),
          (this._w = c * u * d + h * f * p))
        break
      case 'YZX':
        ;((this._x = h * u * d + c * f * p),
          (this._y = c * f * d + h * u * p),
          (this._z = c * u * p - h * f * d),
          (this._w = c * u * d - h * f * p))
        break
      case 'XZY':
        ;((this._x = h * u * d - c * f * p),
          (this._y = c * f * d - h * u * p),
          (this._z = c * u * p + h * f * d),
          (this._w = c * u * d + h * f * p))
        break
      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + o)
    }
    return (t === !0 && this._onChangeCallback(), this)
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i)
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      d = t[10],
      h = i + a + d
    if (h > 0) {
      const f = 0.5 / Math.sqrt(h + 1)
      ;((this._w = 0.25 / f),
        (this._x = (u - l) * f),
        (this._y = (s - c) * f),
        (this._z = (o - r) * f))
    } else if (i > a && i > d) {
      const f = 2 * Math.sqrt(1 + i - a - d)
      ;((this._w = (u - l) / f),
        (this._x = 0.25 * f),
        (this._y = (r + o) / f),
        (this._z = (s + c) / f))
    } else if (a > d) {
      const f = 2 * Math.sqrt(1 + a - i - d)
      ;((this._w = (s - c) / f),
        (this._x = (r + o) / f),
        (this._y = 0.25 * f),
        (this._z = (l + u) / f))
    } else {
      const f = 2 * Math.sqrt(1 + d - i - a)
      ;((this._w = (o - r) / f),
        (this._x = (s + c) / f),
        (this._y = (l + u) / f),
        (this._z = 0.25 * f))
    }
    return (this._onChangeCallback(), this)
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    )
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Nt(this.dot(e), -1, 1)))
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e)
    if (i === 0) return this
    const r = Math.min(1, t / i)
    return (this.slerp(e, r), this)
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return ((this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this)
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
  }
  normalize() {
    let e = this.length()
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e)
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this)
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      u = t._w
    return (
      (this._x = i * u + o * a + r * c - s * l),
      (this._y = r * u + o * l + s * a - i * c),
      (this._z = s * u + o * c + i * l - r * a),
      (this._w = o * u - i * a - r * l - s * c),
      this._onChangeCallback(),
      this
    )
  }
  slerp(e, t) {
    if (t === 0) return this
    if (t === 1) return this.copy(e)
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w
    let a = o * e._w + i * e._x + r * e._y + s * e._z
    if (
      (a < 0
        ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return ((this._w = o), (this._x = i), (this._y = r), (this._z = s), this)
    const l = 1 - a * a
    if (l <= Number.EPSILON) {
      const f = 1 - t
      return (
        (this._w = f * o + t * this._w),
        (this._x = f * i + t * this._x),
        (this._y = f * r + t * this._y),
        (this._z = f * s + t * this._z),
        this.normalize(),
        this
      )
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      d = Math.sin((1 - t) * u) / c,
      h = Math.sin(t * u) / c
    return (
      (this._w = o * d + this._w * h),
      (this._x = i * d + this._x * h),
      (this._y = r * d + this._y * h),
      (this._z = s * d + this._z * h),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i)
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i)
    return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e)
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    )
  }
  toJSON() {
    return this.toArray()
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this)
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    ;(yield this._x, yield this._y, yield this._z, yield this._w)
  }
}
class Y {
  constructor(e = 0, t = 0, i = 0) {
    ;((Y.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i))
  }
  set(e, t, i) {
    return (i === void 0 && (i = this.z), (this.x = e), (this.y = t), (this.z = i), this)
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), this)
  }
  setX(e) {
    return ((this.x = e), this)
  }
  setY(e) {
    return ((this.y = e), this)
  }
  setZ(e) {
    return ((this.z = e), this)
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      default:
        throw new Error('index is out of range: ' + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), (this.z = e.z), this)
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), this)
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), this)
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this)
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this)
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this)
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), this)
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this)
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this)
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), this)
  }
  multiplyVectors(e, t) {
    return ((this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this)
  }
  applyEuler(e) {
    return this.applyQuaternion(IS.setFromEuler(e))
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(IS.setFromAxisAngle(e, t))
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    )
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize()
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15])
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    )
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * r - a * i),
      u = 2 * (a * t - s * r),
      d = 2 * (s * i - o * t)
    return (
      (this.x = t + l * c + o * d - a * u),
      (this.y = i + l * u + a * c - s * d),
      (this.z = r + l * d + s * u - o * c),
      this
    )
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    )
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this)
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = Nt(this.x, e.x, t.x)),
      (this.y = Nt(this.y, e.y, t.y)),
      (this.z = Nt(this.z, e.z, t.z)),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = Nt(this.x, e, t)),
      (this.y = Nt(this.y, e, t)),
      (this.z = Nt(this.z, e, t)),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Nt(i, e, t))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    )
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this)
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    )
  }
  cross(e) {
    return this.crossVectors(this, e)
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z
    return ((this.x = r * l - s * a), (this.y = s * o - i * l), (this.z = i * a - r * o), this)
  }
  projectOnVector(e) {
    const t = e.lengthSq()
    if (t === 0) return this.set(0, 0, 0)
    const i = e.dot(this) / t
    return this.copy(e).multiplyScalar(i)
  }
  projectOnPlane(e) {
    return (mg.copy(this).projectOnVector(e), this.sub(mg))
  }
  reflect(e) {
    return this.sub(mg.copy(e).multiplyScalar(2 * this.dot(e)))
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (t === 0) return Math.PI / 2
    const i = this.dot(e) / t
    return Math.acos(Nt(i, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z
    return t * t + i * i + r * r
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    )
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
  }
  setFromCylindricalCoords(e, t, i) {
    return ((this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this)
  }
  setFromMatrixPosition(e) {
    const t = e.elements
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this)
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length()
    return ((this.x = t), (this.y = i), (this.z = r), this)
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4)
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3)
  }
  setFromEuler(e) {
    return ((this.x = e._x), (this.y = e._y), (this.z = e._z), this)
  }
  setFromColor(e) {
    return ((this.x = e.r), (this.y = e.g), (this.z = e.b), this)
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this)
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e)
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this)
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this)
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      i = Math.sqrt(1 - t * t)
    return ((this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this)
  }
  *[Symbol.iterator]() {
    ;(yield this.x, yield this.y, yield this.z)
  }
}
const mg = new Y(),
  IS = new Qt()
class ir {
  constructor(e = new Y(1 / 0, 1 / 0, 1 / 0), t = new Y(-1 / 0, -1 / 0, -1 / 0)) {
    ;((this.isBox3 = !0), (this.min = e), (this.max = t))
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this)
  }
  setFromArray(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(ls.fromArray(e, t))
    return this
  }
  setFromBufferAttribute(e) {
    this.makeEmpty()
    for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(ls.fromBufferAttribute(e, t))
    return this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t])
    return this
  }
  setFromCenterAndSize(e, t) {
    const i = ls.copy(t).multiplyScalar(0.5)
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this)
  }
  setFromObject(e, t = !1) {
    return (this.makeEmpty(), this.expandByObject(e, t))
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this)
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this)
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this)
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this)
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1)
    const i = e.geometry
    if (i !== void 0) {
      const s = i.getAttribute('position')
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          (e.isMesh === !0 ? e.getVertexPosition(o, ls) : ls.fromBufferAttribute(s, o),
            ls.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ls))
      else
        (e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(), xf.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(), xf.copy(i.boundingBox)),
          xf.applyMatrix4(e.matrixWorld),
          this.union(xf))
    }
    const r = e.children
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t)
    return this
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    )
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    )
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    )
  }
  intersectsSphere(e) {
    return (this.clampPoint(e.center, ls), ls.distanceToSquared(e.center) <= e.radius * e.radius)
  }
  intersectsPlane(e) {
    let t, i
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    )
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1
    ;(this.getCenter(nd),
      Sf.subVectors(this.max, nd),
      sc.subVectors(e.a, nd),
      oc.subVectors(e.b, nd),
      ac.subVectors(e.c, nd),
      aa.subVectors(oc, sc),
      la.subVectors(ac, oc),
      el.subVectors(sc, ac))
    let t = [
      0,
      -aa.z,
      aa.y,
      0,
      -la.z,
      la.y,
      0,
      -el.z,
      el.y,
      aa.z,
      0,
      -aa.x,
      la.z,
      0,
      -la.x,
      el.z,
      0,
      -el.x,
      -aa.y,
      aa.x,
      0,
      -la.y,
      la.x,
      0,
      -el.y,
      el.x,
      0,
    ]
    return !gg(t, sc, oc, ac, Sf) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !gg(t, sc, oc, ac, Sf))
      ? !1
      : (Af.crossVectors(aa, la), (t = [Af.x, Af.y, Af.z]), gg(t, sc, oc, ac, Sf))
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ls).distanceTo(e)
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center), (e.radius = this.getSize(ls).length() * 0.5)),
      e
    )
  }
  intersect(e) {
    return (this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this)
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this)
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (po[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        po[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        po[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        po[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        po[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        po[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        po[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        po[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(po),
        this)
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this)
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
const po = [new Y(), new Y(), new Y(), new Y(), new Y(), new Y(), new Y(), new Y()],
  ls = new Y(),
  xf = new ir(),
  sc = new Y(),
  oc = new Y(),
  ac = new Y(),
  aa = new Y(),
  la = new Y(),
  el = new Y(),
  nd = new Y(),
  Sf = new Y(),
  Af = new Y(),
  tl = new Y()
function gg(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    tl.fromArray(n, s)
    const a = r.x * Math.abs(tl.x) + r.y * Math.abs(tl.y) + r.z * Math.abs(tl.z),
      l = e.dot(tl),
      c = t.dot(tl),
      u = i.dot(tl)
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
  }
  return !0
}
const HP = new ir(),
  id = new Y(),
  yg = new Y()
class oo {
  constructor(e = new Y(), t = -1) {
    ;((this.isSphere = !0), (this.center = e), (this.radius = t))
  }
  set(e, t) {
    return (this.center.copy(e), (this.radius = t), this)
  }
  setFromPoints(e, t) {
    const i = this.center
    t !== void 0 ? i.copy(t) : HP.setFromPoints(e).getCenter(i)
    let r = 0
    for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]))
    return ((this.radius = Math.sqrt(r)), this)
  }
  copy(e) {
    return (this.center.copy(e.center), (this.radius = e.radius), this)
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return (this.center.set(0, 0, 0), (this.radius = -1), this)
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius
    return e.center.distanceToSquared(this.center) <= t * t
  }
  intersectsBox(e) {
    return e.intersectsSphere(this)
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e)
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
      t
    )
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
  }
  applyMatrix4(e) {
    return (this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this)
  }
  translate(e) {
    return (this.center.add(e), this)
  }
  expandByPoint(e) {
    if (this.isEmpty()) return (this.center.copy(e), (this.radius = 0), this)
    id.subVectors(e, this.center)
    const t = id.lengthSq()
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5
      ;(this.center.addScaledVector(id, r / i), (this.radius += r))
    }
    return this
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (yg.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(id.copy(e.center).add(yg)),
              this.expandByPoint(id.copy(e.center).sub(yg))),
          this)
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const mo = new Y(),
  vg = new Y(),
  bf = new Y(),
  ca = new Y(),
  _g = new Y(),
  Tf = new Y(),
  xg = new Y()
let Uh = class {
  constructor(e = new Y(), t = new Y(0, 0, -1)) {
    ;((this.origin = e), (this.direction = t))
  }
  set(e, t) {
    return (this.origin.copy(e), this.direction.copy(t), this)
  }
  copy(e) {
    return (this.origin.copy(e.origin), this.direction.copy(e.direction), this)
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e)
  }
  lookAt(e) {
    return (this.direction.copy(e).sub(this.origin).normalize(), this)
  }
  recast(e) {
    return (this.origin.copy(this.at(e, mo)), this)
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin)
    const i = t.dot(this.direction)
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e))
  }
  distanceSqToPoint(e) {
    const t = mo.subVectors(e, this.origin).dot(this.direction)
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (mo.copy(this.origin).addScaledVector(this.direction, t), mo.distanceToSquared(e))
  }
  distanceSqToSegment(e, t, i, r) {
    ;(vg.copy(e).add(t).multiplyScalar(0.5),
      bf.copy(t).sub(e).normalize(),
      ca.copy(this.origin).sub(vg))
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(bf),
      a = ca.dot(this.direction),
      l = -ca.dot(bf),
      c = ca.lengthSq(),
      u = Math.abs(1 - o * o)
    let d, h, f, p
    if (u > 0)
      if (((d = o * l - a), (h = o * a - l), (p = s * u), d >= 0))
        if (h >= -p)
          if (h <= p) {
            const g = 1 / u
            ;((d *= g), (h *= g), (f = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c))
          } else ((h = s), (d = Math.max(0, -(o * h + a))), (f = -d * d + h * (h + 2 * l) + c))
        else ((h = -s), (d = Math.max(0, -(o * h + a))), (f = -d * d + h * (h + 2 * l) + c))
      else
        h <= -p
          ? ((d = Math.max(0, -(-o * s + a))),
            (h = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (f = -d * d + h * (h + 2 * l) + c))
          : h <= p
            ? ((d = 0), (h = Math.min(Math.max(-s, -l), s)), (f = h * (h + 2 * l) + c))
            : ((d = Math.max(0, -(o * s + a))),
              (h = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
              (f = -d * d + h * (h + 2 * l) + c))
    else ((h = o > 0 ? -s : s), (d = Math.max(0, -(o * h + a))), (f = -d * d + h * (h + 2 * l) + c))
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(vg).addScaledVector(bf, h),
      f
    )
  }
  intersectSphere(e, t) {
    mo.subVectors(e.center, this.origin)
    const i = mo.dot(this.direction),
      r = mo.dot(mo) - i * i,
      s = e.radius * e.radius
    if (r > s) return null
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction)
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null
    const i = -(this.origin.dot(e.normal) + e.constant) / t
    return i >= 0 ? i : null
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e)
    return i === null ? null : this.at(i, t)
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin)
    return t === 0 || e.normal.dot(this.direction) * t < 0
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      h = this.origin
    return (
      c >= 0
        ? ((i = (e.min.x - h.x) * c), (r = (e.max.x - h.x) * c))
        : ((i = (e.max.x - h.x) * c), (r = (e.min.x - h.x) * c)),
      u >= 0
        ? ((s = (e.min.y - h.y) * u), (o = (e.max.y - h.y) * u))
        : ((s = (e.max.y - h.y) * u), (o = (e.min.y - h.y) * u)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - h.z) * d), (l = (e.max.z - h.z) * d))
        : ((a = (e.max.z - h.z) * d), (l = (e.min.z - h.z) * d)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    )
  }
  intersectsBox(e) {
    return this.intersectBox(e, mo) !== null
  }
  intersectTriangle(e, t, i, r, s) {
    ;(_g.subVectors(t, e), Tf.subVectors(i, e), xg.crossVectors(_g, Tf))
    let o = this.direction.dot(xg),
      a
    if (o > 0) {
      if (r) return null
      a = 1
    } else if (o < 0) ((a = -1), (o = -o))
    else return null
    ca.subVectors(this.origin, e)
    const l = a * this.direction.dot(Tf.crossVectors(ca, Tf))
    if (l < 0) return null
    const c = a * this.direction.dot(_g.cross(ca))
    if (c < 0 || l + c > o) return null
    const u = -a * ca.dot(xg)
    return u < 0 ? null : this.at(u / o, s)
  }
  applyMatrix4(e) {
    return (this.origin.applyMatrix4(e), this.direction.transformDirection(e), this)
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class qe {
  constructor(e, t, i, r, s, o, a, l, c, u, d, h, f, p, g, y) {
    ;((qe.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, g, y))
  }
  set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, g, y) {
    const m = this.elements
    return (
      (m[0] = e),
      (m[4] = t),
      (m[8] = i),
      (m[12] = r),
      (m[1] = s),
      (m[5] = o),
      (m[9] = a),
      (m[13] = l),
      (m[2] = c),
      (m[6] = u),
      (m[10] = d),
      (m[14] = h),
      (m[3] = f),
      (m[7] = p),
      (m[11] = g),
      (m[15] = y),
      this
    )
  }
  identity() {
    return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this)
  }
  clone() {
    return new qe().fromArray(this.elements)
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    )
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements
    return ((t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this)
  }
  setFromMatrix3(e) {
    const t = e.elements
    return (
      this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(e, t, i) {
    return (this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this)
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / lc.setFromMatrixColumn(e, 0).length(),
      s = 1 / lc.setFromMatrixColumn(e, 1).length(),
      o = 1 / lc.setFromMatrixColumn(e, 2).length()
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      d = Math.sin(s)
    if (e.order === 'XYZ') {
      const h = o * u,
        f = o * d,
        p = a * u,
        g = a * d
      ;((t[0] = l * u),
        (t[4] = -l * d),
        (t[8] = c),
        (t[1] = f + p * c),
        (t[5] = h - g * c),
        (t[9] = -a * l),
        (t[2] = g - h * c),
        (t[6] = p + f * c),
        (t[10] = o * l))
    } else if (e.order === 'YXZ') {
      const h = l * u,
        f = l * d,
        p = c * u,
        g = c * d
      ;((t[0] = h + g * a),
        (t[4] = p * a - f),
        (t[8] = o * c),
        (t[1] = o * d),
        (t[5] = o * u),
        (t[9] = -a),
        (t[2] = f * a - p),
        (t[6] = g + h * a),
        (t[10] = o * l))
    } else if (e.order === 'ZXY') {
      const h = l * u,
        f = l * d,
        p = c * u,
        g = c * d
      ;((t[0] = h - g * a),
        (t[4] = -o * d),
        (t[8] = p + f * a),
        (t[1] = f + p * a),
        (t[5] = o * u),
        (t[9] = g - h * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l))
    } else if (e.order === 'ZYX') {
      const h = o * u,
        f = o * d,
        p = a * u,
        g = a * d
      ;((t[0] = l * u),
        (t[4] = p * c - f),
        (t[8] = h * c + g),
        (t[1] = l * d),
        (t[5] = g * c + h),
        (t[9] = f * c - p),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l))
    } else if (e.order === 'YZX') {
      const h = o * l,
        f = o * c,
        p = a * l,
        g = a * c
      ;((t[0] = l * u),
        (t[4] = g - h * d),
        (t[8] = p * d + f),
        (t[1] = d),
        (t[5] = o * u),
        (t[9] = -a * u),
        (t[2] = -c * u),
        (t[6] = f * d + p),
        (t[10] = h - g * d))
    } else if (e.order === 'XZY') {
      const h = o * l,
        f = o * c,
        p = a * l,
        g = a * c
      ;((t[0] = l * u),
        (t[4] = -d),
        (t[8] = c * u),
        (t[1] = h * d + g),
        (t[5] = o * u),
        (t[9] = f * d - p),
        (t[2] = p * d - f),
        (t[6] = a * u),
        (t[10] = g * d + h))
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(e) {
    return this.compose($P, e, GP)
  }
  lookAt(e, t, i) {
    const r = this.elements
    return (
      hr.subVectors(e, t),
      hr.lengthSq() === 0 && (hr.z = 1),
      hr.normalize(),
      ua.crossVectors(i, hr),
      ua.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (hr.x += 1e-4) : (hr.z += 1e-4),
        hr.normalize(),
        ua.crossVectors(i, hr)),
      ua.normalize(),
      wf.crossVectors(hr, ua),
      (r[0] = ua.x),
      (r[4] = wf.x),
      (r[8] = hr.x),
      (r[1] = ua.y),
      (r[5] = wf.y),
      (r[9] = hr.y),
      (r[2] = ua.z),
      (r[6] = wf.z),
      (r[10] = hr.z),
      this
    )
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      d = i[5],
      h = i[9],
      f = i[13],
      p = i[2],
      g = i[6],
      y = i[10],
      m = i[14],
      v = i[3],
      x = i[7],
      _ = i[11],
      S = i[15],
      C = r[0],
      A = r[4],
      R = r[8],
      w = r[12],
      M = r[1],
      I = r[5],
      L = r[9],
      U = r[13],
      T = r[2],
      F = r[6],
      V = r[10],
      W = r[14],
      ee = r[3],
      se = r[7],
      he = r[11],
      ne = r[15]
    return (
      (s[0] = o * C + a * M + l * T + c * ee),
      (s[4] = o * A + a * I + l * F + c * se),
      (s[8] = o * R + a * L + l * V + c * he),
      (s[12] = o * w + a * U + l * W + c * ne),
      (s[1] = u * C + d * M + h * T + f * ee),
      (s[5] = u * A + d * I + h * F + f * se),
      (s[9] = u * R + d * L + h * V + f * he),
      (s[13] = u * w + d * U + h * W + f * ne),
      (s[2] = p * C + g * M + y * T + m * ee),
      (s[6] = p * A + g * I + y * F + m * se),
      (s[10] = p * R + g * L + y * V + m * he),
      (s[14] = p * w + g * U + y * W + m * ne),
      (s[3] = v * C + x * M + _ * T + S * ee),
      (s[7] = v * A + x * I + _ * F + S * se),
      (s[11] = v * R + x * L + _ * V + S * he),
      (s[15] = v * w + x * U + _ * W + S * ne),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      h = e[10],
      f = e[14],
      p = e[3],
      g = e[7],
      y = e[11],
      m = e[15]
    return (
      p * (+s * l * d - r * c * d - s * a * h + i * c * h + r * a * f - i * l * f) +
      g * (+t * l * f - t * c * h + s * o * h - r * o * f + r * c * u - s * l * u) +
      y * (+t * c * d - t * a * f - s * o * d + i * o * f + s * a * u - i * c * u) +
      m * (-r * a * u - t * l * d + t * a * h + r * o * d - i * o * h + i * l * u)
    )
  }
  transpose() {
    const e = this.elements
    let t
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    )
  }
  setPosition(e, t, i) {
    const r = this.elements
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    )
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      h = e[10],
      f = e[11],
      p = e[12],
      g = e[13],
      y = e[14],
      m = e[15],
      v = d * y * c - g * h * c + g * l * f - a * y * f - d * l * m + a * h * m,
      x = p * h * c - u * y * c - p * l * f + o * y * f + u * l * m - o * h * m,
      _ = u * g * c - p * d * c + p * a * f - o * g * f - u * a * m + o * d * m,
      S = p * d * l - u * g * l - p * a * h + o * g * h + u * a * y - o * d * y,
      C = t * v + i * x + r * _ + s * S
    if (C === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const A = 1 / C
    return (
      (e[0] = v * A),
      (e[1] = (g * h * s - d * y * s - g * r * f + i * y * f + d * r * m - i * h * m) * A),
      (e[2] = (a * y * s - g * l * s + g * r * c - i * y * c - a * r * m + i * l * m) * A),
      (e[3] = (d * l * s - a * h * s - d * r * c + i * h * c + a * r * f - i * l * f) * A),
      (e[4] = x * A),
      (e[5] = (u * y * s - p * h * s + p * r * f - t * y * f - u * r * m + t * h * m) * A),
      (e[6] = (p * l * s - o * y * s - p * r * c + t * y * c + o * r * m - t * l * m) * A),
      (e[7] = (o * h * s - u * l * s + u * r * c - t * h * c - o * r * f + t * l * f) * A),
      (e[8] = _ * A),
      (e[9] = (p * d * s - u * g * s - p * i * f + t * g * f + u * i * m - t * d * m) * A),
      (e[10] = (o * g * s - p * a * s + p * i * c - t * g * c - o * i * m + t * a * m) * A),
      (e[11] = (u * a * s - o * d * s - u * i * c + t * d * c + o * i * f - t * a * f) * A),
      (e[12] = S * A),
      (e[13] = (u * g * r - p * d * r + p * i * h - t * g * h - u * i * y + t * d * y) * A),
      (e[14] = (p * a * r - o * g * r - p * i * l + t * g * l + o * i * y - t * a * y) * A),
      (e[15] = (o * d * r - u * a * r + u * i * l - t * d * l - o * i * h + t * a * h) * A),
      this
    )
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    )
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
    return Math.sqrt(Math.max(t, i, r))
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    )
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return (this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this)
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return (this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this)
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return (this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this)
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a
    return (
      this.set(
        c * o + i,
        c * a - r * l,
        c * l + r * a,
        0,
        c * a + r * l,
        u * a + i,
        u * l - r * o,
        0,
        c * l - r * a,
        u * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  makeScale(e, t, i) {
    return (this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this)
  }
  makeShear(e, t, i, r, s, o) {
    return (this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this)
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      u = o + o,
      d = a + a,
      h = s * c,
      f = s * u,
      p = s * d,
      g = o * u,
      y = o * d,
      m = a * d,
      v = l * c,
      x = l * u,
      _ = l * d,
      S = i.x,
      C = i.y,
      A = i.z
    return (
      (r[0] = (1 - (g + m)) * S),
      (r[1] = (f + _) * S),
      (r[2] = (p - x) * S),
      (r[3] = 0),
      (r[4] = (f - _) * C),
      (r[5] = (1 - (h + m)) * C),
      (r[6] = (y + v) * C),
      (r[7] = 0),
      (r[8] = (p + x) * A),
      (r[9] = (y - v) * A),
      (r[10] = (1 - (h + g)) * A),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    )
  }
  decompose(e, t, i) {
    const r = this.elements
    let s = lc.set(r[0], r[1], r[2]).length()
    const o = lc.set(r[4], r[5], r[6]).length(),
      a = lc.set(r[8], r[9], r[10]).length()
    ;(this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      cs.copy(this))
    const c = 1 / s,
      u = 1 / o,
      d = 1 / a
    return (
      (cs.elements[0] *= c),
      (cs.elements[1] *= c),
      (cs.elements[2] *= c),
      (cs.elements[4] *= u),
      (cs.elements[5] *= u),
      (cs.elements[6] *= u),
      (cs.elements[8] *= d),
      (cs.elements[9] *= d),
      (cs.elements[10] *= d),
      t.setFromRotationMatrix(cs),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    )
  }
  makePerspective(e, t, i, r, s, o, a = Ir) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      u = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      h = (i + r) / (i - r)
    let f, p
    if (a === Ir) ((f = -(o + s) / (o - s)), (p = (-2 * o * s) / (o - s)))
    else if (a === Xo) ((f = -o / (o - s)), (p = (-o * s) / (o - s)))
    else throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a)
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = h),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = f),
      (l[14] = p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    )
  }
  makeOrthographic(e, t, i, r, s, o, a = Ir) {
    const l = this.elements,
      c = 1 / (t - e),
      u = 1 / (i - r),
      d = 1 / (o - s),
      h = (t + e) * c,
      f = (i + r) * u
    let p, g
    if (a === Ir) ((p = (o + s) * d), (g = -2 * d))
    else if (a === Xo) ((p = s * d), (g = -1 * d))
    else throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a)
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -h),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -f),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = -p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    )
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    )
  }
}
const lc = new Y(),
  cs = new qe(),
  $P = new Y(0, 0, 0),
  GP = new Y(1, 1, 1),
  ua = new Y(),
  wf = new Y(),
  hr = new Y(),
  NS = new qe(),
  PS = new Qt()
class Cs {
  constructor(e = 0, t = 0, i = 0, r = Cs.DEFAULT_ORDER) {
    ;((this.isEuler = !0), (this._x = e), (this._y = t), (this._z = i), (this._order = r))
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;((this._x = e), this._onChangeCallback())
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;((this._y = e), this._onChangeCallback())
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;((this._z = e), this._onChangeCallback())
  }
  get order() {
    return this._order
  }
  set order(e) {
    ;((this._order = e), this._onChangeCallback())
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      d = r[2],
      h = r[6],
      f = r[10]
    switch (t) {
      case 'XYZ':
        ;((this._y = Math.asin(Nt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(h, c)), (this._z = 0)))
        break
      case 'YXZ':
        ;((this._x = Math.asin(-Nt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0)))
        break
      case 'ZXY':
        ;((this._x = Math.asin(Nt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-d, f)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s))))
        break
      case 'ZYX':
        ;((this._y = Math.asin(-Nt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(h, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c))))
        break
      case 'YZX':
        ;((this._z = Math.asin(Nt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, f))))
        break
      case 'XZY':
        ;((this._z = Math.asin(-Nt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(h, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, f)), (this._y = 0)))
        break
      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t)
    }
    return ((this._order = t), i === !0 && this._onChangeCallback(), this)
  }
  setFromQuaternion(e, t, i) {
    return (NS.makeRotationFromQuaternion(e), this.setFromRotationMatrix(NS, t, i))
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t)
  }
  reorder(e) {
    return (PS.setFromEuler(this), this.setFromQuaternion(PS, e))
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    )
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this)
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    ;(yield this._x, yield this._y, yield this._z, yield this._order)
  }
}
Cs.DEFAULT_ORDER = 'XYZ'
class F5 {
  constructor() {
    this.mask = 1
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0
  }
  enable(e) {
    this.mask |= (1 << e) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(e) {
    return (this.mask & e.mask) !== 0
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0
  }
}
let WP = 0
const LS = new Y(),
  cc = new Qt(),
  go = new qe(),
  Cf = new Y(),
  rd = new Y(),
  QP = new Y(),
  jP = new Qt(),
  DS = new Y(1, 0, 0),
  FS = new Y(0, 1, 0),
  OS = new Y(0, 0, 1),
  BS = { type: 'added' },
  qP = { type: 'removed' },
  uc = { type: 'childadded', child: null },
  Sg = { type: 'childremoved', child: null }
class sn extends so {
  constructor() {
    ;(super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: WP++ }),
      (this.uuid = xs()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = sn.DEFAULT_UP.clone()))
    const e = new Y(),
      t = new Cs(),
      i = new Qt(),
      r = new Y(1, 1, 1)
    function s() {
      i.setFromEuler(t, !1)
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1)
    }
    ;(t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new qe() },
        normalMatrix: { value: new pt() },
      }),
      (this.matrix = new qe()),
      (this.matrixWorld = new qe()),
      (this.matrixAutoUpdate = sn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new F5()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {}))
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    ;(this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale))
  }
  applyQuaternion(e) {
    return (this.quaternion.premultiply(e), this)
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t)
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0)
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e)
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e)
  }
  rotateOnAxis(e, t) {
    return (cc.setFromAxisAngle(e, t), this.quaternion.multiply(cc), this)
  }
  rotateOnWorldAxis(e, t) {
    return (cc.setFromAxisAngle(e, t), this.quaternion.premultiply(cc), this)
  }
  rotateX(e) {
    return this.rotateOnAxis(DS, e)
  }
  rotateY(e) {
    return this.rotateOnAxis(FS, e)
  }
  rotateZ(e) {
    return this.rotateOnAxis(OS, e)
  }
  translateOnAxis(e, t) {
    return (
      LS.copy(e).applyQuaternion(this.quaternion),
      this.position.add(LS.multiplyScalar(t)),
      this
    )
  }
  translateX(e) {
    return this.translateOnAxis(DS, e)
  }
  translateY(e) {
    return this.translateOnAxis(FS, e)
  }
  translateZ(e) {
    return this.translateOnAxis(OS, e)
  }
  localToWorld(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld))
  }
  worldToLocal(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(go.copy(this.matrixWorld).invert()))
  }
  lookAt(e, t, i) {
    e.isVector3 ? Cf.copy(e) : Cf.set(e, t, i)
    const r = this.parent
    ;(this.updateWorldMatrix(!0, !1),
      rd.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight ? go.lookAt(rd, Cf, this.up) : go.lookAt(Cf, rd, this.up),
      this.quaternion.setFromRotationMatrix(go),
      r &&
        (go.extractRotation(r.matrixWorld),
        cc.setFromRotationMatrix(go),
        this.quaternion.premultiply(cc.invert())))
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
      return this
    }
    return e === this
      ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(BS),
            (uc.child = e),
            this.dispatchEvent(uc),
            (uc.child = null))
          : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', e),
        this)
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i])
      return this
    }
    const t = this.children.indexOf(e)
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(qP),
        (Sg.child = e),
        this.dispatchEvent(Sg),
        (Sg.child = null)),
      this
    )
  }
  removeFromParent() {
    const e = this.parent
    return (e !== null && e.remove(this), this)
  }
  clear() {
    return this.remove(...this.children)
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      go.copy(this.matrixWorld).invert(),
      e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), go.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(go),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(BS),
      (uc.child = e),
      this.dispatchEvent(uc),
      (uc.child = null),
      this
    )
  }
  getObjectById(e) {
    return this.getObjectByProperty('id', e)
  }
  getObjectByName(e) {
    return this.getObjectByProperty('name', e)
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t)
      if (o !== void 0) return o
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this)
    const r = this.children
    for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i)
    return i
  }
  getWorldPosition(e) {
    return (this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld))
  }
  getWorldQuaternion(e) {
    return (this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rd, e, QP), e)
  }
  getWorldScale(e) {
    return (this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rd, jP, e), e)
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const t = this.matrixWorld.elements
    return e.set(t[8], t[9], t[10]).normalize()
  }
  raycast() {}
  traverse(e) {
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
  }
  traverseVisible(e) {
    if (this.visible === !1) return
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
  }
  traverseAncestors(e) {
    const t = this.parent
    t !== null && (e(t), t.traverseAncestors(e))
  }
  updateMatrix() {
    ;(this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0))
  }
  updateMatrixWorld(e) {
    ;(this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0)))
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e)
  }
  updateWorldMatrix(e, t) {
    const i = this.parent
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
      t === !0)
    ) {
      const r = this.children
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0)
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string',
      i = {}
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = { version: 4.6, type: 'Object', generator: 'Object3D.toJSON' }))
    const r = {}
    ;((r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== '' && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = 'InstancedMesh'),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = 'BatchedMesh'),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() })))
    function s(a, l) {
      return (a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid)
    }
    if (this.isScene)
      (this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid))
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry)
      const a = this.geometry.parameters
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c]
            s(e.shapes, d)
          }
        else s(e.shapes, l)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = []
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]))
        r.material = a
      } else r.material = s(e.materials, this.material)
    if (this.children.length > 0) {
      r.children = []
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object)
    }
    if (this.animations.length > 0) {
      r.animations = []
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a]
        r.animations.push(s(e.animations, l))
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        d = o(e.shapes),
        h = o(e.skeletons),
        f = o(e.animations),
        p = o(e.nodes)
      ;(a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        d.length > 0 && (i.shapes = d),
        h.length > 0 && (i.skeletons = h),
        f.length > 0 && (i.animations = f),
        p.length > 0 && (i.nodes = p))
    }
    return ((i.object = r), i)
    function o(a) {
      const l = []
      for (const c in a) {
        const u = a[c]
        ;(delete u.metadata, l.push(u))
      }
      return l
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e)
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i]
        this.add(r.clone())
      }
    return this
  }
}
sn.DEFAULT_UP = new Y(0, 1, 0)
sn.DEFAULT_MATRIX_AUTO_UPDATE = !0
sn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0
const us = new Y(),
  yo = new Y(),
  Ag = new Y(),
  vo = new Y(),
  dc = new Y(),
  hc = new Y(),
  US = new Y(),
  bg = new Y(),
  Tg = new Y(),
  wg = new Y(),
  Cg = new Mt(),
  Eg = new Mt(),
  Mg = new Mt()
class ps {
  constructor(e = new Y(), t = new Y(), i = new Y()) {
    ;((this.a = e), (this.b = t), (this.c = i))
  }
  static getNormal(e, t, i, r) {
    ;(r.subVectors(i, t), us.subVectors(e, t), r.cross(us))
    const s = r.lengthSq()
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
  }
  static getBarycoord(e, t, i, r, s) {
    ;(us.subVectors(r, t), yo.subVectors(i, t), Ag.subVectors(e, t))
    const o = us.dot(us),
      a = us.dot(yo),
      l = us.dot(Ag),
      c = yo.dot(yo),
      u = yo.dot(Ag),
      d = o * c - a * a
    if (d === 0) return (s.set(0, 0, 0), null)
    const h = 1 / d,
      f = (c * l - a * u) * h,
      p = (o * u - a * l) * h
    return s.set(1 - f - p, p, f)
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, vo) === null
      ? !1
      : vo.x >= 0 && vo.y >= 0 && vo.x + vo.y <= 1
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return this.getBarycoord(e, t, i, r, vo) === null
      ? ((l.x = 0), (l.y = 0), 'z' in l && (l.z = 0), 'w' in l && (l.w = 0), null)
      : (l.setScalar(0),
        l.addScaledVector(s, vo.x),
        l.addScaledVector(o, vo.y),
        l.addScaledVector(a, vo.z),
        l)
  }
  static getInterpolatedAttribute(e, t, i, r, s, o) {
    return (
      Cg.setScalar(0),
      Eg.setScalar(0),
      Mg.setScalar(0),
      Cg.fromBufferAttribute(e, t),
      Eg.fromBufferAttribute(e, i),
      Mg.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(Cg, s.x),
      o.addScaledVector(Eg, s.y),
      o.addScaledVector(Mg, s.z),
      o
    )
  }
  static isFrontFacing(e, t, i, r) {
    return (us.subVectors(i, t), yo.subVectors(e, t), us.cross(yo).dot(r) < 0)
  }
  set(e, t, i) {
    return (this.a.copy(e), this.b.copy(t), this.c.copy(i), this)
  }
  setFromPointsAndIndices(e, t, i, r) {
    return (this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this)
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this)
  }
  getArea() {
    return (
      us.subVectors(this.c, this.b),
      yo.subVectors(this.a, this.b),
      us.cross(yo).length() * 0.5
    )
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(e) {
    return ps.getNormal(this.a, this.b, this.c, e)
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(e, t) {
    return ps.getBarycoord(e, this.a, this.b, this.c, t)
  }
  getInterpolation(e, t, i, r, s) {
    return ps.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
  }
  containsPoint(e) {
    return ps.containsPoint(e, this.a, this.b, this.c)
  }
  isFrontFacing(e) {
    return ps.isFrontFacing(this.a, this.b, this.c, e)
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this)
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c
    let o, a
    ;(dc.subVectors(r, i), hc.subVectors(s, i), bg.subVectors(e, i))
    const l = dc.dot(bg),
      c = hc.dot(bg)
    if (l <= 0 && c <= 0) return t.copy(i)
    Tg.subVectors(e, r)
    const u = dc.dot(Tg),
      d = hc.dot(Tg)
    if (u >= 0 && d <= u) return t.copy(r)
    const h = l * d - u * c
    if (h <= 0 && l >= 0 && u <= 0) return ((o = l / (l - u)), t.copy(i).addScaledVector(dc, o))
    wg.subVectors(e, s)
    const f = dc.dot(wg),
      p = hc.dot(wg)
    if (p >= 0 && f <= p) return t.copy(s)
    const g = f * c - l * p
    if (g <= 0 && c >= 0 && p <= 0) return ((a = c / (c - p)), t.copy(i).addScaledVector(hc, a))
    const y = u * p - f * d
    if (y <= 0 && d - u >= 0 && f - p >= 0)
      return (
        US.subVectors(s, r),
        (a = (d - u) / (d - u + (f - p))),
        t.copy(r).addScaledVector(US, a)
      )
    const m = 1 / (y + g + h)
    return ((o = g * m), (a = h * m), t.copy(i).addScaledVector(dc, o).addScaledVector(hc, a))
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
  }
}
const O5 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  da = { h: 0, s: 0, l: 0 },
  Ef = { h: 0, s: 0, l: 0 }
function Rg(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
  )
}
class gt {
  constructor(e, t, i) {
    return ((this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, i))
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e
      r && r.isColor
        ? this.copy(r)
        : typeof r == 'number'
          ? this.setHex(r)
          : typeof r == 'string' && this.setStyle(r)
    } else this.setRGB(e, t, i)
    return this
  }
  setScalar(e) {
    return ((this.r = e), (this.g = e), (this.b = e), this)
  }
  setHex(e, t = fi) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Tt.toWorkingColorSpace(this, t),
      this
    )
  }
  setRGB(e, t, i, r = Tt.workingColorSpace) {
    return ((this.r = e), (this.g = t), (this.b = i), Tt.toWorkingColorSpace(this, r), this)
  }
  setHSL(e, t, i, r = Tt.workingColorSpace) {
    if (((e = b_(e, 1)), (t = Nt(t, 0, 1)), (i = Nt(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s
      ;((this.r = Rg(o, s, e + 1 / 3)), (this.g = Rg(o, s, e)), (this.b = Rg(o, s, e - 1 / 3)))
    }
    return (Tt.toWorkingColorSpace(this, r), this)
  }
  setStyle(e, t = fi) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.')
    }
    let r
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s
      const o = r[1],
        a = r[2]
      switch (o) {
        case 'rgb':
        case 'rgba':
          if ((s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            )
          if ((s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            )
          break
        case 'hsl':
        case 'hsla':
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t)
            )
          break
        default:
          console.warn('THREE.Color: Unknown color model ' + e)
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        )
      if (o === 6) return this.setHex(parseInt(s, 16), t)
      console.warn('THREE.Color: Invalid hex color ' + e)
    } else if (e && e.length > 0) return this.setColorName(e, t)
    return this
  }
  setColorName(e, t = fi) {
    const i = O5[e.toLowerCase()]
    return (
      i !== void 0 ? this.setHex(i, t) : console.warn('THREE.Color: Unknown color ' + e),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(e) {
    return ((this.r = e.r), (this.g = e.g), (this.b = e.b), this)
  }
  copySRGBToLinear(e) {
    return ((this.r = Vo(e.r)), (this.g = Vo(e.g)), (this.b = Vo(e.b)), this)
  }
  copyLinearToSRGB(e) {
    return ((this.r = Wc(e.r)), (this.g = Wc(e.g)), (this.b = Wc(e.b)), this)
  }
  convertSRGBToLinear() {
    return (this.copySRGBToLinear(this), this)
  }
  convertLinearToSRGB() {
    return (this.copyLinearToSRGB(this), this)
  }
  getHex(e = fi) {
    return (
      Tt.fromWorkingColorSpace(wi.copy(this), e),
      Math.round(Nt(wi.r * 255, 0, 255)) * 65536 +
        Math.round(Nt(wi.g * 255, 0, 255)) * 256 +
        Math.round(Nt(wi.b * 255, 0, 255))
    )
  }
  getHexString(e = fi) {
    return ('000000' + this.getHex(e).toString(16)).slice(-6)
  }
  getHSL(e, t = Tt.workingColorSpace) {
    Tt.fromWorkingColorSpace(wi.copy(this), t)
    const i = wi.r,
      r = wi.g,
      s = wi.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s)
    let l, c
    const u = (a + o) / 2
    if (a === o) ((l = 0), (c = 0))
    else {
      const d = o - a
      switch (((c = u <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0)
          break
        case r:
          l = (s - i) / d + 2
          break
        case s:
          l = (i - r) / d + 4
          break
      }
      l /= 6
    }
    return ((e.h = l), (e.s = c), (e.l = u), e)
  }
  getRGB(e, t = Tt.workingColorSpace) {
    return (Tt.fromWorkingColorSpace(wi.copy(this), t), (e.r = wi.r), (e.g = wi.g), (e.b = wi.b), e)
  }
  getStyle(e = fi) {
    Tt.fromWorkingColorSpace(wi.copy(this), e)
    const t = wi.r,
      i = wi.g,
      r = wi.b
    return e !== fi
      ? 'color('
          .concat(e, ' ')
          .concat(t.toFixed(3), ' ')
          .concat(i.toFixed(3), ' ')
          .concat(r.toFixed(3), ')')
      : 'rgb('
          .concat(Math.round(t * 255), ',')
          .concat(Math.round(i * 255), ',')
          .concat(Math.round(r * 255), ')')
  }
  offsetHSL(e, t, i) {
    return (this.getHSL(da), this.setHSL(da.h + e, da.s + t, da.l + i))
  }
  add(e) {
    return ((this.r += e.r), (this.g += e.g), (this.b += e.b), this)
  }
  addColors(e, t) {
    return ((this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this)
  }
  addScalar(e) {
    return ((this.r += e), (this.g += e), (this.b += e), this)
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    )
  }
  multiply(e) {
    return ((this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this)
  }
  multiplyScalar(e) {
    return ((this.r *= e), (this.g *= e), (this.b *= e), this)
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    )
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    )
  }
  lerpHSL(e, t) {
    ;(this.getHSL(da), e.getHSL(Ef))
    const i = Ud(da.h, Ef.h, t),
      r = Ud(da.s, Ef.s, t),
      s = Ud(da.l, Ef.l, t)
    return (this.setHSL(i, r, s), this)
  }
  setFromVector3(e) {
    return ((this.r = e.x), (this.g = e.y), (this.b = e.z), this)
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    )
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b
  }
  fromArray(e, t = 0) {
    return ((this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this)
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e)
  }
  fromBufferAttribute(e, t) {
    return ((this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this)
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    ;(yield this.r, yield this.g, yield this.b)
  }
}
const wi = new gt()
gt.NAMES = O5
let XP = 0
class es extends so {
  constructor() {
    ;(super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: XP++ }),
      (this.uuid = xs()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = zo),
      (this.side = Ts),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = sh),
      (this.blendDst = oh),
      (this.blendEquation = gl),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new gt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = cu),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = TS),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ic),
      (this.stencilZFail = ic),
      (this.stencilZPass = ic),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0))
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(e) {
    ;(this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e))
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t]
        if (i === void 0) {
          console.warn("THREE.Material: parameter '".concat(t, "' has value of undefined."))
          continue
        }
        const r = this[t]
        if (r === void 0) {
          console.warn(
            "THREE.Material: '".concat(t, "' is not a property of THREE.").concat(this.type, '.')
          )
          continue
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : (this[t] = i)
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    t && (e = { textures: {}, images: {} })
    const i = { metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' } }
    ;((i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
      this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid), (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== zo && (i.blending = this.blending),
      this.side !== Ts && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== sh && (i.blendSrc = this.blendSrc),
      this.blendDst !== oh && (i.blendDst = this.blendDst),
      this.blendEquation !== gl && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== cu && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== TS && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ic && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== ic && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ic && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' && (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' && (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData))
    function r(s) {
      const o = []
      for (const a in s) {
        const l = s[a]
        ;(delete l.metadata, o.push(l))
      }
      return o
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images)
      ;(s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o))
    }
    return i
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;((this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite))
    const t = e.clippingPlanes
    let i = null
    if (t !== null) {
      const r = t.length
      i = new Array(r)
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  onBuild() {
    console.warn('Material: onBuild() has been removed.')
  }
}
class Yr extends es {
  constructor(e) {
    ;(super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new gt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.combine = _5),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const Do = KP()
function KP() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512)
  for (let l = 0; l < 256; ++l) {
    const c = l - 127
    c < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : c < -14
        ? ((i[l] = 1024 >> (-c - 14)),
          (i[l | 256] = (1024 >> (-c - 14)) | 32768),
          (r[l] = -c - 1),
          (r[l | 256] = -c - 1))
        : c <= 15
          ? ((i[l] = (c + 15) << 10),
            (i[l | 256] = ((c + 15) << 10) | 32768),
            (r[l] = 13),
            (r[l | 256] = 13))
          : c < 128
            ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
            : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13))
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64)
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0
    for (; (c & 8388608) === 0; ) ((c <<= 1), (u -= 8388608))
    ;((c &= -8388609), (u += 947912704), (s[l] = c | u))
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13)
  for (let l = 1; l < 31; ++l) o[l] = l << 23
  ;((o[31] = 1199570944), (o[32] = 2147483648))
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23)
  o[63] = 3347054592
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024)
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  }
}
function YP(n) {
  ;(Math.abs(n) > 65504 && console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
    (n = Nt(n, -65504, 65504)),
    (Do.floatView[0] = n))
  const e = Do.uint32View[0],
    t = (e >> 23) & 511
  return Do.baseTable[t] + ((e & 8388607) >> Do.shiftTable[t])
}
function ZP(n) {
  const e = n >> 10
  return (
    (Do.uint32View[0] = Do.mantissaTable[Do.offsetTable[e] + (n & 1023)] + Do.exponentTable[e]),
    Do.floatView[0]
  )
}
const hh = { toHalfFloat: YP, fromHalfFloat: ZP },
  zn = new Y(),
  Mf = new je()
let JP = 0
class _i {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')
    ;((this.isBufferAttribute = !0),
      Object.defineProperty(this, 'id', { value: JP++ }),
      (this.name = ''),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = gm),
      (this.updateRanges = []),
      (this.gpuType = nr),
      (this.version = 0))
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return ((this.usage = e), this)
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    )
  }
  copyAt(e, t, i) {
    ;((e *= this.itemSize), (i *= t.itemSize))
    for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r]
    return this
  }
  copyArray(e) {
    return (this.array.set(e), this)
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        (Mf.fromBufferAttribute(this, t), Mf.applyMatrix3(e), this.setXY(t, Mf.x, Mf.y))
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        (zn.fromBufferAttribute(this, t), zn.applyMatrix3(e), this.setXYZ(t, zn.x, zn.y, zn.z))
    return this
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (zn.fromBufferAttribute(this, t), zn.applyMatrix4(e), this.setXYZ(t, zn.x, zn.y, zn.z))
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (zn.fromBufferAttribute(this, t), zn.applyNormalMatrix(e), this.setXYZ(t, zn.x, zn.y, zn.z))
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (zn.fromBufferAttribute(this, t), zn.transformDirection(e), this.setXYZ(t, zn.x, zn.y, zn.z))
    return this
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this)
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t]
    return (this.normalized && (i = fs(i, this.array)), i)
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = ln(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    )
  }
  getX(e) {
    let t = this.array[e * this.itemSize]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  setX(e, t) {
    return (this.normalized && (t = ln(t, this.array)), (this.array[e * this.itemSize] = t), this)
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  setY(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    )
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    )
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  setW(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    )
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = ln(t, this.array)), (i = ln(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ln(t, this.array)), (i = ln(i, this.array)), (r = ln(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ln(t, this.array)),
        (i = ln(i, this.array)),
        (r = ln(r, this.array)),
        (s = ln(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    )
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this)
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    }
    return (
      this.name !== '' && (e.name = this.name),
      this.usage !== gm && (e.usage = this.usage),
      e
    )
  }
}
class B5 extends _i {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i)
  }
}
class U5 extends _i {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i)
  }
}
class xi extends _i {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i)
  }
}
let eL = 0
const Vr = new qe(),
  Ig = new sn(),
  fc = new Y(),
  fr = new ir(),
  sd = new ir(),
  ai = new Y()
class ki extends so {
  constructor() {
    ;(super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: eL++ }),
      (this.uuid = xs()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {}))
  }
  getIndex() {
    return this.index
  }
  setIndex(e) {
    return (Array.isArray(e) ? (this.index = new (L5(e) ? U5 : B5)(e, 1)) : (this.index = e), this)
  }
  setIndirect(e) {
    return ((this.indirect = e), this)
  }
  getIndirect() {
    return this.indirect
  }
  getAttribute(e) {
    return this.attributes[e]
  }
  setAttribute(e, t) {
    return ((this.attributes[e] = t), this)
  }
  deleteAttribute(e) {
    return (delete this.attributes[e], this)
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(e, t) {
    ;((this.drawRange.start = e), (this.drawRange.count = t))
  }
  applyMatrix4(e) {
    const t = this.attributes.position
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0))
    const i = this.attributes.normal
    if (i !== void 0) {
      const s = new pt().getNormalMatrix(e)
      ;(i.applyNormalMatrix(s), (i.needsUpdate = !0))
    }
    const r = this.attributes.tangent
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(e) {
    return (Vr.makeRotationFromQuaternion(e), this.applyMatrix4(Vr), this)
  }
  rotateX(e) {
    return (Vr.makeRotationX(e), this.applyMatrix4(Vr), this)
  }
  rotateY(e) {
    return (Vr.makeRotationY(e), this.applyMatrix4(Vr), this)
  }
  rotateZ(e) {
    return (Vr.makeRotationZ(e), this.applyMatrix4(Vr), this)
  }
  translate(e, t, i) {
    return (Vr.makeTranslation(e, t, i), this.applyMatrix4(Vr), this)
  }
  scale(e, t, i) {
    return (Vr.makeScale(e, t, i), this.applyMatrix4(Vr), this)
  }
  lookAt(e) {
    return (Ig.lookAt(e), Ig.updateMatrix(), this.applyMatrix4(Ig.matrix), this)
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(fc).negate(),
      this.translate(fc.x, fc.y, fc.z),
      this
    )
  }
  setFromPoints(e) {
    const t = this.getAttribute('position')
    if (t === void 0) {
      const i = []
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r]
        i.push(o.x, o.y, o.z || 0)
      }
      this.setAttribute('position', new xi(i, 3))
    } else {
      const i = Math.min(e.length, t.count)
      for (let r = 0; r < i; r++) {
        const s = e[r]
        t.setXYZ(r, s.x, s.y, s.z || 0)
      }
      ;(e.length > t.count &&
        console.warn(
          'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.'
        ),
        (t.needsUpdate = !0))
    }
    return this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ir())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      ;(console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this
      ),
        this.boundingBox.set(new Y(-1 / 0, -1 / 0, -1 / 0), new Y(1 / 0, 1 / 0, 1 / 0)))
      return
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i]
          ;(fr.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (ai.addVectors(this.boundingBox.min, fr.min),
                this.boundingBox.expandByPoint(ai),
                ai.addVectors(this.boundingBox.max, fr.max),
                this.boundingBox.expandByPoint(ai))
              : (this.boundingBox.expandByPoint(fr.min), this.boundingBox.expandByPoint(fr.max)))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      )
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new oo())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      ;(console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this
      ),
        this.boundingSphere.set(new Y(), 1 / 0))
      return
    }
    if (e) {
      const i = this.boundingSphere.center
      if ((fr.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s]
          ;(sd.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (ai.addVectors(fr.min, sd.min),
                fr.expandByPoint(ai),
                ai.addVectors(fr.max, sd.max),
                fr.expandByPoint(ai))
              : (fr.expandByPoint(sd.min), fr.expandByPoint(sd.max)))
        }
      fr.getCenter(i)
      let r = 0
      for (let s = 0, o = e.count; s < o; s++)
        (ai.fromBufferAttribute(e, s), (r = Math.max(r, i.distanceToSquared(ai))))
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative
          for (let c = 0, u = a.count; c < u; c++)
            (ai.fromBufferAttribute(a, c),
              l && (fc.fromBufferAttribute(e, c), ai.add(fc)),
              (r = Math.max(r, i.distanceToSquared(ai))))
        }
      ;((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ))
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
      )
      return
    }
    const i = t.position,
      r = t.normal,
      s = t.uv
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new _i(new Float32Array(4 * i.count), 4))
    const o = this.getAttribute('tangent'),
      a = [],
      l = []
    for (let R = 0; R < i.count; R++) ((a[R] = new Y()), (l[R] = new Y()))
    const c = new Y(),
      u = new Y(),
      d = new Y(),
      h = new je(),
      f = new je(),
      p = new je(),
      g = new Y(),
      y = new Y()
    function m(R, w, M) {
      ;(c.fromBufferAttribute(i, R),
        u.fromBufferAttribute(i, w),
        d.fromBufferAttribute(i, M),
        h.fromBufferAttribute(s, R),
        f.fromBufferAttribute(s, w),
        p.fromBufferAttribute(s, M),
        u.sub(c),
        d.sub(c),
        f.sub(h),
        p.sub(h))
      const I = 1 / (f.x * p.y - p.x * f.y)
      isFinite(I) &&
        (g.copy(u).multiplyScalar(p.y).addScaledVector(d, -f.y).multiplyScalar(I),
        y.copy(d).multiplyScalar(f.x).addScaledVector(u, -p.x).multiplyScalar(I),
        a[R].add(g),
        a[w].add(g),
        a[M].add(g),
        l[R].add(y),
        l[w].add(y),
        l[M].add(y))
    }
    let v = this.groups
    v.length === 0 && (v = [{ start: 0, count: e.count }])
    for (let R = 0, w = v.length; R < w; ++R) {
      const M = v[R],
        I = M.start,
        L = M.count
      for (let U = I, T = I + L; U < T; U += 3) m(e.getX(U + 0), e.getX(U + 1), e.getX(U + 2))
    }
    const x = new Y(),
      _ = new Y(),
      S = new Y(),
      C = new Y()
    function A(R) {
      ;(S.fromBufferAttribute(r, R), C.copy(S))
      const w = a[R]
      ;(x.copy(w), x.sub(S.multiplyScalar(S.dot(w))).normalize(), _.crossVectors(C, w))
      const I = _.dot(l[R]) < 0 ? -1 : 1
      o.setXYZW(R, x.x, x.y, x.z, I)
    }
    for (let R = 0, w = v.length; R < w; ++R) {
      const M = v[R],
        I = M.start,
        L = M.count
      for (let U = I, T = I + L; U < T; U += 3)
        (A(e.getX(U + 0)), A(e.getX(U + 1)), A(e.getX(U + 2)))
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute('position')
    if (t !== void 0) {
      let i = this.getAttribute('normal')
      if (i === void 0)
        ((i = new _i(new Float32Array(t.count * 3), 3)), this.setAttribute('normal', i))
      else for (let h = 0, f = i.count; h < f; h++) i.setXYZ(h, 0, 0, 0)
      const r = new Y(),
        s = new Y(),
        o = new Y(),
        a = new Y(),
        l = new Y(),
        c = new Y(),
        u = new Y(),
        d = new Y()
      if (e)
        for (let h = 0, f = e.count; h < f; h += 3) {
          const p = e.getX(h + 0),
            g = e.getX(h + 1),
            y = e.getX(h + 2)
          ;(r.fromBufferAttribute(t, p),
            s.fromBufferAttribute(t, g),
            o.fromBufferAttribute(t, y),
            u.subVectors(o, s),
            d.subVectors(r, s),
            u.cross(d),
            a.fromBufferAttribute(i, p),
            l.fromBufferAttribute(i, g),
            c.fromBufferAttribute(i, y),
            a.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(p, a.x, a.y, a.z),
            i.setXYZ(g, l.x, l.y, l.z),
            i.setXYZ(y, c.x, c.y, c.z))
        }
      else
        for (let h = 0, f = t.count; h < f; h += 3)
          (r.fromBufferAttribute(t, h + 0),
            s.fromBufferAttribute(t, h + 1),
            o.fromBufferAttribute(t, h + 2),
            u.subVectors(o, s),
            d.subVectors(r, s),
            u.cross(d),
            i.setXYZ(h + 0, u.x, u.y, u.z),
            i.setXYZ(h + 1, u.x, u.y, u.z),
            i.setXYZ(h + 2, u.x, u.y, u.z))
      ;(this.normalizeNormals(), (i.needsUpdate = !0))
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal
    for (let t = 0, i = e.count; t < i; t++)
      (ai.fromBufferAttribute(e, t), ai.normalize(), e.setXYZ(t, ai.x, ai.y, ai.z))
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        d = a.normalized,
        h = new c.constructor(l.length * u)
      let f = 0,
        p = 0
      for (let g = 0, y = l.length; g < y; g++) {
        a.isInterleavedBufferAttribute ? (f = l[g] * a.data.stride + a.offset) : (f = l[g] * u)
        for (let m = 0; m < u; m++) h[p++] = c[f++]
      }
      return new _i(h, u, d)
    }
    if (this.index === null)
      return (
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'),
        this
      )
    const t = new ki(),
      i = this.index.array,
      r = this.attributes
    for (const a in r) {
      const l = r[a],
        c = e(l, i)
      t.setAttribute(a, c)
    }
    const s = this.morphAttributes
    for (const a in s) {
      const l = [],
        c = s[a]
      for (let u = 0, d = c.length; u < d; u++) {
        const h = c[u],
          f = e(h, i)
        l.push(f)
      }
      t.morphAttributes[a] = l
    }
    t.morphTargetsRelative = this.morphTargetsRelative
    const o = this.groups
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a]
      t.addGroup(c.start, c.count, c.materialIndex)
    }
    return t
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
    }
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== '' && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters
      for (const c in l) l[c] !== void 0 && (e[c] = l[c])
      return e
    }
    e.data = { attributes: {} }
    const t = this.index
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      })
    const i = this.attributes
    for (const l in i) {
      const c = i[l]
      e.data.attributes[l] = c.toJSON(e.data)
    }
    const r = {}
    let s = !1
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = []
      for (let d = 0, h = c.length; d < h; d++) {
        const f = c[d]
        u.push(f.toJSON(e.data))
      }
      u.length > 0 && ((r[l] = u), (s = !0))
    }
    s && ((e.data.morphAttributes = r), (e.data.morphTargetsRelative = this.morphTargetsRelative))
    const o = this.groups
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)))
    const a = this.boundingSphere
    return (
      a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }),
      e
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;((this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null))
    const t = {}
    this.name = e.name
    const i = e.index
    i !== null && this.setIndex(i.clone(t))
    const r = e.attributes
    for (const c in r) {
      const u = r[c]
      this.setAttribute(c, u.clone(t))
    }
    const s = e.morphAttributes
    for (const c in s) {
      const u = [],
        d = s[c]
      for (let h = 0, f = d.length; h < f; h++) u.push(d[h].clone(t))
      this.morphAttributes[c] = u
    }
    this.morphTargetsRelative = e.morphTargetsRelative
    const o = e.groups
    for (let c = 0, u = o.length; c < u; c++) {
      const d = o[c]
      this.addGroup(d.start, d.count, d.materialIndex)
    }
    const a = e.boundingBox
    a !== null && (this.boundingBox = a.clone())
    const l = e.boundingSphere
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
const kS = new qe(),
  nl = new Uh(),
  Rf = new oo(),
  zS = new Y(),
  If = new Y(),
  Nf = new Y(),
  Pf = new Y(),
  Ng = new Y(),
  Lf = new Y(),
  VS = new Y(),
  Df = new Y()
class pn extends sn {
  constructor(e = new ki(), t = new Yr()) {
    ;(super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}))
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          ;(this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s))
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative
    t.fromBufferAttribute(r, e)
    const a = this.morphTargetInfluences
    if (s && a) {
      Lf.set(0, 0, 0)
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          d = s[l]
        u !== 0 &&
          (Ng.fromBufferAttribute(d, e),
          o ? Lf.addScaledVector(Ng, u) : Lf.addScaledVector(Ng.sub(t), u))
      }
      t.add(Lf)
    }
    return t
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Rf.copy(i.boundingSphere),
      Rf.applyMatrix4(s),
      nl.copy(e.ray).recast(e.near),
      !(
        Rf.containsPoint(nl.origin) === !1 &&
        (nl.intersectSphere(Rf, zS) === null ||
          nl.origin.distanceToSquared(zS) > (e.far - e.near) ** 2)
      ) &&
        (kS.copy(s).invert(),
        nl.copy(e.ray).applyMatrix4(kS),
        !(i.boundingBox !== null && nl.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, nl)))
  }
  _computeIntersections(e, t, i) {
    let r
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      d = s.attributes.normal,
      h = s.groups,
      f = s.drawRange
    if (a !== null)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const y = h[p],
            m = o[y.materialIndex],
            v = Math.max(y.start, f.start),
            x = Math.min(a.count, Math.min(y.start + y.count, f.start + f.count))
          for (let _ = v, S = x; _ < S; _ += 3) {
            const C = a.getX(_),
              A = a.getX(_ + 1),
              R = a.getX(_ + 2)
            ;((r = Ff(this, m, e, i, c, u, d, C, A, R)),
              r &&
                ((r.faceIndex = Math.floor(_ / 3)),
                (r.face.materialIndex = y.materialIndex),
                t.push(r)))
          }
        }
      else {
        const p = Math.max(0, f.start),
          g = Math.min(a.count, f.start + f.count)
        for (let y = p, m = g; y < m; y += 3) {
          const v = a.getX(y),
            x = a.getX(y + 1),
            _ = a.getX(y + 2)
          ;((r = Ff(this, o, e, i, c, u, d, v, x, _)),
            r && ((r.faceIndex = Math.floor(y / 3)), t.push(r)))
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const y = h[p],
            m = o[y.materialIndex],
            v = Math.max(y.start, f.start),
            x = Math.min(l.count, Math.min(y.start + y.count, f.start + f.count))
          for (let _ = v, S = x; _ < S; _ += 3) {
            const C = _,
              A = _ + 1,
              R = _ + 2
            ;((r = Ff(this, m, e, i, c, u, d, C, A, R)),
              r &&
                ((r.faceIndex = Math.floor(_ / 3)),
                (r.face.materialIndex = y.materialIndex),
                t.push(r)))
          }
        }
      else {
        const p = Math.max(0, f.start),
          g = Math.min(l.count, f.start + f.count)
        for (let y = p, m = g; y < m; y += 3) {
          const v = y,
            x = y + 1,
            _ = y + 2
          ;((r = Ff(this, o, e, i, c, u, d, v, x, _)),
            r && ((r.faceIndex = Math.floor(y / 3)), t.push(r)))
        }
      }
  }
}
function tL(n, e, t, i, r, s, o, a) {
  let l
  if (
    (e.side === Oi
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === Ts, a)),
    l === null)
  )
    return null
  ;(Df.copy(a), Df.applyMatrix4(n.matrixWorld))
  const c = t.ray.origin.distanceTo(Df)
  return c < t.near || c > t.far ? null : { distance: c, point: Df.clone(), object: n }
}
function Ff(n, e, t, i, r, s, o, a, l, c) {
  ;(n.getVertexPosition(a, If), n.getVertexPosition(l, Nf), n.getVertexPosition(c, Pf))
  const u = tL(n, e, t, i, If, Nf, Pf, VS)
  if (u) {
    const d = new Y()
    ;(ps.getBarycoord(VS, If, Nf, Pf, d),
      r && (u.uv = ps.getInterpolatedAttribute(r, a, l, c, d, new je())),
      s && (u.uv1 = ps.getInterpolatedAttribute(s, a, l, c, d, new je())),
      o &&
        ((u.normal = ps.getInterpolatedAttribute(o, a, l, c, d, new Y())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1)))
    const h = { a, b: l, c, normal: new Y(), materialIndex: 0 }
    ;(ps.getNormal(If, Nf, Pf, h.normal), (u.face = h), (u.barycoord = d))
  }
  return u
}
class Lu extends ki {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    ;(super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      }))
    const a = this
    ;((r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o)))
    const l = [],
      c = [],
      u = [],
      d = []
    let h = 0,
      f = 0
    ;(p('z', 'y', 'x', -1, -1, i, t, e, o, s, 0),
      p('z', 'y', 'x', 1, -1, i, t, -e, o, s, 1),
      p('x', 'z', 'y', 1, 1, e, i, t, r, o, 2),
      p('x', 'z', 'y', 1, -1, e, i, -t, r, o, 3),
      p('x', 'y', 'z', 1, -1, e, t, i, r, s, 4),
      p('x', 'y', 'z', -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute('position', new xi(c, 3)),
      this.setAttribute('normal', new xi(u, 3)),
      this.setAttribute('uv', new xi(d, 2)))
    function p(g, y, m, v, x, _, S, C, A, R, w) {
      const M = _ / A,
        I = S / R,
        L = _ / 2,
        U = S / 2,
        T = C / 2,
        F = A + 1,
        V = R + 1
      let W = 0,
        ee = 0
      const se = new Y()
      for (let he = 0; he < V; he++) {
        const ne = he * I - U
        for (let ie = 0; ie < F; ie++) {
          const be = ie * M - L
          ;((se[g] = be * v),
            (se[y] = ne * x),
            (se[m] = T),
            c.push(se.x, se.y, se.z),
            (se[g] = 0),
            (se[y] = 0),
            (se[m] = C > 0 ? 1 : -1),
            u.push(se.x, se.y, se.z),
            d.push(ie / A),
            d.push(1 - he / R),
            (W += 1))
        }
      }
      for (let he = 0; he < R; he++)
        for (let ne = 0; ne < A; ne++) {
          const ie = h + ne + F * he,
            be = h + ne + F * (he + 1),
            le = h + (ne + 1) + F * (he + 1),
            fe = h + (ne + 1) + F * he
          ;(l.push(ie, be, fe), l.push(be, le, fe), (ee += 6))
        }
      ;(a.addGroup(f, ee, w), (f += ee), (h += W))
    }
  }
  copy(e) {
    return (super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this)
  }
  static fromJSON(e) {
    return new Lu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
  }
}
function pu(n) {
  const e = {}
  for (const t in n) {
    e[t] = {}
    for (const i in n[t]) {
      const r = n[t][i]
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r)
    }
  }
  return e
}
function Wi(n) {
  const e = {}
  for (let t = 0; t < n.length; t++) {
    const i = pu(n[t])
    for (const r in i) e[r] = i[r]
  }
  return e
}
function nL(n) {
  const e = []
  for (let t = 0; t < n.length; t++) e.push(n[t].clone())
  return e
}
function k5(n) {
  const e = n.getRenderTarget()
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : Tt.workingColorSpace
}
const iL = { clone: pu, merge: Wi }
var rL =
    'void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
  sL = 'void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'
class Nr extends es {
  constructor(e) {
    ;(super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = rL),
      (this.fragmentShader = sL),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = pu(e.uniforms)),
      (this.uniformsGroups = nL(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    ;((t.glslVersion = this.glslVersion), (t.uniforms = {}))
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value
      o && o.isTexture
        ? (t.uniforms[r] = { type: 't', value: o.toJSON(e).uuid })
        : o && o.isColor
          ? (t.uniforms[r] = { type: 'c', value: o.getHex() })
          : o && o.isVector2
            ? (t.uniforms[r] = { type: 'v2', value: o.toArray() })
            : o && o.isVector3
              ? (t.uniforms[r] = { type: 'v3', value: o.toArray() })
              : o && o.isVector4
                ? (t.uniforms[r] = { type: 'v4', value: o.toArray() })
                : o && o.isMatrix3
                  ? (t.uniforms[r] = { type: 'm3', value: o.toArray() })
                  : o && o.isMatrix4
                    ? (t.uniforms[r] = { type: 'm4', value: o.toArray() })
                    : (t.uniforms[r] = { value: o })
    }
    ;(Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping))
    const i = {}
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0)
    return (Object.keys(i).length > 0 && (t.extensions = i), t)
  }
}
class z5 extends sn {
  constructor() {
    ;(super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new qe()),
      (this.projectionMatrix = new qe()),
      (this.projectionMatrixInverse = new qe()),
      (this.coordinateSystem = Ir))
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    )
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate()
  }
  updateMatrixWorld(e) {
    ;(super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert())
  }
  updateWorldMatrix(e, t) {
    ;(super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert())
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const ha = new Y(),
  HS = new je(),
  $S = new je()
class Ki extends z5 {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    ;(super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    )
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e
    ;((this.fov = fu * 2 * Math.atan(t)), this.updateProjectionMatrix())
  }
  getFocalLength() {
    const e = Math.tan(Bd * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / e
  }
  getEffectiveFOV() {
    return fu * 2 * Math.atan(Math.tan(Bd * 0.5 * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  getViewBounds(e, t, i) {
    ;(ha.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(ha.x, ha.y).multiplyScalar(-e / ha.z),
      ha.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(ha.x, ha.y).multiplyScalar(-e / ha.z))
  }
  getViewSize(e, t) {
    return (this.getViewBounds(e, HS, $S), t.subVectors($S, HS))
  }
  setViewOffset(e, t, i, r, s, o) {
    ;((this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix())
  }
  clearViewOffset() {
    ;(this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix())
  }
  updateProjectionMatrix() {
    const e = this.near
    let t = (e * Math.tan(Bd * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r
    const o = this.view
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight
      ;((s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / c),
        (r *= o.width / l),
        (i *= o.height / c))
    }
    const a = this.filmOffset
    ;(a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert())
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    )
  }
}
const pc = -90,
  mc = 1
class oL extends sn {
  constructor(e, t, i) {
    ;(super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0))
    const r = new Ki(pc, mc, e, t)
    ;((r.layers = this.layers), this.add(r))
    const s = new Ki(pc, mc, e, t)
    ;((s.layers = this.layers), this.add(s))
    const o = new Ki(pc, mc, e, t)
    ;((o.layers = this.layers), this.add(o))
    const a = new Ki(pc, mc, e, t)
    ;((a.layers = this.layers), this.add(a))
    const l = new Ki(pc, mc, e, t)
    ;((l.layers = this.layers), this.add(l))
    const c = new Ki(pc, mc, e, t)
    ;((c.layers = this.layers), this.add(c))
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, l] = t
    for (const c of t) this.remove(c)
    if (e === Ir)
      (i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1))
    else if (e === Xo)
      (i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1))
    else
      throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + e)
    for (const c of t) (this.add(c), c.updateMatrixWorld())
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld()
    const { renderTarget: i, activeMipmapLevel: r } = this
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem())
    const [s, o, a, l, c, u] = this.children,
      d = e.getRenderTarget(),
      h = e.getActiveCubeFace(),
      f = e.getActiveMipmapLevel(),
      p = e.xr.enabled
    e.xr.enabled = !1
    const g = i.texture.generateMipmaps
    ;((i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, l),
      e.setRenderTarget(i, 4, r),
      e.render(t, c),
      (i.texture.generateMipmaps = g),
      e.setRenderTarget(i, 5, r),
      e.render(t, u),
      e.setRenderTarget(d, h, f),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0))
  }
}
class V5 extends Wn {
  constructor(e, t, i, r, s, o, a, l, c, u) {
    ;((e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : kl),
      super(e, t, i, r, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1))
  }
  get images() {
    return this.image
  }
  set images(e) {
    this.image = e
  }
}
class aL extends Ua {
  constructor(e = 1, t = {}) {
    ;(super(e, e, t), (this.isWebGLCubeRenderTarget = !0))
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i]
    ;((this.texture = new V5(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Rr))
  }
  fromEquirectangularTexture(e, t) {
    ;((this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter))
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          '\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			',
        fragmentShader:
          '\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			',
      },
      r = new Lu(5, 5, 5),
      s = new Nr({
        name: 'CubemapFromEquirect',
        uniforms: pu(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Oi,
        blending: La,
      })
    s.uniforms.tEquirect.value = t
    const o = new pn(r, s),
      a = t.minFilter
    return (
      t.minFilter === Ws && (t.minFilter = Rr),
      new oL(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    )
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget()
    for (let o = 0; o < 6; o++) (e.setRenderTarget(this, o), e.clear(t, i, r))
    e.setRenderTarget(s)
  }
}
class Tl extends sn {
  constructor() {
    ;(super(), (this.isGroup = !0), (this.type = 'Group'))
  }
}
const lL = { type: 'move' }
class Pg {
  constructor() {
    ;((this._targetRay = null), (this._grip = null), (this._hand = null))
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Tl()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Tl()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Y()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Y())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Tl()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Y()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Y())),
      this._grip
    )
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    )
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i)
    }
    return (this.dispatchEvent({ type: 'connected', data: e }), this)
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    )
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null
    const a = this._targetRay,
      l = this._grip,
      c = this._hand
    if (e && t.session.visibilityState !== 'visible-blurred') {
      if (c && e.hand) {
        o = !0
        for (const g of e.hand.values()) {
          const y = t.getJointPose(g, i),
            m = this._getHandJoint(c, g)
          ;(y !== null &&
            (m.matrix.fromArray(y.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.matrixWorldNeedsUpdate = !0),
            (m.jointRadius = y.radius)),
            (m.visible = y !== null))
        }
        const u = c.joints['index-finger-tip'],
          d = c.joints['thumb-tip'],
          h = u.position.distanceTo(d.position),
          f = 0.02,
          p = 0.005
        c.inputState.pinching && h > f + p
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({ type: 'pinchend', handedness: e.handedness, target: this }))
          : !c.inputState.pinching &&
            h <= f - p &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({ type: 'pinchstart', handedness: e.handedness, target: this }))
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0), l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0), l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)))
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(lL)))
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    )
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Tl()
      ;((i.matrixAutoUpdate = !1), (i.visible = !1), (e.joints[t.jointName] = i), e.add(i))
    }
    return e.joints[t.jointName]
  }
}
class cL extends sn {
  constructor() {
    ;(super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Cs()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Cs()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })))
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    )
  }
}
class w_ {
  constructor(e, t) {
    ;((this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = gm),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = xs()))
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return ((this.usage = e), this)
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    )
  }
  copyAt(e, t, i) {
    ;((e *= this.stride), (i *= t.stride))
    for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r]
    return this
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this)
  }
  clone(e) {
    ;(e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer))
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
      i = new this.constructor(t, this.stride)
    return (i.setUsage(this.usage), i)
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this)
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = xs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    )
  }
}
const $i = new Y()
class l0 {
  constructor(e, t, i, r = !1) {
    ;((this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r))
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      ($i.fromBufferAttribute(this, t), $i.applyMatrix4(e), this.setXYZ(t, $i.x, $i.y, $i.z))
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ($i.fromBufferAttribute(this, t), $i.applyNormalMatrix(e), this.setXYZ(t, $i.x, $i.y, $i.z))
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ($i.fromBufferAttribute(this, t), $i.transformDirection(e), this.setXYZ(t, $i.x, $i.y, $i.z))
    return this
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t]
    return (this.normalized && (i = fs(i, this.array)), i)
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = ln(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    )
  }
  setX(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    )
  }
  setY(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    )
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    )
  }
  setW(e, t) {
    return (
      this.normalized && (t = ln(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    )
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3]
    return (this.normalized && (t = fs(t, this.array)), t)
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = ln(t, this.array)), (i = ln(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ln(t, this.array)), (i = ln(i, this.array)), (r = ln(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ln(t, this.array)),
        (i = ln(i, this.array)),
        (r = ln(r, this.array)),
        (s = ln(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    )
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return new _i(new this.array.constructor(t), this.itemSize, this.normalized)
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new l0(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
      )
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      }
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      )
  }
}
const GS = new Y(),
  WS = new Mt(),
  QS = new Mt(),
  uL = new Y(),
  jS = new qe(),
  Of = new Y(),
  Lg = new oo(),
  qS = new qe(),
  Dg = new Uh()
class dL extends pn {
  constructor(e, t) {
    ;(super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = bS),
      (this.bindMatrix = new qe()),
      (this.bindMatrixInverse = new qe()),
      (this.boundingBox = null),
      (this.boundingSphere = null))
  }
  computeBoundingBox() {
    const e = this.geometry
    ;(this.boundingBox === null && (this.boundingBox = new ir()), this.boundingBox.makeEmpty())
    const t = e.getAttribute('position')
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, Of), this.boundingBox.expandByPoint(Of))
  }
  computeBoundingSphere() {
    const e = this.geometry
    ;(this.boundingSphere === null && (this.boundingSphere = new oo()),
      this.boundingSphere.makeEmpty())
    const t = e.getAttribute('position')
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, Of), this.boundingSphere.expandByPoint(Of))
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Lg.copy(this.boundingSphere),
      Lg.applyMatrix4(r),
      e.ray.intersectsSphere(Lg) !== !1 &&
        (qS.copy(r).invert(),
        Dg.copy(e.ray).applyMatrix4(qS),
        !(this.boundingBox !== null && Dg.intersectsBox(this.boundingBox) === !1) &&
          this._computeIntersections(e, t, Dg)))
  }
  getVertexPosition(e, t) {
    return (super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t)
  }
  bind(e, t) {
    ;((this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert())
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const e = new Mt(),
      t = this.geometry.attributes.skinWeight
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i)
      const s = 1 / e.manhattanLength()
      ;(s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w))
    }
  }
  updateMatrixWorld(e) {
    ;(super.updateMatrixWorld(e),
      this.bindMode === bS
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === rP
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode))
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry
    ;(WS.fromBufferAttribute(r.attributes.skinIndex, e),
      QS.fromBufferAttribute(r.attributes.skinWeight, e),
      GS.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0))
    for (let s = 0; s < 4; s++) {
      const o = QS.getComponent(s)
      if (o !== 0) {
        const a = WS.getComponent(s)
        ;(jS.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(uL.copy(GS).applyMatrix4(jS), o))
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse)
  }
}
class fh extends sn {
  constructor() {
    ;(super(), (this.isBone = !0), (this.type = 'Bone'))
  }
}
class vr extends Wn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = vi, u = vi, d, h) {
    ;(super(null, o, a, l, c, u, r, s, d, h),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1))
  }
}
const XS = new qe(),
  hL = new qe()
class c0 {
  constructor(e = [], t = []) {
    ;((this.uuid = xs()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init())
  }
  init() {
    const e = this.bones,
      t = this.boneInverses
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses()
    else if (e.length !== t.length) {
      ;(console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
      ),
        (this.boneInverses = []))
      for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new qe())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new qe()
      ;(this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i))
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i && i.matrixWorld.copy(this.boneInverses[e]).invert()
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale))
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : hL
      ;(XS.multiplyMatrices(a, t[s]), XS.toArray(i, s * 16))
    }
    r !== null && (r.needsUpdate = !0)
  }
  clone() {
    return new c0(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4)
    ;((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)))
    const t = new Float32Array(e * e * 4)
    t.set(this.boneMatrices)
    const i = new vr(t, e, e, Fi, nr)
    return ((i.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = i), this)
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t]
      if (r.name === e) return r
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(e, t) {
    this.uuid = e.uuid
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i]
      let o = t[s]
      ;(o === void 0 &&
        (console.warn('THREE.Skeleton: No bone found with UUID:', s), (o = new fh())),
        this.bones.push(o),
        this.boneInverses.push(new qe().fromArray(e.boneInverses[i])))
    }
    return (this.init(), this)
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: 'Skeleton', generator: 'Skeleton.toJSON' },
      bones: [],
      boneInverses: [],
    }
    e.uuid = this.uuid
    const t = this.bones,
      i = this.boneInverses
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r]
      e.bones.push(o.uuid)
      const a = i[r]
      e.boneInverses.push(a.toArray())
    }
    return e
  }
}
class Ko extends _i {
  constructor(e, t, i, r = 1) {
    ;(super(e, t, i), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = r))
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this)
  }
  toJSON() {
    const e = super.toJSON()
    return ((e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e)
  }
}
const gc = new qe(),
  KS = new qe(),
  Bf = [],
  YS = new ir(),
  fL = new qe(),
  od = new pn(),
  ad = new oo()
class pL extends pn {
  constructor(e, t, i) {
    ;(super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Ko(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null))
    for (let r = 0; r < i; r++) this.setMatrixAt(r, fL)
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count
    ;(this.boundingBox === null && (this.boundingBox = new ir()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty())
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, gc), YS.copy(e.boundingBox).applyMatrix4(gc), this.boundingBox.union(YS))
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count
    ;(this.boundingSphere === null && (this.boundingSphere = new oo()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty())
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, gc),
        ad.copy(e.boundingSphere).applyMatrix4(gc),
        this.boundingSphere.union(ad))
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3)
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16)
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      o = e * s + 1
    for (let a = 0; a < i.length; a++) i[a] = r[o + a]
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count
    if (
      ((od.geometry = this.geometry),
      (od.material = this.material),
      od.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        ad.copy(this.boundingSphere),
        ad.applyMatrix4(i),
        e.ray.intersectsSphere(ad) !== !1))
    )
      for (let s = 0; s < r; s++) {
        ;(this.getMatrixAt(s, gc),
          KS.multiplyMatrices(i, gc),
          (od.matrixWorld = KS),
          od.raycast(e, Bf))
        for (let o = 0, a = Bf.length; o < a; o++) {
          const l = Bf[o]
          ;((l.instanceId = s), (l.object = this), t.push(l))
        }
        Bf.length = 0
      }
  }
  setColorAt(e, t) {
    ;(this.instanceColor === null &&
      (this.instanceColor = new Ko(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)),
      t.toArray(this.instanceColor.array, e * 3))
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16)
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = i.length + 1
    this.morphTexture === null &&
      (this.morphTexture = new vr(new Float32Array(r * this.count), r, this.count, x_, nr))
    const s = this.morphTexture.source.data.data
    let o = 0
    for (let c = 0; c < i.length; c++) o += i[c]
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = r * e
    ;((s[l] = a), s.set(i, l + 1))
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: 'dispose' }),
      this.morphTexture !== null && (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    )
  }
}
const Fg = new Y(),
  mL = new Y(),
  gL = new pt()
class Eo {
  constructor(e = new Y(1, 0, 0), t = 0) {
    ;((this.isPlane = !0), (this.normal = e), (this.constant = t))
  }
  set(e, t) {
    return (this.normal.copy(e), (this.constant = t), this)
  }
  setComponents(e, t, i, r) {
    return (this.normal.set(e, t, i), (this.constant = r), this)
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return (this.normal.copy(e), (this.constant = -t.dot(this.normal)), this)
  }
  setFromCoplanarPoints(e, t, i) {
    const r = Fg.subVectors(i, t).cross(mL.subVectors(e, t)).normalize()
    return (this.setFromNormalAndCoplanarPoint(r, e), this)
  }
  copy(e) {
    return (this.normal.copy(e.normal), (this.constant = e.constant), this)
  }
  normalize() {
    const e = 1 / this.normal.length()
    return (this.normal.multiplyScalar(e), (this.constant *= e), this)
  }
  negate() {
    return ((this.constant *= -1), this.normal.negate(), this)
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
  }
  intersectLine(e, t) {
    const i = e.delta(Fg),
      r = this.normal.dot(i)
    if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null
    const s = -(e.start.dot(this.normal) + this.constant) / r
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end)
    return (t < 0 && i > 0) || (i < 0 && t > 0)
  }
  intersectsBox(e) {
    return e.intersectsPlane(this)
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this)
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(e, t) {
    const i = t || gL.getNormalMatrix(e),
      r = this.coplanarPoint(Fg).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize()
    return ((this.constant = -r.dot(s)), this)
  }
  translate(e) {
    return ((this.constant -= e.dot(this.normal)), this)
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const il = new oo(),
  Uf = new Y()
class C_ {
  constructor(e = new Eo(), t = new Eo(), i = new Eo(), r = new Eo(), s = new Eo(), o = new Eo()) {
    this.planes = [e, t, i, r, s, o]
  }
  set(e, t, i, r, s, o) {
    const a = this.planes
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    )
  }
  copy(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i])
    return this
  }
  setFromProjectionMatrix(e, t = Ir) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      d = r[6],
      h = r[7],
      f = r[8],
      p = r[9],
      g = r[10],
      y = r[11],
      m = r[12],
      v = r[13],
      x = r[14],
      _ = r[15]
    if (
      (i[0].setComponents(l - s, h - c, y - f, _ - m).normalize(),
      i[1].setComponents(l + s, h + c, y + f, _ + m).normalize(),
      i[2].setComponents(l + o, h + u, y + p, _ + v).normalize(),
      i[3].setComponents(l - o, h - u, y - p, _ - v).normalize(),
      i[4].setComponents(l - a, h - d, y - g, _ - x).normalize(),
      t === Ir)
    )
      i[5].setComponents(l + a, h + d, y + g, _ + x).normalize()
    else if (t === Xo) i[5].setComponents(a, d, g, x).normalize()
    else throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + t)
    return this
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      (e.boundingSphere === null && e.computeBoundingSphere(),
        il.copy(e.boundingSphere).applyMatrix4(e.matrixWorld))
    else {
      const t = e.geometry
      ;(t.boundingSphere === null && t.computeBoundingSphere(),
        il.copy(t.boundingSphere).applyMatrix4(e.matrixWorld))
    }
    return this.intersectsSphere(il)
  }
  intersectsSprite(e) {
    return (
      il.center.set(0, 0, 0),
      (il.radius = 0.7071067811865476),
      il.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(il)
    )
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1
    return !0
  }
  intersectsBox(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) {
      const r = t[i]
      if (
        ((Uf.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Uf.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Uf.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Uf) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class H5 extends es {
  constructor(e) {
    ;(super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new gt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const ym = new Y(),
  vm = new Y(),
  ZS = new qe(),
  ld = new Uh(),
  kf = new oo(),
  Og = new Y(),
  JS = new Y()
class E_ extends sn {
  constructor(e = new ki(), t = new H5()) {
    ;(super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0]
      for (let r = 1, s = t.count; r < s; r++)
        (ym.fromBufferAttribute(t, r - 1),
          vm.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += ym.distanceTo(vm)))
      e.setAttribute('lineDistance', new xi(i, 1))
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      )
    return this
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      kf.copy(i.boundingSphere),
      kf.applyMatrix4(r),
      (kf.radius += s),
      e.ray.intersectsSphere(kf) === !1)
    )
      return
    ;(ZS.copy(r).invert(), ld.copy(e.ray).applyMatrix4(ZS))
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = i.index,
      h = i.attributes.position
    if (u !== null) {
      const f = Math.max(0, o.start),
        p = Math.min(u.count, o.start + o.count)
      for (let g = f, y = p - 1; g < y; g += c) {
        const m = u.getX(g),
          v = u.getX(g + 1),
          x = zf(this, e, ld, l, m, v, g)
        x && t.push(x)
      }
      if (this.isLineLoop) {
        const g = u.getX(p - 1),
          y = u.getX(f),
          m = zf(this, e, ld, l, g, y, p - 1)
        m && t.push(m)
      }
    } else {
      const f = Math.max(0, o.start),
        p = Math.min(h.count, o.start + o.count)
      for (let g = f, y = p - 1; g < y; g += c) {
        const m = zf(this, e, ld, l, g, g + 1, g)
        m && t.push(m)
      }
      if (this.isLineLoop) {
        const g = zf(this, e, ld, l, p - 1, f, p - 1)
        g && t.push(g)
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}))
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          ;(this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s))
        }
      }
    }
  }
}
function zf(n, e, t, i, r, s, o) {
  const a = n.geometry.attributes.position
  if (
    (ym.fromBufferAttribute(a, r),
    vm.fromBufferAttribute(a, s),
    t.distanceSqToSegment(ym, vm, Og, JS) > i)
  )
    return
  Og.applyMatrix4(n.matrixWorld)
  const c = e.ray.origin.distanceTo(Og)
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      point: JS.clone().applyMatrix4(n.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    }
}
const eA = new Y(),
  tA = new Y()
class yL extends E_ {
  constructor(e, t) {
    ;(super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments'))
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const t = e.attributes.position,
        i = []
      for (let r = 0, s = t.count; r < s; r += 2)
        (eA.fromBufferAttribute(t, r),
          tA.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + eA.distanceTo(tA)))
      e.setAttribute('lineDistance', new xi(i, 1))
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      )
    return this
  }
}
class vL extends E_ {
  constructor(e, t) {
    ;(super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop'))
  }
}
class $5 extends es {
  constructor(e) {
    ;(super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new gt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    )
  }
}
const nA = new qe(),
  ky = new Uh(),
  Vf = new oo(),
  Hf = new Y()
class _L extends sn {
  constructor(e = new ki(), t = new $5()) {
    ;(super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Vf.copy(i.boundingSphere),
      Vf.applyMatrix4(r),
      (Vf.radius += s),
      e.ray.intersectsSphere(Vf) === !1)
    )
      return
    ;(nA.copy(r).invert(), ky.copy(e.ray).applyMatrix4(nA))
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = i.index,
      d = i.attributes.position
    if (c !== null) {
      const h = Math.max(0, o.start),
        f = Math.min(c.count, o.start + o.count)
      for (let p = h, g = f; p < g; p++) {
        const y = c.getX(p)
        ;(Hf.fromBufferAttribute(d, y), iA(Hf, y, l, r, e, t, this))
      }
    } else {
      const h = Math.max(0, o.start),
        f = Math.min(d.count, o.start + o.count)
      for (let p = h, g = f; p < g; p++) (Hf.fromBufferAttribute(d, p), iA(Hf, p, l, r, e, t, this))
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t)
    if (i.length > 0) {
      const r = t[i[0]]
      if (r !== void 0) {
        ;((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}))
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s)
          ;(this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = s))
        }
      }
    }
  }
}
function iA(n, e, t, i, r, s, o) {
  const a = ky.distanceSqToPoint(n)
  if (a < t) {
    const l = new Y()
    ;(ky.closestPointToPoint(n, l), l.applyMatrix4(i))
    const c = r.ray.origin.distanceTo(l)
    if (c < r.near || c > r.far) return
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    })
  }
}
class G5 extends Wn {
  constructor(e, t) {
    ;(super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = vi),
      (this.minFilter = vi),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0))
  }
}
class Ha extends Wn {
  constructor(e, t, i, r, s, o, a, l, c, u = Nl) {
    if (u !== Nl && u !== hu)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      )
    ;(i === void 0 && u === Nl && (i = Ni),
      i === void 0 && u === hu && (i = du),
      super(null, r, s, o, a, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : vi),
      (this.minFilter = l !== void 0 ? l : vi),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null))
  }
  copy(e) {
    return (super.copy(e), (this.compareFunction = e.compareFunction), this)
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (this.compareFunction !== null && (t.compareFunction = this.compareFunction), t)
  }
}
class ph extends ki {
  constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
    ;(super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      }))
    const c = this
    ;((r = Math.floor(r)), (s = Math.floor(s)))
    const u = [],
      d = [],
      h = [],
      f = []
    let p = 0
    const g = [],
      y = i / 2
    let m = 0
    ;(v(),
      o === !1 && (e > 0 && x(!0), t > 0 && x(!1)),
      this.setIndex(u),
      this.setAttribute('position', new xi(d, 3)),
      this.setAttribute('normal', new xi(h, 3)),
      this.setAttribute('uv', new xi(f, 2)))
    function v() {
      const _ = new Y(),
        S = new Y()
      let C = 0
      const A = (t - e) / i
      for (let R = 0; R <= s; R++) {
        const w = [],
          M = R / s,
          I = M * (t - e) + e
        for (let L = 0; L <= r; L++) {
          const U = L / r,
            T = U * l + a,
            F = Math.sin(T),
            V = Math.cos(T)
          ;((S.x = I * F),
            (S.y = -M * i + y),
            (S.z = I * V),
            d.push(S.x, S.y, S.z),
            _.set(F, A, V).normalize(),
            h.push(_.x, _.y, _.z),
            f.push(U, 1 - M),
            w.push(p++))
        }
        g.push(w)
      }
      for (let R = 0; R < r; R++)
        for (let w = 0; w < s; w++) {
          const M = g[w][R],
            I = g[w + 1][R],
            L = g[w + 1][R + 1],
            U = g[w][R + 1]
          ;((e > 0 || w !== 0) && (u.push(M, I, U), (C += 3)),
            (t > 0 || w !== s - 1) && (u.push(I, L, U), (C += 3)))
        }
      ;(c.addGroup(m, C, 0), (m += C))
    }
    function x(_) {
      const S = p,
        C = new je(),
        A = new Y()
      let R = 0
      const w = _ === !0 ? e : t,
        M = _ === !0 ? 1 : -1
      for (let L = 1; L <= r; L++) (d.push(0, y * M, 0), h.push(0, M, 0), f.push(0.5, 0.5), p++)
      const I = p
      for (let L = 0; L <= r; L++) {
        const T = (L / r) * l + a,
          F = Math.cos(T),
          V = Math.sin(T)
        ;((A.x = w * V),
          (A.y = y * M),
          (A.z = w * F),
          d.push(A.x, A.y, A.z),
          h.push(0, M, 0),
          (C.x = F * 0.5 + 0.5),
          (C.y = V * 0.5 * M + 0.5),
          f.push(C.x, C.y),
          p++)
      }
      for (let L = 0; L < r; L++) {
        const U = S + L,
          T = I + L
        ;(_ === !0 ? u.push(T, T + 1, U) : u.push(T + 1, T, U), (R += 3))
      }
      ;(c.addGroup(m, R, _ === !0 ? 1 : 2), (m += R))
    }
  }
  copy(e) {
    return (super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this)
  }
  static fromJSON(e) {
    return new ph(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class M_ extends ph {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    ;(super(0, e, t, i, r, s, o, a),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      }))
  }
  static fromJSON(e) {
    return new M_(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class mu extends ki {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    ;(super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r }))
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      c = a + 1,
      u = l + 1,
      d = e / a,
      h = t / l,
      f = [],
      p = [],
      g = [],
      y = []
    for (let m = 0; m < u; m++) {
      const v = m * h - o
      for (let x = 0; x < c; x++) {
        const _ = x * d - s
        ;(p.push(_, -v, 0), g.push(0, 0, 1), y.push(x / a), y.push(1 - m / l))
      }
    }
    for (let m = 0; m < l; m++)
      for (let v = 0; v < a; v++) {
        const x = v + c * m,
          _ = v + c * (m + 1),
          S = v + 1 + c * (m + 1),
          C = v + 1 + c * m
        ;(f.push(x, _, C), f.push(_, S, C))
      }
    ;(this.setIndex(f),
      this.setAttribute('position', new xi(p, 3)),
      this.setAttribute('normal', new xi(g, 3)),
      this.setAttribute('uv', new xi(y, 2)))
  }
  copy(e) {
    return (super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this)
  }
  static fromJSON(e) {
    return new mu(e.width, e.height, e.widthSegments, e.heightSegments)
  }
}
class _m extends ki {
  constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
    ;(super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i))))
    const l = Math.min(o + a, Math.PI)
    let c = 0
    const u = [],
      d = new Y(),
      h = new Y(),
      f = [],
      p = [],
      g = [],
      y = []
    for (let m = 0; m <= i; m++) {
      const v = [],
        x = m / i
      let _ = 0
      m === 0 && o === 0 ? (_ = 0.5 / t) : m === i && l === Math.PI && (_ = -0.5 / t)
      for (let S = 0; S <= t; S++) {
        const C = S / t
        ;((d.x = -e * Math.cos(r + C * s) * Math.sin(o + x * a)),
          (d.y = e * Math.cos(o + x * a)),
          (d.z = e * Math.sin(r + C * s) * Math.sin(o + x * a)),
          p.push(d.x, d.y, d.z),
          h.copy(d).normalize(),
          g.push(h.x, h.y, h.z),
          y.push(C + _, 1 - x),
          v.push(c++))
      }
      u.push(v)
    }
    for (let m = 0; m < i; m++)
      for (let v = 0; v < t; v++) {
        const x = u[m][v + 1],
          _ = u[m][v],
          S = u[m + 1][v],
          C = u[m + 1][v + 1]
        ;((m !== 0 || o > 0) && f.push(x, _, C), (m !== i - 1 || l < Math.PI) && f.push(_, S, C))
      }
    ;(this.setIndex(f),
      this.setAttribute('position', new xi(p, 3)),
      this.setAttribute('normal', new xi(g, 3)),
      this.setAttribute('uv', new xi(y, 2)))
  }
  copy(e) {
    return (super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this)
  }
  static fromJSON(e) {
    return new _m(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class R_ extends es {
  constructor(e) {
    ;(super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = 'MeshStandardMaterial'),
      (this.defines = { STANDARD: '' }),
      (this.color = new gt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new gt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = pm),
      (this.normalScale = new je(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Cs()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '' }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class ao extends R_ {
  constructor(e) {
    ;(super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new je(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return Nt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new gt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new gt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new gt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e))
  }
  get anisotropy() {
    return this._anisotropy
  }
  set anisotropy(e) {
    ;(this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e))
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(e) {
    ;(this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e))
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(e) {
    ;(this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e))
  }
  get dispersion() {
    return this._dispersion
  }
  set dispersion(e) {
    ;(this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e))
  }
  get sheen() {
    return this._sheen
  }
  set sheen(e) {
    ;(this._sheen > 0 != e > 0 && this.version++, (this._sheen = e))
  }
  get transmission() {
    return this._transmission
  }
  set transmission(e) {
    ;(this._transmission > 0 != e > 0 && this.version++, (this._transmission = e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    )
  }
}
class xL extends es {
  constructor(e) {
    ;(super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = cP),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    )
  }
}
class SL extends es {
  constructor(e) {
    ;(super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    )
  }
}
function $f(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == 'number'
      ? new e(n)
      : Array.prototype.slice.call(n)
}
function AL(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function bL(n) {
  function e(r, s) {
    return n[r] - n[s]
  }
  const t = n.length,
    i = new Array(t)
  for (let r = 0; r !== t; ++r) i[r] = r
  return (i.sort(e), i)
}
function rA(n, e, t) {
  const i = n.length,
    r = new n.constructor(i)
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l]
  }
  return r
}
function W5(n, e, t, i) {
  let r = 1,
    s = n[0]
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++]
  if (s === void 0) return
  let o = s[i]
  if (o !== void 0)
    if (Array.isArray(o))
      do ((o = s[i]), o !== void 0 && (e.push(s.time), t.push.apply(t, o)), (s = n[r++]))
      while (s !== void 0)
    else if (o.toArray !== void 0)
      do ((o = s[i]), o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), (s = n[r++]))
      while (s !== void 0)
    else
      do ((o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]))
      while (s !== void 0)
}
class kh {
  constructor(e, t, i, r) {
    ;((this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {}))
  }
  evaluate(e) {
    const t = this.parameterPositions
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1]
    e: {
      t: {
        let o
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i
                return ((i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1))
              }
              if (i === a) break
              if (((s = r), (r = t[++i]), e < r)) break t
            }
            o = t.length
            break n
          }
          if (!(e >= s)) {
            const a = t[1]
            e < a && ((i = 2), (s = a))
            for (let l = i - 2; ; ) {
              if (s === void 0) return ((this._cachedIndex = 0), this.copySampleValue_(0))
              if (i === l) break
              if (((r = s), (s = t[--i - 1]), e >= s)) break t
            }
            ;((o = i), (i = 0))
            break n
          }
          break e
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1
          e < t[a] ? (o = a) : (i = a + 1)
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return ((this._cachedIndex = 0), this.copySampleValue_(0))
        if (r === void 0)
          return ((i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1))
      }
      ;((this._cachedIndex = i), this.intervalChanged_(i, s, r))
    }
    return this.interpolate_(i, s, e, r)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r
    for (let o = 0; o !== r; ++o) t[o] = i[s + o]
    return t
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
class TL extends kh {
  constructor(e, t, i, r) {
    ;(super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Lc, endingEnd: Lc }))
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o]
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Dc:
          ;((s = e), (a = 2 * t - i))
          break
        case fm:
          ;((s = r.length - 2), (a = t + r[s] - r[s + 1]))
          break
        default:
          ;((s = e), (a = i))
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Dc:
          ;((o = e), (l = 2 * i - t))
          break
        case fm:
          ;((o = 1), (l = i + r[1] - r[0]))
          break
        default:
          ;((o = e - 1), (l = t))
      }
    const c = (i - t) * 0.5,
      u = this.valueSize
    ;((this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u))
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      d = this._offsetNext,
      h = this._weightPrev,
      f = this._weightNext,
      p = (i - t) / (r - t),
      g = p * p,
      y = g * p,
      m = -h * y + 2 * h * g - h * p,
      v = (1 + h) * y + (-1.5 - 2 * h) * g + (-0.5 + h) * p + 1,
      x = (-1 - f) * y + (1.5 + f) * g + 0.5 * p,
      _ = f * y - f * g
    for (let S = 0; S !== a; ++S) s[S] = m * o[u + S] + v * o[c + S] + x * o[l + S] + _ * o[d + S]
    return s
  }
}
class Q5 extends kh {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (i - t) / (r - t),
      d = 1 - u
    for (let h = 0; h !== a; ++h) s[h] = o[c + h] * d + o[l + h] * u
    return s
  }
}
class wL extends kh {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1)
  }
}
class lo {
  constructor(e, t, i, r) {
    if (e === void 0) throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (t === void 0 || t.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e)
    ;((this.name = e),
      (this.times = $f(t, this.TimeBufferType)),
      (this.values = $f(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation))
  }
  static toJSON(e) {
    const t = e.constructor
    let i
    if (t.toJSON !== this.toJSON) i = t.toJSON(e)
    else {
      i = { name: e.name, times: $f(e.times, Array), values: $f(e.values, Array) }
      const r = e.getInterpolation()
      r !== e.DefaultInterpolation && (i.interpolation = r)
    }
    return ((i.type = e.ValueTypeName), i)
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new wL(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodLinear(e) {
    return new Q5(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodSmooth(e) {
    return new TL(this.times, this.values, this.getValueSize(), e)
  }
  setInterpolation(e) {
    let t
    switch (e) {
      case ch:
        t = this.InterpolantFactoryMethodDiscrete
        break
      case uh:
        t = this.InterpolantFactoryMethodLinear
        break
      case hg:
        t = this.InterpolantFactoryMethodSmooth
        break
    }
    if (t === void 0) {
      const i =
        'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation)
        else throw new Error(i)
      return (console.warn('THREE.KeyframeTrack:', i), this)
    }
    return ((this.createInterpolant = t), this)
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ch
      case this.InterpolantFactoryMethodLinear:
        return uh
      case this.InterpolantFactoryMethodSmooth:
        return hg
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
    }
    return this
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
    }
    return this
  }
  trim(e, t) {
    const i = this.times,
      r = i.length
    let s = 0,
      o = r - 1
    for (; s !== r && i[s] < e; ) ++s
    for (; o !== -1 && i[o] > t; ) --o
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1))
      const a = this.getValueSize()
      ;((this.times = i.slice(s, o)), (this.values = this.values.slice(s * a, o * a)))
    }
    return this
  }
  validate() {
    let e = !0
    const t = this.getValueSize()
    t - Math.floor(t) !== 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (e = !1))
    const i = this.times,
      r = this.values,
      s = i.length
    s === 0 && (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1))
    let o = null
    for (let a = 0; a !== s; a++) {
      const l = i[a]
      if (typeof l == 'number' && isNaN(l)) {
        ;(console.error('THREE.KeyframeTrack: Time is not a valid number.', this, a, l), (e = !1))
        break
      }
      if (o !== null && o > l) {
        ;(console.error('THREE.KeyframeTrack: Out of order keys.', this, a, l, o), (e = !1))
        break
      }
      o = l
    }
    if (r !== void 0 && AL(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a]
        if (isNaN(c)) {
          ;(console.error('THREE.KeyframeTrack: Value is not a valid number.', this, a, c),
            (e = !1))
          break
        }
      }
    return e
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === hg,
      s = e.length - 1
    let o = 1
    for (let a = 1; a < s; ++a) {
      let l = !1
      const c = e[a],
        u = e[a + 1]
      if (c !== u && (a !== 1 || c !== e[0]))
        if (r) l = !0
        else {
          const d = a * i,
            h = d - i,
            f = d + i
          for (let p = 0; p !== i; ++p) {
            const g = t[d + p]
            if (g !== t[h + p] || g !== t[f + p]) {
              l = !0
              break
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a]
          const d = a * i,
            h = o * i
          for (let f = 0; f !== i; ++f) t[h + f] = t[d + f]
        }
        ++o
      }
    }
    if (s > 0) {
      e[o] = e[s]
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c]
      ++o
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    )
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t)
    return ((r.createInterpolant = this.createInterpolant), r)
  }
}
lo.prototype.TimeBufferType = Float32Array
lo.prototype.ValueBufferType = Float32Array
lo.prototype.DefaultInterpolation = uh
class Du extends lo {
  constructor(e, t, i) {
    super(e, t, i)
  }
}
Du.prototype.ValueTypeName = 'bool'
Du.prototype.ValueBufferType = Array
Du.prototype.DefaultInterpolation = ch
Du.prototype.InterpolantFactoryMethodLinear = void 0
Du.prototype.InterpolantFactoryMethodSmooth = void 0
class j5 extends lo {}
j5.prototype.ValueTypeName = 'color'
class gu extends lo {}
gu.prototype.ValueTypeName = 'number'
class CL extends kh {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t)
    let c = e * a
    for (let u = c + a; c !== u; c += 4) Qt.slerpFlat(s, 0, o, c - a, o, c, l)
    return s
  }
}
class yu extends lo {
  InterpolantFactoryMethodLinear(e) {
    return new CL(this.times, this.values, this.getValueSize(), e)
  }
}
yu.prototype.ValueTypeName = 'quaternion'
yu.prototype.InterpolantFactoryMethodSmooth = void 0
class Fu extends lo {
  constructor(e, t, i) {
    super(e, t, i)
  }
}
Fu.prototype.ValueTypeName = 'string'
Fu.prototype.ValueBufferType = Array
Fu.prototype.DefaultInterpolation = ch
Fu.prototype.InterpolantFactoryMethodLinear = void 0
Fu.prototype.InterpolantFactoryMethodSmooth = void 0
class vu extends lo {}
vu.prototype.ValueTypeName = 'vector'
class zy {
  constructor(e = '', t = -1, i = [], r = A_) {
    ;((this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = xs()),
      this.duration < 0 && this.resetDuration())
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1)
    for (let o = 0, a = i.length; o !== a; ++o) t.push(ML(i[o]).scale(r))
    const s = new this(e.name, e.duration, t, e.blendMode)
    return ((s.uuid = e.uuid), s)
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }
    for (let s = 0, o = i.length; s !== o; ++s) t.push(lo.toJSON(i[s]))
    return r
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = []
    for (let a = 0; a < s; a++) {
      let l = [],
        c = []
      ;(l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0))
      const u = bL(l)
      ;((l = rA(l, 1, u)),
        (c = rA(c, 1, u)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(new gu('.morphTargetInfluences[' + t[a].name + ']', l, c).scale(1 / i)))
    }
    return new this(e, -1, o)
  }
  static findByName(e, t) {
    let i = e
    if (!Array.isArray(e)) {
      const r = e
      i = (r.geometry && r.geometry.animations) || r.animations
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r]
    return null
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s)
      if (u && u.length > 1) {
        const d = u[1]
        let h = r[d]
        ;(h || (r[d] = h = []), h.push(c))
      }
    }
    const o = []
    for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i))
    return o
  }
  static parseAnimation(e, t) {
    if (!e) return (console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null)
    const i = function (d, h, f, p, g) {
        if (f.length !== 0) {
          const y = [],
            m = []
          ;(W5(f, y, m, p), y.length !== 0 && g.push(new d(h, y, m)))
        }
      },
      r = [],
      s = e.name || 'default',
      o = e.fps || 30,
      a = e.blendMode
    let l = e.length || -1
    const c = e.hierarchy || []
    for (let d = 0; d < c.length; d++) {
      const h = c[d].keys
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          const f = {}
          let p
          for (p = 0; p < h.length; p++)
            if (h[p].morphTargets)
              for (let g = 0; g < h[p].morphTargets.length; g++) f[h[p].morphTargets[g]] = -1
          for (const g in f) {
            const y = [],
              m = []
            for (let v = 0; v !== h[p].morphTargets.length; ++v) {
              const x = h[p]
              ;(y.push(x.time), m.push(x.morphTarget === g ? 1 : 0))
            }
            r.push(new gu('.morphTargetInfluence[' + g + ']', y, m))
          }
          l = f.length * o
        } else {
          const f = '.bones[' + t[d].name + ']'
          ;(i(vu, f + '.position', h, 'pos', r),
            i(yu, f + '.quaternion', h, 'rot', r),
            i(vu, f + '.scale', h, 'scl', r))
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a)
  }
  resetDuration() {
    const e = this.tracks
    let t = 0
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i]
      t = Math.max(t, s.times[s.times.length - 1])
    }
    return ((this.duration = t), this)
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration)
    return this
  }
  validate() {
    let e = !0
    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate()
    return e
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize()
    return this
  }
  clone() {
    const e = []
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone())
    return new this.constructor(this.name, this.duration, e, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function EL(n) {
  switch (n.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return gu
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return vu
    case 'color':
      return j5
    case 'quaternion':
      return yu
    case 'bool':
    case 'boolean':
      return Du
    case 'string':
      return Fu
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + n)
}
function ML(n) {
  if (n.type === void 0) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  const e = EL(n.type)
  if (n.times === void 0) {
    const t = [],
      i = []
    ;(W5(n.keys, t, i, 'value'), (n.times = t), (n.values = i))
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const Ma = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e)
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n]
  },
  remove: function (n) {
    delete this.files[n]
  },
  clear: function () {
    this.files = {}
  },
}
class RL {
  constructor(e, t, i) {
    const r = this
    let s = !1,
      o = 0,
      a = 0,
      l
    const c = []
    ;((this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (u) {
        ;(a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), (s = !0))
      }),
      (this.itemEnd = function (u) {
        ;(o++,
          r.onProgress !== void 0 && r.onProgress(u, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad()))
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u)
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u
      }),
      (this.setURLModifier = function (u) {
        return ((l = u), this)
      }),
      (this.addHandler = function (u, d) {
        return (c.push(u, d), this)
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u)
        return (d !== -1 && c.splice(d, 2), this)
      }),
      (this.getHandler = function (u) {
        for (let d = 0, h = c.length; d < h; d += 2) {
          const f = c[d],
            p = c[d + 1]
          if ((f.global && (f.lastIndex = 0), f.test(u))) return p
        }
        return null
      }))
  }
}
const IL = new RL()
class Ou {
  constructor(e) {
    ;((this.manager = e !== void 0 ? e : IL),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {}))
  }
  load() {}
  loadAsync(e, t) {
    const i = this
    return new Promise(function (r, s) {
      i.load(e, r, t, s)
    })
  }
  parse() {}
  setCrossOrigin(e) {
    return ((this.crossOrigin = e), this)
  }
  setWithCredentials(e) {
    return ((this.withCredentials = e), this)
  }
  setPath(e) {
    return ((this.path = e), this)
  }
  setResourcePath(e) {
    return ((this.resourcePath = e), this)
  }
  setRequestHeader(e) {
    return ((this.requestHeader = e), this)
  }
}
Ou.DEFAULT_MATERIAL_NAME = '__DEFAULT'
const _o = {}
class NL extends Error {
  constructor(e, t) {
    ;(super(e), (this.response = t))
  }
}
class q5 extends Ou {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    ;(e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)))
    const s = Ma.get(e)
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          ;(t && t(s), this.manager.itemEnd(e))
        }, 0),
        s
      )
    if (_o[e] !== void 0) {
      _o[e].push({ onLoad: t, onProgress: i, onError: r })
      return
    }
    ;((_o[e] = []), _o[e].push({ onLoad: t, onProgress: i, onError: r }))
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin',
      }),
      a = this.mimeType,
      l = this.responseType
    ;(fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 && console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' || c.body === void 0 || c.body.getReader === void 0)
          )
            return c
          const u = _o[e],
            d = c.body.getReader(),
            h = c.headers.get('X-File-Size') || c.headers.get('Content-Length'),
            f = h ? parseInt(h) : 0,
            p = f !== 0
          let g = 0
          const y = new ReadableStream({
            start(m) {
              v()
              function v() {
                d.read().then(
                  ({ done: x, value: _ }) => {
                    if (x) m.close()
                    else {
                      g += _.byteLength
                      const S = new ProgressEvent('progress', {
                        lengthComputable: p,
                        loaded: g,
                        total: f,
                      })
                      for (let C = 0, A = u.length; C < A; C++) {
                        const R = u[C]
                        R.onProgress && R.onProgress(S)
                      }
                      ;(m.enqueue(_), v())
                    }
                  },
                  (x) => {
                    m.error(x)
                  }
                )
              }
            },
          })
          return new Response(y)
        } else
          throw new NL(
            'fetch for "'
              .concat(c.url, '" responded with ')
              .concat(c.status, ': ')
              .concat(c.statusText),
            c
          )
      })
      .then((c) => {
        switch (l) {
          case 'arraybuffer':
            return c.arrayBuffer()
          case 'blob':
            return c.blob()
          case 'document':
            return c.text().then((u) => new DOMParser().parseFromString(u, a))
          case 'json':
            return c.json()
          default:
            if (a === void 0) return c.text()
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                h = d && d[1] ? d[1].toLowerCase() : void 0,
                f = new TextDecoder(h)
              return c.arrayBuffer().then((p) => f.decode(p))
            }
        }
      })
      .then((c) => {
        Ma.add(e, c)
        const u = _o[e]
        delete _o[e]
        for (let d = 0, h = u.length; d < h; d++) {
          const f = u[d]
          f.onLoad && f.onLoad(c)
        }
      })
      .catch((c) => {
        const u = _o[e]
        if (u === void 0) throw (this.manager.itemError(e), c)
        delete _o[e]
        for (let d = 0, h = u.length; d < h; d++) {
          const f = u[d]
          f.onError && f.onError(c)
        }
        this.manager.itemError(e)
      })
      .finally(() => {
        this.manager.itemEnd(e)
      }),
      this.manager.itemStart(e))
  }
  setResponseType(e) {
    return ((this.responseType = e), this)
  }
  setMimeType(e) {
    return ((this.mimeType = e), this)
  }
}
class PL extends Ou {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    ;(this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e)))
    const s = this,
      o = Ma.get(e)
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          ;(t && t(o), s.manager.itemEnd(e))
        }, 0),
        o
      )
    const a = dh('img')
    function l() {
      ;(u(), Ma.add(e, this), t && t(this), s.manager.itemEnd(e))
    }
    function c(d) {
      ;(u(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e))
    }
    function u() {
      ;(a.removeEventListener('load', l, !1), a.removeEventListener('error', c, !1))
    }
    return (
      a.addEventListener('load', l, !1),
      a.addEventListener('error', c, !1),
      e.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    )
  }
}
class LL extends Ou {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = new Wn(),
      o = new PL(this.manager)
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          ;((s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s))
        },
        i,
        r
      ),
      s
    )
  }
}
class I_ extends sn {
  constructor(e, t = 1) {
    ;(super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new gt(e)),
      (this.intensity = t))
  }
  dispose() {}
  copy(e, t) {
    return (super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this)
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    )
  }
}
const Bg = new qe(),
  sA = new Y(),
  oA = new Y()
class N_ {
  constructor(e) {
    ;((this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new je(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new qe()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new C_()),
      (this._frameExtents = new je(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Mt(0, 0, 1, 1)]))
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix
    ;(sA.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(sA),
      oA.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(oA),
      t.updateMatrixWorld(),
      Bg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Bg),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(Bg))
  }
  getViewport(e) {
    return this._viewports[e]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    ;(this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose())
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const e = {}
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    )
  }
}
class DL extends N_ {
  constructor() {
    ;(super(new Ki(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1))
  }
  updateMatrices(e) {
    const t = this.camera,
      i = fu * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far
    ;((i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e))
  }
  copy(e) {
    return (super.copy(e), (this.focus = e.focus), this)
  }
}
class FL extends I_ {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    ;(super(e, t),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(sn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new sn()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new DL()))
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(e) {
    this.intensity = e / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
const aA = new qe(),
  cd = new Y(),
  Ug = new Y()
class OL extends N_ {
  constructor() {
    ;(super(new Ki(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new je(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Mt(2, 1, 1, 1),
        new Mt(0, 1, 1, 1),
        new Mt(3, 1, 1, 1),
        new Mt(1, 1, 1, 1),
        new Mt(3, 0, 1, 1),
        new Mt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Y(1, 0, 0),
        new Y(-1, 0, 0),
        new Y(0, 0, 1),
        new Y(0, 0, -1),
        new Y(0, 1, 0),
        new Y(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 1, 0),
        new Y(0, 0, 1),
        new Y(0, 0, -1),
      ]))
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far
    ;(s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      cd.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(cd),
      Ug.copy(i.position),
      Ug.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(Ug),
      i.updateMatrixWorld(),
      r.makeTranslation(-cd.x, -cd.y, -cd.z),
      aA.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(aA))
  }
}
class BL extends I_ {
  constructor(e, t, i = 0, r = 2) {
    ;(super(e, t),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new OL()))
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
class Bu extends z5 {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    ;(super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    )
  }
  setViewOffset(e, t, i, r, s, o) {
    ;(this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix())
  }
  clearViewOffset() {
    ;(this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix())
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;((s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height))
    }
    ;(this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert())
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    )
  }
}
class UL extends N_ {
  constructor() {
    ;(super(new Bu(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0))
  }
}
class kL extends I_ {
  constructor(e, t) {
    ;(super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(sn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new sn()),
      (this.shadow = new UL()))
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this)
  }
}
class kd {
  static decodeText(e) {
    if (
      (console.warn(
        'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.'
      ),
      typeof TextDecoder < 'u')
    )
      return new TextDecoder().decode(e)
    let t = ''
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i])
    try {
      return decodeURIComponent(escape(t))
    } catch (i) {
      return t
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf('/')
    return t === -1 ? './' : e.slice(0, t + 1)
  }
  static resolveURL(e, t) {
    return typeof e != 'string' || e === ''
      ? ''
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
  }
}
class zL extends ki {
  constructor() {
    ;(super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0))
  }
  copy(e) {
    return (super.copy(e), (this.instanceCount = e.instanceCount), this)
  }
  toJSON() {
    const e = super.toJSON()
    return ((e.instanceCount = this.instanceCount), (e.isInstancedBufferGeometry = !0), e)
  }
}
class VL extends Ou {
  constructor(e) {
    ;(super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
      typeof fetch > 'u' && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' }))
  }
  setOptions(e) {
    return ((this.options = e), this)
  }
  load(e, t, i, r) {
    ;(e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)))
    const s = this,
      o = Ma.get(e)
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((c) => {
          ;(t && t(c), s.manager.itemEnd(e))
        }).catch((c) => {
          r && r(c)
        })
        return
      }
      return (
        setTimeout(function () {
          ;(t && t(o), s.manager.itemEnd(e))
        }, 0),
        o
      )
    }
    const a = {}
    ;((a.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (a.headers = this.requestHeader))
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob()
      })
      .then(function (c) {
        return createImageBitmap(c, Object.assign(s.options, { colorSpaceConversion: 'none' }))
      })
      .then(function (c) {
        return (Ma.add(e, c), t && t(c), s.manager.itemEnd(e), c)
      })
      .catch(function (c) {
        ;(r && r(c), Ma.remove(e), s.manager.itemError(e), s.manager.itemEnd(e))
      })
    ;(Ma.add(e, l), s.manager.itemStart(e))
  }
}
class HL extends Ki {
  constructor(e = []) {
    ;(super(), (this.isArrayCamera = !0), (this.cameras = e), (this.index = 0))
  }
}
class $L {
  constructor(e = !0) {
    ;((this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1))
  }
  start() {
    ;((this.startTime = lA()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0))
  }
  stop() {
    ;(this.getElapsedTime(), (this.running = !1), (this.autoStart = !1))
  }
  getElapsedTime() {
    return (this.getDelta(), this.elapsedTime)
  }
  getDelta() {
    let e = 0
    if (this.autoStart && !this.running) return (this.start(), 0)
    if (this.running) {
      const t = lA()
      ;((e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e))
    }
    return e
  }
}
function lA() {
  return performance.now()
}
class GL {
  constructor(e, t, i) {
    ;((this.binding = e), (this.valueSize = i))
    let r, s, o
    switch (t) {
      case 'quaternion':
        ;((r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5))
        break
      case 'string':
      case 'bool':
        ;((r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5)))
        break
      default:
        ;((r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5)))
    }
    ;((this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0))
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r
    let o = this.cumulativeWeight
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a]
      o = t
    } else {
      o += t
      const a = t / o
      this._mixBufferRegion(i, s, 0, a, r)
    }
    this.cumulativeWeight = o
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex
    ;(this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e))
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding
    if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)) {
      const l = t * this._origIndex
      this._mixBufferRegion(i, r, l, 1 - s, t)
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t)
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r)
        break
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex
    e.getValue(t, r)
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)]
    ;(this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0))
  }
  restoreOriginalState() {
    const e = this.valueSize * 3
    this.binding.setValue(this.buffer, e)
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize
    for (let i = e; i < t; i++) this.buffer[i] = 0
  }
  _setAdditiveIdentityQuaternion() {
    ;(this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1))
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize
    for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o]
  }
  _slerp(e, t, i, r) {
    Qt.slerpFlat(e, t, e, t, e, i, r)
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s
    ;(Qt.multiplyQuaternionsFlat(e, o, e, t, e, i), Qt.slerpFlat(e, t, e, t, e, o, r))
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r
    for (let a = 0; a !== s; ++a) {
      const l = t + a
      e[l] = e[l] * o + e[i + a] * r
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o
      e[a] = e[a] + e[i + o] * r
    }
  }
}
const P_ = '\\[\\]\\.:\\/',
  WL = new RegExp('[' + P_ + ']', 'g'),
  L_ = '[^' + P_ + ']',
  QL = '[^' + P_.replace('\\.', '') + ']',
  jL = /((?:WC+[\/:])*)/.source.replace('WC', L_),
  qL = /(WCOD+)?/.source.replace('WCOD', QL),
  XL = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', L_),
  KL = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', L_),
  YL = new RegExp('^' + jL + qL + XL + KL + '$'),
  ZL = ['material', 'materials', 'bones', 'map']
class JL {
  constructor(e, t, i) {
    const r = i || nn.parseTrackName(t)
    ;((this._targetGroup = e), (this._bindings = e.subscribe_(t, r)))
  }
  getValue(e, t) {
    this.bind()
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i]
    r !== void 0 && r.getValue(e, t)
  }
  setValue(e, t) {
    const i = this._bindings
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t)
  }
  bind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
  }
  unbind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
  }
}
class nn {
  constructor(e, t, i) {
    ;((this.path = t),
      (this.parsedPath = i || nn.parseTrackName(t)),
      (this.node = nn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound))
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new nn.Composite(e, t, i) : new nn(e, t, i)
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, '_').replace(WL, '')
  }
  static parseTrackName(e) {
    const t = YL.exec(e)
    if (t === null) throw new Error('PropertyBinding: Cannot parse trackName: ' + e)
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf('.')
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1)
      ZL.indexOf(s) !== -1 && ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s))
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e)
    return i
  }
  static findNode(e, t) {
    if (t === void 0 || t === '' || t === '.' || t === -1 || t === e.name || t === e.uuid) return e
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t)
      if (i !== void 0) return i
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o]
            if (a.name === t || a.uuid === t) return a
            const l = i(a.children)
            if (l) return l
          }
          return null
        },
        r = i(e.children)
      if (r) return r
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName]
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t)
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t]
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ;((this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0))
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ;((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0))
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t]
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ;((this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0))
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ;((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0))
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t)
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    ;(this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0))
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    ;(this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0))
  }
  _getValue_unbound(e, t) {
    ;(this.bind(), this.getValue(e, t))
  }
  _setValue_unbound(e, t) {
    ;(this.bind(), this.setValue(e, t))
  }
  bind() {
    let e = this.node
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName
    let s = t.propertyIndex
    if (
      (e || ((e = nn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.')
      return
    }
    if (i) {
      let c = t.objectIndex
      switch (i) {
        case 'materials':
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            )
            return
          }
          if (!e.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this
            )
            return
          }
          e = e.material.materials
          break
        case 'bones':
          if (!e.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this
            )
            return
          }
          e = e.skeleton.bones
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u
              break
            }
          break
        case 'map':
          if ('map' in e) {
            e = e.map
            break
          }
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            )
            return
          }
          if (!e.material.map) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this
            )
            return
          }
          e = e.material.map
          break
        default:
          if (e[i] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this
            )
            return
          }
          e = e[i]
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            e
          )
          return
        }
        e = e[c]
      }
    }
    const o = e[r]
    if (o === void 0) {
      const c = t.nodeName
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          c +
          '.' +
          r +
          " but it wasn't found.",
        e
      )
      return
    }
    let a = this.Versioning.None
    ;((this.targetObject = e),
      e.isMaterial === !0
        ? (a = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate))
    let l = this.BindingType.Direct
    if (s !== void 0) {
      if (r === 'morphTargetInfluences') {
        if (!e.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this
          )
          return
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this
          )
          return
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
      }
      ;((l = this.BindingType.ArrayElement), (this.resolvedProperty = o), (this.propertyIndex = s))
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
          ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = r)
    ;((this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]))
  }
  unbind() {
    ;((this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound))
  }
}
nn.Composite = JL
nn.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }
nn.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }
nn.prototype.GetterByBindingType = [
  nn.prototype._getValue_direct,
  nn.prototype._getValue_array,
  nn.prototype._getValue_arrayElement,
  nn.prototype._getValue_toArray,
]
nn.prototype.SetterByBindingTypeAndVersioning = [
  [
    nn.prototype._setValue_direct,
    nn.prototype._setValue_direct_setNeedsUpdate,
    nn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    nn.prototype._setValue_array,
    nn.prototype._setValue_array_setNeedsUpdate,
    nn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    nn.prototype._setValue_arrayElement,
    nn.prototype._setValue_arrayElement_setNeedsUpdate,
    nn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    nn.prototype._setValue_fromArray,
    nn.prototype._setValue_fromArray_setNeedsUpdate,
    nn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class eD {
  constructor(e, t, i = null, r = t.blendMode) {
    ;((this._mixer = e), (this._clip = t), (this._localRoot = i), (this.blendMode = r))
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: Lc, endingEnd: Lc }
    for (let c = 0; c !== o; ++c) {
      const u = s[c].createInterpolant(null)
      ;((a[c] = u), (u.settings = l))
    }
    ;((this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = Vl),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0))
  }
  play() {
    return (this._mixer._activateAction(this), this)
  }
  stop() {
    return (this._mixer._deactivateAction(this), this.reset())
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(e) {
    return ((this._startTime = e), this)
  }
  setLoop(e, t) {
    return ((this.loop = e), (this.repetitions = t), this)
  }
  setEffectiveWeight(e) {
    return ((this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading())
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1)
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0)
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s
      ;(e.warp(1, o, t), this.warp(a, 1, t))
    }
    return this
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i)
  }
  stopFading() {
    const e = this._weightInterpolant
    return (
      e !== null && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(e) {
    return ((this.timeScale = this._clip.duration / e), this.stopWarping())
  }
  syncWith(e) {
    return ((this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping())
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e)
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale
    let a = this._timeScaleInterpolant
    a === null && ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a))
    const l = a.parameterPositions,
      c = a.sampleValues
    return ((l[0] = s), (l[1] = s + i), (c[0] = e / o), (c[1] = t / o), this)
  }
  stopWarping() {
    const e = this._timeScaleInterpolant
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e)
      return
    }
    const s = this._startTime
    if (s !== null) {
      const l = (e - s) * i
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l))
    }
    t *= this._updateTimeScale(e)
    const o = this._updateTime(t),
      a = this._updateWeight(e)
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings
      switch (this.blendMode) {
        case aP:
          for (let u = 0, d = l.length; u !== d; ++u) (l[u].evaluate(o), c[u].accumulateAdditive(a))
          break
        case A_:
        default:
          for (let u = 0, d = l.length; u !== d; ++u) (l[u].evaluate(o), c[u].accumulate(r, a))
      }
    }
  }
  _updateWeight(e) {
    let t = 0
    if (this.enabled) {
      t = this.weight
      const i = this._weightInterpolant
      if (i !== null) {
        const r = i.evaluate(e)[0]
        ;((t *= r),
          e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)))
      }
    }
    return ((this._effectiveWeight = t), t)
  }
  _updateTimeScale(e) {
    let t = 0
    if (!this.paused) {
      t = this.timeScale
      const i = this._timeScaleInterpolant
      if (i !== null) {
        const r = i.evaluate(e)[0]
        ;((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(), t === 0 ? (this.paused = !0) : (this.timeScale = t)))
      }
    }
    return ((this._effectiveTimeScale = t), t)
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop
    let r = this.time + e,
      s = this._loopCount
    const o = i === oP
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r
    if (i === Jr) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      e: {
        if (r >= t) r = t
        else if (r < 0) r = 0
        else {
          this.time = r
          break e
        }
        ;(this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({ type: 'finished', action: this, direction: e < 0 ? -1 : 1 }))
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t)
        ;((r -= t * a), (s += Math.abs(a)))
        const l = this.repetitions - s
        if (l <= 0)
          (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: e > 0 ? 1 : -1,
            }))
        else {
          if (l === 1) {
            const c = e < 0
            this._setEndings(c, !c, o)
          } else this._setEndings(!1, !1, o)
          ;((this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: a }))
        }
      } else this.time = r
      if (o && (s & 1) === 1) return t - r
    }
    return r
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings
    i
      ? ((r.endingStart = Dc), (r.endingEnd = Dc))
      : (e ? (r.endingStart = this.zeroSlopeAtStart ? Dc : Lc) : (r.endingStart = fm),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Dc : Lc) : (r.endingEnd = fm))
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time
    let o = this._weightInterpolant
    o === null && ((o = r._lendControlInterpolant()), (this._weightInterpolant = o))
    const a = o.parameterPositions,
      l = o.sampleValues
    return ((a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this)
  }
}
const tD = new Float32Array(1)
class nD extends so {
  constructor(e) {
    ;(super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1))
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      c = this._bindingsByRootAndName
    let u = c[l]
    u === void 0 && ((u = {}), (c[l] = u))
    for (let d = 0; d !== s; ++d) {
      const h = r[d],
        f = h.name
      let p = u[f]
      if (p !== void 0) (++p.referenceCount, (o[d] = p))
      else {
        if (((p = o[d]), p !== void 0)) {
          p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, l, f))
          continue
        }
        const g = t && t._propertyBindings[d].binding.parsedPath
        ;((p = new GL(nn.create(i, f, g), h.ValueTypeName, h.getValueSize())),
          ++p.referenceCount,
          this._addInactiveBinding(p, l, f),
          (o[d] = p))
      }
      a[d].resultBuffer = p.buffer
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r]
        ;(this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i))
      }
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
      }
      this._lendAction(e)
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s))
      }
      this._takeBackAction(e)
    }
  }
  _initMemoryManager() {
    ;((this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0))
    const e = this
    this.stats = {
      actions: {
        get total() {
          return e._actions.length
        },
        get inUse() {
          return e._nActiveActions
        },
      },
      bindings: {
        get total() {
          return e._bindings.length
        },
        get inUse() {
          return e._nActiveBindings
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length
        },
        get inUse() {
          return e._nActiveControlInterpolants
        },
      },
    }
  }
  _isActiveAction(e) {
    const t = e._cacheIndex
    return t !== null && t < this._nActiveActions
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip
    let o = s[t]
    if (o === void 0)
      ((o = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (s[t] = o))
    else {
      const a = o.knownActions
      ;((e._byClipCacheIndex = a.length), a.push(e))
    }
    ;((e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e))
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex
    ;((i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null))
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex
    ;((c._byClipCacheIndex = u), (l[u] = c), l.pop(), (e._byClipCacheIndex = null))
    const d = a.actionByRoot,
      h = (e._localRoot || this._root).uuid
    ;(delete d[h], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e))
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i]
      --s.referenceCount === 0 && this._removeInactiveBinding(s)
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r]
    ;((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s))
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r]
    ;((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s))
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings
    let o = r[t]
    ;(o === void 0 && ((o = {}), (r[t] = o)), (o[i] = e), (e._cacheIndex = s.length), s.push(e))
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      c = e._cacheIndex
    ;((l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r])
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r]
    ;((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s))
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r]
    ;((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s))
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++
    let i = e[t]
    return (
      i === void 0 &&
        ((i = new Q5(new Float32Array(2), new Float32Array(2), 1, tD)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    )
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r]
    ;((e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s))
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid
    let o = typeof e == 'string' ? zy.findByName(r, e) : e
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a]
    let c = null
    if ((i === void 0 && (o !== null ? (i = o.blendMode) : (i = A_)), l !== void 0)) {
      const d = l.actionByRoot[s]
      if (d !== void 0 && d.blendMode === i) return d
      ;((c = l.knownActions[0]), o === null && (o = c._clip))
    }
    if (o === null) return null
    const u = new eD(this, o, t, i)
    return (this._bindAction(u, c), this._addInactiveAction(u, a, s), u)
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == 'string' ? zy.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o]
    return (a !== void 0 && a.actionByRoot[r]) || null
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions
    for (let i = t - 1; i >= 0; --i) e[i].stop()
    return this
  }
  update(e) {
    e *= this.timeScale
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1)
    for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o)
    const a = this._bindings,
      l = this._nActiveBindings
    for (let c = 0; c !== l; ++c) a[c].apply(o)
    return this
  }
  setTime(e) {
    this.time = 0
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0
    return this.update(e)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i]
    if (s !== void 0) {
      const o = s.knownActions
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a]
        this._deactivateAction(c)
        const u = c._cacheIndex,
          d = t[t.length - 1]
        ;((c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (d._cacheIndex = u),
          (t[u] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(c))
      }
      delete r[i]
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t]
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
    }
    const r = this._bindingsByRootAndName,
      s = r[t]
    if (s !== void 0)
      for (const o in s) {
        const a = s[o]
        ;(a.restoreOriginalState(), this._removeInactiveBinding(a))
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t)
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
  }
}
class iD extends w_ {
  constructor(e, t, i = 1) {
    ;(super(e, t), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = i))
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this)
  }
  clone(e) {
    const t = super.clone(e)
    return ((t.meshPerAttribute = this.meshPerAttribute), t)
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return ((t.isInstancedInterleavedBuffer = !0), (t.meshPerAttribute = this.meshPerAttribute), t)
  }
}
class cA {
  constructor(e = 1, t = 0, i = 0) {
    return ((this.radius = e), (this.phi = t), (this.theta = i), this)
  }
  set(e, t, i) {
    return ((this.radius = e), (this.phi = t), (this.theta = i), this)
  }
  copy(e) {
    return ((this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this)
  }
  makeSafe() {
    return ((this.phi = Nt(this.phi, 1e-6, Math.PI - 1e-6)), this)
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)), (this.phi = Math.acos(Nt(t / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class D_ {
  constructor(e, t, i, r) {
    ;((D_.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r))
  }
  identity() {
    return (this.set(1, 0, 0, 1), this)
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++) this.elements[i] = e[i + t]
    return this
  }
  set(e, t, i, r) {
    const s = this.elements
    return ((s[0] = e), (s[2] = t), (s[1] = i), (s[3] = r), this)
  }
}
function uA(n, e, t, i) {
  const r = rD(i)
  switch (t) {
    case T5:
      return n * e
    case C5:
      return n * e
    case E5:
      return n * e * 2
    case x_:
      return ((n * e) / r.components) * r.byteLength
    case a0:
      return ((n * e) / r.components) * r.byteLength
    case lh:
      return ((n * e * 2) / r.components) * r.byteLength
    case S_:
      return ((n * e * 2) / r.components) * r.byteLength
    case w5:
      return ((n * e * 3) / r.components) * r.byteLength
    case Fi:
      return ((n * e * 4) / r.components) * r.byteLength
    case Co:
      return ((n * e * 4) / r.components) * r.byteLength
    case Mp:
    case Rp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case Ip:
    case Np:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case fy:
    case my:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4
    case hy:
    case py:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2
    case gy:
    case yy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8
    case vy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case _y:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16
    case xy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16
    case Sy:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16
    case Ay:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16
    case by:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16
    case Ty:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16
    case wy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16
    case Cy:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16
    case Ey:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16
    case My:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16
    case Ry:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16
    case Iy:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16
    case Ny:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16
    case Py:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16
    case Pp:
    case Ly:
    case Dy:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    case M5:
    case Fy:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8
    case Oy:
    case By:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
  }
  throw new Error('Unable to determine texture byte length for '.concat(t, ' format.'))
}
function rD(n) {
  switch (n) {
    case eo:
    case S5:
      return { byteLength: 1, components: 1 }
    case ah:
    case A5:
    case ws:
      return { byteLength: 2, components: 1 }
    case v_:
    case __:
      return { byteLength: 2, components: 4 }
    case Ni:
    case o0:
    case nr:
      return { byteLength: 4, components: 1 }
    case b5:
      return { byteLength: 4, components: 3 }
  }
  throw new Error('Unknown texture type '.concat(n, '.'))
}
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: g_ } }))
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = g_))
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function X5() {
  let n = null,
    e = !1,
    t = null,
    i = null
  function r(s, o) {
    ;(t(s, o), (i = n.requestAnimationFrame(r)))
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0))
    },
    stop: function () {
      ;(n.cancelAnimationFrame(i), (e = !1))
    },
    setAnimationLoop: function (s) {
      t = s
    },
    setContext: function (s) {
      n = s
    },
  }
}
function sD(n) {
  const e = new WeakMap()
  function t(a, l) {
    const c = a.array,
      u = a.usage,
      d = c.byteLength,
      h = n.createBuffer()
    ;(n.bindBuffer(l, h), n.bufferData(l, c, u), a.onUploadCallback())
    let f
    if (c instanceof Float32Array) f = n.FLOAT
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (f = n.HALF_FLOAT) : (f = n.UNSIGNED_SHORT)
    else if (c instanceof Int16Array) f = n.SHORT
    else if (c instanceof Uint32Array) f = n.UNSIGNED_INT
    else if (c instanceof Int32Array) f = n.INT
    else if (c instanceof Int8Array) f = n.BYTE
    else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE
    else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE
    else throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + c)
    return { buffer: h, type: f, bytesPerElement: c.BYTES_PER_ELEMENT, version: a.version, size: d }
  }
  function i(a, l, c) {
    const u = l.array,
      d = l.updateRanges
    if ((n.bindBuffer(c, a), d.length === 0)) n.bufferSubData(c, 0, u)
    else {
      d.sort((f, p) => f.start - p.start)
      let h = 0
      for (let f = 1; f < d.length; f++) {
        const p = d[h],
          g = d[f]
        g.start <= p.start + p.count + 1
          ? (p.count = Math.max(p.count, g.start + g.count - p.start))
          : (++h, (d[h] = g))
      }
      d.length = h + 1
      for (let f = 0, p = d.length; f < p; f++) {
        const g = d[f]
        n.bufferSubData(c, g.start * u.BYTES_PER_ELEMENT, u, g.start, g.count)
      }
      l.clearUpdateRanges()
    }
    l.onUploadCallback()
  }
  function r(a) {
    return (a.isInterleavedBufferAttribute && (a = a.data), e.get(a))
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data)
    const l = e.get(a)
    l && (n.deleteBuffer(l.buffer), e.delete(a))
  }
  function o(a, l) {
    if ((a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)) {
      const u = e.get(a)
      ;(!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        })
      return
    }
    const c = e.get(a)
    if (c === void 0) e.set(a, t(a, l))
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        )
      ;(i(c.buffer, a, l), (c.version = a.version))
    }
  }
  return { get: r, remove: s, update: o }
}
var oD =
    '#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif',
  aD =
    '#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif',
  lD = '#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif',
  cD = '#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif',
  uD =
    '#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif',
  dD = '#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif',
  hD =
    '#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif',
  fD = '#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif',
  pD =
    '#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif',
  mD =
    '#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif',
  gD =
    'vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif',
  yD =
    'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif',
  vD =
    'float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated',
  _D =
    '#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif',
  xD =
    '#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif',
  SD =
    '#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif',
  AD =
    '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
  bD = '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif',
  TD = '#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif',
  wD =
    '#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif',
  CD =
    '#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif',
  ED =
    '#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif',
  MD =
    '#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif',
  RD =
    '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated',
  ID =
    '#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif',
  ND =
    'vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif',
  PD =
    '#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif',
  LD =
    '#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif',
  DD =
    '#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
  FD = '#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif',
  OD = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  BD =
    'vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
  UD =
    '#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif',
  kD =
    '#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif',
  zD =
    '#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif',
  VD =
    '#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif',
  HD =
    '#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif',
  $D = '#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif',
  GD = '#ifdef USE_FOG\n	varying float vFogDepth;\n#endif',
  WD =
    '#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
  QD =
    '#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif',
  jD =
    '#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}',
  qD = '#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif',
  XD =
    'LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;',
  KD =
    'varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert',
  YD =
    'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif',
  ZD =
    '#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif',
  JD = 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
  eF =
    'varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon',
  tF =
    'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
  nF =
    'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong',
  iF =
    'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif',
  rF =
    'struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
  sF =
    '\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
  oF =
    '#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif',
  aF =
    '#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif',
  lF =
    '#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
  cF =
    '#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif',
  uF = '#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif',
  dF =
    '#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif',
  hF =
    '#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif',
  fF = '#ifdef USE_MAP\n	uniform sampler2D map;\n#endif',
  pF =
    '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
  mF =
    '#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif',
  gF =
    'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif',
  yF = '#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif',
  vF =
    '#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif',
  _F =
    '#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif',
  xF =
    '#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif',
  SF =
    '#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif',
  AF =
    '#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif',
  bF =
    'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;',
  TF =
    '#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
  wF =
    '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif',
  CF =
    '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif',
  EF =
    '#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif',
  MF =
    '#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif',
  RF = '#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif',
  IF =
    '#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif',
  NF =
    '#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif',
  PF =
    '#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif',
  LF =
    '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
  DF =
    'vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}',
  FF = '#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif',
  OF =
    'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
  BF = '#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
  UF =
    '#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif',
  kF =
    'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif',
  zF = '#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif',
  VF =
    '#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif',
  HF =
    '#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif',
  $F =
    '#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif',
  GF =
    'float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}',
  WF =
    '#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
  QF =
    '#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif',
  jF =
    '#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
  qF =
    '#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif',
  XF =
    'float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif',
  KF = '#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif',
  YF = '#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
  ZF =
    '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
  JF =
    '#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif',
  e7 =
    '#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif',
  t7 =
    '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif',
  n7 =
    '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif',
  i7 =
    '#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif',
  r7 =
    '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif'
const s7 =
    'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
  o7 =
    'uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
  a7 =
    'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}',
  l7 =
    '#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
  c7 =
    'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}',
  u7 =
    'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
  d7 =
    '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}',
  h7 =
    '#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}',
  f7 =
    '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}',
  p7 =
    '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}',
  m7 =
    'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}',
  g7 =
    'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
  y7 =
    'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}',
  v7 =
    'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}',
  _7 =
    '#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}',
  x7 =
    'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  S7 =
    '#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
  A7 =
    '#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  b7 =
    '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}',
  T7 =
    '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  w7 =
    '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}',
  C7 =
    '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}',
  E7 =
    '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
  M7 =
    '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  R7 =
    '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}',
  I7 =
    '#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  N7 =
    '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
  P7 =
    '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
  L7 =
    'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}',
  D7 =
    'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}',
  F7 =
    '#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
  O7 =
    'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}',
  B7 =
    'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}',
  U7 =
    'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}',
  It = {
    alphahash_fragment: oD,
    alphahash_pars_fragment: aD,
    alphamap_fragment: lD,
    alphamap_pars_fragment: cD,
    alphatest_fragment: uD,
    alphatest_pars_fragment: dD,
    aomap_fragment: hD,
    aomap_pars_fragment: fD,
    batching_pars_vertex: pD,
    batching_vertex: mD,
    begin_vertex: gD,
    beginnormal_vertex: yD,
    bsdfs: vD,
    iridescence_fragment: _D,
    bumpmap_pars_fragment: xD,
    clipping_planes_fragment: SD,
    clipping_planes_pars_fragment: AD,
    clipping_planes_pars_vertex: bD,
    clipping_planes_vertex: TD,
    color_fragment: wD,
    color_pars_fragment: CD,
    color_pars_vertex: ED,
    color_vertex: MD,
    common: RD,
    cube_uv_reflection_fragment: ID,
    defaultnormal_vertex: ND,
    displacementmap_pars_vertex: PD,
    displacementmap_vertex: LD,
    emissivemap_fragment: DD,
    emissivemap_pars_fragment: FD,
    colorspace_fragment: OD,
    colorspace_pars_fragment: BD,
    envmap_fragment: UD,
    envmap_common_pars_fragment: kD,
    envmap_pars_fragment: zD,
    envmap_pars_vertex: VD,
    envmap_physical_pars_fragment: ZD,
    envmap_vertex: HD,
    fog_vertex: $D,
    fog_pars_vertex: GD,
    fog_fragment: WD,
    fog_pars_fragment: QD,
    gradientmap_pars_fragment: jD,
    lightmap_pars_fragment: qD,
    lights_lambert_fragment: XD,
    lights_lambert_pars_fragment: KD,
    lights_pars_begin: YD,
    lights_toon_fragment: JD,
    lights_toon_pars_fragment: eF,
    lights_phong_fragment: tF,
    lights_phong_pars_fragment: nF,
    lights_physical_fragment: iF,
    lights_physical_pars_fragment: rF,
    lights_fragment_begin: sF,
    lights_fragment_maps: oF,
    lights_fragment_end: aF,
    logdepthbuf_fragment: lF,
    logdepthbuf_pars_fragment: cF,
    logdepthbuf_pars_vertex: uF,
    logdepthbuf_vertex: dF,
    map_fragment: hF,
    map_pars_fragment: fF,
    map_particle_fragment: pF,
    map_particle_pars_fragment: mF,
    metalnessmap_fragment: gF,
    metalnessmap_pars_fragment: yF,
    morphinstance_vertex: vF,
    morphcolor_vertex: _F,
    morphnormal_vertex: xF,
    morphtarget_pars_vertex: SF,
    morphtarget_vertex: AF,
    normal_fragment_begin: bF,
    normal_fragment_maps: TF,
    normal_pars_fragment: wF,
    normal_pars_vertex: CF,
    normal_vertex: EF,
    normalmap_pars_fragment: MF,
    clearcoat_normal_fragment_begin: RF,
    clearcoat_normal_fragment_maps: IF,
    clearcoat_pars_fragment: NF,
    iridescence_pars_fragment: PF,
    opaque_fragment: LF,
    packing: DF,
    premultiplied_alpha_fragment: FF,
    project_vertex: OF,
    dithering_fragment: BF,
    dithering_pars_fragment: UF,
    roughnessmap_fragment: kF,
    roughnessmap_pars_fragment: zF,
    shadowmap_pars_fragment: VF,
    shadowmap_pars_vertex: HF,
    shadowmap_vertex: $F,
    shadowmask_pars_fragment: GF,
    skinbase_vertex: WF,
    skinning_pars_vertex: QF,
    skinning_vertex: jF,
    skinnormal_vertex: qF,
    specularmap_fragment: XF,
    specularmap_pars_fragment: KF,
    tonemapping_fragment: YF,
    tonemapping_pars_fragment: ZF,
    transmission_fragment: JF,
    transmission_pars_fragment: e7,
    uv_pars_fragment: t7,
    uv_pars_vertex: n7,
    uv_vertex: i7,
    worldpos_vertex: r7,
    background_vert: s7,
    background_frag: o7,
    backgroundCube_vert: a7,
    backgroundCube_frag: l7,
    cube_vert: c7,
    cube_frag: u7,
    depth_vert: d7,
    depth_frag: h7,
    distanceRGBA_vert: f7,
    distanceRGBA_frag: p7,
    equirect_vert: m7,
    equirect_frag: g7,
    linedashed_vert: y7,
    linedashed_frag: v7,
    meshbasic_vert: _7,
    meshbasic_frag: x7,
    meshlambert_vert: S7,
    meshlambert_frag: A7,
    meshmatcap_vert: b7,
    meshmatcap_frag: T7,
    meshnormal_vert: w7,
    meshnormal_frag: C7,
    meshphong_vert: E7,
    meshphong_frag: M7,
    meshphysical_vert: R7,
    meshphysical_frag: I7,
    meshtoon_vert: N7,
    meshtoon_frag: P7,
    points_vert: L7,
    points_frag: D7,
    shadow_vert: F7,
    shadow_frag: O7,
    sprite_vert: B7,
    sprite_frag: U7,
  },
  tt = {
    common: {
      diffuse: { value: new gt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new pt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pt() },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null }, specularMapTransform: { value: new pt() } },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new pt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new pt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new pt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new pt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new pt() },
      normalScale: { value: new je(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new pt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new pt() } },
    metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new pt() } },
    roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new pt() } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new gt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: { direction: {}, color: {} } },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
      rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new gt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new pt() },
    },
    sprite: {
      diffuse: { value: new gt(16777215) },
      opacity: { value: 1 },
      center: { value: new je(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new pt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new pt() },
      alphaTest: { value: 0 },
    },
  },
  Vs = {
    basic: {
      uniforms: Wi([tt.common, tt.specularmap, tt.envmap, tt.aomap, tt.lightmap, tt.fog]),
      vertexShader: It.meshbasic_vert,
      fragmentShader: It.meshbasic_frag,
    },
    lambert: {
      uniforms: Wi([
        tt.common,
        tt.specularmap,
        tt.envmap,
        tt.aomap,
        tt.lightmap,
        tt.emissivemap,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        tt.fog,
        tt.lights,
        { emissive: { value: new gt(0) } },
      ]),
      vertexShader: It.meshlambert_vert,
      fragmentShader: It.meshlambert_frag,
    },
    phong: {
      uniforms: Wi([
        tt.common,
        tt.specularmap,
        tt.envmap,
        tt.aomap,
        tt.lightmap,
        tt.emissivemap,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        tt.fog,
        tt.lights,
        {
          emissive: { value: new gt(0) },
          specular: { value: new gt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: It.meshphong_vert,
      fragmentShader: It.meshphong_frag,
    },
    standard: {
      uniforms: Wi([
        tt.common,
        tt.envmap,
        tt.aomap,
        tt.lightmap,
        tt.emissivemap,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        tt.roughnessmap,
        tt.metalnessmap,
        tt.fog,
        tt.lights,
        {
          emissive: { value: new gt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: It.meshphysical_vert,
      fragmentShader: It.meshphysical_frag,
    },
    toon: {
      uniforms: Wi([
        tt.common,
        tt.aomap,
        tt.lightmap,
        tt.emissivemap,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        tt.gradientmap,
        tt.fog,
        tt.lights,
        { emissive: { value: new gt(0) } },
      ]),
      vertexShader: It.meshtoon_vert,
      fragmentShader: It.meshtoon_frag,
    },
    matcap: {
      uniforms: Wi([
        tt.common,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        tt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: It.meshmatcap_vert,
      fragmentShader: It.meshmatcap_frag,
    },
    points: {
      uniforms: Wi([tt.points, tt.fog]),
      vertexShader: It.points_vert,
      fragmentShader: It.points_frag,
    },
    dashed: {
      uniforms: Wi([
        tt.common,
        tt.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
      ]),
      vertexShader: It.linedashed_vert,
      fragmentShader: It.linedashed_frag,
    },
    depth: {
      uniforms: Wi([tt.common, tt.displacementmap]),
      vertexShader: It.depth_vert,
      fragmentShader: It.depth_frag,
    },
    normal: {
      uniforms: Wi([
        tt.common,
        tt.bumpmap,
        tt.normalmap,
        tt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: It.meshnormal_vert,
      fragmentShader: It.meshnormal_frag,
    },
    sprite: {
      uniforms: Wi([tt.sprite, tt.fog]),
      vertexShader: It.sprite_vert,
      fragmentShader: It.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new pt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: It.background_vert,
      fragmentShader: It.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new pt() },
      },
      vertexShader: It.backgroundCube_vert,
      fragmentShader: It.backgroundCube_frag,
    },
    cube: {
      uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
      vertexShader: It.cube_vert,
      fragmentShader: It.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: It.equirect_vert,
      fragmentShader: It.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Wi([
        tt.common,
        tt.displacementmap,
        {
          referencePosition: { value: new Y() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: It.distanceRGBA_vert,
      fragmentShader: It.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Wi([tt.lights, tt.fog, { color: { value: new gt(0) }, opacity: { value: 1 } }]),
      vertexShader: It.shadow_vert,
      fragmentShader: It.shadow_frag,
    },
  }
Vs.physical = {
  uniforms: Wi([
    Vs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new pt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new pt() },
      clearcoatNormalScale: { value: new je(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new pt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new pt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new pt() },
      sheen: { value: 0 },
      sheenColor: { value: new gt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new pt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new pt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new pt() },
      transmissionSamplerSize: { value: new je() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new pt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new gt(0) },
      specularColor: { value: new gt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new pt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new pt() },
      anisotropyVector: { value: new je() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new pt() },
    },
  ]),
  vertexShader: It.meshphysical_vert,
  fragmentShader: It.meshphysical_frag,
}
const Gf = { r: 0, b: 0, g: 0 },
  rl = new Cs(),
  k7 = new qe()
function z7(n, e, t, i, r, s, o) {
  const a = new gt(0)
  let l = s === !0 ? 0 : 1,
    c,
    u,
    d = null,
    h = 0,
    f = null
  function p(x) {
    let _ = x.isScene === !0 ? x.background : null
    return (_ && _.isTexture && (_ = (x.backgroundBlurriness > 0 ? t : e).get(_)), _)
  }
  function g(x) {
    let _ = !1
    const S = p(x)
    S === null ? m(a, l) : S && S.isColor && (m(S, 1), (_ = !0))
    const C = n.xr.getEnvironmentBlendMode()
    ;(C === 'additive'
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : C === 'alpha-blend' && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || _) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil)))
  }
  function y(x, _) {
    const S = p(_)
    S && (S.isCubeTexture || S.mapping === s0)
      ? (u === void 0 &&
          ((u = new pn(
            new Lu(1, 1, 1),
            new Nr({
              name: 'BackgroundCubeMaterial',
              uniforms: pu(Vs.backgroundCube.uniforms),
              vertexShader: Vs.backgroundCube.vertexShader,
              fragmentShader: Vs.backgroundCube.fragmentShader,
              side: Oi,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          u.geometry.deleteAttribute('normal'),
          u.geometry.deleteAttribute('uv'),
          (u.onBeforeRender = function (C, A, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
          }),
          Object.defineProperty(u.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value
            },
          }),
          r.update(u)),
        rl.copy(_.backgroundRotation),
        (rl.x *= -1),
        (rl.y *= -1),
        (rl.z *= -1),
        S.isCubeTexture && S.isRenderTargetTexture === !1 && ((rl.y *= -1), (rl.z *= -1)),
        (u.material.uniforms.envMap.value = S),
        (u.material.uniforms.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(k7.makeRotationFromEuler(rl)),
        (u.material.toneMapped = Tt.getTransfer(S.colorSpace) !== Jt),
        (d !== S || h !== S.version || f !== n.toneMapping) &&
          ((u.material.needsUpdate = !0), (d = S), (h = S.version), (f = n.toneMapping)),
        u.layers.enableAll(),
        x.unshift(u, u.geometry, u.material, 0, 0, null))
      : S &&
        S.isTexture &&
        (c === void 0 &&
          ((c = new pn(
            new mu(2, 2),
            new Nr({
              name: 'BackgroundMaterial',
              uniforms: pu(Vs.background.uniforms),
              vertexShader: Vs.background.vertexShader,
              fragmentShader: Vs.background.fragmentShader,
              side: Ts,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute('normal'),
          Object.defineProperty(c.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value
            },
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = S),
        (c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
        (c.material.toneMapped = Tt.getTransfer(S.colorSpace) !== Jt),
        S.matrixAutoUpdate === !0 && S.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(S.matrix),
        (d !== S || h !== S.version || f !== n.toneMapping) &&
          ((c.material.needsUpdate = !0), (d = S), (h = S.version), (f = n.toneMapping)),
        c.layers.enableAll(),
        x.unshift(c, c.geometry, c.material, 0, 0, null))
  }
  function m(x, _) {
    ;(x.getRGB(Gf, k5(n)), i.buffers.color.setClear(Gf.r, Gf.g, Gf.b, _, o))
  }
  function v() {
    ;(u !== void 0 && (u.geometry.dispose(), u.material.dispose(), (u = void 0)),
      c !== void 0 && (c.geometry.dispose(), c.material.dispose(), (c = void 0)))
  }
  return {
    getClearColor: function () {
      return a
    },
    setClearColor: function (x, _ = 1) {
      ;(a.set(x), (l = _), m(a, l))
    },
    getClearAlpha: function () {
      return l
    },
    setClearAlpha: function (x) {
      ;((l = x), m(a, l))
    },
    render: g,
    addToRenderList: y,
    dispose: v,
  }
}
function V7(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    i = {},
    r = h(null)
  let s = r,
    o = !1
  function a(M, I, L, U, T) {
    let F = !1
    const V = d(U, L, I)
    ;(s !== V && ((s = V), c(s.object)),
      (F = f(M, U, L, T)),
      F && p(M, U, L, T),
      T !== null && e.update(T, n.ELEMENT_ARRAY_BUFFER),
      (F || o) &&
        ((o = !1),
        _(M, I, L, U),
        T !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(T).buffer)))
  }
  function l() {
    return n.createVertexArray()
  }
  function c(M) {
    return n.bindVertexArray(M)
  }
  function u(M) {
    return n.deleteVertexArray(M)
  }
  function d(M, I, L) {
    const U = L.wireframe === !0
    let T = i[M.id]
    T === void 0 && ((T = {}), (i[M.id] = T))
    let F = T[I.id]
    F === void 0 && ((F = {}), (T[I.id] = F))
    let V = F[U]
    return (V === void 0 && ((V = h(l())), (F[U] = V)), V)
  }
  function h(M) {
    const I = [],
      L = [],
      U = []
    for (let T = 0; T < t; T++) ((I[T] = 0), (L[T] = 0), (U[T] = 0))
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: I,
      enabledAttributes: L,
      attributeDivisors: U,
      object: M,
      attributes: {},
      index: null,
    }
  }
  function f(M, I, L, U) {
    const T = s.attributes,
      F = I.attributes
    let V = 0
    const W = L.getAttributes()
    for (const ee in W)
      if (W[ee].location >= 0) {
        const he = T[ee]
        let ne = F[ee]
        if (
          (ne === void 0 &&
            (ee === 'instanceMatrix' && M.instanceMatrix && (ne = M.instanceMatrix),
            ee === 'instanceColor' && M.instanceColor && (ne = M.instanceColor)),
          he === void 0 || he.attribute !== ne || (ne && he.data !== ne.data))
        )
          return !0
        V++
      }
    return s.attributesNum !== V || s.index !== U
  }
  function p(M, I, L, U) {
    const T = {},
      F = I.attributes
    let V = 0
    const W = L.getAttributes()
    for (const ee in W)
      if (W[ee].location >= 0) {
        let he = F[ee]
        he === void 0 &&
          (ee === 'instanceMatrix' && M.instanceMatrix && (he = M.instanceMatrix),
          ee === 'instanceColor' && M.instanceColor && (he = M.instanceColor))
        const ne = {}
        ;((ne.attribute = he), he && he.data && (ne.data = he.data), (T[ee] = ne), V++)
      }
    ;((s.attributes = T), (s.attributesNum = V), (s.index = U))
  }
  function g() {
    const M = s.newAttributes
    for (let I = 0, L = M.length; I < L; I++) M[I] = 0
  }
  function y(M) {
    m(M, 0)
  }
  function m(M, I) {
    const L = s.newAttributes,
      U = s.enabledAttributes,
      T = s.attributeDivisors
    ;((L[M] = 1),
      U[M] === 0 && (n.enableVertexAttribArray(M), (U[M] = 1)),
      T[M] !== I && (n.vertexAttribDivisor(M, I), (T[M] = I)))
  }
  function v() {
    const M = s.newAttributes,
      I = s.enabledAttributes
    for (let L = 0, U = I.length; L < U; L++)
      I[L] !== M[L] && (n.disableVertexAttribArray(L), (I[L] = 0))
  }
  function x(M, I, L, U, T, F, V) {
    V === !0 ? n.vertexAttribIPointer(M, I, L, T, F) : n.vertexAttribPointer(M, I, L, U, T, F)
  }
  function _(M, I, L, U) {
    g()
    const T = U.attributes,
      F = L.getAttributes(),
      V = I.defaultAttributeValues
    for (const W in F) {
      const ee = F[W]
      if (ee.location >= 0) {
        let se = T[W]
        if (
          (se === void 0 &&
            (W === 'instanceMatrix' && M.instanceMatrix && (se = M.instanceMatrix),
            W === 'instanceColor' && M.instanceColor && (se = M.instanceColor)),
          se !== void 0)
        ) {
          const he = se.normalized,
            ne = se.itemSize,
            ie = e.get(se)
          if (ie === void 0) continue
          const be = ie.buffer,
            le = ie.type,
            fe = ie.bytesPerElement,
            we = le === n.INT || le === n.UNSIGNED_INT || se.gpuType === o0
          if (se.isInterleavedBufferAttribute) {
            const Ee = se.data,
              Ie = Ee.stride,
              ze = se.offset
            if (Ee.isInstancedInterleavedBuffer) {
              for (let Be = 0; Be < ee.locationSize; Be++) m(ee.location + Be, Ee.meshPerAttribute)
              M.isInstancedMesh !== !0 &&
                U._maxInstanceCount === void 0 &&
                (U._maxInstanceCount = Ee.meshPerAttribute * Ee.count)
            } else for (let Be = 0; Be < ee.locationSize; Be++) y(ee.location + Be)
            n.bindBuffer(n.ARRAY_BUFFER, be)
            for (let Be = 0; Be < ee.locationSize; Be++)
              x(
                ee.location + Be,
                ne / ee.locationSize,
                le,
                he,
                Ie * fe,
                (ze + (ne / ee.locationSize) * Be) * fe,
                we
              )
          } else {
            if (se.isInstancedBufferAttribute) {
              for (let Ee = 0; Ee < ee.locationSize; Ee++) m(ee.location + Ee, se.meshPerAttribute)
              M.isInstancedMesh !== !0 &&
                U._maxInstanceCount === void 0 &&
                (U._maxInstanceCount = se.meshPerAttribute * se.count)
            } else for (let Ee = 0; Ee < ee.locationSize; Ee++) y(ee.location + Ee)
            n.bindBuffer(n.ARRAY_BUFFER, be)
            for (let Ee = 0; Ee < ee.locationSize; Ee++)
              x(
                ee.location + Ee,
                ne / ee.locationSize,
                le,
                he,
                ne * fe,
                (ne / ee.locationSize) * Ee * fe,
                we
              )
          }
        } else if (V !== void 0) {
          const he = V[W]
          if (he !== void 0)
            switch (he.length) {
              case 2:
                n.vertexAttrib2fv(ee.location, he)
                break
              case 3:
                n.vertexAttrib3fv(ee.location, he)
                break
              case 4:
                n.vertexAttrib4fv(ee.location, he)
                break
              default:
                n.vertexAttrib1fv(ee.location, he)
            }
        }
      }
    }
    v()
  }
  function S() {
    R()
    for (const M in i) {
      const I = i[M]
      for (const L in I) {
        const U = I[L]
        for (const T in U) (u(U[T].object), delete U[T])
        delete I[L]
      }
      delete i[M]
    }
  }
  function C(M) {
    if (i[M.id] === void 0) return
    const I = i[M.id]
    for (const L in I) {
      const U = I[L]
      for (const T in U) (u(U[T].object), delete U[T])
      delete I[L]
    }
    delete i[M.id]
  }
  function A(M) {
    for (const I in i) {
      const L = i[I]
      if (L[M.id] === void 0) continue
      const U = L[M.id]
      for (const T in U) (u(U[T].object), delete U[T])
      delete L[M.id]
    }
  }
  function R() {
    ;(w(), (o = !0), s !== r && ((s = r), c(s.object)))
  }
  function w() {
    ;((r.geometry = null), (r.program = null), (r.wireframe = !1))
  }
  return {
    setup: a,
    reset: R,
    resetDefaultState: w,
    dispose: S,
    releaseStatesOfGeometry: C,
    releaseStatesOfProgram: A,
    initAttributes: g,
    enableAttribute: y,
    disableUnusedAttributes: v,
  }
}
function H7(n, e, t) {
  let i
  function r(c) {
    i = c
  }
  function s(c, u) {
    ;(n.drawArrays(i, c, u), t.update(u, i, 1))
  }
  function o(c, u, d) {
    d !== 0 && (n.drawArraysInstanced(i, c, u, d), t.update(u, i, d))
  }
  function a(c, u, d) {
    if (d === 0) return
    e.get('WEBGL_multi_draw').multiDrawArraysWEBGL(i, c, 0, u, 0, d)
    let f = 0
    for (let p = 0; p < d; p++) f += u[p]
    t.update(f, i, 1)
  }
  function l(c, u, d, h) {
    if (d === 0) return
    const f = e.get('WEBGL_multi_draw')
    if (f === null) for (let p = 0; p < c.length; p++) o(c[p], u[p], h[p])
    else {
      f.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, h, 0, d)
      let p = 0
      for (let g = 0; g < d; g++) p += u[g] * h[g]
      t.update(p, i, 1)
    }
  }
  ;((this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l))
}
function $7(n, e, t, i) {
  let r
  function s() {
    if (r !== void 0) return r
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const A = e.get('EXT_texture_filter_anisotropic')
      r = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else r = 0
    return r
  }
  function o(A) {
    return !(A !== Fi && i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
  }
  function a(A) {
    const R = A === ws && (e.has('EXT_color_buffer_half_float') || e.has('EXT_color_buffer_float'))
    return !(
      A !== eo &&
      i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      A !== nr &&
      !R
    )
  }
  function l(A) {
    if (A === 'highp') {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0
      )
        return 'highp'
      A = 'mediump'
    }
    return A === 'mediump' &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0
      ? 'mediump'
      : 'lowp'
  }
  let c = t.precision !== void 0 ? t.precision : 'highp'
  const u = l(c)
  u !== c &&
    (console.warn('THREE.WebGLRenderer:', c, 'not supported, using', u, 'instead.'), (c = u))
  const d = t.logarithmicDepthBuffer === !0,
    h = t.reverseDepthBuffer === !0 && e.has('EXT_clip_control'),
    f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    g = n.getParameter(n.MAX_TEXTURE_SIZE),
    y = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    m = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    v = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    x = n.getParameter(n.MAX_VARYING_VECTORS),
    _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    S = p > 0,
    C = n.getParameter(n.MAX_SAMPLES)
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: h,
    maxTextures: f,
    maxVertexTextures: p,
    maxTextureSize: g,
    maxCubemapSize: y,
    maxAttributes: m,
    maxVertexUniforms: v,
    maxVaryings: x,
    maxFragmentUniforms: _,
    vertexTextures: S,
    maxSamples: C,
  }
}
function G7(n) {
  const e = this
  let t = null,
    i = 0,
    r = !1,
    s = !1
  const o = new Eo(),
    a = new pt(),
    l = { value: null, needsUpdate: !1 }
  ;((this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, h) {
      const f = d.length !== 0 || h || i !== 0 || r
      return ((r = h), (i = d.length), f)
    }),
    (this.beginShadows = function () {
      ;((s = !0), u(null))
    }),
    (this.endShadows = function () {
      s = !1
    }),
    (this.setGlobalState = function (d, h) {
      t = u(d, h, 0)
    }),
    (this.setState = function (d, h, f) {
      const p = d.clippingPlanes,
        g = d.clipIntersection,
        y = d.clipShadows,
        m = n.get(d)
      if (!r || p === null || p.length === 0 || (s && !y)) s ? u(null) : c()
      else {
        const v = s ? 0 : i,
          x = v * 4
        let _ = m.clippingState || null
        ;((l.value = _), (_ = u(p, h, x, f)))
        for (let S = 0; S !== x; ++S) _[S] = t[S]
        ;((m.clippingState = _),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += v))
      }
    }))
  function c() {
    ;(l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0))
  }
  function u(d, h, f, p) {
    const g = d !== null ? d.length : 0
    let y = null
    if (g !== 0) {
      if (((y = l.value), p !== !0 || y === null)) {
        const m = f + g * 4,
          v = h.matrixWorldInverse
        ;(a.getNormalMatrix(v), (y === null || y.length < m) && (y = new Float32Array(m)))
        for (let x = 0, _ = f; x !== g; ++x, _ += 4)
          (o.copy(d[x]).applyMatrix4(v, a), o.normal.toArray(y, _), (y[_ + 3] = o.constant))
      }
      ;((l.value = y), (l.needsUpdate = !0))
    }
    return ((e.numPlanes = g), (e.numIntersection = 0), y)
  }
}
function W7(n) {
  let e = new WeakMap()
  function t(o, a) {
    return (a === uy ? (o.mapping = kl) : a === dy && (o.mapping = zl), o)
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping
      if (a === uy || a === dy)
        if (e.has(o)) {
          const l = e.get(o).texture
          return t(l, o.mapping)
        } else {
          const l = o.image
          if (l && l.height > 0) {
            const c = new aL(l.height)
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener('dispose', r),
              t(c.texture, o.mapping)
            )
          } else return null
        }
    }
    return o
  }
  function r(o) {
    const a = o.target
    a.removeEventListener('dispose', r)
    const l = e.get(a)
    l !== void 0 && (e.delete(a), l.dispose())
  }
  function s() {
    e = new WeakMap()
  }
  return { get: i, dispose: s }
}
const Fc = 4,
  dA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  yl = 20,
  kg = new Bu(),
  hA = new gt()
let zg = null,
  Vg = 0,
  Hg = 0,
  $g = !1
const ml = (1 + Math.sqrt(5)) / 2,
  yc = 1 / ml,
  fA = [
    new Y(-ml, yc, 0),
    new Y(ml, yc, 0),
    new Y(-yc, 0, ml),
    new Y(yc, 0, ml),
    new Y(0, ml, -yc),
    new Y(0, ml, yc),
    new Y(-1, 1, -1),
    new Y(1, 1, -1),
    new Y(-1, 1, 1),
    new Y(1, 1, 1),
  ]
let pA = class {
  constructor(e) {
    ;((this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial))
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    ;((zg = this._renderer.getRenderTarget()),
      (Vg = this._renderer.getActiveCubeFace()),
      (Hg = this._renderer.getActiveMipmapLevel()),
      ($g = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256))
    const s = this._allocateTargets()
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    )
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t)
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t)
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = yA()), this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = gA()), this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    ;(this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose())
  }
  _setSize(e) {
    ;((this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax)))
  }
  _dispose() {
    ;(this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose())
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
  }
  _cleanup(e) {
    ;(this._renderer.setRenderTarget(zg, Vg, Hg),
      (this._renderer.xr.enabled = $g),
      (e.scissorTest = !1),
      Wf(e, 0, 0, e.width, e.height))
  }
  _fromTexture(e, t) {
    ;(e.mapping === kl || e.mapping === zl
      ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width)
      : this._setSize(e.image.width / 4),
      (zg = this._renderer.getRenderTarget()),
      (Vg = this._renderer.getActiveCubeFace()),
      (Hg = this._renderer.getActiveMipmapLevel()),
      ($g = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1))
    const i = t || this._allocateTargets()
    return (this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i)
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Rr,
        minFilter: Rr,
        generateMipmaps: !1,
        type: ws,
        format: Fi,
        colorSpace: Ui,
        depthBuffer: !1,
      },
      r = mA(e, t, i)
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      ;(this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = mA(e, t, i)))
      const { _lodMax: s } = this
      ;(({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Q7(s)),
        (this._blurMaterial = j7(s, e, t)))
    }
    return r
  }
  _compileMaterial(e) {
    const t = new pn(this._lodPlanes[0], e)
    this._renderer.compile(t, kg)
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new Ki(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      h = u.toneMapping
    ;(u.getClearColor(hA), (u.toneMapping = _s), (u.autoClear = !1))
    const f = new Yr({ name: 'PMREM.Background', side: Oi, depthWrite: !1, depthTest: !1 }),
      p = new pn(new Lu(), f)
    let g = !1
    const y = e.background
    y
      ? y.isColor && (f.color.copy(y), (e.background = null), (g = !0))
      : (f.color.copy(hA), (g = !0))
    for (let m = 0; m < 6; m++) {
      const v = m % 3
      v === 0
        ? (a.up.set(0, l[m], 0), a.lookAt(c[m], 0, 0))
        : v === 1
          ? (a.up.set(0, 0, l[m]), a.lookAt(0, c[m], 0))
          : (a.up.set(0, l[m], 0), a.lookAt(0, 0, c[m]))
      const x = this._cubeSize
      ;(Wf(r, v * x, m > 2 ? x : 0, x, x),
        u.setRenderTarget(r),
        g && u.render(p, a),
        u.render(e, a))
    }
    ;(p.geometry.dispose(),
      p.material.dispose(),
      (u.toneMapping = h),
      (u.autoClear = d),
      (e.background = y))
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === kl || e.mapping === zl
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = yA()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = gA())
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new pn(this._lodPlanes[0], s),
      a = s.uniforms
    a.envMap.value = e
    const l = this._cubeSize
    ;(Wf(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, kg))
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear
    t.autoClear = !1
    const r = this._lodPlanes.length
    for (let s = 1; s < r; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        a = fA[(r - s - 1) % fA.length]
      this._blur(e, s - 1, s, o, a)
    }
    t.autoClear = i
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget
    ;(this._halfBlur(e, o, t, i, r, 'latitudinal', s),
      this._halfBlur(o, e, i, i, r, 'longitudinal', s))
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial
    o !== 'latitudinal' &&
      o !== 'longitudinal' &&
      console.error('blur direction must be either latitudinal or longitudinal!')
    const u = 3,
      d = new pn(this._lodPlanes[r], c),
      h = c.uniforms,
      f = this._sizeLods[i] - 1,
      p = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * yl - 1),
      g = s / p,
      y = isFinite(s) ? 1 + Math.floor(u * g) : yl
    y > yl &&
      console.warn(
        'sigmaRadians, '
          .concat(s, ', is too large and will clip, as it requested ')
          .concat(y, ' samples when the maximum is set to ')
          .concat(yl)
      )
    const m = []
    let v = 0
    for (let A = 0; A < yl; ++A) {
      const R = A / g,
        w = Math.exp((-R * R) / 2)
      ;(m.push(w), A === 0 ? (v += w) : A < y && (v += 2 * w))
    }
    for (let A = 0; A < m.length; A++) m[A] = m[A] / v
    ;((h.envMap.value = e.texture),
      (h.samples.value = y),
      (h.weights.value = m),
      (h.latitudinal.value = o === 'latitudinal'),
      a && (h.poleAxis.value = a))
    const { _lodMax: x } = this
    ;((h.dTheta.value = p), (h.mipInt.value = x - i))
    const _ = this._sizeLods[r],
      S = 3 * _ * (r > x - Fc ? r - x + Fc : 0),
      C = 4 * (this._cubeSize - _)
    ;(Wf(t, S, C, 3 * _, 2 * _), l.setRenderTarget(t), l.render(d, kg))
  }
}
function Q7(n) {
  const e = [],
    t = [],
    i = []
  let r = n
  const s = n - Fc + 1 + dA.length
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r)
    t.push(a)
    let l = 1 / a
    ;(o > n - Fc ? (l = dA[o - n + Fc - 1]) : o === 0 && (l = 0), i.push(l))
    const c = 1 / (a - 2),
      u = -c,
      d = 1 + c,
      h = [u, u, d, u, d, d, u, u, d, d, u, d],
      f = 6,
      p = 6,
      g = 3,
      y = 2,
      m = 1,
      v = new Float32Array(g * p * f),
      x = new Float32Array(y * p * f),
      _ = new Float32Array(m * p * f)
    for (let C = 0; C < f; C++) {
      const A = ((C % 3) * 2) / 3 - 1,
        R = C > 2 ? 0 : -1,
        w = [
          A,
          R,
          0,
          A + 2 / 3,
          R,
          0,
          A + 2 / 3,
          R + 1,
          0,
          A,
          R,
          0,
          A + 2 / 3,
          R + 1,
          0,
          A,
          R + 1,
          0,
        ]
      ;(v.set(w, g * p * C), x.set(h, y * p * C))
      const M = [C, C, C, C, C, C]
      _.set(M, m * p * C)
    }
    const S = new ki()
    ;(S.setAttribute('position', new _i(v, g)),
      S.setAttribute('uv', new _i(x, y)),
      S.setAttribute('faceIndex', new _i(_, m)),
      e.push(S),
      r > Fc && r--)
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i }
}
function mA(n, e, t) {
  const i = new Ua(n, e, t)
  return ((i.texture.mapping = s0), (i.texture.name = 'PMREM.cubeUv'), (i.scissorTest = !0), i)
}
function Wf(n, e, t, i, r) {
  ;(n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r))
}
function j7(n, e, t) {
  const i = new Float32Array(yl),
    r = new Y(0, 1, 0)
  return new Nr({
    name: 'SphericalGaussianBlur',
    defines: {
      n: yl,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: ''.concat(n, '.0'),
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: F_(),
    fragmentShader:
      "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		",
    blending: La,
    depthTest: !1,
    depthWrite: !1,
  })
}
function gA() {
  return new Nr({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: F_(),
    fragmentShader:
      '\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		',
    blending: La,
    depthTest: !1,
    depthWrite: !1,
  })
}
function yA() {
  return new Nr({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: F_(),
    fragmentShader:
      '\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		',
    blending: La,
    depthTest: !1,
    depthWrite: !1,
  })
}
function F_() {
  return '\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	'
}
function q7(n) {
  let e = new WeakMap(),
    t = null
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === uy || l === dy,
        u = l === kl || l === zl
      if (c || u) {
        let d = e.get(a)
        const h = d !== void 0 ? d.texture.pmremVersion : 0
        if (a.isRenderTargetTexture && a.pmremVersion !== h)
          return (
            t === null && (t = new pA(n)),
            (d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            (d.texture.pmremVersion = a.pmremVersion),
            e.set(a, d),
            d.texture
          )
        if (d !== void 0) return d.texture
        {
          const f = a.image
          return (c && f && f.height > 0) || (u && f && r(f))
            ? (t === null && (t = new pA(n)),
              (d = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (d.texture.pmremVersion = a.pmremVersion),
              e.set(a, d),
              a.addEventListener('dispose', s),
              d.texture)
            : null
        }
      }
    }
    return a
  }
  function r(a) {
    let l = 0
    const c = 6
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++
    return l === c
  }
  function s(a) {
    const l = a.target
    l.removeEventListener('dispose', s)
    const c = e.get(l)
    c !== void 0 && (e.delete(l), c.dispose())
  }
  function o() {
    ;((e = new WeakMap()), t !== null && (t.dispose(), (t = null)))
  }
  return { get: i, dispose: o }
}
function X7(n) {
  const e = {}
  function t(i) {
    if (e[i] !== void 0) return e[i]
    let r
    switch (i) {
      case 'WEBGL_depth_texture':
        r =
          n.getExtension('WEBGL_depth_texture') ||
          n.getExtension('MOZ_WEBGL_depth_texture') ||
          n.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        r =
          n.getExtension('EXT_texture_filter_anisotropic') ||
          n.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          n.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        r =
          n.getExtension('WEBGL_compressed_texture_s3tc') ||
          n.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        r =
          n.getExtension('WEBGL_compressed_texture_pvrtc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        r = n.getExtension(i)
    }
    return ((e[i] = r), r)
  }
  return {
    has: function (i) {
      return t(i) !== null
    },
    init: function () {
      ;(t('EXT_color_buffer_float'),
        t('WEBGL_clip_cull_distance'),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture'),
        t('WEBGL_render_shared_exponent'))
    },
    get: function (i) {
      const r = t(i)
      return (r === null && Ec('THREE.WebGLRenderer: ' + i + ' extension not supported.'), r)
    },
  }
}
function K7(n, e, t, i) {
  const r = {},
    s = new WeakMap()
  function o(d) {
    const h = d.target
    h.index !== null && e.remove(h.index)
    for (const p in h.attributes) e.remove(h.attributes[p])
    ;(h.removeEventListener('dispose', o), delete r[h.id])
    const f = s.get(h)
    ;(f && (e.remove(f), s.delete(h)),
      i.releaseStatesOfGeometry(h),
      h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
      t.memory.geometries--)
  }
  function a(d, h) {
    return (
      r[h.id] === !0 || (h.addEventListener('dispose', o), (r[h.id] = !0), t.memory.geometries++),
      h
    )
  }
  function l(d) {
    const h = d.attributes
    for (const f in h) e.update(h[f], n.ARRAY_BUFFER)
  }
  function c(d) {
    const h = [],
      f = d.index,
      p = d.attributes.position
    let g = 0
    if (f !== null) {
      const v = f.array
      g = f.version
      for (let x = 0, _ = v.length; x < _; x += 3) {
        const S = v[x + 0],
          C = v[x + 1],
          A = v[x + 2]
        h.push(S, C, C, A, A, S)
      }
    } else if (p !== void 0) {
      const v = p.array
      g = p.version
      for (let x = 0, _ = v.length / 3 - 1; x < _; x += 3) {
        const S = x + 0,
          C = x + 1,
          A = x + 2
        h.push(S, C, C, A, A, S)
      }
    } else return
    const y = new (L5(h) ? U5 : B5)(h, 1)
    y.version = g
    const m = s.get(d)
    ;(m && e.remove(m), s.set(d, y))
  }
  function u(d) {
    const h = s.get(d)
    if (h) {
      const f = d.index
      f !== null && h.version < f.version && c(d)
    } else c(d)
    return s.get(d)
  }
  return { get: a, update: l, getWireframeAttribute: u }
}
function Y7(n, e, t) {
  let i
  function r(h) {
    i = h
  }
  let s, o
  function a(h) {
    ;((s = h.type), (o = h.bytesPerElement))
  }
  function l(h, f) {
    ;(n.drawElements(i, f, s, h * o), t.update(f, i, 1))
  }
  function c(h, f, p) {
    p !== 0 && (n.drawElementsInstanced(i, f, s, h * o, p), t.update(f, i, p))
  }
  function u(h, f, p) {
    if (p === 0) return
    e.get('WEBGL_multi_draw').multiDrawElementsWEBGL(i, f, 0, s, h, 0, p)
    let y = 0
    for (let m = 0; m < p; m++) y += f[m]
    t.update(y, i, 1)
  }
  function d(h, f, p, g) {
    if (p === 0) return
    const y = e.get('WEBGL_multi_draw')
    if (y === null) for (let m = 0; m < h.length; m++) c(h[m] / o, f[m], g[m])
    else {
      y.multiDrawElementsInstancedWEBGL(i, f, 0, s, h, 0, g, 0, p)
      let m = 0
      for (let v = 0; v < p; v++) m += f[v] * g[v]
      t.update(m, i, 1)
    }
  }
  ;((this.setMode = r),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = d))
}
function Z7(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3)
        break
      case n.LINES:
        t.lines += a * (s / 2)
        break
      case n.LINE_STRIP:
        t.lines += a * (s - 1)
        break
      case n.LINE_LOOP:
        t.lines += a * s
        break
      case n.POINTS:
        t.points += a * s
        break
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', o)
        break
    }
  }
  function r() {
    ;((t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0))
  }
  return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: i }
}
function J7(n, e, t) {
  const i = new WeakMap(),
    r = new Mt()
  function s(o, a, l) {
    const c = o.morphTargetInfluences,
      u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
      d = u !== void 0 ? u.length : 0
    let h = i.get(a)
    if (h === void 0 || h.count !== d) {
      let w = function () {
        ;(A.dispose(), i.delete(a), a.removeEventListener('dispose', w))
      }
      h !== void 0 && h.texture.dispose()
      const f = a.morphAttributes.position !== void 0,
        p = a.morphAttributes.normal !== void 0,
        g = a.morphAttributes.color !== void 0,
        y = a.morphAttributes.position || [],
        m = a.morphAttributes.normal || [],
        v = a.morphAttributes.color || []
      let x = 0
      ;(f === !0 && (x = 1), p === !0 && (x = 2), g === !0 && (x = 3))
      let _ = a.attributes.position.count * x,
        S = 1
      _ > e.maxTextureSize && ((S = Math.ceil(_ / e.maxTextureSize)), (_ = e.maxTextureSize))
      const C = new Float32Array(_ * S * 4 * d),
        A = new T_(C, _, S, d)
      ;((A.type = nr), (A.needsUpdate = !0))
      const R = x * 4
      for (let M = 0; M < d; M++) {
        const I = y[M],
          L = m[M],
          U = v[M],
          T = _ * S * 4 * M
        for (let F = 0; F < I.count; F++) {
          const V = F * R
          ;(f === !0 &&
            (r.fromBufferAttribute(I, F),
            (C[T + V + 0] = r.x),
            (C[T + V + 1] = r.y),
            (C[T + V + 2] = r.z),
            (C[T + V + 3] = 0)),
            p === !0 &&
              (r.fromBufferAttribute(L, F),
              (C[T + V + 4] = r.x),
              (C[T + V + 5] = r.y),
              (C[T + V + 6] = r.z),
              (C[T + V + 7] = 0)),
            g === !0 &&
              (r.fromBufferAttribute(U, F),
              (C[T + V + 8] = r.x),
              (C[T + V + 9] = r.y),
              (C[T + V + 10] = r.z),
              (C[T + V + 11] = U.itemSize === 4 ? r.w : 1)))
        }
      }
      ;((h = { count: d, texture: A, size: new je(_, S) }),
        i.set(a, h),
        a.addEventListener('dispose', w))
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(n, 'morphTexture', o.morphTexture, t)
    else {
      let f = 0
      for (let g = 0; g < c.length; g++) f += c[g]
      const p = a.morphTargetsRelative ? 1 : 1 - f
      ;(l.getUniforms().setValue(n, 'morphTargetBaseInfluence', p),
        l.getUniforms().setValue(n, 'morphTargetInfluences', c))
    }
    ;(l.getUniforms().setValue(n, 'morphTargetsTexture', h.texture, t),
      l.getUniforms().setValue(n, 'morphTargetsTextureSize', h.size))
  }
  return { update: s }
}
function eO(n, e, t, i) {
  let r = new WeakMap()
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      d = e.get(l, u)
    if (
      (r.get(d) !== c && (e.update(d), r.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener('dispose', a) === !1 && l.addEventListener('dispose', a),
        r.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const h = l.skeleton
      r.get(h) !== c && (h.update(), r.set(h, c))
    }
    return d
  }
  function o() {
    r = new WeakMap()
  }
  function a(l) {
    const c = l.target
    ;(c.removeEventListener('dispose', a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor))
  }
  return { update: s, dispose: o }
}
const K5 = new Wn(),
  vA = new Ha(1, 1),
  Y5 = new T_(),
  Z5 = new VP(),
  J5 = new V5(),
  _A = [],
  xA = [],
  SA = new Float32Array(16),
  AA = new Float32Array(9),
  bA = new Float32Array(4)
function Uu(n, e, t) {
  const i = n[0]
  if (i <= 0 || i > 0) return n
  const r = e * t
  let s = _A[r]
  if ((s === void 0 && ((s = new Float32Array(r)), (_A[r] = s)), e !== 0)) {
    i.toArray(s, 0)
    for (let o = 1, a = 0; o !== e; ++o) ((a += t), n[o].toArray(s, a))
  }
  return s
}
function ni(n, e) {
  if (n.length !== e.length) return !1
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1
  return !0
}
function ii(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}
function u0(n, e) {
  let t = xA[e]
  t === void 0 && ((t = new Int32Array(e)), (xA[e] = t))
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit()
  return t
}
function tO(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e))
}
function nO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (ni(t, e)) return
    ;(n.uniform2fv(this.addr, e), ii(t, e))
  }
}
function iO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z))
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b))
  else {
    if (ni(t, e)) return
    ;(n.uniform3fv(this.addr, e), ii(t, e))
  }
}
function rO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (ni(t, e)) return
    ;(n.uniform4fv(this.addr, e), ii(t, e))
  }
}
function sO(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (ni(t, e)) return
    ;(n.uniformMatrix2fv(this.addr, !1, e), ii(t, e))
  } else {
    if (ni(t, i)) return
    ;(bA.set(i), n.uniformMatrix2fv(this.addr, !1, bA), ii(t, i))
  }
}
function oO(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (ni(t, e)) return
    ;(n.uniformMatrix3fv(this.addr, !1, e), ii(t, e))
  } else {
    if (ni(t, i)) return
    ;(AA.set(i), n.uniformMatrix3fv(this.addr, !1, AA), ii(t, i))
  }
}
function aO(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (ni(t, e)) return
    ;(n.uniformMatrix4fv(this.addr, !1, e), ii(t, e))
  } else {
    if (ni(t, i)) return
    ;(SA.set(i), n.uniformMatrix4fv(this.addr, !1, SA), ii(t, i))
  }
}
function lO(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e))
}
function cO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (ni(t, e)) return
    ;(n.uniform2iv(this.addr, e), ii(t, e))
  }
}
function uO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z))
  else {
    if (ni(t, e)) return
    ;(n.uniform3iv(this.addr, e), ii(t, e))
  }
}
function dO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (ni(t, e)) return
    ;(n.uniform4iv(this.addr, e), ii(t, e))
  }
}
function hO(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e))
}
function fO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (ni(t, e)) return
    ;(n.uniform2uiv(this.addr, e), ii(t, e))
  }
}
function pO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z))
  else {
    if (ni(t, e)) return
    ;(n.uniform3uiv(this.addr, e), ii(t, e))
  }
}
function mO(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (ni(t, e)) return
    ;(n.uniform4uiv(this.addr, e), ii(t, e))
  }
}
function gO(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r))
  let s
  ;(this.type === n.SAMPLER_2D_SHADOW ? ((vA.compareFunction = P5), (s = vA)) : (s = K5),
    t.setTexture2D(e || s, r))
}
function yO(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  ;(i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture3D(e || Z5, r))
}
function vO(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  ;(i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTextureCube(e || J5, r))
}
function _O(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  ;(i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)), t.setTexture2DArray(e || Y5, r))
}
function xO(n) {
  switch (n) {
    case 5126:
      return tO
    case 35664:
      return nO
    case 35665:
      return iO
    case 35666:
      return rO
    case 35674:
      return sO
    case 35675:
      return oO
    case 35676:
      return aO
    case 5124:
    case 35670:
      return lO
    case 35667:
    case 35671:
      return cO
    case 35668:
    case 35672:
      return uO
    case 35669:
    case 35673:
      return dO
    case 5125:
      return hO
    case 36294:
      return fO
    case 36295:
      return pO
    case 36296:
      return mO
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gO
    case 35679:
    case 36299:
    case 36307:
      return yO
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return vO
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return _O
  }
}
function SO(n, e) {
  n.uniform1fv(this.addr, e)
}
function AO(n, e) {
  const t = Uu(e, this.size, 2)
  n.uniform2fv(this.addr, t)
}
function bO(n, e) {
  const t = Uu(e, this.size, 3)
  n.uniform3fv(this.addr, t)
}
function TO(n, e) {
  const t = Uu(e, this.size, 4)
  n.uniform4fv(this.addr, t)
}
function wO(n, e) {
  const t = Uu(e, this.size, 4)
  n.uniformMatrix2fv(this.addr, !1, t)
}
function CO(n, e) {
  const t = Uu(e, this.size, 9)
  n.uniformMatrix3fv(this.addr, !1, t)
}
function EO(n, e) {
  const t = Uu(e, this.size, 16)
  n.uniformMatrix4fv(this.addr, !1, t)
}
function MO(n, e) {
  n.uniform1iv(this.addr, e)
}
function RO(n, e) {
  n.uniform2iv(this.addr, e)
}
function IO(n, e) {
  n.uniform3iv(this.addr, e)
}
function NO(n, e) {
  n.uniform4iv(this.addr, e)
}
function PO(n, e) {
  n.uniform1uiv(this.addr, e)
}
function LO(n, e) {
  n.uniform2uiv(this.addr, e)
}
function DO(n, e) {
  n.uniform3uiv(this.addr, e)
}
function FO(n, e) {
  n.uniform4uiv(this.addr, e)
}
function OO(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = u0(t, r)
  ni(i, s) || (n.uniform1iv(this.addr, s), ii(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || K5, s[o])
}
function BO(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = u0(t, r)
  ni(i, s) || (n.uniform1iv(this.addr, s), ii(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || Z5, s[o])
}
function UO(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = u0(t, r)
  ni(i, s) || (n.uniform1iv(this.addr, s), ii(i, s))
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || J5, s[o])
}
function kO(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = u0(t, r)
  ni(i, s) || (n.uniform1iv(this.addr, s), ii(i, s))
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || Y5, s[o])
}
function zO(n) {
  switch (n) {
    case 5126:
      return SO
    case 35664:
      return AO
    case 35665:
      return bO
    case 35666:
      return TO
    case 35674:
      return wO
    case 35675:
      return CO
    case 35676:
      return EO
    case 5124:
    case 35670:
      return MO
    case 35667:
    case 35671:
      return RO
    case 35668:
    case 35672:
      return IO
    case 35669:
    case 35673:
      return NO
    case 5125:
      return PO
    case 36294:
      return LO
    case 36295:
      return DO
    case 36296:
      return FO
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return OO
    case 35679:
    case 36299:
    case 36307:
      return BO
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return UO
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return kO
  }
}
class VO {
  constructor(e, t, i) {
    ;((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = xO(t.type)))
  }
}
class HO {
  constructor(e, t, i) {
    ;((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = zO(t.type)))
  }
}
class $O {
  constructor(e) {
    ;((this.id = e), (this.seq = []), (this.map = {}))
  }
  setValue(e, t, i) {
    const r = this.seq
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s]
      a.setValue(e, t[a.id], i)
    }
  }
}
const Gg = /(\w+)(\])?(\[|\.)?/g
function TA(n, e) {
  ;(n.seq.push(e), (n.map[e.id] = e))
}
function GO(n, e, t) {
  const i = n.name,
    r = i.length
  for (Gg.lastIndex = 0; ; ) {
    const s = Gg.exec(i),
      o = Gg.lastIndex
    let a = s[1]
    const l = s[2] === ']',
      c = s[3]
    if ((l && (a = a | 0), c === void 0 || (c === '[' && o + 2 === r))) {
      TA(t, c === void 0 ? new VO(a, n, e) : new HO(a, n, e))
      break
    } else {
      let d = t.map[a]
      ;(d === void 0 && ((d = new $O(a)), TA(t, d)), (t = d))
    }
  }
}
class Lp {
  constructor(e, t) {
    ;((this.seq = []), (this.map = {}))
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS)
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name)
      GO(s, o, this)
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t]
    s !== void 0 && s.setValue(e, i, r)
  }
  setOptional(e, t, i) {
    const r = t[i]
    r !== void 0 && this.setValue(e, i, r)
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id]
      l.needsUpdate !== !1 && a.setValue(e, l.value, r)
    }
  }
  static seqWithValue(e, t) {
    const i = []
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r]
      o.id in t && i.push(o)
    }
    return i
  }
}
function wA(n, e, t) {
  const i = n.createShader(e)
  return (n.shaderSource(i, t), n.compileShader(i), i)
}
const WO = 37297
let QO = 0
function jO(n, e) {
  const t = n.split('\n'),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length)
  for (let o = r; o < s; o++) {
    const a = o + 1
    i.push(
      ''
        .concat(a === e ? '>' : ' ', ' ')
        .concat(a, ': ')
        .concat(t[o])
    )
  }
  return i.join('\n')
}
const CA = new pt()
function qO(n) {
  Tt._getMatrix(CA, Tt.workingColorSpace, n)
  const e = 'mat3( '.concat(
    CA.elements.map((t) => t.toFixed(4)),
    ' )'
  )
  switch (Tt.getTransfer(n)) {
    case mm:
      return [e, 'LinearTransferOETF']
    case Jt:
      return [e, 'sRGBTransferOETF']
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space: ', n),
        [e, 'LinearTransferOETF']
      )
  }
}
function EA(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim()
  if (i && r === '') return ''
  const s = /ERROR: 0:(\d+)/.exec(r)
  if (s) {
    const o = parseInt(s[1])
    return t.toUpperCase() + '\n\n' + r + '\n\n' + jO(n.getShaderSource(e), o)
  } else return r
}
function XO(n, e) {
  const t = qO(e)
  return [
    'vec4 '.concat(n, '( vec4 value ) {'),
    '	return '.concat(t[1], '( vec4( value.rgb * ').concat(t[0], ', value.a ) );'),
    '}',
  ].join('\n')
}
function KO(n, e) {
  let t
  switch (e) {
    case YN:
      t = 'Linear'
      break
    case ZN:
      t = 'Reinhard'
      break
    case JN:
      t = 'Cineon'
      break
    case eP:
      t = 'ACESFilmic'
      break
    case nP:
      t = 'AgX'
      break
    case iP:
      t = 'Neutral'
      break
    case tP:
      t = 'Custom'
      break
    default:
      ;(console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (t = 'Linear'))
  }
  return 'vec3 ' + n + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
}
const Qf = new Y()
function YO() {
  Tt.getLuminanceCoefficients(Qf)
  const n = Qf.x.toFixed(4),
    e = Qf.y.toFixed(4),
    t = Qf.z.toFixed(4)
  return [
    'float luminance( const in vec3 rgb ) {',
    '	const vec3 weights = vec3( '.concat(n, ', ').concat(e, ', ').concat(t, ' );'),
    '	return dot( weights, rgb );',
    '}',
  ].join('\n')
}
function ZO(n) {
  return [
    n.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
    n.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ]
    .filter(wd)
    .join('\n')
}
function JO(n) {
  const e = []
  for (const t in n) {
    const i = n[t]
    i !== !1 && e.push('#define ' + t + ' ' + i)
  }
  return e.join('\n')
}
function eB(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES)
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name
    let a = 1
    ;(s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = { type: s.type, location: n.getAttribLocation(e, o), locationSize: a }))
  }
  return t
}
function wd(n) {
  return n !== ''
}
function MA(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function RA(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const tB = /^[ \t]*#include +<([\w\d./]+)>/gm
function Vy(n) {
  return n.replace(tB, iB)
}
const nB = new Map()
function iB(n, e) {
  let t = It[e]
  if (t === void 0) {
    const i = nB.get(e)
    if (i !== void 0)
      ((t = It[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        ))
    else throw new Error('Can not resolve #include <' + e + '>')
  }
  return Vy(t)
}
const rB =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function IA(n) {
  return n.replace(rB, sB)
}
function sB(n, e, t, i) {
  let r = ''
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i.replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]').replace(/UNROLLED_LOOP_INDEX/g, s)
  return r
}
function NA(n) {
  let e = 'precision '
    .concat(n.precision, ' float;\n	precision ')
    .concat(n.precision, ' int;\n	precision ')
    .concat(n.precision, ' sampler2D;\n	precision ')
    .concat(n.precision, ' samplerCube;\n	precision ')
    .concat(n.precision, ' sampler3D;\n	precision ')
    .concat(n.precision, ' sampler2DArray;\n	precision ')
    .concat(n.precision, ' sampler2DShadow;\n	precision ')
    .concat(n.precision, ' samplerCubeShadow;\n	precision ')
    .concat(n.precision, ' sampler2DArrayShadow;\n	precision ')
    .concat(n.precision, ' isampler2D;\n	precision ')
    .concat(n.precision, ' isampler3D;\n	precision ')
    .concat(n.precision, ' isamplerCube;\n	precision ')
    .concat(n.precision, ' isampler2DArray;\n	precision ')
    .concat(n.precision, ' usampler2D;\n	precision ')
    .concat(n.precision, ' usampler3D;\n	precision ')
    .concat(n.precision, ' usamplerCube;\n	precision ')
    .concat(n.precision, ' usampler2DArray;\n	')
  return (
    n.precision === 'highp'
      ? (e += '\n#define HIGH_PRECISION')
      : n.precision === 'mediump'
        ? (e += '\n#define MEDIUM_PRECISION')
        : n.precision === 'lowp' && (e += '\n#define LOW_PRECISION'),
    e
  )
}
function oB(n) {
  let e = 'SHADOWMAP_TYPE_BASIC'
  return (
    n.shadowMapType === y5
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : n.shadowMapType === NN
        ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
        : n.shadowMapType === Ar && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  )
}
function aB(n) {
  let e = 'ENVMAP_TYPE_CUBE'
  if (n.envMap)
    switch (n.envMapMode) {
      case kl:
      case zl:
        e = 'ENVMAP_TYPE_CUBE'
        break
      case s0:
        e = 'ENVMAP_TYPE_CUBE_UV'
        break
    }
  return e
}
function lB(n) {
  let e = 'ENVMAP_MODE_REFLECTION'
  if (n.envMap)
    switch (n.envMapMode) {
      case zl:
        e = 'ENVMAP_MODE_REFRACTION'
        break
    }
  return e
}
function cB(n) {
  let e = 'ENVMAP_BLENDING_NONE'
  if (n.envMap)
    switch (n.combine) {
      case _5:
        e = 'ENVMAP_BLENDING_MULTIPLY'
        break
      case XN:
        e = 'ENVMAP_BLENDING_MIX'
        break
      case KN:
        e = 'ENVMAP_BLENDING_ADD'
        break
    }
  return e
}
function uB(n) {
  const e = n.envMapCubeUVHeight
  if (e === null) return null
  const t = Math.log2(e) - 2,
    i = 1 / e
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)), texelHeight: i, maxMip: t }
}
function dB(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines
  let o = t.vertexShader,
    a = t.fragmentShader
  const l = oB(t),
    c = aB(t),
    u = lB(t),
    d = cB(t),
    h = uB(t),
    f = ZO(t),
    p = JO(s),
    g = r.createProgram()
  let y,
    m,
    v = t.glslVersion ? '#version ' + t.glslVersion + '\n' : ''
  ;(t.isRawShaderMaterial
    ? ((y = ['#define SHADER_TYPE ' + t.shaderType, '#define SHADER_NAME ' + t.shaderName, p]
        .filter(wd)
        .join('\n')),
      y.length > 0 && (y += '\n'),
      (m = ['#define SHADER_TYPE ' + t.shaderType, '#define SHADER_NAME ' + t.shaderName, p]
        .filter(wd)
        .join('\n')),
      m.length > 0 && (m += '\n'))
    : ((y = [
        NA(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
        t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        t.batching ? '#define USE_BATCHING' : '',
        t.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        t.instancing ? '#define USE_INSTANCING' : '',
        t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + u : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
        t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
        t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
        t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
        t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
        t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
        t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
        t.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv : '',
        t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
        t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
        t.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv : '',
        t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
        t.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv : '',
        t.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
          : '',
        t.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv : '',
        t.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
          : '',
        t.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv : '',
        t.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv : '',
        t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
        t.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv : '',
        t.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
          : '',
        t.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv : '',
        t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.skinning ? '#define USE_SKINNING' : '',
        t.morphTargets ? '#define USE_MORPHTARGETS' : '',
        t.morphNormals && t.flatShading === !1 ? '#define USE_MORPHNORMALS' : '',
        t.morphColors ? '#define USE_MORPHCOLORS' : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
          : '',
        t.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + l : '',
        t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        '\n',
      ]
        .filter(wd)
        .join('\n')),
      (m = [
        NA(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        t.map ? '#define USE_MAP' : '',
        t.matcap ? '#define USE_MATCAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + c : '',
        t.envMap ? '#define ' + u : '',
        t.envMap ? '#define ' + d : '',
        h ? '#define CUBEUV_TEXEL_WIDTH ' + h.texelWidth : '',
        h ? '#define CUBEUV_TEXEL_HEIGHT ' + h.texelHeight : '',
        h ? '#define CUBEUV_MAX_MIP ' + h.maxMip + '.0' : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoat ? '#define USE_CLEARCOAT' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.dispersion ? '#define USE_DISPERSION' : '',
        t.iridescence ? '#define USE_IRIDESCENCE' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaTest ? '#define USE_ALPHATEST' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.sheen ? '#define USE_SHEEN' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors || t.instancingColor || t.batchingColor ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.gradientMap ? '#define USE_GRADIENTMAP' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + l : '',
        t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        t.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        t.toneMapping !== _s ? '#define TONE_MAPPING' : '',
        t.toneMapping !== _s ? It.tonemapping_pars_fragment : '',
        t.toneMapping !== _s ? KO('toneMapping', t.toneMapping) : '',
        t.dithering ? '#define DITHERING' : '',
        t.opaque ? '#define OPAQUE' : '',
        It.colorspace_pars_fragment,
        XO('linearToOutputTexel', t.outputColorSpace),
        YO(),
        t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
        '\n',
      ]
        .filter(wd)
        .join('\n'))),
    (o = Vy(o)),
    (o = MA(o, t)),
    (o = RA(o, t)),
    (a = Vy(a)),
    (a = MA(a, t)),
    (a = RA(a, t)),
    (o = IA(o)),
    (a = IA(a)),
    t.isRawShaderMaterial !== !0 &&
      ((v = '#version 300 es\n'),
      (y =
        [f, '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') +
        '\n' +
        y),
      (m =
        [
          '#define varying in',
          t.glslVersion === wS ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
          t.glslVersion === wS ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join('\n') +
        '\n' +
        m)))
  const x = v + y + o,
    _ = v + m + a,
    S = wA(r, r.VERTEX_SHADER, x),
    C = wA(r, r.FRAGMENT_SHADER, _)
  ;(r.attachShader(g, S),
    r.attachShader(g, C),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(g, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(g, 0, 'position'),
    r.linkProgram(g))
  function A(I) {
    if (n.debug.checkShaderErrors) {
      const L = r.getProgramInfoLog(g).trim(),
        U = r.getShaderInfoLog(S).trim(),
        T = r.getShaderInfoLog(C).trim()
      let F = !0,
        V = !0
      if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
        if (((F = !1), typeof n.debug.onShaderError == 'function'))
          n.debug.onShaderError(r, g, S, C)
        else {
          const W = EA(r, S, 'vertex'),
            ee = EA(r, C, 'fragment')
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              r.getError() +
              ' - VALIDATE_STATUS ' +
              r.getProgramParameter(g, r.VALIDATE_STATUS) +
              '\n\nMaterial Name: ' +
              I.name +
              '\nMaterial Type: ' +
              I.type +
              '\n\nProgram Info Log: ' +
              L +
              '\n' +
              W +
              '\n' +
              ee
          )
        }
      else
        L !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', L)
          : (U === '' || T === '') && (V = !1)
      V &&
        (I.diagnostics = {
          runnable: F,
          programLog: L,
          vertexShader: { log: U, prefix: y },
          fragmentShader: { log: T, prefix: m },
        })
    }
    ;(r.deleteShader(S), r.deleteShader(C), (R = new Lp(r, g)), (w = eB(r, g)))
  }
  let R
  this.getUniforms = function () {
    return (R === void 0 && A(this), R)
  }
  let w
  this.getAttributes = function () {
    return (w === void 0 && A(this), w)
  }
  let M = t.rendererExtensionParallelShaderCompile === !1
  return (
    (this.isReady = function () {
      return (M === !1 && (M = r.getProgramParameter(g, WO)), M)
    }),
    (this.destroy = function () {
      ;(i.releaseStatesOfProgram(this), r.deleteProgram(g), (this.program = void 0))
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = QO++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = S),
    (this.fragmentShader = C),
    this
  )
}
let hB = 0
class fB {
  constructor() {
    ;((this.shaderCache = new Map()), (this.materialCache = new Map()))
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e)
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    )
  }
  remove(e) {
    const t = this.materialCache.get(e)
    for (const i of t) (i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code))
    return (this.materialCache.delete(e), this)
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id
  }
  dispose() {
    ;(this.shaderCache.clear(), this.materialCache.clear())
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache
    let i = t.get(e)
    return (i === void 0 && ((i = new Set()), t.set(e, i)), i)
  }
  _getShaderStage(e) {
    const t = this.shaderCache
    let i = t.get(e)
    return (i === void 0 && ((i = new pB(e)), t.set(e, i)), i)
  }
}
class pB {
  constructor(e) {
    ;((this.id = hB++), (this.code = e), (this.usedTimes = 0))
  }
}
function mB(n, e, t, i, r, s, o) {
  const a = new F5(),
    l = new fB(),
    c = new Set(),
    u = [],
    d = r.logarithmicDepthBuffer,
    h = r.vertexTextures
  let f = r.precision
  const p = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  }
  function g(w) {
    return (c.add(w), w === 0 ? 'uv' : 'uv'.concat(w))
  }
  function y(w, M, I, L, U) {
    const T = L.fog,
      F = U.geometry,
      V = w.isMeshStandardMaterial ? L.environment : null,
      W = (w.isMeshStandardMaterial ? t : e).get(w.envMap || V),
      ee = W && W.mapping === s0 ? W.image.height : null,
      se = p[w.type]
    w.precision !== null &&
      ((f = r.getMaxPrecision(w.precision)),
      f !== w.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          w.precision,
          'not supported, using',
          f,
          'instead.'
        ))
    const he = F.morphAttributes.position || F.morphAttributes.normal || F.morphAttributes.color,
      ne = he !== void 0 ? he.length : 0
    let ie = 0
    ;(F.morphAttributes.position !== void 0 && (ie = 1),
      F.morphAttributes.normal !== void 0 && (ie = 2),
      F.morphAttributes.color !== void 0 && (ie = 3))
    let be, le, fe, we
    if (se) {
      const on = Vs[se]
      ;((be = on.vertexShader), (le = on.fragmentShader))
    } else
      ((be = w.vertexShader),
        (le = w.fragmentShader),
        l.update(w),
        (fe = l.getVertexShaderID(w)),
        (we = l.getFragmentShaderID(w)))
    const Ee = n.getRenderTarget(),
      Ie = n.state.buffers.depth.getReversed(),
      ze = U.isInstancedMesh === !0,
      Be = U.isBatchedMesh === !0,
      it = !!w.map,
      te = !!w.matcap,
      re = !!W,
      b = !!w.aoMap,
      oe = !!w.lightMap,
      J = !!w.bumpMap,
      H = !!w.normalMap,
      P = !!w.displacementMap,
      k = !!w.emissiveMap,
      j = !!w.metalnessMap,
      B = !!w.roughnessMap,
      D = w.anisotropy > 0,
      Q = w.clearcoat > 0,
      G = w.dispersion > 0,
      X = w.iridescence > 0,
      ue = w.sheen > 0,
      z = w.transmission > 0,
      E = D && !!w.anisotropyMap,
      N = Q && !!w.clearcoatMap,
      q = Q && !!w.clearcoatNormalMap,
      Z = Q && !!w.clearcoatRoughnessMap,
      $ = X && !!w.iridescenceMap,
      ae = X && !!w.iridescenceThicknessMap,
      Ue = ue && !!w.sheenColorMap,
      Le = ue && !!w.sheenRoughnessMap,
      Ve = !!w.specularMap,
      Je = !!w.specularColorMap,
      rt = !!w.specularIntensityMap,
      pe = z && !!w.transmissionMap,
      Ze = z && !!w.thicknessMap,
      Ce = !!w.gradientMap,
      De = !!w.alphaMap,
      Xe = w.alphaTest > 0,
      et = !!w.alphaHash,
      _t = !!w.extensions
    let hn = _s
    w.toneMapped && (Ee === null || Ee.isXRRenderTarget === !0) && (hn = n.toneMapping)
    const bi = {
      shaderID: se,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: be,
      fragmentShader: le,
      defines: w.defines,
      customVertexShaderID: fe,
      customFragmentShaderID: we,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: f,
      batching: Be,
      batchingColor: Be && U._colorsTexture !== null,
      instancing: ze,
      instancingColor: ze && U.instanceColor !== null,
      instancingMorph: ze && U.morphTexture !== null,
      supportsVertexTextures: h,
      outputColorSpace:
        Ee === null ? n.outputColorSpace : Ee.isXRRenderTarget === !0 ? Ee.texture.colorSpace : Ui,
      alphaToCoverage: !!w.alphaToCoverage,
      map: it,
      matcap: te,
      envMap: re,
      envMapMode: re && W.mapping,
      envMapCubeUVHeight: ee,
      aoMap: b,
      lightMap: oe,
      bumpMap: J,
      normalMap: H,
      displacementMap: h && P,
      emissiveMap: k,
      normalMapObjectSpace: H && w.normalMapType === I5,
      normalMapTangentSpace: H && w.normalMapType === pm,
      metalnessMap: j,
      roughnessMap: B,
      anisotropy: D,
      anisotropyMap: E,
      clearcoat: Q,
      clearcoatMap: N,
      clearcoatNormalMap: q,
      clearcoatRoughnessMap: Z,
      dispersion: G,
      iridescence: X,
      iridescenceMap: $,
      iridescenceThicknessMap: ae,
      sheen: ue,
      sheenColorMap: Ue,
      sheenRoughnessMap: Le,
      specularMap: Ve,
      specularColorMap: Je,
      specularIntensityMap: rt,
      transmission: z,
      transmissionMap: pe,
      thicknessMap: Ze,
      gradientMap: Ce,
      opaque: w.transparent === !1 && w.blending === zo && w.alphaToCoverage === !1,
      alphaMap: De,
      alphaTest: Xe,
      alphaHash: et,
      combine: w.combine,
      mapUv: it && g(w.map.channel),
      aoMapUv: b && g(w.aoMap.channel),
      lightMapUv: oe && g(w.lightMap.channel),
      bumpMapUv: J && g(w.bumpMap.channel),
      normalMapUv: H && g(w.normalMap.channel),
      displacementMapUv: P && g(w.displacementMap.channel),
      emissiveMapUv: k && g(w.emissiveMap.channel),
      metalnessMapUv: j && g(w.metalnessMap.channel),
      roughnessMapUv: B && g(w.roughnessMap.channel),
      anisotropyMapUv: E && g(w.anisotropyMap.channel),
      clearcoatMapUv: N && g(w.clearcoatMap.channel),
      clearcoatNormalMapUv: q && g(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Z && g(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: $ && g(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: ae && g(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ue && g(w.sheenColorMap.channel),
      sheenRoughnessMapUv: Le && g(w.sheenRoughnessMap.channel),
      specularMapUv: Ve && g(w.specularMap.channel),
      specularColorMapUv: Je && g(w.specularColorMap.channel),
      specularIntensityMapUv: rt && g(w.specularIntensityMap.channel),
      transmissionMapUv: pe && g(w.transmissionMap.channel),
      thicknessMapUv: Ze && g(w.thicknessMap.channel),
      alphaMapUv: De && g(w.alphaMap.channel),
      vertexTangents: !!F.attributes.tangent && (H || D),
      vertexColors: w.vertexColors,
      vertexAlphas:
        w.vertexColors === !0 && !!F.attributes.color && F.attributes.color.itemSize === 4,
      pointsUvs: U.isPoints === !0 && !!F.attributes.uv && (it || De),
      fog: !!T,
      useFog: w.fog === !0,
      fogExp2: !!T && T.isFogExp2,
      flatShading: w.flatShading === !0,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: Ie,
      skinning: U.isSkinnedMesh === !0,
      morphTargets: F.morphAttributes.position !== void 0,
      morphNormals: F.morphAttributes.normal !== void 0,
      morphColors: F.morphAttributes.color !== void 0,
      morphTargetsCount: ne,
      morphTextureStride: ie,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: n.shadowMap.enabled && I.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: hn,
      decodeVideoTexture:
        it && w.map.isVideoTexture === !0 && Tt.getTransfer(w.map.colorSpace) === Jt,
      decodeVideoTextureEmissive:
        k && w.emissiveMap.isVideoTexture === !0 && Tt.getTransfer(w.emissiveMap.colorSpace) === Jt,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === wr,
      flipSided: w.side === Oi,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionClipCullDistance:
        _t && w.extensions.clipCullDistance === !0 && i.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((_t && w.extensions.multiDraw === !0) || Be) && i.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: i.has('KHR_parallel_shader_compile'),
      customProgramCacheKey: w.customProgramCacheKey(),
    }
    return (
      (bi.vertexUv1s = c.has(1)),
      (bi.vertexUv2s = c.has(2)),
      (bi.vertexUv3s = c.has(3)),
      c.clear(),
      bi
    )
  }
  function m(w) {
    const M = []
    if (
      (w.shaderID
        ? M.push(w.shaderID)
        : (M.push(w.customVertexShaderID), M.push(w.customFragmentShaderID)),
      w.defines !== void 0)
    )
      for (const I in w.defines) (M.push(I), M.push(w.defines[I]))
    return (
      w.isRawShaderMaterial === !1 && (v(M, w), x(M, w), M.push(n.outputColorSpace)),
      M.push(w.customProgramCacheKey),
      M.join()
    )
  }
  function v(w, M) {
    ;(w.push(M.precision),
      w.push(M.outputColorSpace),
      w.push(M.envMapMode),
      w.push(M.envMapCubeUVHeight),
      w.push(M.mapUv),
      w.push(M.alphaMapUv),
      w.push(M.lightMapUv),
      w.push(M.aoMapUv),
      w.push(M.bumpMapUv),
      w.push(M.normalMapUv),
      w.push(M.displacementMapUv),
      w.push(M.emissiveMapUv),
      w.push(M.metalnessMapUv),
      w.push(M.roughnessMapUv),
      w.push(M.anisotropyMapUv),
      w.push(M.clearcoatMapUv),
      w.push(M.clearcoatNormalMapUv),
      w.push(M.clearcoatRoughnessMapUv),
      w.push(M.iridescenceMapUv),
      w.push(M.iridescenceThicknessMapUv),
      w.push(M.sheenColorMapUv),
      w.push(M.sheenRoughnessMapUv),
      w.push(M.specularMapUv),
      w.push(M.specularColorMapUv),
      w.push(M.specularIntensityMapUv),
      w.push(M.transmissionMapUv),
      w.push(M.thicknessMapUv),
      w.push(M.combine),
      w.push(M.fogExp2),
      w.push(M.sizeAttenuation),
      w.push(M.morphTargetsCount),
      w.push(M.morphAttributeCount),
      w.push(M.numDirLights),
      w.push(M.numPointLights),
      w.push(M.numSpotLights),
      w.push(M.numSpotLightMaps),
      w.push(M.numHemiLights),
      w.push(M.numRectAreaLights),
      w.push(M.numDirLightShadows),
      w.push(M.numPointLightShadows),
      w.push(M.numSpotLightShadows),
      w.push(M.numSpotLightShadowsWithMaps),
      w.push(M.numLightProbes),
      w.push(M.shadowMapType),
      w.push(M.toneMapping),
      w.push(M.numClippingPlanes),
      w.push(M.numClipIntersection),
      w.push(M.depthPacking))
  }
  function x(w, M) {
    ;(a.disableAll(),
      M.supportsVertexTextures && a.enable(0),
      M.instancing && a.enable(1),
      M.instancingColor && a.enable(2),
      M.instancingMorph && a.enable(3),
      M.matcap && a.enable(4),
      M.envMap && a.enable(5),
      M.normalMapObjectSpace && a.enable(6),
      M.normalMapTangentSpace && a.enable(7),
      M.clearcoat && a.enable(8),
      M.iridescence && a.enable(9),
      M.alphaTest && a.enable(10),
      M.vertexColors && a.enable(11),
      M.vertexAlphas && a.enable(12),
      M.vertexUv1s && a.enable(13),
      M.vertexUv2s && a.enable(14),
      M.vertexUv3s && a.enable(15),
      M.vertexTangents && a.enable(16),
      M.anisotropy && a.enable(17),
      M.alphaHash && a.enable(18),
      M.batching && a.enable(19),
      M.dispersion && a.enable(20),
      M.batchingColor && a.enable(21),
      w.push(a.mask),
      a.disableAll(),
      M.fog && a.enable(0),
      M.useFog && a.enable(1),
      M.flatShading && a.enable(2),
      M.logarithmicDepthBuffer && a.enable(3),
      M.reverseDepthBuffer && a.enable(4),
      M.skinning && a.enable(5),
      M.morphTargets && a.enable(6),
      M.morphNormals && a.enable(7),
      M.morphColors && a.enable(8),
      M.premultipliedAlpha && a.enable(9),
      M.shadowMapEnabled && a.enable(10),
      M.doubleSided && a.enable(11),
      M.flipSided && a.enable(12),
      M.useDepthPacking && a.enable(13),
      M.dithering && a.enable(14),
      M.transmission && a.enable(15),
      M.sheen && a.enable(16),
      M.opaque && a.enable(17),
      M.pointsUvs && a.enable(18),
      M.decodeVideoTexture && a.enable(19),
      M.decodeVideoTextureEmissive && a.enable(20),
      M.alphaToCoverage && a.enable(21),
      w.push(a.mask))
  }
  function _(w) {
    const M = p[w.type]
    let I
    if (M) {
      const L = Vs[M]
      I = iL.clone(L.uniforms)
    } else I = w.uniforms
    return I
  }
  function S(w, M) {
    let I
    for (let L = 0, U = u.length; L < U; L++) {
      const T = u[L]
      if (T.cacheKey === M) {
        ;((I = T), ++I.usedTimes)
        break
      }
    }
    return (I === void 0 && ((I = new dB(n, M, w, s)), u.push(I)), I)
  }
  function C(w) {
    if (--w.usedTimes === 0) {
      const M = u.indexOf(w)
      ;((u[M] = u[u.length - 1]), u.pop(), w.destroy())
    }
  }
  function A(w) {
    l.remove(w)
  }
  function R() {
    l.dispose()
  }
  return {
    getParameters: y,
    getProgramCacheKey: m,
    getUniforms: _,
    acquireProgram: S,
    releaseProgram: C,
    releaseShaderCache: A,
    programs: u,
    dispose: R,
  }
}
function gB() {
  let n = new WeakMap()
  function e(o) {
    return n.has(o)
  }
  function t(o) {
    let a = n.get(o)
    return (a === void 0 && ((a = {}), n.set(o, a)), a)
  }
  function i(o) {
    n.delete(o)
  }
  function r(o, a, l) {
    n.get(o)[a] = l
  }
  function s() {
    n = new WeakMap()
  }
  return { has: e, get: t, remove: i, update: r, dispose: s }
}
function yB(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id
}
function PA(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id
}
function LA() {
  const n = []
  let e = 0
  const t = [],
    i = [],
    r = []
  function s() {
    ;((e = 0), (t.length = 0), (i.length = 0), (r.length = 0))
  }
  function o(d, h, f, p, g, y) {
    let m = n[e]
    return (
      m === void 0
        ? ((m = {
            id: d.id,
            object: d,
            geometry: h,
            material: f,
            groupOrder: p,
            renderOrder: d.renderOrder,
            z: g,
            group: y,
          }),
          (n[e] = m))
        : ((m.id = d.id),
          (m.object = d),
          (m.geometry = h),
          (m.material = f),
          (m.groupOrder = p),
          (m.renderOrder = d.renderOrder),
          (m.z = g),
          (m.group = y)),
      e++,
      m
    )
  }
  function a(d, h, f, p, g, y) {
    const m = o(d, h, f, p, g, y)
    f.transmission > 0 ? i.push(m) : f.transparent === !0 ? r.push(m) : t.push(m)
  }
  function l(d, h, f, p, g, y) {
    const m = o(d, h, f, p, g, y)
    f.transmission > 0 ? i.unshift(m) : f.transparent === !0 ? r.unshift(m) : t.unshift(m)
  }
  function c(d, h) {
    ;(t.length > 1 && t.sort(d || yB),
      i.length > 1 && i.sort(h || PA),
      r.length > 1 && r.sort(h || PA))
  }
  function u() {
    for (let d = e, h = n.length; d < h; d++) {
      const f = n[d]
      if (f.id === null) break
      ;((f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null))
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  }
}
function vB() {
  let n = new WeakMap()
  function e(i, r) {
    const s = n.get(i)
    let o
    return (
      s === void 0
        ? ((o = new LA()), n.set(i, [o]))
        : r >= s.length
          ? ((o = new LA()), s.push(o))
          : (o = s[r]),
      o
    )
  }
  function t() {
    n = new WeakMap()
  }
  return { get: e, dispose: t }
}
function _B() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case 'DirectionalLight':
          t = { direction: new Y(), color: new gt() }
          break
        case 'SpotLight':
          t = {
            position: new Y(),
            direction: new Y(),
            color: new gt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case 'PointLight':
          t = { position: new Y(), color: new gt(), distance: 0, decay: 0 }
          break
        case 'HemisphereLight':
          t = { direction: new Y(), skyColor: new gt(), groundColor: new gt() }
          break
        case 'RectAreaLight':
          t = { color: new gt(), position: new Y(), halfWidth: new Y(), halfHeight: new Y() }
          break
      }
      return ((n[e.id] = t), t)
    },
  }
}
function xB() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case 'DirectionalLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
          }
          break
        case 'SpotLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
          }
          break
        case 'PointLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new je(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      return ((n[e.id] = t), t)
    },
  }
}
let SB = 0
function AB(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function bB(n) {
  const e = new _B(),
    t = xB(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    }
  for (let c = 0; c < 9; c++) i.probe.push(new Y())
  const r = new Y(),
    s = new qe(),
    o = new qe()
  function a(c) {
    let u = 0,
      d = 0,
      h = 0
    for (let w = 0; w < 9; w++) i.probe[w].set(0, 0, 0)
    let f = 0,
      p = 0,
      g = 0,
      y = 0,
      m = 0,
      v = 0,
      x = 0,
      _ = 0,
      S = 0,
      C = 0,
      A = 0
    c.sort(AB)
    for (let w = 0, M = c.length; w < M; w++) {
      const I = c[w],
        L = I.color,
        U = I.intensity,
        T = I.distance,
        F = I.shadow && I.shadow.map ? I.shadow.map.texture : null
      if (I.isAmbientLight) ((u += L.r * U), (d += L.g * U), (h += L.b * U))
      else if (I.isLightProbe) {
        for (let V = 0; V < 9; V++) i.probe[V].addScaledVector(I.sh.coefficients[V], U)
        A++
      } else if (I.isDirectionalLight) {
        const V = e.get(I)
        if ((V.color.copy(I.color).multiplyScalar(I.intensity), I.castShadow)) {
          const W = I.shadow,
            ee = t.get(I)
          ;((ee.shadowIntensity = W.intensity),
            (ee.shadowBias = W.bias),
            (ee.shadowNormalBias = W.normalBias),
            (ee.shadowRadius = W.radius),
            (ee.shadowMapSize = W.mapSize),
            (i.directionalShadow[f] = ee),
            (i.directionalShadowMap[f] = F),
            (i.directionalShadowMatrix[f] = I.shadow.matrix),
            v++)
        }
        ;((i.directional[f] = V), f++)
      } else if (I.isSpotLight) {
        const V = e.get(I)
        ;(V.position.setFromMatrixPosition(I.matrixWorld),
          V.color.copy(L).multiplyScalar(U),
          (V.distance = T),
          (V.coneCos = Math.cos(I.angle)),
          (V.penumbraCos = Math.cos(I.angle * (1 - I.penumbra))),
          (V.decay = I.decay),
          (i.spot[g] = V))
        const W = I.shadow
        if (
          (I.map && ((i.spotLightMap[S] = I.map), S++, W.updateMatrices(I), I.castShadow && C++),
          (i.spotLightMatrix[g] = W.matrix),
          I.castShadow)
        ) {
          const ee = t.get(I)
          ;((ee.shadowIntensity = W.intensity),
            (ee.shadowBias = W.bias),
            (ee.shadowNormalBias = W.normalBias),
            (ee.shadowRadius = W.radius),
            (ee.shadowMapSize = W.mapSize),
            (i.spotShadow[g] = ee),
            (i.spotShadowMap[g] = F),
            _++)
        }
        g++
      } else if (I.isRectAreaLight) {
        const V = e.get(I)
        ;(V.color.copy(L).multiplyScalar(U),
          V.halfWidth.set(I.width * 0.5, 0, 0),
          V.halfHeight.set(0, I.height * 0.5, 0),
          (i.rectArea[y] = V),
          y++)
      } else if (I.isPointLight) {
        const V = e.get(I)
        if (
          (V.color.copy(I.color).multiplyScalar(I.intensity),
          (V.distance = I.distance),
          (V.decay = I.decay),
          I.castShadow)
        ) {
          const W = I.shadow,
            ee = t.get(I)
          ;((ee.shadowIntensity = W.intensity),
            (ee.shadowBias = W.bias),
            (ee.shadowNormalBias = W.normalBias),
            (ee.shadowRadius = W.radius),
            (ee.shadowMapSize = W.mapSize),
            (ee.shadowCameraNear = W.camera.near),
            (ee.shadowCameraFar = W.camera.far),
            (i.pointShadow[p] = ee),
            (i.pointShadowMap[p] = F),
            (i.pointShadowMatrix[p] = I.shadow.matrix),
            x++)
        }
        ;((i.point[p] = V), p++)
      } else if (I.isHemisphereLight) {
        const V = e.get(I)
        ;(V.skyColor.copy(I.color).multiplyScalar(U),
          V.groundColor.copy(I.groundColor).multiplyScalar(U),
          (i.hemi[m] = V),
          m++)
      }
    }
    ;(y > 0 &&
      (n.has('OES_texture_float_linear') === !0
        ? ((i.rectAreaLTC1 = tt.LTC_FLOAT_1), (i.rectAreaLTC2 = tt.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = tt.LTC_HALF_1), (i.rectAreaLTC2 = tt.LTC_HALF_2))),
      (i.ambient[0] = u),
      (i.ambient[1] = d),
      (i.ambient[2] = h))
    const R = i.hash
    ;(R.directionalLength !== f ||
      R.pointLength !== p ||
      R.spotLength !== g ||
      R.rectAreaLength !== y ||
      R.hemiLength !== m ||
      R.numDirectionalShadows !== v ||
      R.numPointShadows !== x ||
      R.numSpotShadows !== _ ||
      R.numSpotMaps !== S ||
      R.numLightProbes !== A) &&
      ((i.directional.length = f),
      (i.spot.length = g),
      (i.rectArea.length = y),
      (i.point.length = p),
      (i.hemi.length = m),
      (i.directionalShadow.length = v),
      (i.directionalShadowMap.length = v),
      (i.pointShadow.length = x),
      (i.pointShadowMap.length = x),
      (i.spotShadow.length = _),
      (i.spotShadowMap.length = _),
      (i.directionalShadowMatrix.length = v),
      (i.pointShadowMatrix.length = x),
      (i.spotLightMatrix.length = _ + S - C),
      (i.spotLightMap.length = S),
      (i.numSpotLightShadowsWithMaps = C),
      (i.numLightProbes = A),
      (R.directionalLength = f),
      (R.pointLength = p),
      (R.spotLength = g),
      (R.rectAreaLength = y),
      (R.hemiLength = m),
      (R.numDirectionalShadows = v),
      (R.numPointShadows = x),
      (R.numSpotShadows = _),
      (R.numSpotMaps = S),
      (R.numLightProbes = A),
      (i.version = SB++))
  }
  function l(c, u) {
    let d = 0,
      h = 0,
      f = 0,
      p = 0,
      g = 0
    const y = u.matrixWorldInverse
    for (let m = 0, v = c.length; m < v; m++) {
      const x = c[m]
      if (x.isDirectionalLight) {
        const _ = i.directional[d]
        ;(_.direction.setFromMatrixPosition(x.matrixWorld),
          r.setFromMatrixPosition(x.target.matrixWorld),
          _.direction.sub(r),
          _.direction.transformDirection(y),
          d++)
      } else if (x.isSpotLight) {
        const _ = i.spot[f]
        ;(_.position.setFromMatrixPosition(x.matrixWorld),
          _.position.applyMatrix4(y),
          _.direction.setFromMatrixPosition(x.matrixWorld),
          r.setFromMatrixPosition(x.target.matrixWorld),
          _.direction.sub(r),
          _.direction.transformDirection(y),
          f++)
      } else if (x.isRectAreaLight) {
        const _ = i.rectArea[p]
        ;(_.position.setFromMatrixPosition(x.matrixWorld),
          _.position.applyMatrix4(y),
          o.identity(),
          s.copy(x.matrixWorld),
          s.premultiply(y),
          o.extractRotation(s),
          _.halfWidth.set(x.width * 0.5, 0, 0),
          _.halfHeight.set(0, x.height * 0.5, 0),
          _.halfWidth.applyMatrix4(o),
          _.halfHeight.applyMatrix4(o),
          p++)
      } else if (x.isPointLight) {
        const _ = i.point[h]
        ;(_.position.setFromMatrixPosition(x.matrixWorld), _.position.applyMatrix4(y), h++)
      } else if (x.isHemisphereLight) {
        const _ = i.hemi[g]
        ;(_.direction.setFromMatrixPosition(x.matrixWorld), _.direction.transformDirection(y), g++)
      }
    }
  }
  return { setup: a, setupView: l, state: i }
}
function DA(n) {
  const e = new bB(n),
    t = [],
    i = []
  function r(u) {
    ;((c.camera = u), (t.length = 0), (i.length = 0))
  }
  function s(u) {
    t.push(u)
  }
  function o(u) {
    i.push(u)
  }
  function a() {
    e.setup(t)
  }
  function l(u) {
    e.setupView(t, u)
  }
  const c = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  }
  return { init: r, state: c, setupLights: a, setupLightsView: l, pushLight: s, pushShadow: o }
}
function TB(n) {
  let e = new WeakMap()
  function t(r, s = 0) {
    const o = e.get(r)
    let a
    return (
      o === void 0
        ? ((a = new DA(n)), e.set(r, [a]))
        : s >= o.length
          ? ((a = new DA(n)), o.push(a))
          : (a = o[s]),
      a
    )
  }
  function i() {
    e = new WeakMap()
  }
  return { get: t, dispose: i }
}
const wB = 'void main() {\n	gl_Position = vec4( position, 1.0 );\n}',
  CB =
    'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
function EB(n, e, t) {
  let i = new C_()
  const r = new je(),
    s = new je(),
    o = new Mt(),
    a = new xL({ depthPacking: uP }),
    l = new SL(),
    c = {},
    u = t.maxTextureSize,
    d = { [Ts]: Oi, [Oi]: Ts, [wr]: wr },
    h = new Nr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new je() },
        radius: { value: 4 },
      },
      vertexShader: wB,
      fragmentShader: CB,
    }),
    f = h.clone()
  f.defines.HORIZONTAL_PASS = 1
  const p = new ki()
  p.setAttribute('position', new _i(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))
  const g = new pn(p, h),
    y = this
  ;((this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = y5))
  let m = this.type
  this.render = function (C, A, R) {
    if (y.enabled === !1 || (y.autoUpdate === !1 && y.needsUpdate === !1) || C.length === 0) return
    const w = n.getRenderTarget(),
      M = n.getActiveCubeFace(),
      I = n.getActiveMipmapLevel(),
      L = n.state
    ;(L.setBlending(La),
      L.buffers.color.setClear(1, 1, 1, 1),
      L.buffers.depth.setTest(!0),
      L.setScissorTest(!1))
    const U = m !== Ar && this.type === Ar,
      T = m === Ar && this.type !== Ar
    for (let F = 0, V = C.length; F < V; F++) {
      const W = C[F],
        ee = W.shadow
      if (ee === void 0) {
        console.warn('THREE.WebGLShadowMap:', W, 'has no shadow.')
        continue
      }
      if (ee.autoUpdate === !1 && ee.needsUpdate === !1) continue
      r.copy(ee.mapSize)
      const se = ee.getFrameExtents()
      if (
        (r.multiply(se),
        s.copy(ee.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u && ((s.x = Math.floor(u / se.x)), (r.x = s.x * se.x), (ee.mapSize.x = s.x)),
          r.y > u && ((s.y = Math.floor(u / se.y)), (r.y = s.y * se.y), (ee.mapSize.y = s.y))),
        ee.map === null || U === !0 || T === !0)
      ) {
        const ne = this.type !== Ar ? { minFilter: vi, magFilter: vi } : {}
        ;(ee.map !== null && ee.map.dispose(),
          (ee.map = new Ua(r.x, r.y, ne)),
          (ee.map.texture.name = W.name + '.shadowMap'),
          ee.camera.updateProjectionMatrix())
      }
      ;(n.setRenderTarget(ee.map), n.clear())
      const he = ee.getViewportCount()
      for (let ne = 0; ne < he; ne++) {
        const ie = ee.getViewport(ne)
        ;(o.set(s.x * ie.x, s.y * ie.y, s.x * ie.z, s.y * ie.w),
          L.viewport(o),
          ee.updateMatrices(W, ne),
          (i = ee.getFrustum()),
          _(A, R, ee.camera, W, this.type))
      }
      ;(ee.isPointLightShadow !== !0 && this.type === Ar && v(ee, R), (ee.needsUpdate = !1))
    }
    ;((m = this.type), (y.needsUpdate = !1), n.setRenderTarget(w, M, I))
  }
  function v(C, A) {
    const R = e.update(g)
    ;(h.defines.VSM_SAMPLES !== C.blurSamples &&
      ((h.defines.VSM_SAMPLES = C.blurSamples),
      (f.defines.VSM_SAMPLES = C.blurSamples),
      (h.needsUpdate = !0),
      (f.needsUpdate = !0)),
      C.mapPass === null && (C.mapPass = new Ua(r.x, r.y)),
      (h.uniforms.shadow_pass.value = C.map.texture),
      (h.uniforms.resolution.value = C.mapSize),
      (h.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.mapPass),
      n.clear(),
      n.renderBufferDirect(A, null, R, h, g, null),
      (f.uniforms.shadow_pass.value = C.mapPass.texture),
      (f.uniforms.resolution.value = C.mapSize),
      (f.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.map),
      n.clear(),
      n.renderBufferDirect(A, null, R, f, g, null))
  }
  function x(C, A, R, w) {
    let M = null
    const I = R.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial
    if (I !== void 0) M = I
    else if (
      ((M = R.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        A.clipShadows === !0 &&
        Array.isArray(A.clippingPlanes) &&
        A.clippingPlanes.length !== 0) ||
        (A.displacementMap && A.displacementScale !== 0) ||
        (A.alphaMap && A.alphaTest > 0) ||
        (A.map && A.alphaTest > 0))
    ) {
      const L = M.uuid,
        U = A.uuid
      let T = c[L]
      T === void 0 && ((T = {}), (c[L] = T))
      let F = T[U]
      ;(F === void 0 && ((F = M.clone()), (T[U] = F), A.addEventListener('dispose', S)), (M = F))
    }
    if (
      ((M.visible = A.visible),
      (M.wireframe = A.wireframe),
      w === Ar
        ? (M.side = A.shadowSide !== null ? A.shadowSide : A.side)
        : (M.side = A.shadowSide !== null ? A.shadowSide : d[A.side]),
      (M.alphaMap = A.alphaMap),
      (M.alphaTest = A.alphaTest),
      (M.map = A.map),
      (M.clipShadows = A.clipShadows),
      (M.clippingPlanes = A.clippingPlanes),
      (M.clipIntersection = A.clipIntersection),
      (M.displacementMap = A.displacementMap),
      (M.displacementScale = A.displacementScale),
      (M.displacementBias = A.displacementBias),
      (M.wireframeLinewidth = A.wireframeLinewidth),
      (M.linewidth = A.linewidth),
      R.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const L = n.properties.get(M)
      L.light = R
    }
    return M
  }
  function _(C, A, R, w, M) {
    if (C.visible === !1) return
    if (
      C.layers.test(A.layers) &&
      (C.isMesh || C.isLine || C.isPoints) &&
      (C.castShadow || (C.receiveShadow && M === Ar)) &&
      (!C.frustumCulled || i.intersectsObject(C))
    ) {
      C.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, C.matrixWorld)
      const U = e.update(C),
        T = C.material
      if (Array.isArray(T)) {
        const F = U.groups
        for (let V = 0, W = F.length; V < W; V++) {
          const ee = F[V],
            se = T[ee.materialIndex]
          if (se && se.visible) {
            const he = x(C, se, w, M)
            ;(C.onBeforeShadow(n, C, A, R, U, he, ee),
              n.renderBufferDirect(R, null, U, he, C, ee),
              C.onAfterShadow(n, C, A, R, U, he, ee))
          }
        }
      } else if (T.visible) {
        const F = x(C, T, w, M)
        ;(C.onBeforeShadow(n, C, A, R, U, F, null),
          n.renderBufferDirect(R, null, U, F, C, null),
          C.onAfterShadow(n, C, A, R, U, F, null))
      }
    }
    const L = C.children
    for (let U = 0, T = L.length; U < T; U++) _(L[U], A, R, w, M)
  }
  function S(C) {
    C.target.removeEventListener('dispose', S)
    for (const R in c) {
      const w = c[R],
        M = C.target.uuid
      M in w && (w[M].dispose(), delete w[M])
    }
  }
}
const MB = { [iy]: ry, [sy]: ly, [oy]: cy, [cu]: ay, [ry]: iy, [ly]: sy, [cy]: oy, [ay]: cu }
function RB(n, e) {
  function t() {
    let pe = !1
    const Ze = new Mt()
    let Ce = null
    const De = new Mt(0, 0, 0, 0)
    return {
      setMask: function (Xe) {
        Ce !== Xe && !pe && (n.colorMask(Xe, Xe, Xe, Xe), (Ce = Xe))
      },
      setLocked: function (Xe) {
        pe = Xe
      },
      setClear: function (Xe, et, _t, hn, bi) {
        ;(bi === !0 && ((Xe *= hn), (et *= hn), (_t *= hn)),
          Ze.set(Xe, et, _t, hn),
          De.equals(Ze) === !1 && (n.clearColor(Xe, et, _t, hn), De.copy(Ze)))
      },
      reset: function () {
        ;((pe = !1), (Ce = null), De.set(-1, 0, 0, 0))
      },
    }
  }
  function i() {
    let pe = !1,
      Ze = !1,
      Ce = null,
      De = null,
      Xe = null
    return {
      setReversed: function (et) {
        if (Ze !== et) {
          const _t = e.get('EXT_clip_control')
          Ze
            ? _t.clipControlEXT(_t.LOWER_LEFT_EXT, _t.ZERO_TO_ONE_EXT)
            : _t.clipControlEXT(_t.LOWER_LEFT_EXT, _t.NEGATIVE_ONE_TO_ONE_EXT)
          const hn = Xe
          ;((Xe = null), this.setClear(hn))
        }
        Ze = et
      },
      getReversed: function () {
        return Ze
      },
      setTest: function (et) {
        et ? Ee(n.DEPTH_TEST) : Ie(n.DEPTH_TEST)
      },
      setMask: function (et) {
        Ce !== et && !pe && (n.depthMask(et), (Ce = et))
      },
      setFunc: function (et) {
        if ((Ze && (et = MB[et]), De !== et)) {
          switch (et) {
            case iy:
              n.depthFunc(n.NEVER)
              break
            case ry:
              n.depthFunc(n.ALWAYS)
              break
            case sy:
              n.depthFunc(n.LESS)
              break
            case cu:
              n.depthFunc(n.LEQUAL)
              break
            case oy:
              n.depthFunc(n.EQUAL)
              break
            case ay:
              n.depthFunc(n.GEQUAL)
              break
            case ly:
              n.depthFunc(n.GREATER)
              break
            case cy:
              n.depthFunc(n.NOTEQUAL)
              break
            default:
              n.depthFunc(n.LEQUAL)
          }
          De = et
        }
      },
      setLocked: function (et) {
        pe = et
      },
      setClear: function (et) {
        Xe !== et && (Ze && (et = 1 - et), n.clearDepth(et), (Xe = et))
      },
      reset: function () {
        ;((pe = !1), (Ce = null), (De = null), (Xe = null), (Ze = !1))
      },
    }
  }
  function r() {
    let pe = !1,
      Ze = null,
      Ce = null,
      De = null,
      Xe = null,
      et = null,
      _t = null,
      hn = null,
      bi = null
    return {
      setTest: function (on) {
        pe || (on ? Ee(n.STENCIL_TEST) : Ie(n.STENCIL_TEST))
      },
      setMask: function (on) {
        Ze !== on && !pe && (n.stencilMask(on), (Ze = on))
      },
      setFunc: function (on, os, ho) {
        ;(Ce !== on || De !== os || Xe !== ho) &&
          (n.stencilFunc(on, os, ho), (Ce = on), (De = os), (Xe = ho))
      },
      setOp: function (on, os, ho) {
        ;(et !== on || _t !== os || hn !== ho) &&
          (n.stencilOp(on, os, ho), (et = on), (_t = os), (hn = ho))
      },
      setLocked: function (on) {
        pe = on
      },
      setClear: function (on) {
        bi !== on && (n.clearStencil(on), (bi = on))
      },
      reset: function () {
        ;((pe = !1),
          (Ze = null),
          (Ce = null),
          (De = null),
          (Xe = null),
          (et = null),
          (_t = null),
          (hn = null),
          (bi = null))
      },
    }
  }
  const s = new t(),
    o = new i(),
    a = new r(),
    l = new WeakMap(),
    c = new WeakMap()
  let u = {},
    d = {},
    h = new WeakMap(),
    f = [],
    p = null,
    g = !1,
    y = null,
    m = null,
    v = null,
    x = null,
    _ = null,
    S = null,
    C = null,
    A = new gt(0, 0, 0),
    R = 0,
    w = !1,
    M = null,
    I = null,
    L = null,
    U = null,
    T = null
  const F = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
  let V = !1,
    W = 0
  const ee = n.getParameter(n.VERSION)
  ee.indexOf('WebGL') !== -1
    ? ((W = parseFloat(/^WebGL (\d)/.exec(ee)[1])), (V = W >= 1))
    : ee.indexOf('OpenGL ES') !== -1 &&
      ((W = parseFloat(/^OpenGL ES (\d)/.exec(ee)[1])), (V = W >= 2))
  let se = null,
    he = {}
  const ne = n.getParameter(n.SCISSOR_BOX),
    ie = n.getParameter(n.VIEWPORT),
    be = new Mt().fromArray(ne),
    le = new Mt().fromArray(ie)
  function fe(pe, Ze, Ce, De) {
    const Xe = new Uint8Array(4),
      et = n.createTexture()
    ;(n.bindTexture(pe, et),
      n.texParameteri(pe, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(pe, n.TEXTURE_MAG_FILTER, n.NEAREST))
    for (let _t = 0; _t < Ce; _t++)
      pe === n.TEXTURE_3D || pe === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Ze, 0, n.RGBA, 1, 1, De, 0, n.RGBA, n.UNSIGNED_BYTE, Xe)
        : n.texImage2D(Ze + _t, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Xe)
    return et
  }
  const we = {}
  ;((we[n.TEXTURE_2D] = fe(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (we[n.TEXTURE_CUBE_MAP] = fe(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
    (we[n.TEXTURE_2D_ARRAY] = fe(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (we[n.TEXTURE_3D] = fe(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    Ee(n.DEPTH_TEST),
    o.setFunc(cu),
    J(!1),
    H(_S),
    Ee(n.CULL_FACE),
    b(La))
  function Ee(pe) {
    u[pe] !== !0 && (n.enable(pe), (u[pe] = !0))
  }
  function Ie(pe) {
    u[pe] !== !1 && (n.disable(pe), (u[pe] = !1))
  }
  function ze(pe, Ze) {
    return d[pe] !== Ze
      ? (n.bindFramebuffer(pe, Ze),
        (d[pe] = Ze),
        pe === n.DRAW_FRAMEBUFFER && (d[n.FRAMEBUFFER] = Ze),
        pe === n.FRAMEBUFFER && (d[n.DRAW_FRAMEBUFFER] = Ze),
        !0)
      : !1
  }
  function Be(pe, Ze) {
    let Ce = f,
      De = !1
    if (pe) {
      ;((Ce = h.get(Ze)), Ce === void 0 && ((Ce = []), h.set(Ze, Ce)))
      const Xe = pe.textures
      if (Ce.length !== Xe.length || Ce[0] !== n.COLOR_ATTACHMENT0) {
        for (let et = 0, _t = Xe.length; et < _t; et++) Ce[et] = n.COLOR_ATTACHMENT0 + et
        ;((Ce.length = Xe.length), (De = !0))
      }
    } else Ce[0] !== n.BACK && ((Ce[0] = n.BACK), (De = !0))
    De && n.drawBuffers(Ce)
  }
  function it(pe) {
    return p !== pe ? (n.useProgram(pe), (p = pe), !0) : !1
  }
  const te = { [gl]: n.FUNC_ADD, [PN]: n.FUNC_SUBTRACT, [LN]: n.FUNC_REVERSE_SUBTRACT }
  ;((te[DN] = n.MIN), (te[FN] = n.MAX))
  const re = {
    [ON]: n.ZERO,
    [BN]: n.ONE,
    [UN]: n.SRC_COLOR,
    [sh]: n.SRC_ALPHA,
    [GN]: n.SRC_ALPHA_SATURATE,
    [HN]: n.DST_COLOR,
    [zN]: n.DST_ALPHA,
    [kN]: n.ONE_MINUS_SRC_COLOR,
    [oh]: n.ONE_MINUS_SRC_ALPHA,
    [$N]: n.ONE_MINUS_DST_COLOR,
    [VN]: n.ONE_MINUS_DST_ALPHA,
    [WN]: n.CONSTANT_COLOR,
    [QN]: n.ONE_MINUS_CONSTANT_COLOR,
    [jN]: n.CONSTANT_ALPHA,
    [qN]: n.ONE_MINUS_CONSTANT_ALPHA,
  }
  function b(pe, Ze, Ce, De, Xe, et, _t, hn, bi, on) {
    if (pe === La) {
      g === !0 && (Ie(n.BLEND), (g = !1))
      return
    }
    if ((g === !1 && (Ee(n.BLEND), (g = !0)), pe !== v5)) {
      if (pe !== y || on !== w) {
        if (((m !== gl || _ !== gl) && (n.blendEquation(n.FUNC_ADD), (m = gl), (_ = gl)), on))
          switch (pe) {
            case zo:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA)
              break
            case xS:
              n.blendFunc(n.ONE, n.ONE)
              break
            case SS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE)
              break
            case AS:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', pe)
              break
          }
        else
          switch (pe) {
            case zo:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA)
              break
            case xS:
              n.blendFunc(n.SRC_ALPHA, n.ONE)
              break
            case SS:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE)
              break
            case AS:
              n.blendFunc(n.ZERO, n.SRC_COLOR)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', pe)
              break
          }
        ;((v = null),
          (x = null),
          (S = null),
          (C = null),
          A.set(0, 0, 0),
          (R = 0),
          (y = pe),
          (w = on))
      }
      return
    }
    ;((Xe = Xe || Ze),
      (et = et || Ce),
      (_t = _t || De),
      (Ze !== m || Xe !== _) && (n.blendEquationSeparate(te[Ze], te[Xe]), (m = Ze), (_ = Xe)),
      (Ce !== v || De !== x || et !== S || _t !== C) &&
        (n.blendFuncSeparate(re[Ce], re[De], re[et], re[_t]),
        (v = Ce),
        (x = De),
        (S = et),
        (C = _t)),
      (hn.equals(A) === !1 || bi !== R) &&
        (n.blendColor(hn.r, hn.g, hn.b, bi), A.copy(hn), (R = bi)),
      (y = pe),
      (w = !1))
  }
  function oe(pe, Ze) {
    pe.side === wr ? Ie(n.CULL_FACE) : Ee(n.CULL_FACE)
    let Ce = pe.side === Oi
    ;(Ze && (Ce = !Ce),
      J(Ce),
      pe.blending === zo && pe.transparent === !1
        ? b(La)
        : b(
            pe.blending,
            pe.blendEquation,
            pe.blendSrc,
            pe.blendDst,
            pe.blendEquationAlpha,
            pe.blendSrcAlpha,
            pe.blendDstAlpha,
            pe.blendColor,
            pe.blendAlpha,
            pe.premultipliedAlpha
          ),
      o.setFunc(pe.depthFunc),
      o.setTest(pe.depthTest),
      o.setMask(pe.depthWrite),
      s.setMask(pe.colorWrite))
    const De = pe.stencilWrite
    ;(a.setTest(De),
      De &&
        (a.setMask(pe.stencilWriteMask),
        a.setFunc(pe.stencilFunc, pe.stencilRef, pe.stencilFuncMask),
        a.setOp(pe.stencilFail, pe.stencilZFail, pe.stencilZPass)),
      k(pe.polygonOffset, pe.polygonOffsetFactor, pe.polygonOffsetUnits),
      pe.alphaToCoverage === !0 ? Ee(n.SAMPLE_ALPHA_TO_COVERAGE) : Ie(n.SAMPLE_ALPHA_TO_COVERAGE))
  }
  function J(pe) {
    M !== pe && (pe ? n.frontFace(n.CW) : n.frontFace(n.CCW), (M = pe))
  }
  function H(pe) {
    ;(pe !== RN
      ? (Ee(n.CULL_FACE),
        pe !== I &&
          (pe === _S
            ? n.cullFace(n.BACK)
            : pe === IN
              ? n.cullFace(n.FRONT)
              : n.cullFace(n.FRONT_AND_BACK)))
      : Ie(n.CULL_FACE),
      (I = pe))
  }
  function P(pe) {
    pe !== L && (V && n.lineWidth(pe), (L = pe))
  }
  function k(pe, Ze, Ce) {
    pe
      ? (Ee(n.POLYGON_OFFSET_FILL),
        (U !== Ze || T !== Ce) && (n.polygonOffset(Ze, Ce), (U = Ze), (T = Ce)))
      : Ie(n.POLYGON_OFFSET_FILL)
  }
  function j(pe) {
    pe ? Ee(n.SCISSOR_TEST) : Ie(n.SCISSOR_TEST)
  }
  function B(pe) {
    ;(pe === void 0 && (pe = n.TEXTURE0 + F - 1), se !== pe && (n.activeTexture(pe), (se = pe)))
  }
  function D(pe, Ze, Ce) {
    Ce === void 0 && (se === null ? (Ce = n.TEXTURE0 + F - 1) : (Ce = se))
    let De = he[Ce]
    ;(De === void 0 && ((De = { type: void 0, texture: void 0 }), (he[Ce] = De)),
      (De.type !== pe || De.texture !== Ze) &&
        (se !== Ce && (n.activeTexture(Ce), (se = Ce)),
        n.bindTexture(pe, Ze || we[pe]),
        (De.type = pe),
        (De.texture = Ze)))
  }
  function Q() {
    const pe = he[se]
    pe !== void 0 &&
      pe.type !== void 0 &&
      (n.bindTexture(pe.type, null), (pe.type = void 0), (pe.texture = void 0))
  }
  function G() {
    try {
      n.compressedTexImage2D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function X() {
    try {
      n.compressedTexImage3D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function ue() {
    try {
      n.texSubImage2D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function z() {
    try {
      n.texSubImage3D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function E() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function N() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function q() {
    try {
      n.texStorage2D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function Z() {
    try {
      n.texStorage3D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function $() {
    try {
      n.texImage2D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function ae() {
    try {
      n.texImage3D.apply(n, arguments)
    } catch (pe) {
      console.error('THREE.WebGLState:', pe)
    }
  }
  function Ue(pe) {
    be.equals(pe) === !1 && (n.scissor(pe.x, pe.y, pe.z, pe.w), be.copy(pe))
  }
  function Le(pe) {
    le.equals(pe) === !1 && (n.viewport(pe.x, pe.y, pe.z, pe.w), le.copy(pe))
  }
  function Ve(pe, Ze) {
    let Ce = c.get(Ze)
    Ce === void 0 && ((Ce = new WeakMap()), c.set(Ze, Ce))
    let De = Ce.get(pe)
    De === void 0 && ((De = n.getUniformBlockIndex(Ze, pe.name)), Ce.set(pe, De))
  }
  function Je(pe, Ze) {
    const De = c.get(Ze).get(pe)
    l.get(Ze) !== De && (n.uniformBlockBinding(Ze, De, pe.__bindingPointIndex), l.set(Ze, De))
  }
  function rt() {
    ;(n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      o.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (u = {}),
      (se = null),
      (he = {}),
      (d = {}),
      (h = new WeakMap()),
      (f = []),
      (p = null),
      (g = !1),
      (y = null),
      (m = null),
      (v = null),
      (x = null),
      (_ = null),
      (S = null),
      (C = null),
      (A = new gt(0, 0, 0)),
      (R = 0),
      (w = !1),
      (M = null),
      (I = null),
      (L = null),
      (U = null),
      (T = null),
      be.set(0, 0, n.canvas.width, n.canvas.height),
      le.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      o.reset(),
      a.reset())
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: Ee,
    disable: Ie,
    bindFramebuffer: ze,
    drawBuffers: Be,
    useProgram: it,
    setBlending: b,
    setMaterial: oe,
    setFlipSided: J,
    setCullFace: H,
    setLineWidth: P,
    setPolygonOffset: k,
    setScissorTest: j,
    activeTexture: B,
    bindTexture: D,
    unbindTexture: Q,
    compressedTexImage2D: G,
    compressedTexImage3D: X,
    texImage2D: $,
    texImage3D: ae,
    updateUBOMapping: Ve,
    uniformBlockBinding: Je,
    texStorage2D: q,
    texStorage3D: Z,
    texSubImage2D: ue,
    texSubImage3D: z,
    compressedTexSubImage2D: E,
    compressedTexSubImage3D: N,
    scissor: Ue,
    viewport: Le,
    reset: rt,
  }
}
function IB(n, e, t, i, r, s, o) {
  const a = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    l = typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new je(),
    u = new WeakMap()
  let d
  const h = new WeakMap()
  let f = !1
  try {
    f = typeof OffscreenCanvas < 'u' && new OffscreenCanvas(1, 1).getContext('2d') !== null
  } catch (B) {}
  function p(B, D) {
    return f ? new OffscreenCanvas(B, D) : dh('canvas')
  }
  function g(B, D, Q) {
    let G = 1
    const X = j(B)
    if (((X.width > Q || X.height > Q) && (G = Q / Math.max(X.width, X.height)), G < 1))
      if (
        (typeof HTMLImageElement < 'u' && B instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && B instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && B instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && B instanceof VideoFrame)
      ) {
        const ue = Math.floor(G * X.width),
          z = Math.floor(G * X.height)
        d === void 0 && (d = p(ue, z))
        const E = D ? p(ue, z) : d
        return (
          (E.width = ue),
          (E.height = z),
          E.getContext('2d').drawImage(B, 0, 0, ue, z),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              X.width +
              'x' +
              X.height +
              ') to (' +
              ue +
              'x' +
              z +
              ').'
          ),
          E
        )
      } else
        return (
          'data' in B &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                X.width +
                'x' +
                X.height +
                ').'
            ),
          B
        )
    return B
  }
  function y(B) {
    return B.generateMipmaps
  }
  function m(B) {
    n.generateMipmap(B)
  }
  function v(B) {
    return B.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : B.isWebGL3DRenderTarget
        ? n.TEXTURE_3D
        : B.isWebGLArrayRenderTarget || B.isCompressedArrayTexture
          ? n.TEXTURE_2D_ARRAY
          : n.TEXTURE_2D
  }
  function x(B, D, Q, G, X = !1) {
    if (B !== null) {
      if (n[B] !== void 0) return n[B]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'"
      )
    }
    let ue = D
    if (
      (D === n.RED &&
        (Q === n.FLOAT && (ue = n.R32F),
        Q === n.HALF_FLOAT && (ue = n.R16F),
        Q === n.UNSIGNED_BYTE && (ue = n.R8)),
      D === n.RED_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (ue = n.R8UI),
        Q === n.UNSIGNED_SHORT && (ue = n.R16UI),
        Q === n.UNSIGNED_INT && (ue = n.R32UI),
        Q === n.BYTE && (ue = n.R8I),
        Q === n.SHORT && (ue = n.R16I),
        Q === n.INT && (ue = n.R32I)),
      D === n.RG &&
        (Q === n.FLOAT && (ue = n.RG32F),
        Q === n.HALF_FLOAT && (ue = n.RG16F),
        Q === n.UNSIGNED_BYTE && (ue = n.RG8)),
      D === n.RG_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (ue = n.RG8UI),
        Q === n.UNSIGNED_SHORT && (ue = n.RG16UI),
        Q === n.UNSIGNED_INT && (ue = n.RG32UI),
        Q === n.BYTE && (ue = n.RG8I),
        Q === n.SHORT && (ue = n.RG16I),
        Q === n.INT && (ue = n.RG32I)),
      D === n.RGB_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (ue = n.RGB8UI),
        Q === n.UNSIGNED_SHORT && (ue = n.RGB16UI),
        Q === n.UNSIGNED_INT && (ue = n.RGB32UI),
        Q === n.BYTE && (ue = n.RGB8I),
        Q === n.SHORT && (ue = n.RGB16I),
        Q === n.INT && (ue = n.RGB32I)),
      D === n.RGBA_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (ue = n.RGBA8UI),
        Q === n.UNSIGNED_SHORT && (ue = n.RGBA16UI),
        Q === n.UNSIGNED_INT && (ue = n.RGBA32UI),
        Q === n.BYTE && (ue = n.RGBA8I),
        Q === n.SHORT && (ue = n.RGBA16I),
        Q === n.INT && (ue = n.RGBA32I)),
      D === n.RGB && Q === n.UNSIGNED_INT_5_9_9_9_REV && (ue = n.RGB9_E5),
      D === n.RGBA)
    ) {
      const z = X ? mm : Tt.getTransfer(G)
      ;(Q === n.FLOAT && (ue = n.RGBA32F),
        Q === n.HALF_FLOAT && (ue = n.RGBA16F),
        Q === n.UNSIGNED_BYTE && (ue = z === Jt ? n.SRGB8_ALPHA8 : n.RGBA8),
        Q === n.UNSIGNED_SHORT_4_4_4_4 && (ue = n.RGBA4),
        Q === n.UNSIGNED_SHORT_5_5_5_1 && (ue = n.RGB5_A1))
    }
    return (
      (ue === n.R16F ||
        ue === n.R32F ||
        ue === n.RG16F ||
        ue === n.RG32F ||
        ue === n.RGBA16F ||
        ue === n.RGBA32F) &&
        e.get('EXT_color_buffer_float'),
      ue
    )
  }
  function _(B, D) {
    let Q
    return (
      B
        ? D === null || D === Ni || D === du
          ? (Q = n.DEPTH24_STENCIL8)
          : D === nr
            ? (Q = n.DEPTH32F_STENCIL8)
            : D === ah &&
              ((Q = n.DEPTH24_STENCIL8),
              console.warn(
                'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.'
              ))
        : D === null || D === Ni || D === du
          ? (Q = n.DEPTH_COMPONENT24)
          : D === nr
            ? (Q = n.DEPTH_COMPONENT32F)
            : D === ah && (Q = n.DEPTH_COMPONENT16),
      Q
    )
  }
  function S(B, D) {
    return y(B) === !0 || (B.isFramebufferTexture && B.minFilter !== vi && B.minFilter !== Rr)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : B.mipmaps !== void 0 && B.mipmaps.length > 0
        ? B.mipmaps.length
        : B.isCompressedTexture && Array.isArray(B.image)
          ? D.mipmaps.length
          : 1
  }
  function C(B) {
    const D = B.target
    ;(D.removeEventListener('dispose', C), R(D), D.isVideoTexture && u.delete(D))
  }
  function A(B) {
    const D = B.target
    ;(D.removeEventListener('dispose', A), M(D))
  }
  function R(B) {
    const D = i.get(B)
    if (D.__webglInit === void 0) return
    const Q = B.source,
      G = h.get(Q)
    if (G) {
      const X = G[D.__cacheKey]
      ;(X.usedTimes--, X.usedTimes === 0 && w(B), Object.keys(G).length === 0 && h.delete(Q))
    }
    i.remove(B)
  }
  function w(B) {
    const D = i.get(B)
    n.deleteTexture(D.__webglTexture)
    const Q = B.source,
      G = h.get(Q)
    ;(delete G[D.__cacheKey], o.memory.textures--)
  }
  function M(B) {
    const D = i.get(B)
    if (
      (B.depthTexture && (B.depthTexture.dispose(), i.remove(B.depthTexture)),
      B.isWebGLCubeRenderTarget)
    )
      for (let G = 0; G < 6; G++) {
        if (Array.isArray(D.__webglFramebuffer[G]))
          for (let X = 0; X < D.__webglFramebuffer[G].length; X++)
            n.deleteFramebuffer(D.__webglFramebuffer[G][X])
        else n.deleteFramebuffer(D.__webglFramebuffer[G])
        D.__webglDepthbuffer && n.deleteRenderbuffer(D.__webglDepthbuffer[G])
      }
    else {
      if (Array.isArray(D.__webglFramebuffer))
        for (let G = 0; G < D.__webglFramebuffer.length; G++)
          n.deleteFramebuffer(D.__webglFramebuffer[G])
      else n.deleteFramebuffer(D.__webglFramebuffer)
      if (
        (D.__webglDepthbuffer && n.deleteRenderbuffer(D.__webglDepthbuffer),
        D.__webglMultisampledFramebuffer && n.deleteFramebuffer(D.__webglMultisampledFramebuffer),
        D.__webglColorRenderbuffer)
      )
        for (let G = 0; G < D.__webglColorRenderbuffer.length; G++)
          D.__webglColorRenderbuffer[G] && n.deleteRenderbuffer(D.__webglColorRenderbuffer[G])
      D.__webglDepthRenderbuffer && n.deleteRenderbuffer(D.__webglDepthRenderbuffer)
    }
    const Q = B.textures
    for (let G = 0, X = Q.length; G < X; G++) {
      const ue = i.get(Q[G])
      ;(ue.__webglTexture && (n.deleteTexture(ue.__webglTexture), o.memory.textures--),
        i.remove(Q[G]))
    }
    i.remove(B)
  }
  let I = 0
  function L() {
    I = 0
  }
  function U() {
    const B = I
    return (
      B >= r.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            B +
            ' texture units while this GPU supports only ' +
            r.maxTextures
        ),
      (I += 1),
      B
    )
  }
  function T(B) {
    const D = []
    return (
      D.push(B.wrapS),
      D.push(B.wrapT),
      D.push(B.wrapR || 0),
      D.push(B.magFilter),
      D.push(B.minFilter),
      D.push(B.anisotropy),
      D.push(B.internalFormat),
      D.push(B.format),
      D.push(B.type),
      D.push(B.generateMipmaps),
      D.push(B.premultiplyAlpha),
      D.push(B.flipY),
      D.push(B.unpackAlignment),
      D.push(B.colorSpace),
      D.join()
    )
  }
  function F(B, D) {
    const Q = i.get(B)
    if (
      (B.isVideoTexture && P(B),
      B.isRenderTargetTexture === !1 && B.version > 0 && Q.__version !== B.version)
    ) {
      const G = B.image
      if (G === null)
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.')
      else if (G.complete === !1)
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')
      else {
        le(Q, B, D)
        return
      }
    }
    t.bindTexture(n.TEXTURE_2D, Q.__webglTexture, n.TEXTURE0 + D)
  }
  function V(B, D) {
    const Q = i.get(B)
    if (B.version > 0 && Q.__version !== B.version) {
      le(Q, B, D)
      return
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, Q.__webglTexture, n.TEXTURE0 + D)
  }
  function W(B, D) {
    const Q = i.get(B)
    if (B.version > 0 && Q.__version !== B.version) {
      le(Q, B, D)
      return
    }
    t.bindTexture(n.TEXTURE_3D, Q.__webglTexture, n.TEXTURE0 + D)
  }
  function ee(B, D) {
    const Q = i.get(B)
    if (B.version > 0 && Q.__version !== B.version) {
      fe(Q, B, D)
      return
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Q.__webglTexture, n.TEXTURE0 + D)
  }
  const se = { [uu]: n.REPEAT, [wa]: n.CLAMP_TO_EDGE, [hm]: n.MIRRORED_REPEAT },
    he = {
      [vi]: n.NEAREST,
      [x5]: n.NEAREST_MIPMAP_NEAREST,
      [Td]: n.NEAREST_MIPMAP_LINEAR,
      [Rr]: n.LINEAR,
      [Ep]: n.LINEAR_MIPMAP_NEAREST,
      [Ws]: n.LINEAR_MIPMAP_LINEAR,
    },
    ne = {
      [dP]: n.NEVER,
      [gP]: n.ALWAYS,
      [N5]: n.LESS,
      [P5]: n.LEQUAL,
      [hP]: n.EQUAL,
      [mP]: n.GEQUAL,
      [fP]: n.GREATER,
      [pP]: n.NOTEQUAL,
    }
  function ie(B, D) {
    if (
      (D.type === nr &&
        e.has('OES_texture_float_linear') === !1 &&
        (D.magFilter === Rr ||
          D.magFilter === Ep ||
          D.magFilter === Td ||
          D.magFilter === Ws ||
          D.minFilter === Rr ||
          D.minFilter === Ep ||
          D.minFilter === Td ||
          D.minFilter === Ws) &&
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
        ),
      n.texParameteri(B, n.TEXTURE_WRAP_S, se[D.wrapS]),
      n.texParameteri(B, n.TEXTURE_WRAP_T, se[D.wrapT]),
      (B === n.TEXTURE_3D || B === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(B, n.TEXTURE_WRAP_R, se[D.wrapR]),
      n.texParameteri(B, n.TEXTURE_MAG_FILTER, he[D.magFilter]),
      n.texParameteri(B, n.TEXTURE_MIN_FILTER, he[D.minFilter]),
      D.compareFunction &&
        (n.texParameteri(B, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(B, n.TEXTURE_COMPARE_FUNC, ne[D.compareFunction])),
      e.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        D.magFilter === vi ||
        (D.minFilter !== Td && D.minFilter !== Ws) ||
        (D.type === nr && e.has('OES_texture_float_linear') === !1)
      )
        return
      if (D.anisotropy > 1 || i.get(D).__currentAnisotropy) {
        const Q = e.get('EXT_texture_filter_anisotropic')
        ;(n.texParameterf(
          B,
          Q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
          (i.get(D).__currentAnisotropy = D.anisotropy))
      }
    }
  }
  function be(B, D) {
    let Q = !1
    B.__webglInit === void 0 && ((B.__webglInit = !0), D.addEventListener('dispose', C))
    const G = D.source
    let X = h.get(G)
    X === void 0 && ((X = {}), h.set(G, X))
    const ue = T(D)
    if (ue !== B.__cacheKey) {
      ;(X[ue] === void 0 &&
        ((X[ue] = { texture: n.createTexture(), usedTimes: 0 }), o.memory.textures++, (Q = !0)),
        X[ue].usedTimes++)
      const z = X[B.__cacheKey]
      ;(z !== void 0 && (X[B.__cacheKey].usedTimes--, z.usedTimes === 0 && w(D)),
        (B.__cacheKey = ue),
        (B.__webglTexture = X[ue].texture))
    }
    return Q
  }
  function le(B, D, Q) {
    let G = n.TEXTURE_2D
    ;((D.isDataArrayTexture || D.isCompressedArrayTexture) && (G = n.TEXTURE_2D_ARRAY),
      D.isData3DTexture && (G = n.TEXTURE_3D))
    const X = be(B, D),
      ue = D.source
    t.bindTexture(G, B.__webglTexture, n.TEXTURE0 + Q)
    const z = i.get(ue)
    if (ue.version !== z.__version || X === !0) {
      t.activeTexture(n.TEXTURE0 + Q)
      const E = Tt.getPrimaries(Tt.workingColorSpace),
        N = D.colorSpace === $s ? null : Tt.getPrimaries(D.colorSpace),
        q = D.colorSpace === $s || E === N ? n.NONE : n.BROWSER_DEFAULT_WEBGL
      ;(n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, q))
      let Z = g(D.image, !1, r.maxTextureSize)
      Z = k(D, Z)
      const $ = s.convert(D.format, D.colorSpace),
        ae = s.convert(D.type)
      let Ue = x(D.internalFormat, $, ae, D.colorSpace, D.isVideoTexture)
      ie(G, D)
      let Le
      const Ve = D.mipmaps,
        Je = D.isVideoTexture !== !0,
        rt = z.__version === void 0 || X === !0,
        pe = ue.dataReady,
        Ze = S(D, Z)
      if (D.isDepthTexture)
        ((Ue = _(D.format === hu, D.type)),
          rt &&
            (Je
              ? t.texStorage2D(n.TEXTURE_2D, 1, Ue, Z.width, Z.height)
              : t.texImage2D(n.TEXTURE_2D, 0, Ue, Z.width, Z.height, 0, $, ae, null)))
      else if (D.isDataTexture)
        if (Ve.length > 0) {
          Je && rt && t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Ve[0].width, Ve[0].height)
          for (let Ce = 0, De = Ve.length; Ce < De; Ce++)
            ((Le = Ve[Ce]),
              Je
                ? pe && t.texSubImage2D(n.TEXTURE_2D, Ce, 0, 0, Le.width, Le.height, $, ae, Le.data)
                : t.texImage2D(n.TEXTURE_2D, Ce, Ue, Le.width, Le.height, 0, $, ae, Le.data))
          D.generateMipmaps = !1
        } else
          Je
            ? (rt && t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Z.width, Z.height),
              pe && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Z.width, Z.height, $, ae, Z.data))
            : t.texImage2D(n.TEXTURE_2D, 0, Ue, Z.width, Z.height, 0, $, ae, Z.data)
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          Je && rt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ze, Ue, Ve[0].width, Ve[0].height, Z.depth)
          for (let Ce = 0, De = Ve.length; Ce < De; Ce++)
            if (((Le = Ve[Ce]), D.format !== Fi))
              if ($ !== null)
                if (Je) {
                  if (pe)
                    if (D.layerUpdates.size > 0) {
                      const Xe = uA(Le.width, Le.height, D.format, D.type)
                      for (const et of D.layerUpdates) {
                        const _t = Le.data.subarray(
                          (et * Xe) / Le.data.BYTES_PER_ELEMENT,
                          ((et + 1) * Xe) / Le.data.BYTES_PER_ELEMENT
                        )
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Ce,
                          0,
                          0,
                          et,
                          Le.width,
                          Le.height,
                          1,
                          $,
                          _t
                        )
                      }
                      D.clearLayerUpdates()
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Ce,
                        0,
                        0,
                        0,
                        Le.width,
                        Le.height,
                        Z.depth,
                        $,
                        Le.data
                      )
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    Ue,
                    Le.width,
                    Le.height,
                    Z.depth,
                    0,
                    Le.data,
                    0,
                    0
                  )
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                )
            else
              Je
                ? pe &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    0,
                    0,
                    0,
                    Le.width,
                    Le.height,
                    Z.depth,
                    $,
                    ae,
                    Le.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ce,
                    Ue,
                    Le.width,
                    Le.height,
                    Z.depth,
                    0,
                    $,
                    ae,
                    Le.data
                  )
        } else {
          Je && rt && t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Ve[0].width, Ve[0].height)
          for (let Ce = 0, De = Ve.length; Ce < De; Ce++)
            ((Le = Ve[Ce]),
              D.format !== Fi
                ? $ !== null
                  ? Je
                    ? pe &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Ce,
                        0,
                        0,
                        Le.width,
                        Le.height,
                        $,
                        Le.data
                      )
                    : t.compressedTexImage2D(n.TEXTURE_2D, Ce, Ue, Le.width, Le.height, 0, Le.data)
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                    )
                : Je
                  ? pe &&
                    t.texSubImage2D(n.TEXTURE_2D, Ce, 0, 0, Le.width, Le.height, $, ae, Le.data)
                  : t.texImage2D(n.TEXTURE_2D, Ce, Ue, Le.width, Le.height, 0, $, ae, Le.data))
        }
      else if (D.isDataArrayTexture)
        if (Je) {
          if ((rt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ze, Ue, Z.width, Z.height, Z.depth), pe))
            if (D.layerUpdates.size > 0) {
              const Ce = uA(Z.width, Z.height, D.format, D.type)
              for (const De of D.layerUpdates) {
                const Xe = Z.data.subarray(
                  (De * Ce) / Z.data.BYTES_PER_ELEMENT,
                  ((De + 1) * Ce) / Z.data.BYTES_PER_ELEMENT
                )
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, De, Z.width, Z.height, 1, $, ae, Xe)
              }
              D.clearLayerUpdates()
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Z.width,
                Z.height,
                Z.depth,
                $,
                ae,
                Z.data
              )
        } else t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ue, Z.width, Z.height, Z.depth, 0, $, ae, Z.data)
      else if (D.isData3DTexture)
        Je
          ? (rt && t.texStorage3D(n.TEXTURE_3D, Ze, Ue, Z.width, Z.height, Z.depth),
            pe &&
              t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Z.width, Z.height, Z.depth, $, ae, Z.data))
          : t.texImage3D(n.TEXTURE_3D, 0, Ue, Z.width, Z.height, Z.depth, 0, $, ae, Z.data)
      else if (D.isFramebufferTexture) {
        if (rt)
          if (Je) t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Z.width, Z.height)
          else {
            let Ce = Z.width,
              De = Z.height
            for (let Xe = 0; Xe < Ze; Xe++)
              (t.texImage2D(n.TEXTURE_2D, Xe, Ue, Ce, De, 0, $, ae, null), (Ce >>= 1), (De >>= 1))
          }
      } else if (Ve.length > 0) {
        if (Je && rt) {
          const Ce = j(Ve[0])
          t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Ce.width, Ce.height)
        }
        for (let Ce = 0, De = Ve.length; Ce < De; Ce++)
          ((Le = Ve[Ce]),
            Je
              ? pe && t.texSubImage2D(n.TEXTURE_2D, Ce, 0, 0, $, ae, Le)
              : t.texImage2D(n.TEXTURE_2D, Ce, Ue, $, ae, Le))
        D.generateMipmaps = !1
      } else if (Je) {
        if (rt) {
          const Ce = j(Z)
          t.texStorage2D(n.TEXTURE_2D, Ze, Ue, Ce.width, Ce.height)
        }
        pe && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, $, ae, Z)
      } else t.texImage2D(n.TEXTURE_2D, 0, Ue, $, ae, Z)
      ;(y(D) && m(G), (z.__version = ue.version), D.onUpdate && D.onUpdate(D))
    }
    B.__version = D.version
  }
  function fe(B, D, Q) {
    if (D.image.length !== 6) return
    const G = be(B, D),
      X = D.source
    t.bindTexture(n.TEXTURE_CUBE_MAP, B.__webglTexture, n.TEXTURE0 + Q)
    const ue = i.get(X)
    if (X.version !== ue.__version || G === !0) {
      t.activeTexture(n.TEXTURE0 + Q)
      const z = Tt.getPrimaries(Tt.workingColorSpace),
        E = D.colorSpace === $s ? null : Tt.getPrimaries(D.colorSpace),
        N = D.colorSpace === $s || z === E ? n.NONE : n.BROWSER_DEFAULT_WEBGL
      ;(n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, D.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, D.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, N))
      const q = D.isCompressedTexture || D.image[0].isCompressedTexture,
        Z = D.image[0] && D.image[0].isDataTexture,
        $ = []
      for (let De = 0; De < 6; De++)
        (!q && !Z
          ? ($[De] = g(D.image[De], !0, r.maxCubemapSize))
          : ($[De] = Z ? D.image[De].image : D.image[De]),
          ($[De] = k(D, $[De])))
      const ae = $[0],
        Ue = s.convert(D.format, D.colorSpace),
        Le = s.convert(D.type),
        Ve = x(D.internalFormat, Ue, Le, D.colorSpace),
        Je = D.isVideoTexture !== !0,
        rt = ue.__version === void 0 || G === !0,
        pe = X.dataReady
      let Ze = S(D, ae)
      ie(n.TEXTURE_CUBE_MAP, D)
      let Ce
      if (q) {
        Je && rt && t.texStorage2D(n.TEXTURE_CUBE_MAP, Ze, Ve, ae.width, ae.height)
        for (let De = 0; De < 6; De++) {
          Ce = $[De].mipmaps
          for (let Xe = 0; Xe < Ce.length; Xe++) {
            const et = Ce[Xe]
            D.format !== Fi
              ? Ue !== null
                ? Je
                  ? pe &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                      Xe,
                      0,
                      0,
                      et.width,
                      et.height,
                      Ue,
                      et.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                      Xe,
                      Ve,
                      et.width,
                      et.height,
                      0,
                      et.data
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                  )
              : Je
                ? pe &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                    Xe,
                    0,
                    0,
                    et.width,
                    et.height,
                    Ue,
                    Le,
                    et.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                    Xe,
                    Ve,
                    et.width,
                    et.height,
                    0,
                    Ue,
                    Le,
                    et.data
                  )
          }
        }
      } else {
        if (((Ce = D.mipmaps), Je && rt)) {
          Ce.length > 0 && Ze++
          const De = j($[0])
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ze, Ve, De.width, De.height)
        }
        for (let De = 0; De < 6; De++)
          if (Z) {
            Je
              ? pe &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                  0,
                  0,
                  0,
                  $[De].width,
                  $[De].height,
                  Ue,
                  Le,
                  $[De].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                  0,
                  Ve,
                  $[De].width,
                  $[De].height,
                  0,
                  Ue,
                  Le,
                  $[De].data
                )
            for (let Xe = 0; Xe < Ce.length; Xe++) {
              const _t = Ce[Xe].image[De].image
              Je
                ? pe &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                    Xe + 1,
                    0,
                    0,
                    _t.width,
                    _t.height,
                    Ue,
                    Le,
                    _t.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                    Xe + 1,
                    Ve,
                    _t.width,
                    _t.height,
                    0,
                    Ue,
                    Le,
                    _t.data
                  )
            }
          } else {
            Je
              ? pe && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, 0, 0, Ue, Le, $[De])
              : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, Ve, Ue, Le, $[De])
            for (let Xe = 0; Xe < Ce.length; Xe++) {
              const et = Ce[Xe]
              Je
                ? pe &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + De,
                    Xe + 1,
                    0,
                    0,
                    Ue,
                    Le,
                    et.image[De]
                  )
                : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + De, Xe + 1, Ve, Ue, Le, et.image[De])
            }
          }
      }
      ;(y(D) && m(n.TEXTURE_CUBE_MAP), (ue.__version = X.version), D.onUpdate && D.onUpdate(D))
    }
    B.__version = D.version
  }
  function we(B, D, Q, G, X, ue) {
    const z = s.convert(Q.format, Q.colorSpace),
      E = s.convert(Q.type),
      N = x(Q.internalFormat, z, E, Q.colorSpace),
      q = i.get(D),
      Z = i.get(Q)
    if (((Z.__renderTarget = D), !q.__hasExternalTextures)) {
      const $ = Math.max(1, D.width >> ue),
        ae = Math.max(1, D.height >> ue)
      X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(X, ue, N, $, ae, D.depth, 0, z, E, null)
        : t.texImage2D(X, ue, N, $, ae, 0, z, E, null)
    }
    ;(t.bindFramebuffer(n.FRAMEBUFFER, B),
      H(D)
        ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, G, X, Z.__webglTexture, 0, J(D))
        : (X === n.TEXTURE_2D ||
            (X >= n.TEXTURE_CUBE_MAP_POSITIVE_X && X <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, G, X, Z.__webglTexture, ue),
      t.bindFramebuffer(n.FRAMEBUFFER, null))
  }
  function Ee(B, D, Q) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, B), D.depthBuffer)) {
      const G = D.depthTexture,
        X = G && G.isDepthTexture ? G.type : null,
        ue = _(D.stencilBuffer, X),
        z = D.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        E = J(D)
      ;(H(D)
        ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, E, ue, D.width, D.height)
        : Q
          ? n.renderbufferStorageMultisample(n.RENDERBUFFER, E, ue, D.width, D.height)
          : n.renderbufferStorage(n.RENDERBUFFER, ue, D.width, D.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, z, n.RENDERBUFFER, B))
    } else {
      const G = D.textures
      for (let X = 0; X < G.length; X++) {
        const ue = G[X],
          z = s.convert(ue.format, ue.colorSpace),
          E = s.convert(ue.type),
          N = x(ue.internalFormat, z, E, ue.colorSpace),
          q = J(D)
        Q && H(D) === !1
          ? n.renderbufferStorageMultisample(n.RENDERBUFFER, q, N, D.width, D.height)
          : H(D)
            ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, q, N, D.width, D.height)
            : n.renderbufferStorage(n.RENDERBUFFER, N, D.width, D.height)
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null)
  }
  function Ie(B, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported')
    if ((t.bindFramebuffer(n.FRAMEBUFFER, B), !(D.depthTexture && D.depthTexture.isDepthTexture)))
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
    const G = i.get(D.depthTexture)
    ;((G.__renderTarget = D),
      (!G.__webglTexture ||
        D.depthTexture.image.width !== D.width ||
        D.depthTexture.image.height !== D.height) &&
        ((D.depthTexture.image.width = D.width),
        (D.depthTexture.image.height = D.height),
        (D.depthTexture.needsUpdate = !0)),
      F(D.depthTexture, 0))
    const X = G.__webglTexture,
      ue = J(D)
    if (D.depthTexture.format === Nl)
      H(D)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            X,
            0,
            ue
          )
        : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, X, 0)
    else if (D.depthTexture.format === hu)
      H(D)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            X,
            0,
            ue
          )
        : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, X, 0)
    else throw new Error('Unknown depthTexture format')
  }
  function ze(B) {
    const D = i.get(B),
      Q = B.isWebGLCubeRenderTarget === !0
    if (D.__boundDepthTexture !== B.depthTexture) {
      const G = B.depthTexture
      if ((D.__depthDisposeCallback && D.__depthDisposeCallback(), G)) {
        const X = () => {
          ;(delete D.__boundDepthTexture,
            delete D.__depthDisposeCallback,
            G.removeEventListener('dispose', X))
        }
        ;(G.addEventListener('dispose', X), (D.__depthDisposeCallback = X))
      }
      D.__boundDepthTexture = G
    }
    if (B.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (Q) throw new Error('target.depthTexture not supported in Cube render targets')
      Ie(D.__webglFramebuffer, B)
    } else if (Q) {
      D.__webglDepthbuffer = []
      for (let G = 0; G < 6; G++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer[G]),
          D.__webglDepthbuffer[G] === void 0)
        )
          ((D.__webglDepthbuffer[G] = n.createRenderbuffer()), Ee(D.__webglDepthbuffer[G], B, !1))
        else {
          const X = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
            ue = D.__webglDepthbuffer[G]
          ;(n.bindRenderbuffer(n.RENDERBUFFER, ue),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, X, n.RENDERBUFFER, ue))
        }
    } else if (
      (t.bindFramebuffer(n.FRAMEBUFFER, D.__webglFramebuffer), D.__webglDepthbuffer === void 0)
    )
      ((D.__webglDepthbuffer = n.createRenderbuffer()), Ee(D.__webglDepthbuffer, B, !1))
    else {
      const G = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        X = D.__webglDepthbuffer
      ;(n.bindRenderbuffer(n.RENDERBUFFER, X),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, G, n.RENDERBUFFER, X))
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null)
  }
  function Be(B, D, Q) {
    const G = i.get(B)
    ;(D !== void 0 && we(G.__webglFramebuffer, B, B.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
      Q !== void 0 && ze(B))
  }
  function it(B) {
    const D = B.texture,
      Q = i.get(B),
      G = i.get(D)
    B.addEventListener('dispose', A)
    const X = B.textures,
      ue = B.isWebGLCubeRenderTarget === !0,
      z = X.length > 1
    if (
      (z ||
        (G.__webglTexture === void 0 && (G.__webglTexture = n.createTexture()),
        (G.__version = D.version),
        o.memory.textures++),
      ue)
    ) {
      Q.__webglFramebuffer = []
      for (let E = 0; E < 6; E++)
        if (D.mipmaps && D.mipmaps.length > 0) {
          Q.__webglFramebuffer[E] = []
          for (let N = 0; N < D.mipmaps.length; N++)
            Q.__webglFramebuffer[E][N] = n.createFramebuffer()
        } else Q.__webglFramebuffer[E] = n.createFramebuffer()
    } else {
      if (D.mipmaps && D.mipmaps.length > 0) {
        Q.__webglFramebuffer = []
        for (let E = 0; E < D.mipmaps.length; E++) Q.__webglFramebuffer[E] = n.createFramebuffer()
      } else Q.__webglFramebuffer = n.createFramebuffer()
      if (z)
        for (let E = 0, N = X.length; E < N; E++) {
          const q = i.get(X[E])
          q.__webglTexture === void 0 &&
            ((q.__webglTexture = n.createTexture()), o.memory.textures++)
        }
      if (B.samples > 0 && H(B) === !1) {
        ;((Q.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (Q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, Q.__webglMultisampledFramebuffer))
        for (let E = 0; E < X.length; E++) {
          const N = X[E]
          ;((Q.__webglColorRenderbuffer[E] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, Q.__webglColorRenderbuffer[E]))
          const q = s.convert(N.format, N.colorSpace),
            Z = s.convert(N.type),
            $ = x(N.internalFormat, q, Z, N.colorSpace, B.isXRRenderTarget === !0),
            ae = J(B)
          ;(n.renderbufferStorageMultisample(n.RENDERBUFFER, ae, $, B.width, B.height),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + E,
              n.RENDERBUFFER,
              Q.__webglColorRenderbuffer[E]
            ))
        }
        ;(n.bindRenderbuffer(n.RENDERBUFFER, null),
          B.depthBuffer &&
            ((Q.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Ee(Q.__webglDepthRenderbuffer, B, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null))
      }
    }
    if (ue) {
      ;(t.bindTexture(n.TEXTURE_CUBE_MAP, G.__webglTexture), ie(n.TEXTURE_CUBE_MAP, D))
      for (let E = 0; E < 6; E++)
        if (D.mipmaps && D.mipmaps.length > 0)
          for (let N = 0; N < D.mipmaps.length; N++)
            we(
              Q.__webglFramebuffer[E][N],
              B,
              D,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + E,
              N
            )
        else
          we(
            Q.__webglFramebuffer[E],
            B,
            D,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + E,
            0
          )
      ;(y(D) && m(n.TEXTURE_CUBE_MAP), t.unbindTexture())
    } else if (z) {
      for (let E = 0, N = X.length; E < N; E++) {
        const q = X[E],
          Z = i.get(q)
        ;(t.bindTexture(n.TEXTURE_2D, Z.__webglTexture),
          ie(n.TEXTURE_2D, q),
          we(Q.__webglFramebuffer, B, q, n.COLOR_ATTACHMENT0 + E, n.TEXTURE_2D, 0),
          y(q) && m(n.TEXTURE_2D))
      }
      t.unbindTexture()
    } else {
      let E = n.TEXTURE_2D
      if (
        ((B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) &&
          (E = B.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(E, G.__webglTexture),
        ie(E, D),
        D.mipmaps && D.mipmaps.length > 0)
      )
        for (let N = 0; N < D.mipmaps.length; N++)
          we(Q.__webglFramebuffer[N], B, D, n.COLOR_ATTACHMENT0, E, N)
      else we(Q.__webglFramebuffer, B, D, n.COLOR_ATTACHMENT0, E, 0)
      ;(y(D) && m(E), t.unbindTexture())
    }
    B.depthBuffer && ze(B)
  }
  function te(B) {
    const D = B.textures
    for (let Q = 0, G = D.length; Q < G; Q++) {
      const X = D[Q]
      if (y(X)) {
        const ue = v(B),
          z = i.get(X).__webglTexture
        ;(t.bindTexture(ue, z), m(ue), t.unbindTexture())
      }
    }
  }
  const re = [],
    b = []
  function oe(B) {
    if (B.samples > 0) {
      if (H(B) === !1) {
        const D = B.textures,
          Q = B.width,
          G = B.height
        let X = n.COLOR_BUFFER_BIT
        const ue = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
          z = i.get(B),
          E = D.length > 1
        if (E)
          for (let N = 0; N < D.length; N++)
            (t.bindFramebuffer(n.FRAMEBUFFER, z.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + N,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, z.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + N,
                n.TEXTURE_2D,
                null,
                0
              ))
        ;(t.bindFramebuffer(n.READ_FRAMEBUFFER, z.__webglMultisampledFramebuffer),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, z.__webglFramebuffer))
        for (let N = 0; N < D.length; N++) {
          if (
            (B.resolveDepthBuffer &&
              (B.depthBuffer && (X |= n.DEPTH_BUFFER_BIT),
              B.stencilBuffer && B.resolveStencilBuffer && (X |= n.STENCIL_BUFFER_BIT)),
            E)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              z.__webglColorRenderbuffer[N]
            )
            const q = i.get(D[N]).__webglTexture
            n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, q, 0)
          }
          ;(n.blitFramebuffer(0, 0, Q, G, 0, 0, Q, G, X, n.NEAREST),
            l === !0 &&
              ((re.length = 0),
              (b.length = 0),
              re.push(n.COLOR_ATTACHMENT0 + N),
              B.depthBuffer &&
                B.resolveDepthBuffer === !1 &&
                (re.push(ue), b.push(ue), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, b)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, re)))
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          E)
        )
          for (let N = 0; N < D.length; N++) {
            ;(t.bindFramebuffer(n.FRAMEBUFFER, z.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + N,
                n.RENDERBUFFER,
                z.__webglColorRenderbuffer[N]
              ))
            const q = i.get(D[N]).__webglTexture
            ;(t.bindFramebuffer(n.FRAMEBUFFER, z.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + N,
                n.TEXTURE_2D,
                q,
                0
              ))
          }
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, z.__webglMultisampledFramebuffer)
      } else if (B.depthBuffer && B.resolveDepthBuffer === !1 && l) {
        const D = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [D])
      }
    }
  }
  function J(B) {
    return Math.min(r.maxSamples, B.samples)
  }
  function H(B) {
    const D = i.get(B)
    return (
      B.samples > 0 &&
      e.has('WEBGL_multisampled_render_to_texture') === !0 &&
      D.__useRenderToTexture !== !1
    )
  }
  function P(B) {
    const D = o.render.frame
    u.get(B) !== D && (u.set(B, D), B.update())
  }
  function k(B, D) {
    const Q = B.colorSpace,
      G = B.format,
      X = B.type
    return (
      B.isCompressedTexture === !0 ||
        B.isVideoTexture === !0 ||
        (Q !== Ui &&
          Q !== $s &&
          (Tt.getTransfer(Q) === Jt
            ? (G !== Fi || X !== eo) &&
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
              )
            : console.error('THREE.WebGLTextures: Unsupported texture color space:', Q))),
      D
    )
  }
  function j(B) {
    return (
      typeof HTMLImageElement < 'u' && B instanceof HTMLImageElement
        ? ((c.width = B.naturalWidth || B.width), (c.height = B.naturalHeight || B.height))
        : typeof VideoFrame < 'u' && B instanceof VideoFrame
          ? ((c.width = B.displayWidth), (c.height = B.displayHeight))
          : ((c.width = B.width), (c.height = B.height)),
      c
    )
  }
  ;((this.allocateTextureUnit = U),
    (this.resetTextureUnits = L),
    (this.setTexture2D = F),
    (this.setTexture2DArray = V),
    (this.setTexture3D = W),
    (this.setTextureCube = ee),
    (this.rebindTextures = Be),
    (this.setupRenderTarget = it),
    (this.updateRenderTargetMipmap = te),
    (this.updateMultisampleRenderTarget = oe),
    (this.setupDepthRenderbuffer = ze),
    (this.setupFrameBufferTexture = we),
    (this.useMultisampledRTT = H))
}
function eC(n, e) {
  function t(i, r = $s) {
    let s
    const o = Tt.getTransfer(r)
    if (i === eo) return n.UNSIGNED_BYTE
    if (i === v_) return n.UNSIGNED_SHORT_4_4_4_4
    if (i === __) return n.UNSIGNED_SHORT_5_5_5_1
    if (i === b5) return n.UNSIGNED_INT_5_9_9_9_REV
    if (i === S5) return n.BYTE
    if (i === A5) return n.SHORT
    if (i === ah) return n.UNSIGNED_SHORT
    if (i === o0) return n.INT
    if (i === Ni) return n.UNSIGNED_INT
    if (i === nr) return n.FLOAT
    if (i === ws) return n.HALF_FLOAT
    if (i === T5) return n.ALPHA
    if (i === w5) return n.RGB
    if (i === Fi) return n.RGBA
    if (i === C5) return n.LUMINANCE
    if (i === E5) return n.LUMINANCE_ALPHA
    if (i === Nl) return n.DEPTH_COMPONENT
    if (i === hu) return n.DEPTH_STENCIL
    if (i === x_) return n.RED
    if (i === a0) return n.RED_INTEGER
    if (i === lh) return n.RG
    if (i === S_) return n.RG_INTEGER
    if (i === Co) return n.RGBA_INTEGER
    if (i === Mp || i === Rp || i === Ip || i === Np)
      if (o === Jt)
        if (((s = e.get('WEBGL_compressed_texture_s3tc_srgb')), s !== null)) {
          if (i === Mp) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (i === Rp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (i === Ip) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (i === Np) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null
      else if (((s = e.get('WEBGL_compressed_texture_s3tc')), s !== null)) {
        if (i === Mp) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (i === Rp) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (i === Ip) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (i === Np) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null
    if (i === hy || i === fy || i === py || i === my)
      if (((s = e.get('WEBGL_compressed_texture_pvrtc')), s !== null)) {
        if (i === hy) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (i === fy) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (i === py) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (i === my) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else return null
    if (i === gy || i === yy || i === vy)
      if (((s = e.get('WEBGL_compressed_texture_etc')), s !== null)) {
        if (i === gy || i === yy) return o === Jt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2
        if (i === vy)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
      } else return null
    if (
      i === _y ||
      i === xy ||
      i === Sy ||
      i === Ay ||
      i === by ||
      i === Ty ||
      i === wy ||
      i === Cy ||
      i === Ey ||
      i === My ||
      i === Ry ||
      i === Iy ||
      i === Ny ||
      i === Py
    )
      if (((s = e.get('WEBGL_compressed_texture_astc')), s !== null)) {
        if (i === _y)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (i === xy)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (i === Sy)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (i === Ay)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (i === by)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (i === Ty)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (i === wy)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (i === Cy)
          return o === Jt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (i === Ey)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (i === My)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (i === Ry)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (i === Iy)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (i === Ny)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (i === Py)
          return o === Jt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else return null
    if (i === Pp || i === Ly || i === Dy)
      if (((s = e.get('EXT_texture_compression_bptc')), s !== null)) {
        if (i === Pp)
          return o === Jt
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
        if (i === Ly) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT
        if (i === Dy) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
      } else return null
    if (i === M5 || i === Fy || i === Oy || i === By)
      if (((s = e.get('EXT_texture_compression_rgtc')), s !== null)) {
        if (i === Pp) return s.COMPRESSED_RED_RGTC1_EXT
        if (i === Fy) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT
        if (i === Oy) return s.COMPRESSED_RED_GREEN_RGTC2_EXT
        if (i === By) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } else return null
    return i === du ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
  }
  return { convert: t }
}
const NB = '\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}',
  PB =
    '\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n	if ( coord.x >= 1.0 ) {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n	} else {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n	}\n\n}'
class LB {
  constructor() {
    ;((this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0))
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Wn(),
        s = e.properties.get(r)
      ;((s.__webglTexture = t.texture),
        (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r))
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        i = new Nr({
          vertexShader: NB,
          fragmentShader: PB,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        })
      this.mesh = new pn(new mu(20, 20), i)
    }
    return this.mesh
  }
  reset() {
    ;((this.texture = null), (this.mesh = null))
  }
  getDepthTexture() {
    return this.texture
  }
}
class DB extends so {
  constructor(e, t) {
    super()
    const i = this
    let r = null,
      s = 1,
      o = null,
      a = 'local-floor',
      l = 1,
      c = null,
      u = null,
      d = null,
      h = null,
      f = null,
      p = null
    const g = new LB(),
      y = t.getContextAttributes()
    let m = null,
      v = null
    const x = [],
      _ = [],
      S = new je()
    let C = null
    const A = new Ki()
    A.viewport = new Mt()
    const R = new Ki()
    R.viewport = new Mt()
    const w = [A, R],
      M = new HL()
    let I = null,
      L = null
    ;((this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (le) {
        let fe = x[le]
        return (fe === void 0 && ((fe = new Pg()), (x[le] = fe)), fe.getTargetRaySpace())
      }),
      (this.getControllerGrip = function (le) {
        let fe = x[le]
        return (fe === void 0 && ((fe = new Pg()), (x[le] = fe)), fe.getGripSpace())
      }),
      (this.getHand = function (le) {
        let fe = x[le]
        return (fe === void 0 && ((fe = new Pg()), (x[le] = fe)), fe.getHandSpace())
      }))
    function U(le) {
      const fe = _.indexOf(le.inputSource)
      if (fe === -1) return
      const we = x[fe]
      we !== void 0 &&
        (we.update(le.inputSource, le.frame, c || o),
        we.dispatchEvent({ type: le.type, data: le.inputSource }))
    }
    function T() {
      ;(r.removeEventListener('select', U),
        r.removeEventListener('selectstart', U),
        r.removeEventListener('selectend', U),
        r.removeEventListener('squeeze', U),
        r.removeEventListener('squeezestart', U),
        r.removeEventListener('squeezeend', U),
        r.removeEventListener('end', T),
        r.removeEventListener('inputsourceschange', F))
      for (let le = 0; le < x.length; le++) {
        const fe = _[le]
        fe !== null && ((_[le] = null), x[le].disconnect(fe))
      }
      ;((I = null),
        (L = null),
        g.reset(),
        e.setRenderTarget(m),
        (f = null),
        (h = null),
        (d = null),
        (r = null),
        (v = null),
        be.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(C),
        e.setSize(S.width, S.height, !1),
        i.dispatchEvent({ type: 'sessionend' }))
    }
    ;((this.setFramebufferScaleFactor = function (le) {
      ;((s = le),
        i.isPresenting === !0 &&
          console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.'))
    }),
      (this.setReferenceSpaceType = function (le) {
        ;((a = le),
          i.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.'
            ))
      }),
      (this.getReferenceSpace = function () {
        return c || o
      }),
      (this.setReferenceSpace = function (le) {
        c = le
      }),
      (this.getBaseLayer = function () {
        return h !== null ? h : f
      }),
      (this.getBinding = function () {
        return d
      }),
      (this.getFrame = function () {
        return p
      }),
      (this.getSession = function () {
        return r
      }),
      (this.setSession = async function (le) {
        if (((r = le), r !== null)) {
          if (
            ((m = e.getRenderTarget()),
            r.addEventListener('select', U),
            r.addEventListener('selectstart', U),
            r.addEventListener('selectend', U),
            r.addEventListener('squeeze', U),
            r.addEventListener('squeezestart', U),
            r.addEventListener('squeezeend', U),
            r.addEventListener('end', T),
            r.addEventListener('inputsourceschange', F),
            y.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (C = e.getPixelRatio()),
            e.getSize(S),
            typeof XRWebGLBinding < 'u' && 'createProjectionLayer' in XRWebGLBinding.prototype)
          ) {
            let we = null,
              Ee = null,
              Ie = null
            y.depth &&
              ((Ie = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (we = y.stencil ? hu : Nl),
              (Ee = y.stencil ? du : Ni))
            const ze = { colorFormat: t.RGBA8, depthFormat: Ie, scaleFactor: s }
            ;((d = new XRWebGLBinding(r, t)),
              (h = d.createProjectionLayer(ze)),
              r.updateRenderState({ layers: [h] }),
              e.setPixelRatio(1),
              e.setSize(h.textureWidth, h.textureHeight, !1),
              (v = new Ua(h.textureWidth, h.textureHeight, {
                format: Fi,
                type: eo,
                depthTexture: new Ha(
                  h.textureWidth,
                  h.textureHeight,
                  Ee,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  we
                ),
                stencilBuffer: y.stencil,
                colorSpace: e.outputColorSpace,
                samples: y.antialias ? 4 : 0,
                resolveDepthBuffer: h.ignoreDepthValues === !1,
              })))
          } else {
            const we = {
              antialias: y.antialias,
              alpha: !0,
              depth: y.depth,
              stencil: y.stencil,
              framebufferScaleFactor: s,
            }
            ;((f = new XRWebGLLayer(r, t, we)),
              r.updateRenderState({ baseLayer: f }),
              e.setPixelRatio(1),
              e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
              (v = new Ua(f.framebufferWidth, f.framebufferHeight, {
                format: Fi,
                type: eo,
                colorSpace: e.outputColorSpace,
                stencilBuffer: y.stencil,
              })))
          }
          ;((v.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await r.requestReferenceSpace(a)),
            be.setContext(r),
            be.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: 'sessionstart' }))
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode
      }),
      (this.getDepthTexture = function () {
        return g.getDepthTexture()
      }))
    function F(le) {
      for (let fe = 0; fe < le.removed.length; fe++) {
        const we = le.removed[fe],
          Ee = _.indexOf(we)
        Ee >= 0 && ((_[Ee] = null), x[Ee].disconnect(we))
      }
      for (let fe = 0; fe < le.added.length; fe++) {
        const we = le.added[fe]
        let Ee = _.indexOf(we)
        if (Ee === -1) {
          for (let ze = 0; ze < x.length; ze++)
            if (ze >= _.length) {
              ;(_.push(we), (Ee = ze))
              break
            } else if (_[ze] === null) {
              ;((_[ze] = we), (Ee = ze))
              break
            }
          if (Ee === -1) break
        }
        const Ie = x[Ee]
        Ie && Ie.connect(we)
      }
    }
    const V = new Y(),
      W = new Y()
    function ee(le, fe, we) {
      ;(V.setFromMatrixPosition(fe.matrixWorld), W.setFromMatrixPosition(we.matrixWorld))
      const Ee = V.distanceTo(W),
        Ie = fe.projectionMatrix.elements,
        ze = we.projectionMatrix.elements,
        Be = Ie[14] / (Ie[10] - 1),
        it = Ie[14] / (Ie[10] + 1),
        te = (Ie[9] + 1) / Ie[5],
        re = (Ie[9] - 1) / Ie[5],
        b = (Ie[8] - 1) / Ie[0],
        oe = (ze[8] + 1) / ze[0],
        J = Be * b,
        H = Be * oe,
        P = Ee / (-b + oe),
        k = P * -b
      if (
        (fe.matrixWorld.decompose(le.position, le.quaternion, le.scale),
        le.translateX(k),
        le.translateZ(P),
        le.matrixWorld.compose(le.position, le.quaternion, le.scale),
        le.matrixWorldInverse.copy(le.matrixWorld).invert(),
        Ie[10] === -1)
      )
        (le.projectionMatrix.copy(fe.projectionMatrix),
          le.projectionMatrixInverse.copy(fe.projectionMatrixInverse))
      else {
        const j = Be + P,
          B = it + P,
          D = J - k,
          Q = H + (Ee - k),
          G = ((te * it) / B) * j,
          X = ((re * it) / B) * j
        ;(le.projectionMatrix.makePerspective(D, Q, G, X, j, B),
          le.projectionMatrixInverse.copy(le.projectionMatrix).invert())
      }
    }
    function se(le, fe) {
      ;(fe === null
        ? le.matrixWorld.copy(le.matrix)
        : le.matrixWorld.multiplyMatrices(fe.matrixWorld, le.matrix),
        le.matrixWorldInverse.copy(le.matrixWorld).invert())
    }
    this.updateCamera = function (le) {
      if (r === null) return
      let fe = le.near,
        we = le.far
      ;(g.texture !== null &&
        (g.depthNear > 0 && (fe = g.depthNear), g.depthFar > 0 && (we = g.depthFar)),
        (M.near = R.near = A.near = fe),
        (M.far = R.far = A.far = we),
        (I !== M.near || L !== M.far) &&
          (r.updateRenderState({ depthNear: M.near, depthFar: M.far }), (I = M.near), (L = M.far)),
        (A.layers.mask = le.layers.mask | 2),
        (R.layers.mask = le.layers.mask | 4),
        (M.layers.mask = A.layers.mask | R.layers.mask))
      const Ee = le.parent,
        Ie = M.cameras
      se(M, Ee)
      for (let ze = 0; ze < Ie.length; ze++) se(Ie[ze], Ee)
      ;(Ie.length === 2 ? ee(M, A, R) : M.projectionMatrix.copy(A.projectionMatrix), he(le, M, Ee))
    }
    function he(le, fe, we) {
      ;(we === null
        ? le.matrix.copy(fe.matrixWorld)
        : (le.matrix.copy(we.matrixWorld), le.matrix.invert(), le.matrix.multiply(fe.matrixWorld)),
        le.matrix.decompose(le.position, le.quaternion, le.scale),
        le.updateMatrixWorld(!0),
        le.projectionMatrix.copy(fe.projectionMatrix),
        le.projectionMatrixInverse.copy(fe.projectionMatrixInverse),
        le.isPerspectiveCamera &&
          ((le.fov = fu * 2 * Math.atan(1 / le.projectionMatrix.elements[5])), (le.zoom = 1)))
    }
    ;((this.getCamera = function () {
      return M
    }),
      (this.getFoveation = function () {
        if (!(h === null && f === null)) return l
      }),
      (this.setFoveation = function (le) {
        ;((l = le),
          h !== null && (h.fixedFoveation = le),
          f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = le))
      }),
      (this.hasDepthSensing = function () {
        return g.texture !== null
      }),
      (this.getDepthSensingMesh = function () {
        return g.getMesh(M)
      }))
    let ne = null
    function ie(le, fe) {
      if (((u = fe.getViewerPose(c || o)), (p = fe), u !== null)) {
        const we = u.views
        f !== null && (e.setRenderTargetFramebuffer(v, f.framebuffer), e.setRenderTarget(v))
        let Ee = !1
        we.length !== M.cameras.length && ((M.cameras.length = 0), (Ee = !0))
        for (let Be = 0; Be < we.length; Be++) {
          const it = we[Be]
          let te = null
          if (f !== null) te = f.getViewport(it)
          else {
            const b = d.getViewSubImage(h, it)
            ;((te = b.viewport),
              Be === 0 &&
                (e.setRenderTargetTextures(
                  v,
                  b.colorTexture,
                  h.ignoreDepthValues ? void 0 : b.depthStencilTexture
                ),
                e.setRenderTarget(v)))
          }
          let re = w[Be]
          ;(re === void 0 &&
            ((re = new Ki()), re.layers.enable(Be), (re.viewport = new Mt()), (w[Be] = re)),
            re.matrix.fromArray(it.transform.matrix),
            re.matrix.decompose(re.position, re.quaternion, re.scale),
            re.projectionMatrix.fromArray(it.projectionMatrix),
            re.projectionMatrixInverse.copy(re.projectionMatrix).invert(),
            re.viewport.set(te.x, te.y, te.width, te.height),
            Be === 0 &&
              (M.matrix.copy(re.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)),
            Ee === !0 && M.cameras.push(re))
        }
        const Ie = r.enabledFeatures
        if (Ie && Ie.includes('depth-sensing') && r.depthUsage == 'gpu-optimized' && d) {
          const Be = d.getDepthInformation(we[0])
          Be && Be.isValid && Be.texture && g.init(e, Be, r.renderState)
        }
      }
      for (let we = 0; we < x.length; we++) {
        const Ee = _[we],
          Ie = x[we]
        Ee !== null && Ie !== void 0 && Ie.update(Ee, fe, c || o)
      }
      ;(ne && ne(le, fe),
        fe.detectedPlanes && i.dispatchEvent({ type: 'planesdetected', data: fe }),
        (p = null))
    }
    const be = new X5()
    ;(be.setAnimationLoop(ie),
      (this.setAnimationLoop = function (le) {
        ne = le
      }),
      (this.dispose = function () {}))
  }
}
const sl = new Cs(),
  FB = new qe()
function OB(n, e) {
  function t(y, m) {
    ;(y.matrixAutoUpdate === !0 && y.updateMatrix(), m.value.copy(y.matrix))
  }
  function i(y, m) {
    ;(m.color.getRGB(y.fogColor.value, k5(n)),
      m.isFog
        ? ((y.fogNear.value = m.near), (y.fogFar.value = m.far))
        : m.isFogExp2 && (y.fogDensity.value = m.density))
  }
  function r(y, m, v, x, _) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? s(y, m)
      : m.isMeshToonMaterial
        ? (s(y, m), d(y, m))
        : m.isMeshPhongMaterial
          ? (s(y, m), u(y, m))
          : m.isMeshStandardMaterial
            ? (s(y, m), h(y, m), m.isMeshPhysicalMaterial && f(y, m, _))
            : m.isMeshMatcapMaterial
              ? (s(y, m), p(y, m))
              : m.isMeshDepthMaterial
                ? s(y, m)
                : m.isMeshDistanceMaterial
                  ? (s(y, m), g(y, m))
                  : m.isMeshNormalMaterial
                    ? s(y, m)
                    : m.isLineBasicMaterial
                      ? (o(y, m), m.isLineDashedMaterial && a(y, m))
                      : m.isPointsMaterial
                        ? l(y, m, v, x)
                        : m.isSpriteMaterial
                          ? c(y, m)
                          : m.isShadowMaterial
                            ? (y.color.value.copy(m.color), (y.opacity.value = m.opacity))
                            : m.isShaderMaterial && (m.uniformsNeedUpdate = !1)
  }
  function s(y, m) {
    ;((y.opacity.value = m.opacity),
      m.color && y.diffuse.value.copy(m.color),
      m.emissive && y.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((y.map.value = m.map), t(m.map, y.mapTransform)),
      m.alphaMap && ((y.alphaMap.value = m.alphaMap), t(m.alphaMap, y.alphaMapTransform)),
      m.bumpMap &&
        ((y.bumpMap.value = m.bumpMap),
        t(m.bumpMap, y.bumpMapTransform),
        (y.bumpScale.value = m.bumpScale),
        m.side === Oi && (y.bumpScale.value *= -1)),
      m.normalMap &&
        ((y.normalMap.value = m.normalMap),
        t(m.normalMap, y.normalMapTransform),
        y.normalScale.value.copy(m.normalScale),
        m.side === Oi && y.normalScale.value.negate()),
      m.displacementMap &&
        ((y.displacementMap.value = m.displacementMap),
        t(m.displacementMap, y.displacementMapTransform),
        (y.displacementScale.value = m.displacementScale),
        (y.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((y.emissiveMap.value = m.emissiveMap), t(m.emissiveMap, y.emissiveMapTransform)),
      m.specularMap &&
        ((y.specularMap.value = m.specularMap), t(m.specularMap, y.specularMapTransform)),
      m.alphaTest > 0 && (y.alphaTest.value = m.alphaTest))
    const v = e.get(m),
      x = v.envMap,
      _ = v.envMapRotation
    ;(x &&
      ((y.envMap.value = x),
      sl.copy(_),
      (sl.x *= -1),
      (sl.y *= -1),
      (sl.z *= -1),
      x.isCubeTexture && x.isRenderTargetTexture === !1 && ((sl.y *= -1), (sl.z *= -1)),
      y.envMapRotation.value.setFromMatrix4(FB.makeRotationFromEuler(sl)),
      (y.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
      (y.reflectivity.value = m.reflectivity),
      (y.ior.value = m.ior),
      (y.refractionRatio.value = m.refractionRatio)),
      m.lightMap &&
        ((y.lightMap.value = m.lightMap),
        (y.lightMapIntensity.value = m.lightMapIntensity),
        t(m.lightMap, y.lightMapTransform)),
      m.aoMap &&
        ((y.aoMap.value = m.aoMap),
        (y.aoMapIntensity.value = m.aoMapIntensity),
        t(m.aoMap, y.aoMapTransform)))
  }
  function o(y, m) {
    ;(y.diffuse.value.copy(m.color),
      (y.opacity.value = m.opacity),
      m.map && ((y.map.value = m.map), t(m.map, y.mapTransform)))
  }
  function a(y, m) {
    ;((y.dashSize.value = m.dashSize),
      (y.totalSize.value = m.dashSize + m.gapSize),
      (y.scale.value = m.scale))
  }
  function l(y, m, v, x) {
    ;(y.diffuse.value.copy(m.color),
      (y.opacity.value = m.opacity),
      (y.size.value = m.size * v),
      (y.scale.value = x * 0.5),
      m.map && ((y.map.value = m.map), t(m.map, y.uvTransform)),
      m.alphaMap && ((y.alphaMap.value = m.alphaMap), t(m.alphaMap, y.alphaMapTransform)),
      m.alphaTest > 0 && (y.alphaTest.value = m.alphaTest))
  }
  function c(y, m) {
    ;(y.diffuse.value.copy(m.color),
      (y.opacity.value = m.opacity),
      (y.rotation.value = m.rotation),
      m.map && ((y.map.value = m.map), t(m.map, y.mapTransform)),
      m.alphaMap && ((y.alphaMap.value = m.alphaMap), t(m.alphaMap, y.alphaMapTransform)),
      m.alphaTest > 0 && (y.alphaTest.value = m.alphaTest))
  }
  function u(y, m) {
    ;(y.specular.value.copy(m.specular), (y.shininess.value = Math.max(m.shininess, 1e-4)))
  }
  function d(y, m) {
    m.gradientMap && (y.gradientMap.value = m.gradientMap)
  }
  function h(y, m) {
    ;((y.metalness.value = m.metalness),
      m.metalnessMap &&
        ((y.metalnessMap.value = m.metalnessMap), t(m.metalnessMap, y.metalnessMapTransform)),
      (y.roughness.value = m.roughness),
      m.roughnessMap &&
        ((y.roughnessMap.value = m.roughnessMap), t(m.roughnessMap, y.roughnessMapTransform)),
      m.envMap && (y.envMapIntensity.value = m.envMapIntensity))
  }
  function f(y, m, v) {
    ;((y.ior.value = m.ior),
      m.sheen > 0 &&
        (y.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (y.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((y.sheenColorMap.value = m.sheenColorMap), t(m.sheenColorMap, y.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((y.sheenRoughnessMap.value = m.sheenRoughnessMap),
          t(m.sheenRoughnessMap, y.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((y.clearcoat.value = m.clearcoat),
        (y.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((y.clearcoatMap.value = m.clearcoatMap), t(m.clearcoatMap, y.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((y.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          t(m.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((y.clearcoatNormalMap.value = m.clearcoatNormalMap),
          t(m.clearcoatNormalMap, y.clearcoatNormalMapTransform),
          y.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === Oi && y.clearcoatNormalScale.value.negate())),
      m.dispersion > 0 && (y.dispersion.value = m.dispersion),
      m.iridescence > 0 &&
        ((y.iridescence.value = m.iridescence),
        (y.iridescenceIOR.value = m.iridescenceIOR),
        (y.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (y.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((y.iridescenceMap.value = m.iridescenceMap),
          t(m.iridescenceMap, y.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((y.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          t(m.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((y.transmission.value = m.transmission),
        (y.transmissionSamplerMap.value = v.texture),
        y.transmissionSamplerSize.value.set(v.width, v.height),
        m.transmissionMap &&
          ((y.transmissionMap.value = m.transmissionMap),
          t(m.transmissionMap, y.transmissionMapTransform)),
        (y.thickness.value = m.thickness),
        m.thicknessMap &&
          ((y.thicknessMap.value = m.thicknessMap), t(m.thicknessMap, y.thicknessMapTransform)),
        (y.attenuationDistance.value = m.attenuationDistance),
        y.attenuationColor.value.copy(m.attenuationColor)),
      m.anisotropy > 0 &&
        (y.anisotropyVector.value.set(
          m.anisotropy * Math.cos(m.anisotropyRotation),
          m.anisotropy * Math.sin(m.anisotropyRotation)
        ),
        m.anisotropyMap &&
          ((y.anisotropyMap.value = m.anisotropyMap),
          t(m.anisotropyMap, y.anisotropyMapTransform))),
      (y.specularIntensity.value = m.specularIntensity),
      y.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((y.specularColorMap.value = m.specularColorMap),
        t(m.specularColorMap, y.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((y.specularIntensityMap.value = m.specularIntensityMap),
        t(m.specularIntensityMap, y.specularIntensityMapTransform)))
  }
  function p(y, m) {
    m.matcap && (y.matcap.value = m.matcap)
  }
  function g(y, m) {
    const v = e.get(m).light
    ;(y.referencePosition.value.setFromMatrixPosition(v.matrixWorld),
      (y.nearDistance.value = v.shadow.camera.near),
      (y.farDistance.value = v.shadow.camera.far))
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r }
}
function BB(n, e, t, i) {
  let r = {},
    s = {},
    o = []
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS)
  function l(v, x) {
    const _ = x.program
    i.uniformBlockBinding(v, _)
  }
  function c(v, x) {
    let _ = r[v.id]
    _ === void 0 && (p(v), (_ = u(v)), (r[v.id] = _), v.addEventListener('dispose', y))
    const S = x.program
    i.updateUBOMapping(v, S)
    const C = e.render.frame
    s[v.id] !== C && (h(v), (s[v.id] = C))
  }
  function u(v) {
    const x = d()
    v.__bindingPointIndex = x
    const _ = n.createBuffer(),
      S = v.__size,
      C = v.usage
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, _),
      n.bufferData(n.UNIFORM_BUFFER, S, C),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, x, _),
      _
    )
  }
  function d() {
    for (let v = 0; v < a; v++) if (o.indexOf(v) === -1) return (o.push(v), v)
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
      ),
      0
    )
  }
  function h(v) {
    const x = r[v.id],
      _ = v.uniforms,
      S = v.__cache
    n.bindBuffer(n.UNIFORM_BUFFER, x)
    for (let C = 0, A = _.length; C < A; C++) {
      const R = Array.isArray(_[C]) ? _[C] : [_[C]]
      for (let w = 0, M = R.length; w < M; w++) {
        const I = R[w]
        if (f(I, C, w, S) === !0) {
          const L = I.__offset,
            U = Array.isArray(I.value) ? I.value : [I.value]
          let T = 0
          for (let F = 0; F < U.length; F++) {
            const V = U[F],
              W = g(V)
            typeof V == 'number' || typeof V == 'boolean'
              ? ((I.__data[0] = V), n.bufferSubData(n.UNIFORM_BUFFER, L + T, I.__data))
              : V.isMatrix3
                ? ((I.__data[0] = V.elements[0]),
                  (I.__data[1] = V.elements[1]),
                  (I.__data[2] = V.elements[2]),
                  (I.__data[3] = 0),
                  (I.__data[4] = V.elements[3]),
                  (I.__data[5] = V.elements[4]),
                  (I.__data[6] = V.elements[5]),
                  (I.__data[7] = 0),
                  (I.__data[8] = V.elements[6]),
                  (I.__data[9] = V.elements[7]),
                  (I.__data[10] = V.elements[8]),
                  (I.__data[11] = 0))
                : (V.toArray(I.__data, T), (T += W.storage / Float32Array.BYTES_PER_ELEMENT))
          }
          n.bufferSubData(n.UNIFORM_BUFFER, L, I.__data)
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null)
  }
  function f(v, x, _, S) {
    const C = v.value,
      A = x + '_' + _
    if (S[A] === void 0)
      return (typeof C == 'number' || typeof C == 'boolean' ? (S[A] = C) : (S[A] = C.clone()), !0)
    {
      const R = S[A]
      if (typeof C == 'number' || typeof C == 'boolean') {
        if (R !== C) return ((S[A] = C), !0)
      } else if (R.equals(C) === !1) return (R.copy(C), !0)
    }
    return !1
  }
  function p(v) {
    const x = v.uniforms
    let _ = 0
    const S = 16
    for (let A = 0, R = x.length; A < R; A++) {
      const w = Array.isArray(x[A]) ? x[A] : [x[A]]
      for (let M = 0, I = w.length; M < I; M++) {
        const L = w[M],
          U = Array.isArray(L.value) ? L.value : [L.value]
        for (let T = 0, F = U.length; T < F; T++) {
          const V = U[T],
            W = g(V),
            ee = _ % S,
            se = ee % W.boundary,
            he = ee + se
          ;((_ += se),
            he !== 0 && S - he < W.storage && (_ += S - he),
            (L.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT)),
            (L.__offset = _),
            (_ += W.storage))
        }
      }
    }
    const C = _ % S
    return (C > 0 && (_ += S - C), (v.__size = _), (v.__cache = {}), this)
  }
  function g(v) {
    const x = { boundary: 0, storage: 0 }
    return (
      typeof v == 'number' || typeof v == 'boolean'
        ? ((x.boundary = 4), (x.storage = 4))
        : v.isVector2
          ? ((x.boundary = 8), (x.storage = 8))
          : v.isVector3 || v.isColor
            ? ((x.boundary = 16), (x.storage = 12))
            : v.isVector4
              ? ((x.boundary = 16), (x.storage = 16))
              : v.isMatrix3
                ? ((x.boundary = 48), (x.storage = 48))
                : v.isMatrix4
                  ? ((x.boundary = 64), (x.storage = 64))
                  : v.isTexture
                    ? console.warn(
                        'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                      )
                    : console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', v),
      x
    )
  }
  function y(v) {
    const x = v.target
    x.removeEventListener('dispose', y)
    const _ = o.indexOf(x.__bindingPointIndex)
    ;(o.splice(_, 1), n.deleteBuffer(r[x.id]), delete r[x.id], delete s[x.id])
  }
  function m() {
    for (const v in r) n.deleteBuffer(r[v])
    ;((o = []), (r = {}), (s = {}))
  }
  return { bind: l, update: c, dispose: m }
}
class UB {
  constructor(e = {}) {
    const {
      canvas: t = LP(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = 'default',
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: h = !1,
    } = e
    this.isWebGLRenderer = !0
    let f
    if (i !== null) {
      if (typeof WebGLRenderingContext < 'u' && i instanceof WebGLRenderingContext)
        throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.')
      f = i.getContextAttributes().alpha
    } else f = o
    const p = new Uint32Array(4),
      g = new Int32Array(4)
    let y = null,
      m = null
    const v = [],
      x = []
    ;((this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = fi),
      (this.toneMapping = _s),
      (this.toneMappingExposure = 1))
    const _ = this
    let S = !1,
      C = 0,
      A = 0,
      R = null,
      w = -1,
      M = null
    const I = new Mt(),
      L = new Mt()
    let U = null
    const T = new gt(0)
    let F = 0,
      V = t.width,
      W = t.height,
      ee = 1,
      se = null,
      he = null
    const ne = new Mt(0, 0, V, W),
      ie = new Mt(0, 0, V, W)
    let be = !1
    const le = new C_()
    let fe = !1,
      we = !1
    this.transmissionResolutionScale = 1
    const Ee = new qe(),
      Ie = new qe(),
      ze = new Y(),
      Be = new Mt(),
      it = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }
    let te = !1
    function re() {
      return R === null ? ee : 1
    }
    let b = i
    function oe(K, ge) {
      return t.getContext(K, ge)
    }
    try {
      const K = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      }
      if (
        ('setAttribute' in t && t.setAttribute('data-engine', 'three.js r'.concat(g_)),
        t.addEventListener('webglcontextlost', De, !1),
        t.addEventListener('webglcontextrestored', Xe, !1),
        t.addEventListener('webglcontextcreationerror', et, !1),
        b === null)
      ) {
        const ge = 'webgl2'
        if (((b = oe(ge, K)), b === null))
          throw oe(ge)
            ? new Error('Error creating WebGL context with your selected attributes.')
            : new Error('Error creating WebGL context.')
      }
    } catch (K) {
      throw (console.error('THREE.WebGLRenderer: ' + K.message), K)
    }
    let J, H, P, k, j, B, D, Q, G, X, ue, z, E, N, q, Z, $, ae, Ue, Le, Ve, Je, rt, pe
    function Ze() {
      ;((J = new X7(b)),
        J.init(),
        (Je = new eC(b, J)),
        (H = new $7(b, J, e, Je)),
        (P = new RB(b, J)),
        H.reverseDepthBuffer && h && P.buffers.depth.setReversed(!0),
        (k = new Z7(b)),
        (j = new gB()),
        (B = new IB(b, J, P, j, H, Je, k)),
        (D = new W7(_)),
        (Q = new q7(_)),
        (G = new sD(b)),
        (rt = new V7(b, G)),
        (X = new K7(b, G, k, rt)),
        (ue = new eO(b, X, G, k)),
        (Ue = new J7(b, H, B)),
        (Z = new G7(j)),
        (z = new mB(_, D, Q, J, H, rt, Z)),
        (E = new OB(_, j)),
        (N = new vB()),
        (q = new TB(J)),
        (ae = new z7(_, D, Q, P, ue, f, l)),
        ($ = new EB(_, ue, H)),
        (pe = new BB(b, k, H, P)),
        (Le = new H7(b, J, k)),
        (Ve = new Y7(b, J, k)),
        (k.programs = z.programs),
        (_.capabilities = H),
        (_.extensions = J),
        (_.properties = j),
        (_.renderLists = N),
        (_.shadowMap = $),
        (_.state = P),
        (_.info = k))
    }
    Ze()
    const Ce = new DB(_, b)
    ;((this.xr = Ce),
      (this.getContext = function () {
        return b
      }),
      (this.getContextAttributes = function () {
        return b.getContextAttributes()
      }),
      (this.forceContextLoss = function () {
        const K = J.get('WEBGL_lose_context')
        K && K.loseContext()
      }),
      (this.forceContextRestore = function () {
        const K = J.get('WEBGL_lose_context')
        K && K.restoreContext()
      }),
      (this.getPixelRatio = function () {
        return ee
      }),
      (this.setPixelRatio = function (K) {
        K !== void 0 && ((ee = K), this.setSize(V, W, !1))
      }),
      (this.getSize = function (K) {
        return K.set(V, W)
      }),
      (this.setSize = function (K, ge, Se = !0) {
        if (Ce.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
          return
        }
        ;((V = K),
          (W = ge),
          (t.width = Math.floor(K * ee)),
          (t.height = Math.floor(ge * ee)),
          Se === !0 && ((t.style.width = K + 'px'), (t.style.height = ge + 'px')),
          this.setViewport(0, 0, K, ge))
      }),
      (this.getDrawingBufferSize = function (K) {
        return K.set(V * ee, W * ee).floor()
      }),
      (this.setDrawingBufferSize = function (K, ge, Se) {
        ;((V = K),
          (W = ge),
          (ee = Se),
          (t.width = Math.floor(K * Se)),
          (t.height = Math.floor(ge * Se)),
          this.setViewport(0, 0, K, ge))
      }),
      (this.getCurrentViewport = function (K) {
        return K.copy(I)
      }),
      (this.getViewport = function (K) {
        return K.copy(ne)
      }),
      (this.setViewport = function (K, ge, Se, Ae) {
        ;(K.isVector4 ? ne.set(K.x, K.y, K.z, K.w) : ne.set(K, ge, Se, Ae),
          P.viewport(I.copy(ne).multiplyScalar(ee).round()))
      }),
      (this.getScissor = function (K) {
        return K.copy(ie)
      }),
      (this.setScissor = function (K, ge, Se, Ae) {
        ;(K.isVector4 ? ie.set(K.x, K.y, K.z, K.w) : ie.set(K, ge, Se, Ae),
          P.scissor(L.copy(ie).multiplyScalar(ee).round()))
      }),
      (this.getScissorTest = function () {
        return be
      }),
      (this.setScissorTest = function (K) {
        P.setScissorTest((be = K))
      }),
      (this.setOpaqueSort = function (K) {
        se = K
      }),
      (this.setTransparentSort = function (K) {
        he = K
      }),
      (this.getClearColor = function (K) {
        return K.copy(ae.getClearColor())
      }),
      (this.setClearColor = function () {
        ae.setClearColor.apply(ae, arguments)
      }),
      (this.getClearAlpha = function () {
        return ae.getClearAlpha()
      }),
      (this.setClearAlpha = function () {
        ae.setClearAlpha.apply(ae, arguments)
      }),
      (this.clear = function (K = !0, ge = !0, Se = !0) {
        let Ae = 0
        if (K) {
          let ye = !1
          if (R !== null) {
            const $e = R.texture.format
            ye = $e === Co || $e === S_ || $e === a0
          }
          if (ye) {
            const $e = R.texture.type,
              nt = $e === eo || $e === Ni || $e === ah || $e === du || $e === v_ || $e === __,
              ot = ae.getClearColor(),
              at = ae.getClearAlpha(),
              St = ot.r,
              bt = ot.g,
              ht = ot.b
            nt
              ? ((p[0] = St),
                (p[1] = bt),
                (p[2] = ht),
                (p[3] = at),
                b.clearBufferuiv(b.COLOR, 0, p))
              : ((g[0] = St), (g[1] = bt), (g[2] = ht), (g[3] = at), b.clearBufferiv(b.COLOR, 0, g))
          } else Ae |= b.COLOR_BUFFER_BIT
        }
        ;(ge && (Ae |= b.DEPTH_BUFFER_BIT),
          Se && ((Ae |= b.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
          b.clear(Ae))
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1)
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }),
      (this.dispose = function () {
        ;(t.removeEventListener('webglcontextlost', De, !1),
          t.removeEventListener('webglcontextrestored', Xe, !1),
          t.removeEventListener('webglcontextcreationerror', et, !1),
          ae.dispose(),
          N.dispose(),
          q.dispose(),
          j.dispose(),
          D.dispose(),
          Q.dispose(),
          ue.dispose(),
          rt.dispose(),
          pe.dispose(),
          z.dispose(),
          Ce.dispose(),
          Ce.removeEventListener('sessionstart', g2),
          Ce.removeEventListener('sessionend', y2),
          Xa.stop())
      }))
    function De(K) {
      ;(K.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (S = !0))
    }
    function Xe() {
      ;(console.log('THREE.WebGLRenderer: Context Restored.'), (S = !1))
      const K = k.autoReset,
        ge = $.enabled,
        Se = $.autoUpdate,
        Ae = $.needsUpdate,
        ye = $.type
      ;(Ze(),
        (k.autoReset = K),
        ($.enabled = ge),
        ($.autoUpdate = Se),
        ($.needsUpdate = Ae),
        ($.type = ye))
    }
    function et(K) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        K.statusMessage
      )
    }
    function _t(K) {
      const ge = K.target
      ;(ge.removeEventListener('dispose', _t), hn(ge))
    }
    function hn(K) {
      ;(bi(K), j.remove(K))
    }
    function bi(K) {
      const ge = j.get(K).programs
      ge !== void 0 &&
        (ge.forEach(function (Se) {
          z.releaseProgram(Se)
        }),
        K.isShaderMaterial && z.releaseShaderCache(K))
    }
    this.renderBufferDirect = function (K, ge, Se, Ae, ye, $e) {
      ge === null && (ge = it)
      const nt = ye.isMesh && ye.matrixWorld.determinant() < 0,
        ot = dI(K, ge, Se, Ae, ye)
      P.setMaterial(Ae, nt)
      let at = Se.index,
        St = 1
      if (Ae.wireframe === !0) {
        if (((at = X.getWireframeAttribute(Se)), at === void 0)) return
        St = 2
      }
      const bt = Se.drawRange,
        ht = Se.attributes.position
      let zt = bt.start * St,
        Kt = (bt.start + bt.count) * St
      ;($e !== null &&
        ((zt = Math.max(zt, $e.start * St)), (Kt = Math.min(Kt, ($e.start + $e.count) * St))),
        at !== null
          ? ((zt = Math.max(zt, 0)), (Kt = Math.min(Kt, at.count)))
          : ht != null && ((zt = Math.max(zt, 0)), (Kt = Math.min(Kt, ht.count))))
      const kn = Kt - zt
      if (kn < 0 || kn === 1 / 0) return
      rt.setup(ye, Ae, ot, Se, at)
      let Cn,
        Vt = Le
      if ((at !== null && ((Cn = G.get(at)), (Vt = Ve), Vt.setIndex(Cn)), ye.isMesh))
        Ae.wireframe === !0
          ? (P.setLineWidth(Ae.wireframeLinewidth * re()), Vt.setMode(b.LINES))
          : Vt.setMode(b.TRIANGLES)
      else if (ye.isLine) {
        let ft = Ae.linewidth
        ;(ft === void 0 && (ft = 1),
          P.setLineWidth(ft * re()),
          ye.isLineSegments
            ? Vt.setMode(b.LINES)
            : ye.isLineLoop
              ? Vt.setMode(b.LINE_LOOP)
              : Vt.setMode(b.LINE_STRIP))
      } else ye.isPoints ? Vt.setMode(b.POINTS) : ye.isSprite && Vt.setMode(b.TRIANGLES)
      if (ye.isBatchedMesh)
        if (ye._multiDrawInstances !== null)
          Vt.renderMultiDrawInstances(
            ye._multiDrawStarts,
            ye._multiDrawCounts,
            ye._multiDrawCount,
            ye._multiDrawInstances
          )
        else if (J.get('WEBGL_multi_draw'))
          Vt.renderMultiDraw(ye._multiDrawStarts, ye._multiDrawCounts, ye._multiDrawCount)
        else {
          const ft = ye._multiDrawStarts,
            di = ye._multiDrawCounts,
            Yt = ye._multiDrawCount,
            as = at ? G.get(at).bytesPerElement : 1,
            Yl = j.get(Ae).currentProgram.getUniforms()
          for (let dr = 0; dr < Yt; dr++)
            (Yl.setValue(b, '_gl_DrawID', dr), Vt.render(ft[dr] / as, di[dr]))
        }
      else if (ye.isInstancedMesh) Vt.renderInstances(zt, kn, ye.count)
      else if (Se.isInstancedBufferGeometry) {
        const ft = Se._maxInstanceCount !== void 0 ? Se._maxInstanceCount : 1 / 0,
          di = Math.min(Se.instanceCount, ft)
        Vt.renderInstances(zt, kn, di)
      } else Vt.render(zt, kn)
    }
    function on(K, ge, Se) {
      K.transparent === !0 && K.side === wr && K.forceSinglePass === !1
        ? ((K.side = Oi),
          (K.needsUpdate = !0),
          hf(K, ge, Se),
          (K.side = Ts),
          (K.needsUpdate = !0),
          hf(K, ge, Se),
          (K.side = wr))
        : hf(K, ge, Se)
    }
    ;((this.compile = function (K, ge, Se = null) {
      ;(Se === null && (Se = K),
        (m = q.get(Se)),
        m.init(ge),
        x.push(m),
        Se.traverseVisible(function (ye) {
          ye.isLight &&
            ye.layers.test(ge.layers) &&
            (m.pushLight(ye), ye.castShadow && m.pushShadow(ye))
        }),
        K !== Se &&
          K.traverseVisible(function (ye) {
            ye.isLight &&
              ye.layers.test(ge.layers) &&
              (m.pushLight(ye), ye.castShadow && m.pushShadow(ye))
          }),
        m.setupLights())
      const Ae = new Set()
      return (
        K.traverse(function (ye) {
          if (!(ye.isMesh || ye.isPoints || ye.isLine || ye.isSprite)) return
          const $e = ye.material
          if ($e)
            if (Array.isArray($e))
              for (let nt = 0; nt < $e.length; nt++) {
                const ot = $e[nt]
                ;(on(ot, Se, ye), Ae.add(ot))
              }
            else (on($e, Se, ye), Ae.add($e))
        }),
        x.pop(),
        (m = null),
        Ae
      )
    }),
      (this.compileAsync = function (K, ge, Se = null) {
        const Ae = this.compile(K, ge, Se)
        return new Promise((ye) => {
          function $e() {
            if (
              (Ae.forEach(function (nt) {
                j.get(nt).currentProgram.isReady() && Ae.delete(nt)
              }),
              Ae.size === 0)
            ) {
              ye(K)
              return
            }
            setTimeout($e, 10)
          }
          J.get('KHR_parallel_shader_compile') !== null ? $e() : setTimeout($e, 10)
        })
      }))
    let os = null
    function ho(K) {
      os && os(K)
    }
    function g2() {
      Xa.stop()
    }
    function y2() {
      Xa.start()
    }
    const Xa = new X5()
    ;(Xa.setAnimationLoop(ho),
      typeof self < 'u' && Xa.setContext(self),
      (this.setAnimationLoop = function (K) {
        ;((os = K), Ce.setAnimationLoop(K), K === null ? Xa.stop() : Xa.start())
      }),
      Ce.addEventListener('sessionstart', g2),
      Ce.addEventListener('sessionend', y2),
      (this.render = function (K, ge) {
        if (ge !== void 0 && ge.isCamera !== !0) {
          console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.')
          return
        }
        if (S === !0) return
        if (
          (K.matrixWorldAutoUpdate === !0 && K.updateMatrixWorld(),
          ge.parent === null && ge.matrixWorldAutoUpdate === !0 && ge.updateMatrixWorld(),
          Ce.enabled === !0 &&
            Ce.isPresenting === !0 &&
            (Ce.cameraAutoUpdate === !0 && Ce.updateCamera(ge), (ge = Ce.getCamera())),
          K.isScene === !0 && K.onBeforeRender(_, K, ge, R),
          (m = q.get(K, x.length)),
          m.init(ge),
          x.push(m),
          Ie.multiplyMatrices(ge.projectionMatrix, ge.matrixWorldInverse),
          le.setFromProjectionMatrix(Ie),
          (we = this.localClippingEnabled),
          (fe = Z.init(this.clippingPlanes, we)),
          (y = N.get(K, v.length)),
          y.init(),
          v.push(y),
          Ce.enabled === !0 && Ce.isPresenting === !0)
        ) {
          const $e = _.xr.getDepthSensingMesh()
          $e !== null && G0($e, ge, -1 / 0, _.sortObjects)
        }
        ;(G0(K, ge, 0, _.sortObjects),
          y.finish(),
          _.sortObjects === !0 && y.sort(se, he),
          (te = Ce.enabled === !1 || Ce.isPresenting === !1 || Ce.hasDepthSensing() === !1),
          te && ae.addToRenderList(y, K),
          this.info.render.frame++,
          fe === !0 && Z.beginShadows())
        const Se = m.state.shadowsArray
        ;($.render(Se, K, ge),
          fe === !0 && Z.endShadows(),
          this.info.autoReset === !0 && this.info.reset())
        const Ae = y.opaque,
          ye = y.transmissive
        if ((m.setupLights(), ge.isArrayCamera)) {
          const $e = ge.cameras
          if (ye.length > 0)
            for (let nt = 0, ot = $e.length; nt < ot; nt++) {
              const at = $e[nt]
              _2(Ae, ye, K, at)
            }
          te && ae.render(K)
          for (let nt = 0, ot = $e.length; nt < ot; nt++) {
            const at = $e[nt]
            v2(y, K, at, at.viewport)
          }
        } else (ye.length > 0 && _2(Ae, ye, K, ge), te && ae.render(K), v2(y, K, ge))
        ;(R !== null &&
          A === 0 &&
          (B.updateMultisampleRenderTarget(R), B.updateRenderTargetMipmap(R)),
          K.isScene === !0 && K.onAfterRender(_, K, ge),
          rt.resetDefaultState(),
          (w = -1),
          (M = null),
          x.pop(),
          x.length > 0
            ? ((m = x[x.length - 1]),
              fe === !0 && Z.setGlobalState(_.clippingPlanes, m.state.camera))
            : (m = null),
          v.pop(),
          v.length > 0 ? (y = v[v.length - 1]) : (y = null))
      }))
    function G0(K, ge, Se, Ae) {
      if (K.visible === !1) return
      if (K.layers.test(ge.layers)) {
        if (K.isGroup) Se = K.renderOrder
        else if (K.isLOD) K.autoUpdate === !0 && K.update(ge)
        else if (K.isLight) (m.pushLight(K), K.castShadow && m.pushShadow(K))
        else if (K.isSprite) {
          if (!K.frustumCulled || le.intersectsSprite(K)) {
            Ae && Be.setFromMatrixPosition(K.matrixWorld).applyMatrix4(Ie)
            const nt = ue.update(K),
              ot = K.material
            ot.visible && y.push(K, nt, ot, Se, Be.z, null)
          }
        } else if (
          (K.isMesh || K.isLine || K.isPoints) &&
          (!K.frustumCulled || le.intersectsObject(K))
        ) {
          const nt = ue.update(K),
            ot = K.material
          if (
            (Ae &&
              (K.boundingSphere !== void 0
                ? (K.boundingSphere === null && K.computeBoundingSphere(),
                  Be.copy(K.boundingSphere.center))
                : (nt.boundingSphere === null && nt.computeBoundingSphere(),
                  Be.copy(nt.boundingSphere.center)),
              Be.applyMatrix4(K.matrixWorld).applyMatrix4(Ie)),
            Array.isArray(ot))
          ) {
            const at = nt.groups
            for (let St = 0, bt = at.length; St < bt; St++) {
              const ht = at[St],
                zt = ot[ht.materialIndex]
              zt && zt.visible && y.push(K, nt, zt, Se, Be.z, ht)
            }
          } else ot.visible && y.push(K, nt, ot, Se, Be.z, null)
        }
      }
      const $e = K.children
      for (let nt = 0, ot = $e.length; nt < ot; nt++) G0($e[nt], ge, Se, Ae)
    }
    function v2(K, ge, Se, Ae) {
      const ye = K.opaque,
        $e = K.transmissive,
        nt = K.transparent
      ;(m.setupLightsView(Se),
        fe === !0 && Z.setGlobalState(_.clippingPlanes, Se),
        Ae && P.viewport(I.copy(Ae)),
        ye.length > 0 && df(ye, ge, Se),
        $e.length > 0 && df($e, ge, Se),
        nt.length > 0 && df(nt, ge, Se),
        P.buffers.depth.setTest(!0),
        P.buffers.depth.setMask(!0),
        P.buffers.color.setMask(!0),
        P.setPolygonOffset(!1))
    }
    function _2(K, ge, Se, Ae) {
      if ((Se.isScene === !0 ? Se.overrideMaterial : null) !== null) return
      m.state.transmissionRenderTarget[Ae.id] === void 0 &&
        (m.state.transmissionRenderTarget[Ae.id] = new Ua(1, 1, {
          generateMipmaps: !0,
          type: J.has('EXT_color_buffer_half_float') || J.has('EXT_color_buffer_float') ? ws : eo,
          minFilter: Ws,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Tt.workingColorSpace,
        }))
      const $e = m.state.transmissionRenderTarget[Ae.id],
        nt = Ae.viewport || I
      $e.setSize(nt.z * _.transmissionResolutionScale, nt.w * _.transmissionResolutionScale)
      const ot = _.getRenderTarget()
      ;(_.setRenderTarget($e),
        _.getClearColor(T),
        (F = _.getClearAlpha()),
        F < 1 && _.setClearColor(16777215, 0.5),
        _.clear(),
        te && ae.render(Se))
      const at = _.toneMapping
      _.toneMapping = _s
      const St = Ae.viewport
      if (
        (Ae.viewport !== void 0 && (Ae.viewport = void 0),
        m.setupLightsView(Ae),
        fe === !0 && Z.setGlobalState(_.clippingPlanes, Ae),
        df(K, Se, Ae),
        B.updateMultisampleRenderTarget($e),
        B.updateRenderTargetMipmap($e),
        J.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let bt = !1
        for (let ht = 0, zt = ge.length; ht < zt; ht++) {
          const Kt = ge[ht],
            kn = Kt.object,
            Cn = Kt.geometry,
            Vt = Kt.material,
            ft = Kt.group
          if (Vt.side === wr && kn.layers.test(Ae.layers)) {
            const di = Vt.side
            ;((Vt.side = Oi),
              (Vt.needsUpdate = !0),
              x2(kn, Se, Ae, Cn, Vt, ft),
              (Vt.side = di),
              (Vt.needsUpdate = !0),
              (bt = !0))
          }
        }
        bt === !0 && (B.updateMultisampleRenderTarget($e), B.updateRenderTargetMipmap($e))
      }
      ;(_.setRenderTarget(ot),
        _.setClearColor(T, F),
        St !== void 0 && (Ae.viewport = St),
        (_.toneMapping = at))
    }
    function df(K, ge, Se) {
      const Ae = ge.isScene === !0 ? ge.overrideMaterial : null
      for (let ye = 0, $e = K.length; ye < $e; ye++) {
        const nt = K[ye],
          ot = nt.object,
          at = nt.geometry,
          St = Ae === null ? nt.material : Ae,
          bt = nt.group
        ot.layers.test(Se.layers) && x2(ot, ge, Se, at, St, bt)
      }
    }
    function x2(K, ge, Se, Ae, ye, $e) {
      ;(K.onBeforeRender(_, ge, Se, Ae, ye, $e),
        K.modelViewMatrix.multiplyMatrices(Se.matrixWorldInverse, K.matrixWorld),
        K.normalMatrix.getNormalMatrix(K.modelViewMatrix),
        ye.onBeforeRender(_, ge, Se, Ae, K, $e),
        ye.transparent === !0 && ye.side === wr && ye.forceSinglePass === !1
          ? ((ye.side = Oi),
            (ye.needsUpdate = !0),
            _.renderBufferDirect(Se, ge, Ae, ye, K, $e),
            (ye.side = Ts),
            (ye.needsUpdate = !0),
            _.renderBufferDirect(Se, ge, Ae, ye, K, $e),
            (ye.side = wr))
          : _.renderBufferDirect(Se, ge, Ae, ye, K, $e),
        K.onAfterRender(_, ge, Se, Ae, ye, $e))
    }
    function hf(K, ge, Se) {
      ge.isScene !== !0 && (ge = it)
      const Ae = j.get(K),
        ye = m.state.lights,
        $e = m.state.shadowsArray,
        nt = ye.state.version,
        ot = z.getParameters(K, ye.state, $e, ge, Se),
        at = z.getProgramCacheKey(ot)
      let St = Ae.programs
      ;((Ae.environment = K.isMeshStandardMaterial ? ge.environment : null),
        (Ae.fog = ge.fog),
        (Ae.envMap = (K.isMeshStandardMaterial ? Q : D).get(K.envMap || Ae.environment)),
        (Ae.envMapRotation =
          Ae.environment !== null && K.envMap === null ? ge.environmentRotation : K.envMapRotation),
        St === void 0 && (K.addEventListener('dispose', _t), (St = new Map()), (Ae.programs = St)))
      let bt = St.get(at)
      if (bt !== void 0) {
        if (Ae.currentProgram === bt && Ae.lightsStateVersion === nt) return (A2(K, ot), bt)
      } else
        ((ot.uniforms = z.getUniforms(K)),
          K.onBeforeCompile(ot, _),
          (bt = z.acquireProgram(ot, at)),
          St.set(at, bt),
          (Ae.uniforms = ot.uniforms))
      const ht = Ae.uniforms
      return (
        ((!K.isShaderMaterial && !K.isRawShaderMaterial) || K.clipping === !0) &&
          (ht.clippingPlanes = Z.uniform),
        A2(K, ot),
        (Ae.needsLights = fI(K)),
        (Ae.lightsStateVersion = nt),
        Ae.needsLights &&
          ((ht.ambientLightColor.value = ye.state.ambient),
          (ht.lightProbe.value = ye.state.probe),
          (ht.directionalLights.value = ye.state.directional),
          (ht.directionalLightShadows.value = ye.state.directionalShadow),
          (ht.spotLights.value = ye.state.spot),
          (ht.spotLightShadows.value = ye.state.spotShadow),
          (ht.rectAreaLights.value = ye.state.rectArea),
          (ht.ltc_1.value = ye.state.rectAreaLTC1),
          (ht.ltc_2.value = ye.state.rectAreaLTC2),
          (ht.pointLights.value = ye.state.point),
          (ht.pointLightShadows.value = ye.state.pointShadow),
          (ht.hemisphereLights.value = ye.state.hemi),
          (ht.directionalShadowMap.value = ye.state.directionalShadowMap),
          (ht.directionalShadowMatrix.value = ye.state.directionalShadowMatrix),
          (ht.spotShadowMap.value = ye.state.spotShadowMap),
          (ht.spotLightMatrix.value = ye.state.spotLightMatrix),
          (ht.spotLightMap.value = ye.state.spotLightMap),
          (ht.pointShadowMap.value = ye.state.pointShadowMap),
          (ht.pointShadowMatrix.value = ye.state.pointShadowMatrix)),
        (Ae.currentProgram = bt),
        (Ae.uniformsList = null),
        bt
      )
    }
    function S2(K) {
      if (K.uniformsList === null) {
        const ge = K.currentProgram.getUniforms()
        K.uniformsList = Lp.seqWithValue(ge.seq, K.uniforms)
      }
      return K.uniformsList
    }
    function A2(K, ge) {
      const Se = j.get(K)
      ;((Se.outputColorSpace = ge.outputColorSpace),
        (Se.batching = ge.batching),
        (Se.batchingColor = ge.batchingColor),
        (Se.instancing = ge.instancing),
        (Se.instancingColor = ge.instancingColor),
        (Se.instancingMorph = ge.instancingMorph),
        (Se.skinning = ge.skinning),
        (Se.morphTargets = ge.morphTargets),
        (Se.morphNormals = ge.morphNormals),
        (Se.morphColors = ge.morphColors),
        (Se.morphTargetsCount = ge.morphTargetsCount),
        (Se.numClippingPlanes = ge.numClippingPlanes),
        (Se.numIntersection = ge.numClipIntersection),
        (Se.vertexAlphas = ge.vertexAlphas),
        (Se.vertexTangents = ge.vertexTangents),
        (Se.toneMapping = ge.toneMapping))
    }
    function dI(K, ge, Se, Ae, ye) {
      ;(ge.isScene !== !0 && (ge = it), B.resetTextureUnits())
      const $e = ge.fog,
        nt = Ae.isMeshStandardMaterial ? ge.environment : null,
        ot =
          R === null ? _.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : Ui,
        at = (Ae.isMeshStandardMaterial ? Q : D).get(Ae.envMap || nt),
        St = Ae.vertexColors === !0 && !!Se.attributes.color && Se.attributes.color.itemSize === 4,
        bt = !!Se.attributes.tangent && (!!Ae.normalMap || Ae.anisotropy > 0),
        ht = !!Se.morphAttributes.position,
        zt = !!Se.morphAttributes.normal,
        Kt = !!Se.morphAttributes.color
      let kn = _s
      Ae.toneMapped && (R === null || R.isXRRenderTarget === !0) && (kn = _.toneMapping)
      const Cn =
          Se.morphAttributes.position || Se.morphAttributes.normal || Se.morphAttributes.color,
        Vt = Cn !== void 0 ? Cn.length : 0,
        ft = j.get(Ae),
        di = m.state.lights
      if (fe === !0 && (we === !0 || K !== M)) {
        const Vi = K === M && Ae.id === w
        Z.setState(Ae, K, Vi)
      }
      let Yt = !1
      Ae.version === ft.__version
        ? ((ft.needsLights && ft.lightsStateVersion !== di.state.version) ||
            ft.outputColorSpace !== ot ||
            (ye.isBatchedMesh && ft.batching === !1) ||
            (!ye.isBatchedMesh && ft.batching === !0) ||
            (ye.isBatchedMesh && ft.batchingColor === !0 && ye.colorTexture === null) ||
            (ye.isBatchedMesh && ft.batchingColor === !1 && ye.colorTexture !== null) ||
            (ye.isInstancedMesh && ft.instancing === !1) ||
            (!ye.isInstancedMesh && ft.instancing === !0) ||
            (ye.isSkinnedMesh && ft.skinning === !1) ||
            (!ye.isSkinnedMesh && ft.skinning === !0) ||
            (ye.isInstancedMesh && ft.instancingColor === !0 && ye.instanceColor === null) ||
            (ye.isInstancedMesh && ft.instancingColor === !1 && ye.instanceColor !== null) ||
            (ye.isInstancedMesh && ft.instancingMorph === !0 && ye.morphTexture === null) ||
            (ye.isInstancedMesh && ft.instancingMorph === !1 && ye.morphTexture !== null) ||
            ft.envMap !== at ||
            (Ae.fog === !0 && ft.fog !== $e) ||
            (ft.numClippingPlanes !== void 0 &&
              (ft.numClippingPlanes !== Z.numPlanes || ft.numIntersection !== Z.numIntersection)) ||
            ft.vertexAlphas !== St ||
            ft.vertexTangents !== bt ||
            ft.morphTargets !== ht ||
            ft.morphNormals !== zt ||
            ft.morphColors !== Kt ||
            ft.toneMapping !== kn ||
            ft.morphTargetsCount !== Vt) &&
          (Yt = !0)
        : ((Yt = !0), (ft.__version = Ae.version))
      let as = ft.currentProgram
      Yt === !0 && (as = hf(Ae, ge, ye))
      let Yl = !1,
        dr = !1,
        Ku = !1
      const Sn = as.getUniforms(),
        Ur = ft.uniforms
      if (
        (P.useProgram(as.program) && ((Yl = !0), (dr = !0), (Ku = !0)),
        Ae.id !== w && ((w = Ae.id), (dr = !0)),
        Yl || M !== K)
      ) {
        ;(P.buffers.depth.getReversed()
          ? (Ee.copy(K.projectionMatrix), FP(Ee), OP(Ee), Sn.setValue(b, 'projectionMatrix', Ee))
          : Sn.setValue(b, 'projectionMatrix', K.projectionMatrix),
          Sn.setValue(b, 'viewMatrix', K.matrixWorldInverse))
        const tr = Sn.map.cameraPosition
        ;(tr !== void 0 && tr.setValue(b, ze.setFromMatrixPosition(K.matrixWorld)),
          H.logarithmicDepthBuffer &&
            Sn.setValue(b, 'logDepthBufFC', 2 / (Math.log(K.far + 1) / Math.LN2)),
          (Ae.isMeshPhongMaterial ||
            Ae.isMeshToonMaterial ||
            Ae.isMeshLambertMaterial ||
            Ae.isMeshBasicMaterial ||
            Ae.isMeshStandardMaterial ||
            Ae.isShaderMaterial) &&
            Sn.setValue(b, 'isOrthographic', K.isOrthographicCamera === !0),
          M !== K && ((M = K), (dr = !0), (Ku = !0)))
      }
      if (ye.isSkinnedMesh) {
        ;(Sn.setOptional(b, ye, 'bindMatrix'), Sn.setOptional(b, ye, 'bindMatrixInverse'))
        const Vi = ye.skeleton
        Vi &&
          (Vi.boneTexture === null && Vi.computeBoneTexture(),
          Sn.setValue(b, 'boneTexture', Vi.boneTexture, B))
      }
      ye.isBatchedMesh &&
        (Sn.setOptional(b, ye, 'batchingTexture'),
        Sn.setValue(b, 'batchingTexture', ye._matricesTexture, B),
        Sn.setOptional(b, ye, 'batchingIdTexture'),
        Sn.setValue(b, 'batchingIdTexture', ye._indirectTexture, B),
        Sn.setOptional(b, ye, 'batchingColorTexture'),
        ye._colorsTexture !== null && Sn.setValue(b, 'batchingColorTexture', ye._colorsTexture, B))
      const kr = Se.morphAttributes
      if (
        ((kr.position !== void 0 || kr.normal !== void 0 || kr.color !== void 0) &&
          Ue.update(ye, Se, as),
        (dr || ft.receiveShadow !== ye.receiveShadow) &&
          ((ft.receiveShadow = ye.receiveShadow),
          Sn.setValue(b, 'receiveShadow', ye.receiveShadow)),
        Ae.isMeshGouraudMaterial &&
          Ae.envMap !== null &&
          ((Ur.envMap.value = at),
          (Ur.flipEnvMap.value = at.isCubeTexture && at.isRenderTargetTexture === !1 ? -1 : 1)),
        Ae.isMeshStandardMaterial &&
          Ae.envMap === null &&
          ge.environment !== null &&
          (Ur.envMapIntensity.value = ge.environmentIntensity),
        dr &&
          (Sn.setValue(b, 'toneMappingExposure', _.toneMappingExposure),
          ft.needsLights && hI(Ur, Ku),
          $e && Ae.fog === !0 && E.refreshFogUniforms(Ur, $e),
          E.refreshMaterialUniforms(Ur, Ae, ee, W, m.state.transmissionRenderTarget[K.id]),
          Lp.upload(b, S2(ft), Ur, B)),
        Ae.isShaderMaterial &&
          Ae.uniformsNeedUpdate === !0 &&
          (Lp.upload(b, S2(ft), Ur, B), (Ae.uniformsNeedUpdate = !1)),
        Ae.isSpriteMaterial && Sn.setValue(b, 'center', ye.center),
        Sn.setValue(b, 'modelViewMatrix', ye.modelViewMatrix),
        Sn.setValue(b, 'normalMatrix', ye.normalMatrix),
        Sn.setValue(b, 'modelMatrix', ye.matrixWorld),
        Ae.isShaderMaterial || Ae.isRawShaderMaterial)
      ) {
        const Vi = Ae.uniformsGroups
        for (let tr = 0, W0 = Vi.length; tr < W0; tr++) {
          const Ka = Vi[tr]
          ;(pe.update(Ka, as), pe.bind(Ka, as))
        }
      }
      return as
    }
    function hI(K, ge) {
      ;((K.ambientLightColor.needsUpdate = ge),
        (K.lightProbe.needsUpdate = ge),
        (K.directionalLights.needsUpdate = ge),
        (K.directionalLightShadows.needsUpdate = ge),
        (K.pointLights.needsUpdate = ge),
        (K.pointLightShadows.needsUpdate = ge),
        (K.spotLights.needsUpdate = ge),
        (K.spotLightShadows.needsUpdate = ge),
        (K.rectAreaLights.needsUpdate = ge),
        (K.hemisphereLights.needsUpdate = ge))
    }
    function fI(K) {
      return (
        K.isMeshLambertMaterial ||
        K.isMeshToonMaterial ||
        K.isMeshPhongMaterial ||
        K.isMeshStandardMaterial ||
        K.isShadowMaterial ||
        (K.isShaderMaterial && K.lights === !0)
      )
    }
    ;((this.getActiveCubeFace = function () {
      return C
    }),
      (this.getActiveMipmapLevel = function () {
        return A
      }),
      (this.getRenderTarget = function () {
        return R
      }),
      (this.setRenderTargetTextures = function (K, ge, Se) {
        ;((j.get(K.texture).__webglTexture = ge), (j.get(K.depthTexture).__webglTexture = Se))
        const Ae = j.get(K)
        ;((Ae.__hasExternalTextures = !0),
          (Ae.__autoAllocateDepthBuffer = Se === void 0),
          Ae.__autoAllocateDepthBuffer ||
            (J.has('WEBGL_multisampled_render_to_texture') === !0 &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
              ),
              (Ae.__useRenderToTexture = !1))))
      }),
      (this.setRenderTargetFramebuffer = function (K, ge) {
        const Se = j.get(K)
        ;((Se.__webglFramebuffer = ge), (Se.__useDefaultFramebuffer = ge === void 0))
      }))
    const pI = b.createFramebuffer()
    ;((this.setRenderTarget = function (K, ge = 0, Se = 0) {
      ;((R = K), (C = ge), (A = Se))
      let Ae = !0,
        ye = null,
        $e = !1,
        nt = !1
      if (K) {
        const at = j.get(K)
        if (at.__useDefaultFramebuffer !== void 0)
          (P.bindFramebuffer(b.FRAMEBUFFER, null), (Ae = !1))
        else if (at.__webglFramebuffer === void 0) B.setupRenderTarget(K)
        else if (at.__hasExternalTextures)
          B.rebindTextures(K, j.get(K.texture).__webglTexture, j.get(K.depthTexture).__webglTexture)
        else if (K.depthBuffer) {
          const ht = K.depthTexture
          if (at.__boundDepthTexture !== ht) {
            if (
              ht !== null &&
              j.has(ht) &&
              (K.width !== ht.image.width || K.height !== ht.image.height)
            )
              throw new Error(
                'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.'
              )
            B.setupDepthRenderbuffer(K)
          }
        }
        const St = K.texture
        ;(St.isData3DTexture || St.isDataArrayTexture || St.isCompressedArrayTexture) && (nt = !0)
        const bt = j.get(K).__webglFramebuffer
        ;(K.isWebGLCubeRenderTarget
          ? (Array.isArray(bt[ge]) ? (ye = bt[ge][Se]) : (ye = bt[ge]), ($e = !0))
          : K.samples > 0 && B.useMultisampledRTT(K) === !1
            ? (ye = j.get(K).__webglMultisampledFramebuffer)
            : Array.isArray(bt)
              ? (ye = bt[Se])
              : (ye = bt),
          I.copy(K.viewport),
          L.copy(K.scissor),
          (U = K.scissorTest))
      } else
        (I.copy(ne).multiplyScalar(ee).floor(), L.copy(ie).multiplyScalar(ee).floor(), (U = be))
      if (
        (Se !== 0 && (ye = pI),
        P.bindFramebuffer(b.FRAMEBUFFER, ye) && Ae && P.drawBuffers(K, ye),
        P.viewport(I),
        P.scissor(L),
        P.setScissorTest(U),
        $e)
      ) {
        const at = j.get(K.texture)
        b.framebufferTexture2D(
          b.FRAMEBUFFER,
          b.COLOR_ATTACHMENT0,
          b.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
          at.__webglTexture,
          Se
        )
      } else if (nt) {
        const at = j.get(K.texture),
          St = ge
        b.framebufferTextureLayer(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, at.__webglTexture, Se, St)
      } else if (K !== null && Se !== 0) {
        const at = j.get(K.texture)
        b.framebufferTexture2D(
          b.FRAMEBUFFER,
          b.COLOR_ATTACHMENT0,
          b.TEXTURE_2D,
          at.__webglTexture,
          Se
        )
      }
      w = -1
    }),
      (this.readRenderTargetPixels = function (K, ge, Se, Ae, ye, $e, nt) {
        if (!(K && K.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          )
          return
        }
        let ot = j.get(K).__webglFramebuffer
        if ((K.isWebGLCubeRenderTarget && nt !== void 0 && (ot = ot[nt]), ot)) {
          P.bindFramebuffer(b.FRAMEBUFFER, ot)
          try {
            const at = K.texture,
              St = at.format,
              bt = at.type
            if (!H.textureFormatReadable(St)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
              )
              return
            }
            if (!H.textureTypeReadable(bt)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
              )
              return
            }
            ge >= 0 &&
              ge <= K.width - Ae &&
              Se >= 0 &&
              Se <= K.height - ye &&
              b.readPixels(ge, Se, Ae, ye, Je.convert(St), Je.convert(bt), $e)
          } finally {
            const at = R !== null ? j.get(R).__webglFramebuffer : null
            P.bindFramebuffer(b.FRAMEBUFFER, at)
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (K, ge, Se, Ae, ye, $e, nt) {
        if (!(K && K.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          )
        let ot = j.get(K).__webglFramebuffer
        if ((K.isWebGLCubeRenderTarget && nt !== void 0 && (ot = ot[nt]), ot)) {
          const at = K.texture,
            St = at.format,
            bt = at.type
          if (!H.textureFormatReadable(St))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.'
            )
          if (!H.textureTypeReadable(bt))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.'
            )
          if (ge >= 0 && ge <= K.width - Ae && Se >= 0 && Se <= K.height - ye) {
            P.bindFramebuffer(b.FRAMEBUFFER, ot)
            const ht = b.createBuffer()
            ;(b.bindBuffer(b.PIXEL_PACK_BUFFER, ht),
              b.bufferData(b.PIXEL_PACK_BUFFER, $e.byteLength, b.STREAM_READ),
              b.readPixels(ge, Se, Ae, ye, Je.convert(St), Je.convert(bt), 0))
            const zt = R !== null ? j.get(R).__webglFramebuffer : null
            P.bindFramebuffer(b.FRAMEBUFFER, zt)
            const Kt = b.fenceSync(b.SYNC_GPU_COMMANDS_COMPLETE, 0)
            return (
              b.flush(),
              await DP(b, Kt, 4),
              b.bindBuffer(b.PIXEL_PACK_BUFFER, ht),
              b.getBufferSubData(b.PIXEL_PACK_BUFFER, 0, $e),
              b.deleteBuffer(ht),
              b.deleteSync(Kt),
              $e
            )
          } else
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.'
            )
        }
      }),
      (this.copyFramebufferToTexture = function (K, ge = null, Se = 0) {
        K.isTexture !== !0 &&
          (Ec('WebGLRenderer: copyFramebufferToTexture function signature has changed.'),
          (ge = arguments[0] || null),
          (K = arguments[1]))
        const Ae = Math.pow(2, -Se),
          ye = Math.floor(K.image.width * Ae),
          $e = Math.floor(K.image.height * Ae),
          nt = ge !== null ? ge.x : 0,
          ot = ge !== null ? ge.y : 0
        ;(B.setTexture2D(K, 0),
          b.copyTexSubImage2D(b.TEXTURE_2D, Se, 0, 0, nt, ot, ye, $e),
          P.unbindTexture())
      }))
    const mI = b.createFramebuffer(),
      gI = b.createFramebuffer()
    ;((this.copyTextureToTexture = function (K, ge, Se = null, Ae = null, ye = 0, $e = null) {
      ;(K.isTexture !== !0 &&
        (Ec('WebGLRenderer: copyTextureToTexture function signature has changed.'),
        (Ae = arguments[0] || null),
        (K = arguments[1]),
        (ge = arguments[2]),
        ($e = arguments[3] || 0),
        (Se = null)),
        $e === null &&
          (ye !== 0
            ? (Ec(
                'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.'
              ),
              ($e = ye),
              (ye = 0))
            : ($e = 0)))
      let nt, ot, at, St, bt, ht, zt, Kt, kn
      const Cn = K.isCompressedTexture ? K.mipmaps[$e] : K.image
      if (Se !== null)
        ((nt = Se.max.x - Se.min.x),
          (ot = Se.max.y - Se.min.y),
          (at = Se.isBox3 ? Se.max.z - Se.min.z : 1),
          (St = Se.min.x),
          (bt = Se.min.y),
          (ht = Se.isBox3 ? Se.min.z : 0))
      else {
        const kr = Math.pow(2, -ye)
        ;((nt = Math.floor(Cn.width * kr)),
          (ot = Math.floor(Cn.height * kr)),
          K.isDataArrayTexture
            ? (at = Cn.depth)
            : K.isData3DTexture
              ? (at = Math.floor(Cn.depth * kr))
              : (at = 1),
          (St = 0),
          (bt = 0),
          (ht = 0))
      }
      Ae !== null ? ((zt = Ae.x), (Kt = Ae.y), (kn = Ae.z)) : ((zt = 0), (Kt = 0), (kn = 0))
      const Vt = Je.convert(ge.format),
        ft = Je.convert(ge.type)
      let di
      ;(ge.isData3DTexture
        ? (B.setTexture3D(ge, 0), (di = b.TEXTURE_3D))
        : ge.isDataArrayTexture || ge.isCompressedArrayTexture
          ? (B.setTexture2DArray(ge, 0), (di = b.TEXTURE_2D_ARRAY))
          : (B.setTexture2D(ge, 0), (di = b.TEXTURE_2D)),
        b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, ge.flipY),
        b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ge.premultiplyAlpha),
        b.pixelStorei(b.UNPACK_ALIGNMENT, ge.unpackAlignment))
      const Yt = b.getParameter(b.UNPACK_ROW_LENGTH),
        as = b.getParameter(b.UNPACK_IMAGE_HEIGHT),
        Yl = b.getParameter(b.UNPACK_SKIP_PIXELS),
        dr = b.getParameter(b.UNPACK_SKIP_ROWS),
        Ku = b.getParameter(b.UNPACK_SKIP_IMAGES)
      ;(b.pixelStorei(b.UNPACK_ROW_LENGTH, Cn.width),
        b.pixelStorei(b.UNPACK_IMAGE_HEIGHT, Cn.height),
        b.pixelStorei(b.UNPACK_SKIP_PIXELS, St),
        b.pixelStorei(b.UNPACK_SKIP_ROWS, bt),
        b.pixelStorei(b.UNPACK_SKIP_IMAGES, ht))
      const Sn = K.isDataArrayTexture || K.isData3DTexture,
        Ur = ge.isDataArrayTexture || ge.isData3DTexture
      if (K.isDepthTexture) {
        const kr = j.get(K),
          Vi = j.get(ge),
          tr = j.get(kr.__renderTarget),
          W0 = j.get(Vi.__renderTarget)
        ;(P.bindFramebuffer(b.READ_FRAMEBUFFER, tr.__webglFramebuffer),
          P.bindFramebuffer(b.DRAW_FRAMEBUFFER, W0.__webglFramebuffer))
        for (let Ka = 0; Ka < at; Ka++)
          (Sn &&
            (b.framebufferTextureLayer(
              b.READ_FRAMEBUFFER,
              b.COLOR_ATTACHMENT0,
              j.get(K).__webglTexture,
              ye,
              ht + Ka
            ),
            b.framebufferTextureLayer(
              b.DRAW_FRAMEBUFFER,
              b.COLOR_ATTACHMENT0,
              j.get(ge).__webglTexture,
              $e,
              kn + Ka
            )),
            b.blitFramebuffer(St, bt, nt, ot, zt, Kt, nt, ot, b.DEPTH_BUFFER_BIT, b.NEAREST))
        ;(P.bindFramebuffer(b.READ_FRAMEBUFFER, null), P.bindFramebuffer(b.DRAW_FRAMEBUFFER, null))
      } else if (ye !== 0 || K.isRenderTargetTexture || j.has(K)) {
        const kr = j.get(K),
          Vi = j.get(ge)
        ;(P.bindFramebuffer(b.READ_FRAMEBUFFER, mI), P.bindFramebuffer(b.DRAW_FRAMEBUFFER, gI))
        for (let tr = 0; tr < at; tr++)
          (Sn
            ? b.framebufferTextureLayer(
                b.READ_FRAMEBUFFER,
                b.COLOR_ATTACHMENT0,
                kr.__webglTexture,
                ye,
                ht + tr
              )
            : b.framebufferTexture2D(
                b.READ_FRAMEBUFFER,
                b.COLOR_ATTACHMENT0,
                b.TEXTURE_2D,
                kr.__webglTexture,
                ye
              ),
            Ur
              ? b.framebufferTextureLayer(
                  b.DRAW_FRAMEBUFFER,
                  b.COLOR_ATTACHMENT0,
                  Vi.__webglTexture,
                  $e,
                  kn + tr
                )
              : b.framebufferTexture2D(
                  b.DRAW_FRAMEBUFFER,
                  b.COLOR_ATTACHMENT0,
                  b.TEXTURE_2D,
                  Vi.__webglTexture,
                  $e
                ),
            ye !== 0
              ? b.blitFramebuffer(St, bt, nt, ot, zt, Kt, nt, ot, b.COLOR_BUFFER_BIT, b.NEAREST)
              : Ur
                ? b.copyTexSubImage3D(di, $e, zt, Kt, kn + tr, St, bt, nt, ot)
                : b.copyTexSubImage2D(di, $e, zt, Kt, St, bt, nt, ot))
        ;(P.bindFramebuffer(b.READ_FRAMEBUFFER, null), P.bindFramebuffer(b.DRAW_FRAMEBUFFER, null))
      } else
        Ur
          ? K.isDataTexture || K.isData3DTexture
            ? b.texSubImage3D(di, $e, zt, Kt, kn, nt, ot, at, Vt, ft, Cn.data)
            : ge.isCompressedArrayTexture
              ? b.compressedTexSubImage3D(di, $e, zt, Kt, kn, nt, ot, at, Vt, Cn.data)
              : b.texSubImage3D(di, $e, zt, Kt, kn, nt, ot, at, Vt, ft, Cn)
          : K.isDataTexture
            ? b.texSubImage2D(b.TEXTURE_2D, $e, zt, Kt, nt, ot, Vt, ft, Cn.data)
            : K.isCompressedTexture
              ? b.compressedTexSubImage2D(
                  b.TEXTURE_2D,
                  $e,
                  zt,
                  Kt,
                  Cn.width,
                  Cn.height,
                  Vt,
                  Cn.data
                )
              : b.texSubImage2D(b.TEXTURE_2D, $e, zt, Kt, nt, ot, Vt, ft, Cn)
      ;(b.pixelStorei(b.UNPACK_ROW_LENGTH, Yt),
        b.pixelStorei(b.UNPACK_IMAGE_HEIGHT, as),
        b.pixelStorei(b.UNPACK_SKIP_PIXELS, Yl),
        b.pixelStorei(b.UNPACK_SKIP_ROWS, dr),
        b.pixelStorei(b.UNPACK_SKIP_IMAGES, Ku),
        $e === 0 && ge.generateMipmaps && b.generateMipmap(di),
        P.unbindTexture())
    }),
      (this.copyTextureToTexture3D = function (K, ge, Se = null, Ae = null, ye = 0) {
        return (
          K.isTexture !== !0 &&
            (Ec('WebGLRenderer: copyTextureToTexture3D function signature has changed.'),
            (Se = arguments[0] || null),
            (Ae = arguments[1] || null),
            (K = arguments[2]),
            (ge = arguments[3]),
            (ye = arguments[4] || 0)),
          Ec(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(K, ge, Se, Ae, ye)
        )
      }),
      (this.initRenderTarget = function (K) {
        j.get(K).__webglFramebuffer === void 0 && B.setupRenderTarget(K)
      }),
      (this.initTexture = function (K) {
        ;(K.isCubeTexture
          ? B.setTextureCube(K, 0)
          : K.isData3DTexture
            ? B.setTexture3D(K, 0)
            : K.isDataArrayTexture || K.isCompressedArrayTexture
              ? B.setTexture2DArray(K, 0)
              : B.setTexture2D(K, 0),
          P.unbindTexture())
      }),
      (this.resetState = function () {
        ;((C = 0), (A = 0), (R = null), P.reset(), rt.reset())
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })))
  }
  get coordinateSystem() {
    return Ir
  }
  get outputColorSpace() {
    return this._outputColorSpace
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e
    const t = this.getContext()
    ;((t.drawingBufferColorspace = Tt._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Tt._getUnpackColorSpace()))
  }
}
class Ft {}
;(xe(Ft, 'DefaultSplatSortDistanceMapPrecision', 16),
  xe(Ft, 'MemoryPageSize', 65536),
  xe(Ft, 'BytesPerFloat', 4),
  xe(Ft, 'BytesPerInt', 4),
  xe(Ft, 'MaxScenes', 32),
  xe(Ft, 'ProgressiveLoadSectionSize', 262144),
  xe(Ft, 'ProgressiveLoadSectionDelayDuration', 15),
  xe(Ft, 'SphericalHarmonics8BitCompressionRange', 3))
const kB = Ft.SphericalHarmonics8BitCompressionRange,
  fa = kB / 2,
  jn = hh.toHalfFloat.bind(hh),
  O_ = hh.fromHalfFloat.bind(hh),
  An = (n, e, t = !1, i, r) => {
    if (e === 0) return n
    if (e === 1 || (e === 2 && !t)) return hh.fromHalfFloat(n)
    if (e === 2) return B_(n, i, r)
  },
  zd = (n, e, t) => {
    n = gi(n, e, t)
    const i = t - e
    return gi(Math.floor(((n - e) / i) * 255), 0, 255)
  },
  B_ = (n, e, t) => {
    const i = t - e
    return (n / 255) * i + e
  },
  tC = (n, e, t) => zd(O_(n, e, t)),
  zB = (n, e, t) => jn(B_(n, e, t)),
  Zt = (n, e, t, i = !1) =>
    t === 0
      ? n.getFloat32(e * 4, !0)
      : t === 1 || (t === 2 && !i)
        ? n.getUint16(e * 2, !0)
        : n.getUint8(e, !0),
  VB = (function () {
    const n = (e) => e
    return function (e, t, i, r = !1) {
      if (t === i) return e
      let s = n
      return (
        t === 2 && r
          ? i === 1
            ? (s = zB)
            : i == 0 && (s = B_)
          : t === 2 || t === 1
            ? i === 0
              ? (s = O_)
              : i == 2 && (r ? (s = tC) : (s = n))
            : t === 0 && (i === 1 ? (s = jn) : i == 2 && (r ? (s = zd) : (s = jn))),
        s(e)
      )
    }
  })(),
  vc = (n, e, t, i, r = 0) => {
    const s = new Uint8Array(n, e),
      o = new Uint8Array(t, i)
    for (let a = 0; a < r; a++) o[a] = s[a]
  },
  Oe = class Oe {
    constructor(e, t = !0) {
      xe(
        this,
        'getSplatScaleAndRotation',
        (function () {
          const e = new qe(),
            t = new qe(),
            i = new qe(),
            r = new Y(),
            s = new Y(),
            o = new Qt()
          return function (a, l, c, u, d) {
            const h = this.globalSplatIndexToSectionMap[a],
              f = this.sections[h],
              p = a - f.splatCountOffset,
              g =
                f.bytesPerSplat * p + Oe.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,
              y = new DataView(this.bufferData, f.dataBase + g)
            ;(s.set(
              An(Zt(y, 0, this.compressionLevel), this.compressionLevel),
              An(Zt(y, 1, this.compressionLevel), this.compressionLevel),
              An(Zt(y, 2, this.compressionLevel), this.compressionLevel)
            ),
              d &&
                (d.x !== void 0 && (s.x = d.x),
                d.y !== void 0 && (s.y = d.y),
                d.z !== void 0 && (s.z = d.z)),
              o.set(
                An(Zt(y, 4, this.compressionLevel), this.compressionLevel),
                An(Zt(y, 5, this.compressionLevel), this.compressionLevel),
                An(Zt(y, 6, this.compressionLevel), this.compressionLevel),
                An(Zt(y, 3, this.compressionLevel), this.compressionLevel)
              ),
              u
                ? (e.makeScale(s.x, s.y, s.z),
                  t.makeRotationFromQuaternion(o),
                  i.copy(e).multiply(t).multiply(u),
                  i.decompose(r, c, l))
                : (l.copy(s), c.copy(o)))
          }
        })()
      )
      xe(
        this,
        'fillSplatScaleRotationArray',
        (function () {
          const e = new qe(),
            t = new qe(),
            i = new qe(),
            r = new Y(),
            s = new Qt(),
            o = new Y(),
            a = (l) => {
              const c = l.w < 0 ? -1 : 1
              ;((l.x *= c), (l.y *= c), (l.z *= c), (l.w *= c))
            }
          return function (l, c, u, d, h, f, p, g) {
            const y = this.splatCount
            ;((d = d || 0), (h = h || y - 1), f === void 0 && (f = d))
            const m = (v, x) => VB(v, x, p)
            for (let v = d; v <= h; v++) {
              const x = this.globalSplatIndexToSectionMap[v],
                _ = this.sections[x],
                S = v - _.splatCountOffset,
                C =
                  _.bytesPerSplat * S +
                  Oe.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,
                A = (v - d + f) * Oe.ScaleComponentCount,
                R = (v - d + f) * Oe.RotationComponentCount,
                w = new DataView(this.bufferData, _.dataBase + C),
                M = g && g.x !== void 0 ? g.x : Zt(w, 0, this.compressionLevel),
                I = g && g.y !== void 0 ? g.y : Zt(w, 1, this.compressionLevel),
                L = g && g.z !== void 0 ? g.z : Zt(w, 2, this.compressionLevel),
                U = Zt(w, 3, this.compressionLevel),
                T = Zt(w, 4, this.compressionLevel),
                F = Zt(w, 5, this.compressionLevel),
                V = Zt(w, 6, this.compressionLevel)
              ;(r.set(
                An(M, this.compressionLevel),
                An(I, this.compressionLevel),
                An(L, this.compressionLevel)
              ),
                s
                  .set(
                    An(T, this.compressionLevel),
                    An(F, this.compressionLevel),
                    An(V, this.compressionLevel),
                    An(U, this.compressionLevel)
                  )
                  .normalize(),
                u &&
                  (o.set(0, 0, 0),
                  e.makeScale(r.x, r.y, r.z),
                  t.makeRotationFromQuaternion(s),
                  i.identity().premultiply(e).premultiply(t),
                  i.premultiply(u),
                  i.decompose(o, s, r),
                  s.normalize()),
                a(s),
                l && ((l[A] = m(r.x, 0)), (l[A + 1] = m(r.y, 0)), (l[A + 2] = m(r.z, 0))),
                c &&
                  ((c[R] = m(s.x, 0)),
                  (c[R + 1] = m(s.y, 0)),
                  (c[R + 2] = m(s.z, 0)),
                  (c[R + 3] = m(s.w, 0))))
            }
          }
        })()
      )
      xe(
        this,
        'fillSphericalHarmonicsArray',
        (function () {
          for (let T = 0; T < 15; T++) new Y()
          const e = new pt(),
            t = new qe(),
            i = new Y(),
            r = new Y(),
            s = new Qt(),
            o = [],
            a = [],
            l = [],
            c = [],
            u = [],
            d = [],
            h = [],
            f = [],
            p = [],
            g = [],
            y = [],
            m = [],
            v = [],
            x = [],
            _ = [],
            S = [],
            C = [],
            A = [],
            R = (T) => T,
            w = (T, F, V, W) => {
              ;((T[0] = F), (T[1] = V), (T[2] = W))
            },
            M = (T, F, V, W, ee) => {
              ;((T[0] = Zt(F, W, ee, !0)),
                (T[1] = Zt(F, W + V, ee, !0)),
                (T[2] = Zt(F, W + V + V, ee, !0)))
            },
            I = (T, F) => {
              ;((F[0] = T[0]), (F[1] = T[1]), (F[2] = T[2]))
            },
            L = (T, F, V, W) => {
              ;((F[V] = W(T[0])), (F[V + 1] = W(T[1])), (F[V + 2] = W(T[2])))
            },
            U = (T, F, V, W, ee) => (
              (F[0] = An(T[0], V, !0, W, ee)),
              (F[1] = An(T[1], V, !0, W, ee)),
              (F[2] = An(T[2], V, !0, W, ee)),
              F
            )
          return function (T, F, V, W, ee, se, he) {
            const ne = this.splatCount
            ;((W = W || 0),
              (ee = ee || ne - 1),
              se === void 0 && (se = W),
              V &&
                F >= 1 &&
                (t.copy(V),
                t.decompose(i, s, r),
                s.normalize(),
                t.makeRotationFromQuaternion(s),
                e.setFromMatrix4(t),
                w(o, e.elements[4], -e.elements[7], e.elements[1]),
                w(a, -e.elements[5], e.elements[8], -e.elements[2]),
                w(l, e.elements[3], -e.elements[6], e.elements[0])))
            const ie = (le) =>
                tC(le, this.minSphericalHarmonicsCoeff, this.maxSphericalHarmonicsCoeff),
              be = (le) => zd(le, this.minSphericalHarmonicsCoeff, this.maxSphericalHarmonicsCoeff)
            for (let le = W; le <= ee; le++) {
              const fe = this.globalSplatIndexToSectionMap[le],
                we = this.sections[fe]
              F = Math.min(F, we.sphericalHarmonicsDegree)
              const Ee = Gc(F),
                Ie = le - we.splatCountOffset,
                ze =
                  we.bytesPerSplat * Ie +
                  Oe.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,
                Be = new DataView(this.bufferData, we.dataBase + ze),
                it = (le - W + se) * Ee
              let te = V ? 0 : this.compressionLevel,
                re = R
              te !== he &&
                (te === 1
                  ? he === 0
                    ? (re = O_)
                    : he == 2 && (re = ie)
                  : te === 0 && (he === 1 ? (re = jn) : he == 2 && (re = be)))
              const b = this.minSphericalHarmonicsCoeff,
                oe = this.maxSphericalHarmonicsCoeff
              F >= 1 &&
                (M(p, Be, 3, 0, this.compressionLevel),
                M(g, Be, 3, 1, this.compressionLevel),
                M(y, Be, 3, 2, this.compressionLevel),
                V
                  ? (U(p, p, this.compressionLevel, b, oe),
                    U(g, g, this.compressionLevel, b, oe),
                    U(y, y, this.compressionLevel, b, oe),
                    Oe.rotateSphericalHarmonics3(p, g, y, o, a, l, x, _, S))
                  : (I(p, x), I(g, _), I(y, S)),
                L(x, T, it, re),
                L(_, T, it + 3, re),
                L(S, T, it + 6, re),
                F >= 2 &&
                  (M(p, Be, 5, 9, this.compressionLevel),
                  M(g, Be, 5, 10, this.compressionLevel),
                  M(y, Be, 5, 11, this.compressionLevel),
                  M(m, Be, 5, 12, this.compressionLevel),
                  M(v, Be, 5, 13, this.compressionLevel),
                  V
                    ? (U(p, p, this.compressionLevel, b, oe),
                      U(g, g, this.compressionLevel, b, oe),
                      U(y, y, this.compressionLevel, b, oe),
                      U(m, m, this.compressionLevel, b, oe),
                      U(v, v, this.compressionLevel, b, oe),
                      Oe.rotateSphericalHarmonics5(
                        p,
                        g,
                        y,
                        m,
                        v,
                        o,
                        a,
                        l,
                        c,
                        u,
                        d,
                        h,
                        f,
                        x,
                        _,
                        S,
                        C,
                        A
                      ))
                    : (I(p, x), I(g, _), I(y, S), I(m, C), I(v, A)),
                  L(x, T, it + 9, re),
                  L(_, T, it + 12, re),
                  L(S, T, it + 15, re),
                  L(C, T, it + 18, re),
                  L(A, T, it + 21, re)))
            }
          }
        })()
      )
      this.constructFromBuffer(e, t)
    }
    getSplatCount() {
      return this.splatCount
    }
    getMaxSplatCount() {
      return this.maxSplatCount
    }
    getMinSphericalHarmonicsDegree() {
      let e = 0
      for (let t = 0; t < this.sections.length; t++) {
        const i = this.sections[t]
        ;(t === 0 || i.sphericalHarmonicsDegree < e) && (e = i.sphericalHarmonicsDegree)
      }
      return e
    }
    getBucketIndex(e, t) {
      let i
      const r = e.fullBucketCount * e.bucketSize
      if (t < r) i = Math.floor(t / e.bucketSize)
      else {
        let s = r
        i = e.fullBucketCount
        let o = 0
        for (; s < e.splatCount; ) {
          let a = e.partiallyFilledBucketLengths[o]
          if (t >= s && t < s + a) break
          ;((s += a), i++, o++)
        }
      }
      return i
    }
    getSplatCenter(e, t, i, r) {
      const s = this.globalSplatIndexToSectionMap[t],
        o = this.sections[s],
        a = t - o.splatCountOffset,
        l = o.bytesPerSplat * a,
        c = new DataView(this.bufferData, o.dataBase + l),
        u = Zt(c, 0, this.compressionLevel),
        d = Zt(c, 1, this.compressionLevel),
        h = Zt(c, 2, this.compressionLevel)
      if (this.compressionLevel >= 1) {
        const p = this.getBucketIndex(o, a) * Oe.BucketStorageSizeFloats,
          g = o.compressionScaleFactor,
          y = o.compressionScaleRange
        ;((i.x = (u - y) * g + o.bucketArray[p]),
          (i.y = (d - y) * g + o.bucketArray[p + 1]),
          (i.z = (h - y) * g + o.bucketArray[p + 2]))
      } else ((i.x = u), (i.y = d), (i.z = h))
      ;((i.x += e[t * 3 + 0]), (i.y += e[t * 3 + 1]), (i.z += e[t * 3 + 2]), r && i.applyMatrix4(r))
    }
    getSplatColor(e, t) {
      const i = this.globalSplatIndexToSectionMap[e],
        r = this.sections[i],
        s = e - r.splatCountOffset,
        o = r.bytesPerSplat * s + Oe.CompressionLevels[this.compressionLevel].ColorOffsetBytes,
        a = new Uint8Array(this.bufferData, r.dataBase + o, 4)
      t.set(a[0], a[1], a[2], a[3])
    }
    fillSplatCenterArray(e, t, i, r, s, o) {
      const a = this.splatCount
      ;((r = r || 0), (s = s || a - 1), o === void 0 && (o = r))
      const l = new Y()
      for (let c = r; c <= s; c++) {
        const u = this.globalSplatIndexToSectionMap[c],
          d = this.sections[u],
          h = c - d.splatCountOffset,
          f = (c - r + o) * Oe.CenterComponentCount,
          p = d.bytesPerSplat * h,
          g = new DataView(this.bufferData, d.dataBase + p),
          y = Zt(g, 0, this.compressionLevel),
          m = Zt(g, 1, this.compressionLevel),
          v = Zt(g, 2, this.compressionLevel)
        if (this.compressionLevel >= 1) {
          const _ = this.getBucketIndex(d, h) * Oe.BucketStorageSizeFloats,
            S = d.compressionScaleFactor,
            C = d.compressionScaleRange
          ;((l.x = (y - C) * S + d.bucketArray[_]),
            (l.y = (m - C) * S + d.bucketArray[_ + 1]),
            (l.z = (v - C) * S + d.bucketArray[_ + 2]))
        } else ((l.x = y), (l.y = m), (l.z = v))
        ;(i && l.applyMatrix4(i),
          (t[f] = l.x + e[c * 3 + 0]),
          (t[f + 1] = l.y + e[c * 3 + 1]),
          (t[f + 2] = l.z + e[c * 3 + 2]))
      }
    }
    fillSplatCovarianceArray(e, t, i, r, s, o) {
      const a = this.splatCount,
        l = new Y(),
        c = new Qt()
      ;((i = i || 0), (r = r || a - 1), s === void 0 && (s = i))
      for (let u = i; u <= r; u++) {
        const d = this.globalSplatIndexToSectionMap[u],
          h = this.sections[d],
          f = u - h.splatCountOffset,
          p = (u - i + s) * Oe.CovarianceComponentCount,
          g = h.bytesPerSplat * f + Oe.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,
          y = new DataView(this.bufferData, h.dataBase + g)
        ;(l.set(
          An(Zt(y, 0, this.compressionLevel), this.compressionLevel),
          An(Zt(y, 1, this.compressionLevel), this.compressionLevel),
          An(Zt(y, 2, this.compressionLevel), this.compressionLevel)
        ),
          c.set(
            An(Zt(y, 4, this.compressionLevel), this.compressionLevel),
            An(Zt(y, 5, this.compressionLevel), this.compressionLevel),
            An(Zt(y, 6, this.compressionLevel), this.compressionLevel),
            An(Zt(y, 3, this.compressionLevel), this.compressionLevel)
          ),
          Oe.computeCovariance(l, c, t, e, p, o))
      }
    }
    fillSplatColorArray(e, t, i, r, s) {
      const o = this.splatCount
      ;((i = i || 0), (r = r || o - 1), s === void 0 && (s = i))
      for (let a = i; a <= r; a++) {
        const l = this.globalSplatIndexToSectionMap[a],
          c = this.sections[l],
          u = a - c.splatCountOffset,
          d = (a - i + s) * Oe.ColorComponentCount,
          h = c.bytesPerSplat * u + Oe.CompressionLevels[this.compressionLevel].ColorOffsetBytes,
          f = new Uint8Array(this.bufferData, c.dataBase + h)
        let p = f[3]
        ;((p = p >= t ? p : 0), (e[d] = f[0]), (e[d + 1] = f[1]), (e[d + 2] = f[2]), (e[d + 3] = p))
      }
    }
    static parseHeader(e) {
      const t = new Uint8Array(e, 0, Oe.HeaderSizeBytes),
        i = new Uint16Array(e, 0, Oe.HeaderSizeBytes / 2),
        r = new Uint32Array(e, 0, Oe.HeaderSizeBytes / 4),
        s = new Float32Array(e, 0, Oe.HeaderSizeBytes / 4),
        o = t[0],
        a = t[1],
        l = r[1],
        c = r[2],
        u = r[3],
        d = r[4],
        h = i[10],
        f = new Y(s[6], s[7], s[8]),
        p = s[9] || -fa,
        g = s[10] || fa
      return {
        versionMajor: o,
        versionMinor: a,
        maxSectionCount: l,
        sectionCount: c,
        maxSplatCount: u,
        splatCount: d,
        compressionLevel: h,
        sceneCenter: f,
        minSphericalHarmonicsCoeff: p,
        maxSphericalHarmonicsCoeff: g,
      }
    }
    static writeHeaderCountsToBuffer(e, t, i) {
      const r = new Uint32Array(i, 0, Oe.HeaderSizeBytes / 4)
      ;((r[2] = e), (r[4] = t))
    }
    static writeHeaderToBuffer(e, t) {
      const i = new Uint8Array(t, 0, Oe.HeaderSizeBytes),
        r = new Uint16Array(t, 0, Oe.HeaderSizeBytes / 2),
        s = new Uint32Array(t, 0, Oe.HeaderSizeBytes / 4),
        o = new Float32Array(t, 0, Oe.HeaderSizeBytes / 4)
      ;((i[0] = e.versionMajor),
        (i[1] = e.versionMinor),
        (i[2] = 0),
        (i[3] = 0),
        (s[1] = e.maxSectionCount),
        (s[2] = e.sectionCount),
        (s[3] = e.maxSplatCount),
        (s[4] = e.splatCount),
        (r[10] = e.compressionLevel),
        (o[6] = e.sceneCenter.x),
        (o[7] = e.sceneCenter.y),
        (o[8] = e.sceneCenter.z),
        (o[9] = e.minSphericalHarmonicsCoeff || -fa),
        (o[10] = e.maxSphericalHarmonicsCoeff || fa))
    }
    static parseSectionHeaders(e, t, i = 0, r) {
      const s = e.compressionLevel,
        o = e.maxSectionCount,
        a = new Uint16Array(t, i, (o * Oe.SectionHeaderSizeBytes) / 2),
        l = new Uint32Array(t, i, (o * Oe.SectionHeaderSizeBytes) / 4),
        c = new Float32Array(t, i, (o * Oe.SectionHeaderSizeBytes) / 4),
        u = []
      let d = 0,
        h = d / 2,
        f = d / 4,
        p = Oe.HeaderSizeBytes + e.maxSectionCount * Oe.SectionHeaderSizeBytes,
        g = 0
      for (let y = 0; y < o; y++) {
        const m = l[f + 1],
          v = l[f + 2],
          x = l[f + 3],
          _ = c[f + 4],
          S = _ / 2,
          C = a[h + 10],
          A = l[f + 6] || Oe.CompressionLevels[s].ScaleRange,
          R = l[f + 8],
          w = l[f + 9],
          M = w * 4,
          I = C * x + M,
          L = a[h + 20],
          { bytesPerSplat: U } = Oe.calculateComponentStorage(s, L),
          T = U * m,
          F = T + I,
          V = {
            bytesPerSplat: U,
            splatCountOffset: g,
            splatCount: r ? m : 0,
            maxSplatCount: m,
            bucketSize: v,
            bucketCount: x,
            bucketBlockSize: _,
            halfBucketBlockSize: S,
            bucketStorageSizeBytes: C,
            bucketsStorageSizeBytes: I,
            splatDataStorageSizeBytes: T,
            storageSizeBytes: F,
            compressionScaleRange: A,
            compressionScaleFactor: S / A,
            base: p,
            bucketsBase: p + M,
            dataBase: p + I,
            fullBucketCount: R,
            partiallyFilledBucketCount: w,
            sphericalHarmonicsDegree: L,
          }
        ;((u[y] = V),
          (p += F),
          (d += Oe.SectionHeaderSizeBytes),
          (h = d / 2),
          (f = d / 4),
          (g += m))
      }
      return u
    }
    static writeSectionHeaderToBuffer(e, t, i, r = 0) {
      const s = new Uint16Array(i, r, Oe.SectionHeaderSizeBytes / 2),
        o = new Uint32Array(i, r, Oe.SectionHeaderSizeBytes / 4),
        a = new Float32Array(i, r, Oe.SectionHeaderSizeBytes / 4)
      ;((o[0] = e.splatCount),
        (o[1] = e.maxSplatCount),
        (o[2] = t >= 1 ? e.bucketSize : 0),
        (o[3] = t >= 1 ? e.bucketCount : 0),
        (a[4] = t >= 1 ? e.bucketBlockSize : 0),
        (s[10] = t >= 1 ? Oe.BucketStorageSizeBytes : 0),
        (o[6] = t >= 1 ? e.compressionScaleRange : 0),
        (o[7] = e.storageSizeBytes),
        (o[8] = t >= 1 ? e.fullBucketCount : 0),
        (o[9] = t >= 1 ? e.partiallyFilledBucketCount : 0),
        (s[20] = e.sphericalHarmonicsDegree))
    }
    static writeSectionHeaderSplatCountToBuffer(e, t, i = 0) {
      const r = new Uint32Array(t, i, Oe.SectionHeaderSizeBytes / 4)
      r[0] = e
    }
    constructFromBuffer(e, t) {
      ;((this.bufferData = e),
        (this.globalSplatIndexToLocalSplatIndexMap = []),
        (this.globalSplatIndexToSectionMap = []))
      const i = Oe.parseHeader(this.bufferData)
      ;((this.versionMajor = i.versionMajor),
        (this.versionMinor = i.versionMinor),
        (this.maxSectionCount = i.maxSectionCount),
        (this.sectionCount = t ? i.maxSectionCount : 0),
        (this.maxSplatCount = i.maxSplatCount),
        (this.splatCount = t ? i.maxSplatCount : 0),
        (this.compressionLevel = i.compressionLevel),
        (this.sceneCenter = new Y().copy(i.sceneCenter)),
        (this.minSphericalHarmonicsCoeff = i.minSphericalHarmonicsCoeff),
        (this.maxSphericalHarmonicsCoeff = i.maxSphericalHarmonicsCoeff),
        (this.sections = Oe.parseSectionHeaders(i, this.bufferData, Oe.HeaderSizeBytes, t)),
        this.linkBufferArrays(),
        this.buildMaps())
    }
    static calculateComponentStorage(e, t) {
      const i = Oe.CompressionLevels[e].BytesPerCenter,
        r = Oe.CompressionLevels[e].BytesPerScale,
        s = Oe.CompressionLevels[e].BytesPerRotation,
        o = Oe.CompressionLevels[e].BytesPerColor,
        a = Gc(t),
        l = Oe.CompressionLevels[e].BytesPerSphericalHarmonicsComponent * a,
        c = i + r + s + o + l
      return {
        bytesPerCenter: i,
        bytesPerScale: r,
        bytesPerRotation: s,
        bytesPerColor: o,
        sphericalHarmonicsComponentsPerSplat: a,
        sphericalHarmonicsBytesPerSplat: l,
        bytesPerSplat: c,
      }
    }
    linkBufferArrays() {
      for (let e = 0; e < this.maxSectionCount; e++) {
        const t = this.sections[e]
        ;((t.bucketArray = new Float32Array(
          this.bufferData,
          t.bucketsBase,
          t.bucketCount * Oe.BucketStorageSizeFloats
        )),
          t.partiallyFilledBucketCount > 0 &&
            (t.partiallyFilledBucketLengths = new Uint32Array(
              this.bufferData,
              t.base,
              t.partiallyFilledBucketCount
            )))
      }
    }
    buildMaps() {
      let e = 0
      for (let t = 0; t < this.maxSectionCount; t++) {
        const i = this.sections[t]
        for (let r = 0; r < i.maxSplatCount; r++) {
          const s = e + r
          ;((this.globalSplatIndexToLocalSplatIndexMap[s] = r),
            (this.globalSplatIndexToSectionMap[s] = t))
        }
        e += i.maxSplatCount
      }
    }
    updateLoadedCounts(e, t) {
      ;(Oe.writeHeaderCountsToBuffer(e, t, this.bufferData),
        (this.sectionCount = e),
        (this.splatCount = t))
    }
    updateSectionLoadedCounts(e, t) {
      const i = Oe.HeaderSizeBytes + Oe.SectionHeaderSizeBytes * e
      ;(Oe.writeSectionHeaderSplatCountToBuffer(t, this.bufferData, i),
        (this.sections[e].splatCount = t))
    }
    static generateFromUncompressedSplatArrays(e, t, i, r, s, o, a = []) {
      let l = 0
      for (let S = 0; S < e.length; S++) {
        const C = e[S]
        l = Math.max(C.sphericalHarmonicsDegree, l)
      }
      let c, u
      for (let S = 0; S < e.length; S++) {
        const C = e[S]
        for (let A = 0; A < C.splats.length; A++) {
          const R = C.splats[A]
          for (let w = lt.OFFSET.FRC0; w < lt.OFFSET.FRC23 && w < R.length; w++)
            ((!c || R[w] < c) && (c = R[w]), (!u || R[w] > u) && (u = R[w]))
        }
      }
      ;((c = c || -fa), (u = u || fa))
      const { bytesPerSplat: d } = Oe.calculateComponentStorage(i, l),
        h = Oe.CompressionLevels[i].ScaleRange,
        f = [],
        p = []
      let g = 0
      for (let S = 0; S < e.length; S++) {
        const C = e[S],
          A = new lt(l)
        for (let fe = 0; fe < C.splatCount; fe++) {
          const we = C.splats[fe]
          ;(we[lt.OFFSET.OPACITY] || 0) >= t && A.addSplat(we)
        }
        const R = a[S] || {},
          w = (R.blockSizeFactor || 1) * (s || Oe.BucketBlockSize),
          M = Math.ceil((R.bucketSizeFactor || 1) * (o || Oe.BucketSize)),
          I = Oe.computeBucketsForUncompressedSplatArray(A, w, M),
          L = I.fullBuckets.length,
          U = I.partiallyFullBuckets.map((fe) => fe.splats.length),
          T = U.length,
          F = [...I.fullBuckets, ...I.partiallyFullBuckets],
          V = A.splats.length * d,
          W = T * 4,
          ee = i >= 1 ? F.length * Oe.BucketStorageSizeBytes + W : 0,
          se = V + ee,
          he = new ArrayBuffer(se),
          ne = h / (w * 0.5),
          ie = new Y()
        let be = 0
        for (let fe = 0; fe < F.length; fe++) {
          const we = F[fe]
          ie.fromArray(we.center)
          for (let Ee = 0; Ee < we.splats.length; Ee++) {
            let Ie = we.splats[Ee]
            const ze = A.splats[Ie],
              Be = ee + be * d
            ;(Oe.writeSplatDataToSectionBuffer(ze, he, Be, i, l, ie, ne, h, c, u), be++)
          }
        }
        if (((g += be), i >= 1)) {
          const fe = new Uint32Array(he, 0, U.length * 4)
          for (let Ee = 0; Ee < U.length; Ee++) fe[Ee] = U[Ee]
          const we = new Float32Array(he, W, F.length * Oe.BucketStorageSizeFloats)
          for (let Ee = 0; Ee < F.length; Ee++) {
            const Ie = F[Ee],
              ze = Ee * 3
            ;((we[ze] = Ie.center[0]), (we[ze + 1] = Ie.center[1]), (we[ze + 2] = Ie.center[2]))
          }
        }
        f.push(he)
        const le = new ArrayBuffer(Oe.SectionHeaderSizeBytes)
        ;(Oe.writeSectionHeaderToBuffer(
          {
            maxSplatCount: be,
            splatCount: be,
            bucketSize: M,
            bucketCount: F.length,
            bucketBlockSize: w,
            compressionScaleRange: h,
            storageSizeBytes: se,
            fullBucketCount: L,
            partiallyFilledBucketCount: T,
            sphericalHarmonicsDegree: l,
          },
          i,
          le,
          0
        ),
          p.push(le))
      }
      let y = 0
      for (let S of f) y += S.byteLength
      const m = Oe.HeaderSizeBytes + Oe.SectionHeaderSizeBytes * f.length + y,
        v = new ArrayBuffer(m)
      Oe.writeHeaderToBuffer(
        {
          versionMajor: 0,
          versionMinor: 1,
          maxSectionCount: f.length,
          sectionCount: f.length,
          maxSplatCount: g,
          splatCount: g,
          compressionLevel: i,
          sceneCenter: r,
          minSphericalHarmonicsCoeff: c,
          maxSphericalHarmonicsCoeff: u,
        },
        v
      )
      let x = Oe.HeaderSizeBytes
      for (let S of p)
        (new Uint8Array(v, x, Oe.SectionHeaderSizeBytes).set(new Uint8Array(S)),
          (x += Oe.SectionHeaderSizeBytes))
      for (let S of f)
        (new Uint8Array(v, x, S.byteLength).set(new Uint8Array(S)), (x += S.byteLength))
      return new Oe(v)
    }
    static computeBucketsForUncompressedSplatArray(e, t, i) {
      let r = e.splatCount
      const s = t / 2,
        o = new Y(),
        a = new Y()
      for (let g = 0; g < r; g++) {
        const y = e.splats[g],
          m = [y[lt.OFFSET.X], y[lt.OFFSET.Y], y[lt.OFFSET.Z]]
        ;((g === 0 || m[0] < o.x) && (o.x = m[0]),
          (g === 0 || m[0] > a.x) && (a.x = m[0]),
          (g === 0 || m[1] < o.y) && (o.y = m[1]),
          (g === 0 || m[1] > a.y) && (a.y = m[1]),
          (g === 0 || m[2] < o.z) && (o.z = m[2]),
          (g === 0 || m[2] > a.z) && (a.z = m[2]))
      }
      const l = new Y().copy(a).sub(o),
        c = Math.ceil(l.y / t),
        u = Math.ceil(l.z / t),
        d = new Y(),
        h = [],
        f = {}
      for (let g = 0; g < r; g++) {
        const y = e.splats[g],
          m = [y[lt.OFFSET.X], y[lt.OFFSET.Y], y[lt.OFFSET.Z]],
          v = Math.floor((m[0] - o.x) / t),
          x = Math.floor((m[1] - o.y) / t),
          _ = Math.floor((m[2] - o.z) / t)
        ;((d.x = v * t + o.x + s), (d.y = x * t + o.y + s), (d.z = _ * t + o.z + s))
        const S = v * (c * u) + x * u + _
        let C = f[S]
        ;(C || (f[S] = C = { splats: [], center: d.toArray() }),
          C.splats.push(g),
          C.splats.length >= i && (h.push(C), (f[S] = null)))
      }
      const p = []
      for (let g in f)
        if (f.hasOwnProperty(g)) {
          const y = f[g]
          y && p.push(y)
        }
      return { fullBuckets: h, partiallyFullBuckets: p }
    }
  }
;(xe(Oe, 'CurrentMajorVersion', 0),
  xe(Oe, 'CurrentMinorVersion', 1),
  xe(Oe, 'CenterComponentCount', 3),
  xe(Oe, 'ScaleComponentCount', 3),
  xe(Oe, 'RotationComponentCount', 4),
  xe(Oe, 'ColorComponentCount', 4),
  xe(Oe, 'CovarianceComponentCount', 6),
  xe(Oe, 'SplatScaleOffsetFloat', 3),
  xe(Oe, 'SplatRotationOffsetFloat', 6),
  xe(Oe, 'CompressionLevels', {
    0: {
      BytesPerCenter: 12,
      BytesPerScale: 12,
      BytesPerRotation: 16,
      BytesPerColor: 4,
      ScaleOffsetBytes: 12,
      RotationffsetBytes: 24,
      ColorOffsetBytes: 40,
      SphericalHarmonicsOffsetBytes: 44,
      ScaleRange: 1,
      BytesPerSphericalHarmonicsComponent: 4,
      SphericalHarmonicsOffsetFloat: 11,
      SphericalHarmonicsDegrees: {
        0: { BytesPerSplat: 44 },
        1: { BytesPerSplat: 80 },
        2: { BytesPerSplat: 140 },
      },
    },
    1: {
      BytesPerCenter: 6,
      BytesPerScale: 6,
      BytesPerRotation: 8,
      BytesPerColor: 4,
      ScaleOffsetBytes: 6,
      RotationffsetBytes: 12,
      ColorOffsetBytes: 20,
      SphericalHarmonicsOffsetBytes: 24,
      ScaleRange: 32767,
      BytesPerSphericalHarmonicsComponent: 2,
      SphericalHarmonicsOffsetFloat: 12,
      SphericalHarmonicsDegrees: {
        0: { BytesPerSplat: 24 },
        1: { BytesPerSplat: 42 },
        2: { BytesPerSplat: 72 },
      },
    },
    2: {
      BytesPerCenter: 6,
      BytesPerScale: 6,
      BytesPerRotation: 8,
      BytesPerColor: 4,
      ScaleOffsetBytes: 6,
      RotationffsetBytes: 12,
      ColorOffsetBytes: 20,
      SphericalHarmonicsOffsetBytes: 24,
      ScaleRange: 32767,
      BytesPerSphericalHarmonicsComponent: 1,
      SphericalHarmonicsOffsetFloat: 12,
      SphericalHarmonicsDegrees: {
        0: { BytesPerSplat: 24 },
        1: { BytesPerSplat: 33 },
        2: { BytesPerSplat: 48 },
      },
    },
  }),
  xe(Oe, 'CovarianceSizeFloats', 6),
  xe(Oe, 'HeaderSizeBytes', 4096),
  xe(Oe, 'SectionHeaderSizeBytes', 1024),
  xe(Oe, 'BucketStorageSizeBytes', 12),
  xe(Oe, 'BucketStorageSizeFloats', 3),
  xe(Oe, 'BucketBlockSize', 5),
  xe(Oe, 'BucketSize', 256),
  xe(
    Oe,
    'computeCovariance',
    (function () {
      const e = new qe(),
        t = new pt(),
        i = new pt(),
        r = new pt(),
        s = new pt(),
        o = new pt(),
        a = new pt()
      return function (l, c, u, d, h = 0, f) {
        ;(e.makeScale(l.x, l.y, l.z),
          t.setFromMatrix4(e),
          e.makeRotationFromQuaternion(c),
          i.setFromMatrix4(e),
          r.copy(i).multiply(t),
          s.copy(r).transpose().premultiply(r),
          u && (o.setFromMatrix4(u), a.copy(o).transpose(), s.multiply(a), s.premultiply(o)),
          f >= 1
            ? ((d[h] = jn(s.elements[0])),
              (d[h + 1] = jn(s.elements[3])),
              (d[h + 2] = jn(s.elements[6])),
              (d[h + 3] = jn(s.elements[4])),
              (d[h + 4] = jn(s.elements[7])),
              (d[h + 5] = jn(s.elements[8])))
            : ((d[h] = s.elements[0]),
              (d[h + 1] = s.elements[3]),
              (d[h + 2] = s.elements[6]),
              (d[h + 3] = s.elements[4]),
              (d[h + 4] = s.elements[7]),
              (d[h + 5] = s.elements[8])))
      }
    })()
  ),
  xe(Oe, 'dot3', (e, t, i, r, s) => {
    s[0] = s[1] = s[2] = 0
    const o = r[0],
      a = r[1],
      l = r[2]
    ;(Oe.addInto3(e[0] * o, e[1] * o, e[2] * o, s),
      Oe.addInto3(t[0] * a, t[1] * a, t[2] * a, s),
      Oe.addInto3(i[0] * l, i[1] * l, i[2] * l, s))
  }),
  xe(Oe, 'addInto3', (e, t, i, r) => {
    ;((r[0] = r[0] + e), (r[1] = r[1] + t), (r[2] = r[2] + i))
  }),
  xe(Oe, 'dot5', (e, t, i, r, s, o, a) => {
    a[0] = a[1] = a[2] = 0
    const l = o[0],
      c = o[1],
      u = o[2],
      d = o[3],
      h = o[4]
    ;(Oe.addInto3(e[0] * l, e[1] * l, e[2] * l, a),
      Oe.addInto3(t[0] * c, t[1] * c, t[2] * c, a),
      Oe.addInto3(i[0] * u, i[1] * u, i[2] * u, a),
      Oe.addInto3(r[0] * d, r[1] * d, r[2] * d, a),
      Oe.addInto3(s[0] * h, s[1] * h, s[2] * h, a))
  }),
  xe(Oe, 'rotateSphericalHarmonics3', (e, t, i, r, s, o, a, l, c) => {
    ;(Oe.dot3(e, t, i, r, a), Oe.dot3(e, t, i, s, l), Oe.dot3(e, t, i, o, c))
  }),
  xe(Oe, 'rotateSphericalHarmonics5', (e, t, i, r, s, o, a, l, c, u, d, h, f, p, g, y, m, v) => {
    const x = Math.sqrt(0.25),
      _ = Math.sqrt(3 / 4),
      S = Math.sqrt(1 / 3),
      C = Math.sqrt(4 / 3),
      A = Math.sqrt(1 / 12)
    ;((c[0] = x * (l[2] * o[0] + l[0] * o[2] + (o[2] * l[0] + o[0] * l[2]))),
      (c[1] = l[1] * o[0] + o[1] * l[0]),
      (c[2] = _ * (l[1] * o[1] + o[1] * l[1])),
      (c[3] = l[1] * o[2] + o[1] * l[2]),
      (c[4] = x * (l[2] * o[2] - l[0] * o[0] + (o[2] * l[2] - o[0] * l[0]))),
      Oe.dot5(e, t, i, r, s, c, p),
      (u[0] = x * (a[2] * o[0] + a[0] * o[2] + (o[2] * a[0] + o[0] * a[2]))),
      (u[1] = a[1] * o[0] + o[1] * a[0]),
      (u[2] = _ * (a[1] * o[1] + o[1] * a[1])),
      (u[3] = a[1] * o[2] + o[1] * a[2]),
      (u[4] = x * (a[2] * o[2] - a[0] * o[0] + (o[2] * a[2] - o[0] * a[0]))),
      Oe.dot5(e, t, i, r, s, u, g),
      (d[0] =
        S * (a[2] * a[0] + a[0] * a[2]) +
        -A * (l[2] * l[0] + l[0] * l[2] + (o[2] * o[0] + o[0] * o[2]))),
      (d[1] = C * a[1] * a[0] + -S * (l[1] * l[0] + o[1] * o[0])),
      (d[2] = a[1] * a[1] + -x * (l[1] * l[1] + o[1] * o[1])),
      (d[3] = C * a[1] * a[2] + -S * (l[1] * l[2] + o[1] * o[2])),
      (d[4] =
        S * (a[2] * a[2] - a[0] * a[0]) +
        -A * (l[2] * l[2] - l[0] * l[0] + (o[2] * o[2] - o[0] * o[0]))),
      Oe.dot5(e, t, i, r, s, d, y),
      (h[0] = x * (a[2] * l[0] + a[0] * l[2] + (l[2] * a[0] + l[0] * a[2]))),
      (h[1] = a[1] * l[0] + l[1] * a[0]),
      (h[2] = _ * (a[1] * l[1] + l[1] * a[1])),
      (h[3] = a[1] * l[2] + l[1] * a[2]),
      (h[4] = x * (a[2] * l[2] - a[0] * l[0] + (l[2] * a[2] - l[0] * a[0]))),
      Oe.dot5(e, t, i, r, s, h, m),
      (f[0] = x * (l[2] * l[0] + l[0] * l[2] - (o[2] * o[0] + o[0] * o[2]))),
      (f[1] = l[1] * l[0] - o[1] * o[0]),
      (f[2] = _ * (l[1] * l[1] - o[1] * o[1])),
      (f[3] = l[1] * l[2] - o[1] * o[2]),
      (f[4] = x * (l[2] * l[2] - l[0] * l[0] - (o[2] * o[2] - o[0] * o[0]))),
      Oe.dot5(e, t, i, r, s, f, v))
  }),
  xe(
    Oe,
    'writeSplatDataToSectionBuffer',
    (function () {
      const e = new ArrayBuffer(12),
        t = new ArrayBuffer(12),
        i = new ArrayBuffer(16),
        r = new ArrayBuffer(4),
        s = new ArrayBuffer(256),
        o = new Qt(),
        a = new Y(),
        l = new Y(),
        {
          X: c,
          Y: u,
          Z: d,
          SCALE0: h,
          SCALE1: f,
          SCALE2: p,
          ROTATION0: g,
          ROTATION1: y,
          ROTATION2: m,
          ROTATION3: v,
          FDC0: x,
          FDC1: _,
          FDC2: S,
          OPACITY: C,
          FRC0: A,
          FRC9: R,
        } = lt.OFFSET,
        w = (M, I, L) => {
          const U = L * 2 + 1
          return ((M = Math.round(M * I) + L), gi(M, 0, U))
        }
      return function (M, I, L, U, T, F, V, W, ee = -fa, se = fa) {
        const he = Gc(T),
          ne = Oe.CompressionLevels[U].BytesPerCenter,
          ie = Oe.CompressionLevels[U].BytesPerScale,
          be = Oe.CompressionLevels[U].BytesPerRotation,
          le = Oe.CompressionLevels[U].BytesPerColor,
          fe = L,
          we = fe + ne,
          Ee = we + ie,
          Ie = Ee + be,
          ze = Ie + le
        if (
          (M[g] !== void 0 ? (o.set(M[g], M[y], M[m], M[v]), o.normalize()) : o.set(1, 0, 0, 0),
          M[h] !== void 0 ? a.set(M[h] || 0, M[f] || 0, M[p] || 0) : a.set(0, 0, 0),
          U === 0)
        ) {
          const it = new Float32Array(I, fe, Oe.CenterComponentCount),
            te = new Float32Array(I, Ee, Oe.RotationComponentCount),
            re = new Float32Array(I, we, Oe.ScaleComponentCount)
          if (
            (te.set([o.x, o.y, o.z, o.w]),
            re.set([a.x, a.y, a.z]),
            it.set([M[c], M[u], M[d]]),
            T > 0)
          ) {
            const b = new Float32Array(I, ze, he)
            if (T >= 1) {
              for (let oe = 0; oe < 9; oe++) b[oe] = M[A + oe] || 0
              if (T >= 2) for (let oe = 0; oe < 15; oe++) b[oe + 9] = M[R + oe] || 0
            }
          }
        } else {
          const it = new Uint16Array(e, 0, Oe.CenterComponentCount),
            te = new Uint16Array(i, 0, Oe.RotationComponentCount),
            re = new Uint16Array(t, 0, Oe.ScaleComponentCount)
          if (
            (te.set([jn(o.x), jn(o.y), jn(o.z), jn(o.w)]),
            re.set([jn(a.x), jn(a.y), jn(a.z)]),
            l.set(M[c], M[u], M[d]).sub(F),
            (l.x = w(l.x, V, W)),
            (l.y = w(l.y, V, W)),
            (l.z = w(l.z, V, W)),
            it.set([l.x, l.y, l.z]),
            T > 0)
          ) {
            const b = U === 1 ? Uint16Array : Uint8Array,
              oe = U === 1 ? 2 : 1,
              J = new b(s, 0, he)
            if (T >= 1) {
              for (let P = 0; P < 9; P++) {
                const k = M[A + P] || 0
                J[P] = U === 1 ? jn(k) : zd(k, ee, se)
              }
              const H = 9 * oe
              if ((vc(J.buffer, 0, I, ze, H), T >= 2)) {
                for (let P = 0; P < 15; P++) {
                  const k = M[R + P] || 0
                  J[P + 9] = U === 1 ? jn(k) : zd(k, ee, se)
                }
                vc(J.buffer, H, I, ze + H, 15 * oe)
              }
            }
          }
          ;(vc(it.buffer, 0, I, fe, 6), vc(re.buffer, 0, I, we, 6), vc(te.buffer, 0, I, Ee, 8))
        }
        const Be = new Uint8ClampedArray(r, 0, 4)
        ;(Be.set([M[x] || 0, M[_] || 0, M[S] || 0]),
          (Be[3] = M[C] || 0),
          vc(Be.buffer, 0, I, Ie, 4))
      }
    })()
  ))
let ct = Oe
const FA = new Uint8Array([112, 108, 121, 10]),
  OA = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]),
  Wg = 'end_header',
  Qg = new Map([
    ['char', Int8Array],
    ['uchar', Uint8Array],
    ['short', Int16Array],
    ['ushort', Uint16Array],
    ['int', Int32Array],
    ['uint', Uint32Array],
    ['float', Float32Array],
    ['double', Float64Array],
  ]),
  Qs = (n, e) => {
    const t = (1 << e) - 1
    return (n & t) / t
  },
  BA = (n, e) => {
    ;((n.x = Qs(e >>> 21, 11)), (n.y = Qs(e >>> 11, 10)), (n.z = Qs(e, 11)))
  },
  HB = (n, e) => {
    ;((n.x = Qs(e >>> 24, 8)), (n.y = Qs(e >>> 16, 8)), (n.z = Qs(e >>> 8, 8)), (n.w = Qs(e, 8)))
  },
  $B = (n, e) => {
    const t = 1 / (Math.sqrt(2) * 0.5),
      i = (Qs(e >>> 20, 10) - 0.5) * t,
      r = (Qs(e >>> 10, 10) - 0.5) * t,
      s = (Qs(e, 10) - 0.5) * t,
      o = Math.sqrt(1 - (i * i + r * r + s * s))
    switch (e >>> 30) {
      case 0:
        n.set(o, i, r, s)
        break
      case 1:
        n.set(i, o, r, s)
        break
      case 2:
        n.set(i, r, o, s)
        break
      case 3:
        n.set(i, r, s, o)
        break
    }
  },
  _c = (n, e, t) => n * (1 - t) + e * t,
  Ci = (n, e) => {
    var t
    return (t = n.properties.find((i) => i.name === e && i.storage)) == null ? void 0 : t.storage
  },
  Ei = class Ei {
    static decodeHeaderText(e) {
      let t, i, r
      const s = e.split('\n').filter((l) => !l.startsWith('comment '))
      let o = 0,
        a = !1
      for (let l = 1; l < s.length; ++l) {
        const c = s[l].split(' ')
        switch (c[0]) {
          case 'format':
            if (c[1] !== 'binary_little_endian') throw new Error('Unsupported ply format')
            break
          case 'element':
            ;((t = { name: c[1], count: parseInt(c[2], 10), properties: [], storageSizeBytes: 0 }),
              t.name === 'chunk' ? (i = t) : t.name === 'vertex' && (r = t))
            break
          case 'property': {
            if (!Qg.has(c[1]))
              throw new Error("Unrecognized property data type '".concat(c[1], "' in ply header"))
            const u = Qg.get(c[1]),
              d = u.BYTES_PER_ELEMENT * t.count
            ;(t.name === 'vertex' && (o += u.BYTES_PER_ELEMENT),
              t.properties.push({
                type: c[1],
                name: c[2],
                storage: null,
                byteSize: u.BYTES_PER_ELEMENT,
                storageSizeByes: d,
              }),
              (t.storageSizeBytes += d))
            break
          }
          case Wg:
            a = !0
            break
          default:
            throw new Error("Unrecognized header value '".concat(c[0], "' in ply header"))
        }
        if (a) break
      }
      return {
        chunkElement: i,
        vertexElement: r,
        bytesPerSplat: o,
        headerSizeBytes: e.indexOf(Wg) + Wg.length + 1,
        sphericalHarmonicsDegree: 0,
      }
    }
    static decodeHeader(e) {
      const t = (u, d) => {
          const h = u.length - d.length
          let f, p
          for (f = 0; f <= h; ++f) {
            for (p = 0; p < d.length && u[f + p] === d[p]; ++p);
            if (p === d.length) return f
          }
          return -1
        },
        i = (u, d) => {
          if (u.length < d.length) return !1
          for (let h = 0; h < d.length; ++h) if (u[h] !== d[h]) return !1
          return !0
        }
      let r = new Uint8Array(e),
        s
      if (r.length >= FA.length && !i(r, FA)) throw new Error('Invalid PLY header')
      if (((s = t(r, OA)), s === -1)) throw new Error('End of PLY header not found')
      const o = new TextDecoder('ascii').decode(r.slice(0, s)),
        { chunkElement: a, vertexElement: l, bytesPerSplat: c } = Ei.decodeHeaderText(o)
      return { headerSizeBytes: s + OA.length, bytesPerSplat: c, chunkElement: a, vertexElement: l }
    }
    static readElementData(e, t, i, r, s, o = null) {
      let a = t instanceof DataView ? t : new DataView(t)
      ;((r = r || 0), (s = s || e.count - 1))
      for (let l = r; l <= s; ++l)
        for (let c = 0; c < e.properties.length; ++c) {
          const u = e.properties[c],
            d = Qg.get(u.type),
            h = d.BYTES_PER_ELEMENT * e.count
          if (
            ((!u.storage || u.storage.byteLength < h) &&
              (!o || o(u.name)) &&
              (u.storage = new d(e.count)),
            u.storage)
          )
            switch (u.type) {
              case 'char':
                u.storage[l] = a.getInt8(i)
                break
              case 'uchar':
                u.storage[l] = a.getUint8(i)
                break
              case 'short':
                u.storage[l] = a.getInt16(i, !0)
                break
              case 'ushort':
                u.storage[l] = a.getUint16(i, !0)
                break
              case 'int':
                u.storage[l] = a.getInt32(i, !0)
                break
              case 'uint':
                u.storage[l] = a.getUint32(i, !0)
                break
              case 'float':
                u.storage[l] = a.getFloat32(i, !0)
                break
              case 'double':
                u.storage[l] = a.getFloat64(i, !0)
                break
            }
          i += u.byteSize
        }
      return i
    }
    static readPly(e, t = null) {
      const i = Ei.decodeHeader(e)
      let r = Ei.readElementData(i.chunkElement, e, i.headerSizeBytes, null, null, t)
      return (
        Ei.readElementData(i.vertexElement, e, r, null, null, t),
        { chunkElement: i.chunkElement, vertexElement: i.vertexElement }
      )
    }
    static getElementStorageArrays(e, t) {
      const i = Ci(e, 'min_x'),
        r = Ci(e, 'min_y'),
        s = Ci(e, 'min_z'),
        o = Ci(e, 'max_x'),
        a = Ci(e, 'max_y'),
        l = Ci(e, 'max_z'),
        c = Ci(e, 'min_scale_x'),
        u = Ci(e, 'min_scale_y'),
        d = Ci(e, 'min_scale_z'),
        h = Ci(e, 'max_scale_x'),
        f = Ci(e, 'max_scale_y'),
        p = Ci(e, 'max_scale_z'),
        g = Ci(t, 'packed_position'),
        y = Ci(t, 'packed_rotation'),
        m = Ci(t, 'packed_scale'),
        v = Ci(t, 'packed_color')
      return {
        positionExtremes: { minX: i, maxX: o, minY: r, maxY: a, minZ: s, maxZ: l },
        scaleExtremes: {
          minScaleX: c,
          maxScaleX: h,
          minScaleY: u,
          maxScaleY: f,
          minScaleZ: d,
          maxScaleZ: p,
        },
        position: g,
        rotation: y,
        scale: m,
        color: v,
      }
    }
    static parseToUncompressedSplatBufferSection(e, t, i, r, s, o, a, l, c, u = null) {
      Ei.readElementData(t, o, a, i, r, u)
      const d = ct.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,
        {
          positionExtremes: h,
          scaleExtremes: f,
          position: p,
          rotation: g,
          scale: y,
          color: m,
        } = Ei.getElementStorageArrays(e, t),
        v = lt.createSplat()
      for (let x = i; x <= r; ++x) {
        Ei.decompressSplat(x, s, p, h, y, f, g, m, v)
        const _ = x * d + c
        ct.writeSplatDataToSectionBuffer(v, l, _, 0, 0)
      }
    }
    static parseToUncompressedSplatArraySection(e, t, i, r, s, o, a, l, c = null) {
      Ei.readElementData(t, o, a, i, r, c)
      const {
        positionExtremes: u,
        scaleExtremes: d,
        position: h,
        rotation: f,
        scale: p,
        color: g,
      } = Ei.getElementStorageArrays(e, t)
      for (let y = i; y <= r; ++y) {
        const m = lt.createSplat()
        ;(Ei.decompressSplat(y, s, h, u, p, d, f, g, m), l.addSplat(m))
      }
    }
    static parseToUncompressedSplatArray(e) {
      const { chunkElement: t, vertexElement: i } = Ei.readPly(e),
        r = new lt(),
        {
          positionExtremes: s,
          scaleExtremes: o,
          position: a,
          rotation: l,
          scale: c,
          color: u,
        } = Ei.getElementStorageArrays(t, i)
      for (let h = 0; h < i.count; ++h) {
        r.addDefaultSplat()
        const f = r.getSplat(r.splatCount - 1)
        Ei.decompressSplat(h, 0, a, s, c, o, l, u, f)
      }
      return (new qe().identity(), r)
    }
  }
xe(
  Ei,
  'decompressSplat',
  (function () {
    const e = new Y(),
      t = new Qt(),
      i = new Y(),
      r = new Mt(),
      s = lt.OFFSET
    return function (o, a, l, c, u, d, h, f, p) {
      p = p || lt.createSplat()
      const g = Math.floor((a + o) / 256)
      return (
        BA(e, l[o]),
        $B(t, h[o]),
        BA(i, u[o]),
        HB(r, f[o]),
        (p[s.X] = _c(c.minX[g], c.maxX[g], e.x)),
        (p[s.Y] = _c(c.minY[g], c.maxY[g], e.y)),
        (p[s.Z] = _c(c.minZ[g], c.maxZ[g], e.z)),
        (p[s.ROTATION0] = t.x),
        (p[s.ROTATION1] = t.y),
        (p[s.ROTATION2] = t.z),
        (p[s.ROTATION3] = t.w),
        (p[s.SCALE0] = Math.exp(_c(d.minScaleX[g], d.maxScaleX[g], i.x))),
        (p[s.SCALE1] = Math.exp(_c(d.minScaleY[g], d.maxScaleY[g], i.y))),
        (p[s.SCALE2] = Math.exp(_c(d.minScaleZ[g], d.maxScaleZ[g], i.z))),
        (p[s.FDC0] = gi(Math.floor(r.x * 255), 0, 255)),
        (p[s.FDC1] = gi(Math.floor(r.y * 255), 0, 255)),
        (p[s.FDC2] = gi(Math.floor(r.z * 255), 0, 255)),
        (p[s.OPACITY] = gi(Math.floor(r.w * 255), 0, 255)),
        p
      )
    }
  })()
)
let wl = Ei
const Da = { INRIAV1: 0, INRIAV2: 1, PlayCanvasCompressed: 2 },
  [nC, U_, k_, z_, V_, H_, $_] = [0, 1, 2, 3, 4, 5, 6],
  UA = { double: nC, int: U_, uint: k_, float: z_, short: V_, ushort: H_, uchar: $_ },
  GB = { [nC]: 8, [U_]: 4, [k_]: 4, [z_]: 4, [V_]: 2, [H_]: 2, [$_]: 1 },
  _r = class _r {
    constructor() {}
    decodeSectionHeader(e, t, i = 0) {
      const r = []
      let s = !1,
        o = -1,
        a = 0,
        l = !1,
        c = null
      const u = [],
        d = [],
        h = [],
        f = {}
      for (let m = i; m < e.length; m++) {
        const v = e[m].trim()
        if (v.startsWith('element'))
          if (s) {
            o--
            break
          } else {
            ;((s = !0), (i = m), (o = m))
            const x = v.split(' ')
            let _ = 0
            for (let S of x) {
              const C = S.trim()
              C.length > 0 && (_++, _ === 2 ? (c = C) : _ === 3 && (a = parseInt(C)))
            }
          }
        else if (v.startsWith('property')) {
          const x = v.match(/(\w+)\s+(\w+)\s+(\w+)/)
          if (x) {
            const _ = x[2],
              S = x[3]
            h.push(S)
            const C = t[S]
            f[S] = _
            const A = UA[_]
            C !== void 0 && (u.push(C), (d[C] = A))
          }
        }
        if (v === _r.HeaderEndToken) {
          l = !0
          break
        }
        s && (r.push(v), o++)
      }
      const p = []
      let g = 0
      for (let m of h) {
        const v = f[m]
        if (f.hasOwnProperty(m)) {
          const x = t[m]
          x !== void 0 && (p[x] = g)
        }
        g += GB[UA[v]]
      }
      const y = this.decodeSphericalHarmonicsFromSectionHeader(h, t)
      return {
        headerLines: r,
        headerStartLine: i,
        headerEndLine: o,
        fieldTypes: d,
        fieldIds: u,
        fieldOffsets: p,
        bytesPerVertex: g,
        vertexCount: a,
        dataSizeBytes: g * a,
        endOfHeader: l,
        sectionName: c,
        sphericalHarmonicsDegree: y.degree,
        sphericalHarmonicsCoefficientsPerChannel: y.coefficientsPerChannel,
        sphericalHarmonicsDegree1Fields: y.degree1Fields,
        sphericalHarmonicsDegree2Fields: y.degree2Fields,
      }
    }
    decodeSphericalHarmonicsFromSectionHeader(e, t) {
      let i = 0,
        r = 0
      for (let l of e) l.startsWith('f_rest') && i++
      r = i / 3
      let s = 0
      ;(r >= 3 && (s = 1), r >= 8 && (s = 2))
      let o = [],
        a = []
      for (let l = 0; l < 3; l++) {
        if (s >= 1) for (let c = 0; c < 3; c++) o.push(t['f_rest_' + (c + r * l)])
        if (s >= 2) for (let c = 0; c < 5; c++) a.push(t['f_rest_' + (c + r * l + 3)])
      }
      return { degree: s, coefficientsPerChannel: r, degree1Fields: o, degree2Fields: a }
    }
    static getHeaderSectionNames(e) {
      const t = []
      for (let i of e)
        if (i.startsWith('element')) {
          const r = i.split(' ')
          let s = 0
          for (let o of r) {
            const a = o.trim()
            a.length > 0 && (s++, s === 2 && t.push(a))
          }
        }
      return t
    }
    static checkTextForEndHeader(e) {
      return !!e.includes(_r.HeaderEndToken)
    }
    static checkBufferForEndHeader(e, t, i, r) {
      const s = new Uint8Array(e, Math.max(0, t - i), i),
        o = r.decode(s)
      return _r.checkTextForEndHeader(o)
    }
    static extractHeaderFromBufferToText(e) {
      const t = new TextDecoder()
      let i = 0,
        r = ''
      const s = 100
      for (;;) {
        if (i + s >= e.byteLength)
          throw new Error('End of file reached while searching for end of header')
        const o = new Uint8Array(e, i, s)
        if (((r += t.decode(o)), (i += s), _r.checkBufferForEndHeader(e, i, s * 2, t))) break
      }
      return r
    }
    readHeaderFromBuffer(e) {
      const t = new TextDecoder()
      let i = 0,
        r = ''
      const s = 100
      for (;;) {
        if (i + s >= e.byteLength)
          throw new Error('End of file reached while searching for end of header')
        const o = new Uint8Array(e, i, s)
        if (((r += t.decode(o)), (i += s), _r.checkBufferForEndHeader(e, i, s * 2, t))) break
      }
      return r
    }
    static convertHeaderTextToLines(e) {
      const t = e.split('\n'),
        i = []
      for (let r = 0; r < t.length; r++) {
        const s = t[r].trim()
        if ((i.push(s), s === _r.HeaderEndToken)) break
      }
      return i
    }
    static determineHeaderFormatFromHeaderText(e) {
      const t = _r.convertHeaderTextToLines(e)
      let i = Da.INRIAV1
      for (let r = 0; r < t.length; r++) {
        const s = t[r].trim()
        if (s.startsWith('element chunk') || s.match(/[A-Za-z]*packed_[A-Za-z]*/))
          i = Da.PlayCanvasCompressed
        else if (s.startsWith('element codebook_centers')) i = Da.INRIAV2
        else if (s === _r.HeaderEndToken) break
      }
      return i
    }
    static determineHeaderFormatFromPlyBuffer(e) {
      const t = _r.extractHeaderFromBufferToText(e)
      return _r.determineHeaderFormatFromHeaderText(t)
    }
    static readVertex(e, t, i, r, s, o, a = !0) {
      const l = i * t.bytesPerVertex + r,
        c = t.fieldOffsets,
        u = t.fieldTypes
      for (let d of s) {
        const h = u[d]
        h === z_
          ? (o[d] = e.getFloat32(l + c[d], !0))
          : h === V_
            ? (o[d] = e.getInt16(l + c[d], !0))
            : h === H_
              ? (o[d] = e.getUint16(l + c[d], !0))
              : h === U_
                ? (o[d] = e.getInt32(l + c[d], !0))
                : h === k_
                  ? (o[d] = e.getUint32(l + c[d], !0))
                  : h === $_ &&
                    (a ? (o[d] = e.getUint8(l + c[d]) / 255) : (o[d] = e.getUint8(l + c[d])))
      }
    }
  }
xe(_r, 'HeaderEndToken', 'end_header')
let pi = _r
const iC = [
    'scale_0',
    'scale_1',
    'scale_2',
    'rot_0',
    'rot_1',
    'rot_2',
    'rot_3',
    'x',
    'y',
    'z',
    'f_dc_0',
    'f_dc_1',
    'f_dc_2',
    'opacity',
    'red',
    'green',
    'blue',
    'f_rest_0',
  ],
  WB = iC.map((n, e) => e),
  [kA, QB, jB, qB, XB, KB, YB, ZB, JB, eU, zA, tU, nU, VA, HA, iU, rU, sU] = WB,
  bl = class bl {
    constructor() {
      this.plyParserutils = new pi()
    }
    decodeHeaderLines(e) {
      let t = 0
      e.forEach((u) => {
        u.includes('f_rest_') && t++
      })
      let i = 0
      t >= 45 ? (i = 45) : t >= 24 ? (i = 24) : t >= 9 && (i = 9)
      let s = Array.from(Array(Math.max(i - 1, 0))).map((u, d) => 'f_rest_'.concat(d + 1))
      const o = [...iC, ...s],
        a = o.map((u, d) => d),
        l = a.reduce((u, d) => ((u[o[d]] = d), u), {}),
        c = this.plyParserutils.decodeSectionHeader(e, l, 0)
      return (
        (c.splatCount = c.vertexCount),
        (c.bytesPerSplat = c.bytesPerVertex),
        (c.fieldsToReadIndexes = a),
        c
      )
    }
    decodeHeaderText(e) {
      const t = pi.convertHeaderTextToLines(e),
        i = this.decodeHeaderLines(t)
      return (
        (i.headerText = e),
        (i.headerSizeBytes = e.indexOf(pi.HeaderEndToken) + pi.HeaderEndToken.length + 1),
        i
      )
    }
    decodeHeaderFromBuffer(e) {
      const t = this.plyParserutils.readHeaderFromBuffer(e)
      return this.decodeHeaderText(t)
    }
    findSplatData(e, t) {
      return new DataView(e, t.headerSizeBytes)
    }
    parseToUncompressedSplatBufferSection(e, t, i, r, s, o, a, l = 0) {
      l = Math.min(l, e.sphericalHarmonicsDegree)
      const c = ct.CompressionLevels[0].SphericalHarmonicsDegrees[l].BytesPerSplat
      for (let u = t; u <= i; u++) {
        const d = bl.parseToUncompressedSplat(r, u, e, s, l),
          h = u * c + a
        ct.writeSplatDataToSectionBuffer(d, o, h, 0, l)
      }
    }
    parseToUncompressedSplatArraySection(e, t, i, r, s, o, a = 0) {
      a = Math.min(a, e.sphericalHarmonicsDegree)
      for (let l = t; l <= i; l++) {
        const c = bl.parseToUncompressedSplat(r, l, e, s, a)
        o.addSplat(c)
      }
    }
    decodeSectionSplatData(e, t, i, r) {
      r = Math.min(r, i.sphericalHarmonicsDegree)
      const s = new lt(r)
      for (let o = 0; o < t; o++) {
        const a = bl.parseToUncompressedSplat(e, o, i, 0, r)
        s.addSplat(a)
      }
      return s
    }
    static readSplat(e, t, i, r, s) {
      return pi.readVertex(e, t, i, r, t.fieldsToReadIndexes, s, !0)
    }
    parseToUncompressedSplatArray(e, t = 0) {
      const i = this.decodeHeaderFromBuffer(e),
        r = i.splatCount,
        s = this.findSplatData(e, i)
      return this.decodeSectionSplatData(s, r, i, t)
    }
  }
xe(
  bl,
  'parseToUncompressedSplat',
  (function () {
    let e = []
    const t = new Qt(),
      i = lt.OFFSET.X,
      r = lt.OFFSET.Y,
      s = lt.OFFSET.Z,
      o = lt.OFFSET.SCALE0,
      a = lt.OFFSET.SCALE1,
      l = lt.OFFSET.SCALE2,
      c = lt.OFFSET.ROTATION0,
      u = lt.OFFSET.ROTATION1,
      d = lt.OFFSET.ROTATION2,
      h = lt.OFFSET.ROTATION3,
      f = lt.OFFSET.FDC0,
      p = lt.OFFSET.FDC1,
      g = lt.OFFSET.FDC2,
      y = lt.OFFSET.OPACITY,
      m = []
    for (let v = 0; v < 45; v++) m[v] = lt.OFFSET.FRC0 + v
    return function (v, x, _, S = 0, C = 0) {
      ;((C = Math.min(C, _.sphericalHarmonicsDegree)), bl.readSplat(v, _, x, S, e))
      const A = lt.createSplat(C)
      if (
        (e[kA] !== void 0
          ? ((A[o] = Math.exp(e[kA])), (A[a] = Math.exp(e[QB])), (A[l] = Math.exp(e[jB])))
          : ((A[o] = 0.01), (A[a] = 0.01), (A[l] = 0.01)),
        e[zA] !== void 0
          ? ((A[f] = e[zA] * 255), (A[p] = e[tU] * 255), (A[g] = e[nU] * 255))
          : e[HA] !== void 0
            ? ((A[f] = e[HA] * 255), (A[p] = e[iU] * 255), (A[g] = e[rU] * 255))
            : ((A[f] = 0), (A[p] = 0), (A[g] = 0)),
        e[VA] !== void 0 && (A[y] = (1 / (1 + Math.exp(-e[VA]))) * 255),
        (A[f] = gi(Math.floor(A[f]), 0, 255)),
        (A[p] = gi(Math.floor(A[p]), 0, 255)),
        (A[g] = gi(Math.floor(A[g]), 0, 255)),
        (A[y] = gi(Math.floor(A[y]), 0, 255)),
        C >= 1 && e[sU] !== void 0)
      ) {
        for (let R = 0; R < 9; R++) A[m[R]] = e[_.sphericalHarmonicsDegree1Fields[R]]
        if (C >= 2)
          for (let R = 0; R < 15; R++) A[m[9 + R]] = e[_.sphericalHarmonicsDegree2Fields[R]]
      }
      return (
        t.set(e[qB], e[XB], e[KB], e[YB]),
        t.normalize(),
        (A[c] = t.x),
        (A[u] = t.y),
        (A[d] = t.z),
        (A[h] = t.w),
        (A[i] = e[ZB]),
        (A[r] = e[JB]),
        (A[s] = e[eU]),
        A
      )
    }
  })()
)
let xm = bl
const rC = [
    'features_dc',
    'features_rest_0',
    'features_rest_1',
    'features_rest_2',
    'features_rest_3',
    'features_rest_4',
    'features_rest_5',
    'features_rest_6',
    'features_rest_7',
    'features_rest_8',
    'features_rest_9',
    'features_rest_10',
    'features_rest_11',
    'features_rest_12',
    'features_rest_13',
    'features_rest_14',
    'opacity',
    'scaling',
    'rotation_re',
    'rotation_im',
  ],
  jf = rC.map((n, e) => e),
  [qf, oU, aU, $A, Xf, lU, jg] = [0, 1, 4, 16, 17, 18, 19],
  sC = [
    'scale_0',
    'scale_1',
    'scale_2',
    'rot_0',
    'rot_1',
    'rot_2',
    'rot_3',
    'x',
    'y',
    'z',
    'f_dc_0',
    'f_dc_1',
    'f_dc_2',
    'opacity',
    'red',
    'green',
    'blue',
    'f_rest_0',
    'f_rest_1',
    'f_rest_2',
    'f_rest_3',
    'f_rest_4',
    'f_rest_5',
    'f_rest_6',
    'f_rest_7',
    'f_rest_8',
    'f_rest_9',
    'f_rest_10',
    'f_rest_11',
    'f_rest_12',
    'f_rest_13',
    'f_rest_14',
    'f_rest_15',
    'f_rest_16',
    'f_rest_17',
    'f_rest_18',
    'f_rest_19',
    'f_rest_20',
    'f_rest_21',
    'f_rest_22',
    'f_rest_23',
    'f_rest_24',
    'f_rest_25',
    'f_rest_26',
    'f_rest_27',
    'f_rest_28',
    'f_rest_29',
    'f_rest_30',
    'f_rest_31',
    'f_rest_32',
    'f_rest_33',
    'f_rest_34',
    'f_rest_35',
    'f_rest_36',
    'f_rest_37',
    'f_rest_38',
    'f_rest_39',
    'f_rest_40',
    'f_rest_41',
    'f_rest_42',
    'f_rest_43',
    'f_rest_44',
    'f_rest_45',
  ],
  Hy = sC.map((n, e) => e),
  [GA, cU, uU, dU, hU, fU, pU, mU, gU, yU, $y, oC, aC, WA] = Hy,
  QA = $y,
  vU = oC,
  _U = aC,
  Kf = (n) => {
    const e = (31744 & n) >> 10,
      t = 1023 & n
    return (
      (n >> 15 ? -1 : 1) *
      (e
        ? e === 31
          ? t
            ? NaN
            : 1 / 0
          : Math.pow(2, e - 15) * (1 + t / 1024)
        : (t / 1024) * 6103515625e-14)
    )
  },
  Kd = class Kd {
    constructor() {
      this.plyParserutils = new pi()
    }
    decodeSectionHeadersFromHeaderLines(e) {
      const t = Hy.reduce((u, d) => ((u[sC[d]] = d), u), {}),
        i = jf.reduce((u, d) => ((u[rC[d]] = d), u), {}),
        r = pi.getHeaderSectionNames(e)
      let s
      for (let u = 0; u < r.length; u++) r[u] === 'codebook_centers' && (s = u)
      let o = 0,
        a = !1
      const l = []
      let c = 0
      for (; !a; ) {
        let u
        ;(c === s
          ? (u = this.plyParserutils.decodeSectionHeader(e, i, o))
          : (u = this.plyParserutils.decodeSectionHeader(e, t, o)),
          (a = u.endOfHeader),
          (o = u.headerEndLine + 1),
          a || ((u.splatCount = u.vertexCount), (u.bytesPerSplat = u.bytesPerVertex)),
          l.push(u),
          c++)
      }
      return l
    }
    decodeSectionHeadersFromHeaderText(e) {
      const t = pi.convertHeaderTextToLines(e)
      return this.decodeSectionHeadersFromHeaderLines(t)
    }
    getSplatCountFromSectionHeaders(e) {
      let t = 0
      for (let i of e) i.sectionName !== 'codebook_centers' && (t += i.vertexCount)
      return t
    }
    decodeHeaderFromHeaderText(e) {
      const t = e.indexOf(pi.HeaderEndToken) + pi.HeaderEndToken.length + 1,
        i = this.decodeSectionHeadersFromHeaderText(e),
        r = this.getSplatCountFromSectionHeaders(i)
      return { headerSizeBytes: t, sectionHeaders: i, splatCount: r }
    }
    decodeHeaderFromBuffer(e) {
      const t = this.plyParserutils.readHeaderFromBuffer(e)
      return this.decodeHeaderFromHeaderText(t)
    }
    findVertexData(e, t, i) {
      let r = t.headerSizeBytes
      for (let s = 0; s < i && s < t.sectionHeaders.length; s++) {
        const o = t.sectionHeaders[s]
        r += o.dataSizeBytes
      }
      return new DataView(e, r, t.sectionHeaders[i].dataSizeBytes)
    }
    decodeCodeBook(e, t) {
      const i = [],
        r = []
      for (let s = 0; s < t.vertexCount; s++) {
        pi.readVertex(e, t, s, 0, jf, i)
        for (let o of jf) {
          const a = jf[o]
          let l = r[a]
          ;(l || (r[a] = l = []), l.push(i[o]))
        }
      }
      for (let s = 0; s < r.length; s++) {
        const o = r[s],
          a = 0.28209479177387814
        for (let l = 0; l < o.length; l++) {
          const c = Kf(o[l])
          s === $A
            ? (o[l] = Math.round((1 / (1 + Math.exp(-c))) * 255))
            : s === qf
              ? (o[l] = Math.round((0.5 + a * c) * 255))
              : s === Xf
                ? (o[l] = Math.exp(c))
                : (o[l] = c)
        }
      }
      return r
    }
    decodeSectionSplatData(e, t, i, r, s) {
      s = Math.min(s, i.sphericalHarmonicsDegree)
      const o = new lt(s)
      for (let a = 0; a < t; a++) {
        const l = Kd.parseToUncompressedSplat(e, a, i, r, 0, s)
        o.addSplat(l)
      }
      return o
    }
    static readSplat(e, t, i, r, s) {
      return pi.readVertex(e, t, i, r, Hy, s, !1)
    }
    parseToUncompressedSplatArray(e, t = 0) {
      const i = [],
        r = this.decodeHeaderFromBuffer(e, t)
      let s
      for (let a = 0; a < r.sectionHeaders.length; a++) {
        const l = r.sectionHeaders[a]
        if (l.sectionName === 'codebook_centers') {
          const c = this.findVertexData(e, r, a)
          s = this.decodeCodeBook(c, l)
        }
      }
      for (let a = 0; a < r.sectionHeaders.length; a++) {
        const l = r.sectionHeaders[a]
        if (l.sectionName !== 'codebook_centers') {
          const c = l.vertexCount,
            u = this.findVertexData(e, r, a),
            d = this.decodeSectionSplatData(u, c, l, s, t)
          i.push(d)
        }
      }
      const o = new lt(t)
      for (let a of i) for (let l of a.splats) o.addSplat(l)
      return o
    }
  }
xe(
  Kd,
  'parseToUncompressedSplat',
  (function () {
    let e = []
    const t = new Qt(),
      i = lt.OFFSET.X,
      r = lt.OFFSET.Y,
      s = lt.OFFSET.Z,
      o = lt.OFFSET.SCALE0,
      a = lt.OFFSET.SCALE1,
      l = lt.OFFSET.SCALE2,
      c = lt.OFFSET.ROTATION0,
      u = lt.OFFSET.ROTATION1,
      d = lt.OFFSET.ROTATION2,
      h = lt.OFFSET.ROTATION3,
      f = lt.OFFSET.FDC0,
      p = lt.OFFSET.FDC1,
      g = lt.OFFSET.FDC2,
      y = lt.OFFSET.OPACITY,
      m = []
    for (let v = 0; v < 45; v++) m[v] = lt.OFFSET.FRC0 + v
    return function (v, x, _, S, C = 0, A = 0) {
      ;((A = Math.min(A, _.sphericalHarmonicsDegree)), Kd.readSplat(v, _, x, C, e))
      const R = lt.createSplat(A)
      if (
        (e[GA] !== void 0
          ? ((R[o] = S[Xf][e[GA]]), (R[a] = S[Xf][e[cU]]), (R[l] = S[Xf][e[uU]]))
          : ((R[o] = 0.01), (R[a] = 0.01), (R[l] = 0.01)),
        e[$y] !== void 0
          ? ((R[f] = S[qf][e[$y]]), (R[p] = S[qf][e[oC]]), (R[g] = S[qf][e[aC]]))
          : e[QA] !== void 0
            ? ((R[f] = e[QA] * 255), (R[p] = e[vU] * 255), (R[g] = e[_U] * 255))
            : ((R[f] = 0), (R[p] = 0), (R[g] = 0)),
        e[WA] !== void 0 && (R[y] = S[$A][e[WA]]),
        (R[f] = gi(Math.floor(R[f]), 0, 255)),
        (R[p] = gi(Math.floor(R[p]), 0, 255)),
        (R[g] = gi(Math.floor(R[g]), 0, 255)),
        (R[y] = gi(Math.floor(R[y]), 0, 255)),
        A >= 1 && _.sphericalHarmonicsDegree >= 1)
      ) {
        for (let U = 0; U < 9; U++) {
          const T = S[oU + (U % 3)]
          R[m[U]] = T[e[_.sphericalHarmonicsDegree1Fields[U]]]
        }
        if (A >= 2 && _.sphericalHarmonicsDegree >= 2)
          for (let U = 0; U < 15; U++) {
            const T = S[aU + (U % 5)]
            R[m[9 + U]] = T[e[_.sphericalHarmonicsDegree2Fields[U]]]
          }
      }
      const w = S[lU][e[dU]],
        M = S[jg][e[hU]],
        I = S[jg][e[fU]],
        L = S[jg][e[pU]]
      return (
        t.set(w, M, I, L),
        t.normalize(),
        (R[c] = t.x),
        (R[u] = t.y),
        (R[d] = t.z),
        (R[h] = t.w),
        (R[i] = Kf(e[mU])),
        (R[r] = Kf(e[gU])),
        (R[s] = Kf(e[yU])),
        R
      )
    }
  })()
)
let Gy = Kd
class xU {
  static parseToUncompressedSplatArray(e, t = 0) {
    const i = pi.determineHeaderFormatFromPlyBuffer(e)
    if (i === Da.PlayCanvasCompressed) return wl.parseToUncompressedSplatArray(e)
    if (i === Da.INRIAV1) return new xm().parseToUncompressedSplatArray(e, t)
    if (i === Da.INRIAV2) return new Gy().parseToUncompressedSplatArray(e, t)
  }
}
class G_ {
  constructor(e, t, i, r) {
    ;((this.sectionCount = e),
      (this.sectionFilters = t),
      (this.groupingParameters = i),
      (this.partitionGenerator = r))
  }
  partitionUncompressedSplatArray(e) {
    let t, i, r
    if (this.partitionGenerator) {
      const o = this.partitionGenerator(e)
      ;((t = o.groupingParameters), (i = o.sectionCount), (r = o.sectionFilters))
    } else ((t = this.groupingParameters), (i = this.sectionCount), (r = this.sectionFilters))
    const s = []
    for (let o = 0; o < i; o++) {
      const a = new lt(e.sphericalHarmonicsDegree),
        l = r[o]
      for (let c = 0; c < e.splatCount; c++) l(c) && a.addSplat(e.splats[c])
      s.push(a)
    }
    return { splatArrays: s, parameters: t }
  }
  static getStandardPartitioner(e = 0, t = new Y(), i = ct.BucketBlockSize, r = ct.BucketSize) {
    const s = (o) => {
      const a = lt.OFFSET.X,
        l = lt.OFFSET.Y,
        c = lt.OFFSET.Z
      e <= 0 && (e = o.splatCount)
      const u = new Y(),
        d = 0.5,
        h = (m) => {
          ;((m.x = Math.floor(m.x / d) * d),
            (m.y = Math.floor(m.y / d) * d),
            (m.z = Math.floor(m.z / d) * d))
        }
      ;(o.splats.forEach((m) => {
        ;(u.set(m[a], m[l], m[c]).sub(t), h(u), (m.centerDist = u.lengthSq()))
      }),
        o.splats.sort((m, v) => {
          let x = m.centerDist,
            _ = v.centerDist
          return x > _ ? 1 : -1
        }))
      const f = [],
        p = []
      e = Math.min(o.splatCount, e)
      const g = Math.ceil(o.splatCount / e)
      let y = 0
      for (let m = 0; m < g; m++) {
        let v = y
        ;(f.push((x) => x >= v && x < v + e), p.push({ blocksSize: i, bucketSize: r }), (y += e))
      }
      return { sectionCount: f.length, sectionFilters: f, groupingParameters: p }
    }
    return new G_(void 0, void 0, void 0, s)
  }
}
class d0 {
  constructor(e, t, i, r, s, o, a) {
    ;((this.splatPartitioner = e),
      (this.alphaRemovalThreshold = t),
      (this.compressionLevel = i),
      (this.sectionSize = r),
      (this.sceneCenter = s ? new Y().copy(s) : void 0),
      (this.blockSize = o),
      (this.bucketSize = a))
  }
  generateFromUncompressedSplatArray(e) {
    const t = this.splatPartitioner.partitionUncompressedSplatArray(e)
    return ct.generateFromUncompressedSplatArrays(
      t.splatArrays,
      this.alphaRemovalThreshold,
      this.compressionLevel,
      this.sceneCenter,
      this.blockSize,
      this.bucketSize,
      t.parameters
    )
  }
  static getStandardGenerator(
    e = 1,
    t = 1,
    i = 0,
    r = new Y(),
    s = ct.BucketBlockSize,
    o = ct.BucketSize
  ) {
    const a = G_.getStandardPartitioner(i, r, s, o)
    return new d0(a, e, t, i, r, s, o)
  }
}
const Kn = { Downloading: 0, Processing: 1, Done: 2 }
class W_ extends Error {
  constructor(e) {
    super(e)
  }
}
const Mn = { DirectToSplatBuffer: 0, DirectToSplatArray: 1, DownloadBeforeProcessing: 2 }
function jA(n, e) {
  let t = 0
  for (let r of n) t += r.sizeBytes
  ;(!e || e.byteLength < t) && (e = new ArrayBuffer(t))
  let i = 0
  for (let r of n) (new Uint8Array(e, i, r.sizeBytes).set(r.data), (i += r.sizeBytes))
  return e
}
function qA(n, e, t, i, r, s, o, a) {
  return e
    ? d0.getStandardGenerator(t, i, r, s, o, a).generateFromUncompressedSplatArray(n)
    : ct.generateFromUncompressedSplatArrays([n], t, 0, new Y())
}
class Q_ {
  static loadFromURL(e, t, i, r, s, o, a = !0, l = 0, c, u, d, h, f) {
    let p = i ? Mn.DirectToSplatBuffer : Mn.DirectToSplatArray
    a && (p = Mn.DirectToSplatArray)
    const g = Ft.ProgressiveLoadSectionSize,
      y = ct.HeaderSizeBytes + ct.SectionHeaderSizeBytes,
      m = 1
    let v,
      x,
      _,
      S,
      C = 0,
      A = 0,
      R = !1,
      w = !1,
      M = !1
    const I = p_()
    let L = 0,
      U = 0,
      T = 0,
      F = '',
      V = null,
      W = [],
      ee
    const se = new TextDecoder(),
      he = new xm(),
      ne = (ie, be, le) => {
        const fe = ie >= 100
        if (
          (le &&
            (W.push({
              data: le,
              sizeBytes: le.byteLength,
              startBytes: T,
              endBytes: T + le.byteLength,
            }),
            (T += le.byteLength)),
          p === Mn.DownloadBeforeProcessing)
        )
          fe && I.resolve(W)
        else {
          if (R) {
            if (M && !w) {
              const we = V.headerSizeBytes + V.chunkElement.storageSizeBytes
              ;((S = jA(W, S)),
                S.byteLength >= we &&
                  (wl.readElementData(V.chunkElement, S, V.headerSizeBytes),
                  (L = we),
                  (U = we),
                  (w = !0)))
            }
          } else if (((F += se.decode(le)), pi.checkTextForEndHeader(F))) {
            const we = pi.determineHeaderFormatFromHeaderText(F)
            if (we === Da.INRIAV1)
              ((V = he.decodeHeaderText(F)), (C = V.splatCount), (w = !0), (M = !1))
            else if (we === Da.PlayCanvasCompressed)
              ((V = wl.decodeHeaderText(F)), (C = V.vertexElement.count), (M = !0))
            else {
              if (i)
                throw new W_(
                  'PlyLoader.loadFromURL() -> Selected Ply format cannot be directly loaded.'
                )
              p = Mn.DownloadBeforeProcessing
              return
            }
            l = Math.min(l, V.sphericalHarmonicsDegree)
            const Ee = ct.CompressionLevels[0].SphericalHarmonicsDegrees[l],
              Ie = y + Ee.BytesPerSplat * C
            ;(p === Mn.DirectToSplatBuffer
              ? ((x = new ArrayBuffer(Ie)),
                ct.writeHeaderToBuffer(
                  {
                    versionMajor: ct.CurrentMajorVersion,
                    versionMinor: ct.CurrentMinorVersion,
                    maxSectionCount: m,
                    sectionCount: m,
                    maxSplatCount: C,
                    splatCount: A,
                    compressionLevel: 0,
                    sceneCenter: new Y(),
                  },
                  x
                ))
              : (ee = new lt(l)),
              (L = V.headerSizeBytes),
              (U = V.headerSizeBytes),
              (R = !0))
          }
          if (R && w) {
            if (W.length > 0 && ((v = jA(W, v)), T - L > g || fe)) {
              const Ee = T - U,
                Ie = Math.floor(Ee / V.bytesPerSplat),
                ze = Ie * V.bytesPerSplat,
                Be = Ee - ze,
                it = A + Ie,
                te = U - W[0].startBytes,
                re = new DataView(v, te, ze),
                b = ct.CompressionLevels[0].SphericalHarmonicsDegrees[l],
                oe = A * b.BytesPerSplat + y
              if (
                (p === Mn.DirectToSplatBuffer
                  ? M
                    ? wl.parseToUncompressedSplatBufferSection(
                        V.chunkElement,
                        V.vertexElement,
                        0,
                        Ie - 1,
                        A,
                        re,
                        0,
                        x,
                        oe
                      )
                    : he.parseToUncompressedSplatBufferSection(V, 0, Ie - 1, re, 0, x, oe, l)
                  : M
                    ? wl.parseToUncompressedSplatArraySection(
                        V.chunkElement,
                        V.vertexElement,
                        0,
                        Ie - 1,
                        A,
                        re,
                        0,
                        ee
                      )
                    : he.parseToUncompressedSplatArraySection(V, 0, Ie - 1, re, 0, ee, l),
                (A = it),
                p === Mn.DirectToSplatBuffer &&
                  (_ ||
                    (ct.writeSectionHeaderToBuffer(
                      {
                        maxSplatCount: C,
                        splatCount: A,
                        bucketSize: 0,
                        bucketCount: 0,
                        bucketBlockSize: 0,
                        compressionScaleRange: 0,
                        storageSizeBytes: 0,
                        fullBucketCount: 0,
                        partiallyFilledBucketCount: 0,
                        sphericalHarmonicsDegree: l,
                      },
                      0,
                      x,
                      ct.HeaderSizeBytes
                    ),
                    (_ = new ct(x, !1))),
                  _.updateLoadedCounts(1, A),
                  r && r(_, fe)),
                (L += g),
                (U += ze),
                Be === 0)
              )
                W = []
              else {
                let J = [],
                  H = 0
                for (let P = W.length - 1; P >= 0; P--) {
                  const k = W[P]
                  if (((H += k.sizeBytes), J.unshift(k), H >= Be)) break
                }
                W = J
              }
            }
            fe && (p === Mn.DirectToSplatBuffer ? I.resolve(_) : I.resolve(ee))
          }
        }
        t && t(ie, be, Kn.Downloading)
      }
    return (
      t && t(0, '0%', Kn.Downloading),
      f_(e, ne, !1, c).then(
        () => (
          t && t(0, '0%', Kn.Processing),
          I.promise.then((ie) => {
            if ((t && t(100, '100%', Kn.Done), p === Mn.DownloadBeforeProcessing)) {
              const be = W.map((le) => le.data)
              return new Blob(be)
                .arrayBuffer()
                .then((le) => Q_.loadFromFileData(le, s, o, a, l, u, d, h, f))
            } else return p === Mn.DirectToSplatBuffer ? ie : ms(() => qA(ie, a, s, o, u, d, h, f))
          })
        )
      )
    )
  }
  static loadFromFileData(e, t, i, r, s = 0, o, a, l, c) {
    return ms(() => xU.parseToUncompressedSplatArray(e, s)).then((u) => qA(u, r, t, i, o, a, l, c))
  }
}
const an = class an {
  static parseToUncompressedSplatBufferSection(e, t, i, r, s, o) {
    const a = ct.CompressionLevels[0].BytesPerCenter,
      l = ct.CompressionLevels[0].BytesPerScale,
      c = ct.CompressionLevels[0].BytesPerRotation,
      u = ct.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat
    for (let d = e; d <= t; d++) {
      const h = d * an.RowSizeBytes + r,
        f = new Float32Array(i, h, 3),
        p = new Float32Array(i, h + an.CenterSizeBytes, 3),
        g = new Uint8Array(i, h + an.CenterSizeBytes + an.ScaleSizeBytes, 4),
        y = new Uint8Array(i, h + an.CenterSizeBytes + an.ScaleSizeBytes + an.RotationSizeBytes, 4),
        m = new Qt((y[1] - 128) / 128, (y[2] - 128) / 128, (y[3] - 128) / 128, (y[0] - 128) / 128)
      m.normalize()
      const v = d * u + o,
        x = new Float32Array(s, v, 3),
        _ = new Float32Array(s, v + a, 3),
        S = new Float32Array(s, v + a + l, 4),
        C = new Uint8Array(s, v + a + l + c, 4)
      ;((x[0] = f[0]),
        (x[1] = f[1]),
        (x[2] = f[2]),
        (_[0] = p[0]),
        (_[1] = p[1]),
        (_[2] = p[2]),
        (S[0] = m.w),
        (S[1] = m.x),
        (S[2] = m.y),
        (S[3] = m.z),
        (C[0] = g[0]),
        (C[1] = g[1]),
        (C[2] = g[2]),
        (C[3] = g[3]))
    }
  }
  static parseToUncompressedSplatArraySection(e, t, i, r, s) {
    for (let o = e; o <= t; o++) {
      const a = o * an.RowSizeBytes + r,
        l = new Float32Array(i, a, 3),
        c = new Float32Array(i, a + an.CenterSizeBytes, 3),
        u = new Uint8Array(i, a + an.CenterSizeBytes + an.ScaleSizeBytes, 4),
        d = new Uint8Array(i, a + an.CenterSizeBytes + an.ScaleSizeBytes + an.RotationSizeBytes, 4),
        h = new Qt((d[1] - 128) / 128, (d[2] - 128) / 128, (d[3] - 128) / 128, (d[0] - 128) / 128)
      ;(h.normalize(),
        s.addSplatFromComonents(
          l[0],
          l[1],
          l[2],
          c[0],
          c[1],
          c[2],
          h.w,
          h.x,
          h.y,
          h.z,
          u[0],
          u[1],
          u[2],
          u[3]
        ))
    }
  }
  static parseStandardSplatToUncompressedSplatArray(e) {
    const t = e.byteLength / an.RowSizeBytes,
      i = new lt()
    for (let r = 0; r < t; r++) {
      const s = r * an.RowSizeBytes,
        o = new Float32Array(e, s, 3),
        a = new Float32Array(e, s + an.CenterSizeBytes, 3),
        l = new Uint8Array(e, s + an.CenterSizeBytes + an.ScaleSizeBytes, 4),
        c = new Uint8Array(e, s + an.CenterSizeBytes + an.ScaleSizeBytes + an.ColorSizeBytes, 4),
        u = new Qt((c[1] - 128) / 128, (c[2] - 128) / 128, (c[3] - 128) / 128, (c[0] - 128) / 128)
      ;(u.normalize(),
        i.addSplatFromComonents(
          o[0],
          o[1],
          o[2],
          a[0],
          a[1],
          a[2],
          u.w,
          u.x,
          u.y,
          u.z,
          l[0],
          l[1],
          l[2],
          l[3]
        ))
    }
    return i
  }
}
;(xe(an, 'RowSizeBytes', 32),
  xe(an, 'CenterSizeBytes', 12),
  xe(an, 'ScaleSizeBytes', 12),
  xe(an, 'RotationSizeBytes', 4),
  xe(an, 'ColorSizeBytes', 4))
let vl = an
function XA(n, e, t, i, r, s, o, a) {
  return e
    ? d0.getStandardGenerator(t, i, r, s, o, a).generateFromUncompressedSplatArray(n)
    : ct.generateFromUncompressedSplatArrays([n], t, 0, new Y())
}
class j_ {
  static loadFromURL(e, t, i, r, s, o, a = !0, l, c, u, d, h) {
    let f = i ? Mn.DirectToSplatBuffer : Mn.DirectToSplatArray
    a && (f = Mn.DirectToSplatArray)
    const p = ct.HeaderSizeBytes + ct.SectionHeaderSizeBytes,
      g = Ft.ProgressiveLoadSectionSize,
      y = 1
    let m,
      v,
      x,
      _ = 0,
      S = 0,
      C
    const A = p_()
    let R = 0,
      w = 0,
      M = []
    const I = (L, U, T, F) => {
      const V = L >= 100
      if ((T && M.push(T), f === Mn.DownloadBeforeProcessing)) {
        V && A.resolve(M)
        return
      }
      if (!F) {
        if (i) throw new W_('Cannon directly load .splat because no file size info is available.')
        f = Mn.DownloadBeforeProcessing
        return
      }
      if (!m) {
        ;((_ = F / vl.RowSizeBytes), (m = new ArrayBuffer(F)))
        const W = ct.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,
          ee = p + W * _
        f === Mn.DirectToSplatBuffer
          ? ((v = new ArrayBuffer(ee)),
            ct.writeHeaderToBuffer(
              {
                versionMajor: ct.CurrentMajorVersion,
                versionMinor: ct.CurrentMinorVersion,
                maxSectionCount: y,
                sectionCount: y,
                maxSplatCount: _,
                splatCount: S,
                compressionLevel: 0,
                sceneCenter: new Y(),
              },
              v
            ))
          : (C = new lt(0))
      }
      if (T) {
        ;(new Uint8Array(m, w, T.byteLength).set(new Uint8Array(T)), (w += T.byteLength))
        const W = w - R
        if (W > g || V) {
          const se = (V ? W : g) / vl.RowSizeBytes,
            he = S + se
          ;(f === Mn.DirectToSplatBuffer
            ? vl.parseToUncompressedSplatBufferSection(S, he - 1, m, 0, v, p)
            : vl.parseToUncompressedSplatArraySection(S, he - 1, m, 0, C),
            (S = he),
            f === Mn.DirectToSplatBuffer &&
              (x ||
                (ct.writeSectionHeaderToBuffer(
                  {
                    maxSplatCount: _,
                    splatCount: S,
                    bucketSize: 0,
                    bucketCount: 0,
                    bucketBlockSize: 0,
                    compressionScaleRange: 0,
                    storageSizeBytes: 0,
                    fullBucketCount: 0,
                    partiallyFilledBucketCount: 0,
                  },
                  0,
                  v,
                  ct.HeaderSizeBytes
                ),
                (x = new ct(v, !1))),
              x.updateLoadedCounts(1, S),
              r && r(x, V)),
            (R += g))
        }
      }
      ;(V && (f === Mn.DirectToSplatBuffer ? A.resolve(x) : A.resolve(C)),
        t && t(L, U, Kn.Downloading))
    }
    return (
      t && t(0, '0%', Kn.Downloading),
      f_(e, I, !1, l).then(
        () => (
          t && t(0, '0%', Kn.Processing),
          A.promise.then(
            (L) => (
              t && t(100, '100%', Kn.Done),
              f === Mn.DownloadBeforeProcessing
                ? new Blob(M).arrayBuffer().then((U) => j_.loadFromFileData(U, s, o, a, c, u, d, h))
                : f === Mn.DirectToSplatBuffer
                  ? L
                  : ms(() => XA(L, a, s, o, c, u, d, h))
            )
          )
        )
      )
    )
  }
  static loadFromFileData(e, t, i, r, s, o, a, l) {
    return ms(() => {
      const c = vl.parseStandardSplatToUncompressedSplatArray(e)
      return XA(c, r, t, i, s, o, a, l)
    })
  }
}
const zc = class zc {
  static checkVersion(e) {
    const t = ct.CurrentMajorVersion,
      i = ct.CurrentMinorVersion,
      r = ct.parseHeader(e)
    if ((r.versionMajor === t && r.versionMinor >= i) || r.versionMajor > t) return !0
    throw new Error(
      'KSplat version not supported: v'.concat(r.versionMajor, '.').concat(r.versionMinor, '. ') +
        'Minimum required: v'.concat(t, '.').concat(i)
    )
  }
  static loadFromURL(e, t, i, r, s) {
    let o,
      a,
      l,
      c,
      u = !1,
      d = !1,
      h,
      f = [],
      p = !1,
      g = !1,
      y = 0,
      m = 0,
      v = 0,
      x = !1,
      _ = !1,
      S = !1,
      C = []
    const A = p_(),
      R = () => {
        !u &&
          !d &&
          y >= ct.HeaderSizeBytes &&
          ((d = !0),
          new Blob(C).arrayBuffer().then((F) => {
            ;((l = new ArrayBuffer(ct.HeaderSizeBytes)),
              new Uint8Array(l).set(new Uint8Array(F, 0, ct.HeaderSizeBytes)),
              zc.checkVersion(l),
              (d = !1),
              (u = !0),
              (c = ct.parseHeader(l)),
              window.setTimeout(() => {
                I()
              }, 1))
          }))
      }
    let w = 0
    const M = () => {
        w === 0 &&
          (w++,
          window.setTimeout(() => {
            ;(w--, L())
          }, 1))
      },
      I = () => {
        const T = () => {
          ;((g = !0),
            new Blob(C).arrayBuffer().then((V) => {
              ;((g = !1),
                (p = !0),
                (h = new ArrayBuffer(c.maxSectionCount * ct.SectionHeaderSizeBytes)),
                new Uint8Array(h).set(
                  new Uint8Array(
                    V,
                    ct.HeaderSizeBytes,
                    c.maxSectionCount * ct.SectionHeaderSizeBytes
                  )
                ),
                (f = ct.parseSectionHeaders(c, h, 0, !1)))
              let W = 0
              for (let se = 0; se < c.maxSectionCount; se++) W += f[se].storageSizeBytes
              const ee = ct.HeaderSizeBytes + c.maxSectionCount * ct.SectionHeaderSizeBytes + W
              if (!o) {
                o = new ArrayBuffer(ee)
                let se = 0
                for (let he = 0; he < C.length; he++) {
                  const ne = C[he]
                  ;(new Uint8Array(o, se, ne.byteLength).set(new Uint8Array(ne)),
                    (se += ne.byteLength))
                }
              }
              v = ct.HeaderSizeBytes + ct.SectionHeaderSizeBytes * c.maxSectionCount
              for (let se = 0; se <= f.length && se < c.maxSectionCount; se++)
                v += f[se].storageSizeBytes
              M()
            }))
        }
        !g &&
          !p &&
          u &&
          y >= ct.HeaderSizeBytes + ct.SectionHeaderSizeBytes * c.maxSectionCount &&
          T()
      },
      L = () => {
        if (S) return
        S = !0
        const T = () => {
          if (((S = !1), p)) {
            if (_) return
            if (((x = y >= v), y - m > Ft.ProgressiveLoadSectionSize || x)) {
              ;((m += Ft.ProgressiveLoadSectionSize), (_ = m >= v), a || (a = new ct(o, !1)))
              const V = ct.HeaderSizeBytes + ct.SectionHeaderSizeBytes * c.maxSectionCount
              let W = 0,
                ee = 0,
                se = 0
              for (let ie = 0; ie < c.maxSectionCount; ie++) {
                const be = f[ie],
                  le =
                    W +
                    be.partiallyFilledBucketCount * 4 +
                    be.bucketStorageSizeBytes * be.bucketCount,
                  fe = V + le
                if (m >= fe) {
                  ee++
                  const we = m - fe,
                    ze =
                      ct.CompressionLevels[c.compressionLevel].SphericalHarmonicsDegrees[
                        be.sphericalHarmonicsDegree
                      ].BytesPerSplat
                  let Be = Math.floor(we / ze)
                  ;((Be = Math.min(Be, be.maxSplatCount)),
                    (se += Be),
                    a.updateLoadedCounts(ee, se),
                    a.updateSectionLoadedCounts(ie, Be))
                } else break
                W += be.storageSizeBytes
              }
              r(a, _)
              const he = (m / v) * 100,
                ne = he.toFixed(2) + '%'
              ;(t && t(he, ne, Kn.Downloading), _ ? A.resolve(a) : L())
            }
          }
        }
        window.setTimeout(T, Ft.ProgressiveLoadSectionDelayDuration)
      }
    return f_(
      e,
      (T, F, V) => {
        ;(V &&
          (C.push(V),
          o && new Uint8Array(o, y, V.byteLength).set(new Uint8Array(V)),
          (y += V.byteLength)),
          i ? (R(), I(), L()) : t && t(T, F, Kn.Downloading))
      },
      !i,
      s
    ).then(
      (T) => (
        t && t(0, '0%', Kn.Processing),
        (i ? A.promise : zc.loadFromFileData(T)).then((V) => (t && t(100, '100%', Kn.Done), V))
      )
    )
  }
  static loadFromFileData(e) {
    return ms(() => (zc.checkVersion(e), new ct(e)))
  }
}
xe(
  zc,
  'downloadFile',
  (function () {
    let e
    return function (t, i) {
      const r = new Blob([t.bufferData], { type: 'application/octet-stream' })
      ;(e || ((e = document.createElement('a')), document.body.appendChild(e)),
        (e.download = i),
        (e.href = URL.createObjectURL(r)),
        e.click())
    }
  })()
)
let Wy = zc
const Hs = { Splat: 0, KSplat: 1, Ply: 2 },
  KA = (n) =>
    n.endsWith('.ply')
      ? Hs.Ply
      : n.endsWith('.splat')
        ? Hs.Splat
        : n.endsWith('.ksplat')
          ? Hs.KSplat
          : null,
  YA = { type: 'change' },
  qg = { type: 'start' },
  ZA = { type: 'end' },
  Yf = new Uh(),
  JA = new Eo(),
  SU = Math.cos(70 * Ea.DEG2RAD)
class Zf extends so {
  constructor(e, t) {
    ;(super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = 'none'),
      (this.enabled = !0),
      (this.target = new Y()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -Math.PI / 72),
      (this.maxAzimuthAngle = Math.PI / 72),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !1),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' }),
      (this.mouseButtons = { LEFT: tc.ROTATE, MIDDLE: tc.DOLLY, RIGHT: tc.PAN }),
      (this.touches = { ONE: nc.ROTATE, TWO: nc.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return a.phi
      }),
      (this.getAzimuthalAngle = function () {
        return a.theta
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target)
      }),
      (this.listenToKeyEvents = ($) => {
        ;($.addEventListener('keydown', G), (this._domElementKeyEvents = $))
      }),
      (this.stopListenToKeyEvents = () => {
        ;(this._domElementKeyEvents.removeEventListener('keydown', G),
          (this._domElementKeyEvents = null))
      }),
      (this.saveState = function () {
        ;(i.target0.copy(i.target), i.position0.copy(i.object.position), (i.zoom0 = i.object.zoom))
      }),
      (this.reset = function () {
        ;(i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          this.clearDampedRotation(),
          this.clearDampedPan(),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(YA),
          i.update(),
          (s = r.NONE))
      }),
      (this.clearDampedRotation = function () {
        ;((l.theta = 0), (l.phi = 0))
      }),
      (this.clearDampedPan = function () {
        u.set(0, 0, 0)
      }),
      (this.update = (function () {
        const $ = new Y(),
          ae = new Qt().setFromUnitVectors(e.up, new Y(0, 1, 0)),
          Ue = ae.clone().invert(),
          Le = new Y(),
          Ve = new Qt(),
          Je = new Y(),
          rt = 2 * Math.PI
        return function () {
          ;(ae.setFromUnitVectors(e.up, new Y(0, 1, 0)), Ue.copy(ae).invert())
          const Ze = i.object.position
          ;($.copy(Ze).sub(i.target),
            $.applyQuaternion(ae),
            a.setFromVector3($),
            i.autoRotate && s === r.NONE && I(w()),
            i.enableDamping
              ? ((a.theta += l.theta * i.dampingFactor), (a.phi += l.phi * i.dampingFactor))
              : ((a.theta += l.theta), (a.phi += l.phi)))
          let Ce = i.minAzimuthAngle,
            De = i.maxAzimuthAngle
          ;(isFinite(Ce) &&
            isFinite(De) &&
            (Ce < -Math.PI ? (Ce += rt) : Ce > Math.PI && (Ce -= rt),
            De < -Math.PI ? (De += rt) : De > Math.PI && (De -= rt),
            Ce <= De
              ? (a.theta = Math.max(Ce, Math.min(De, a.theta)))
              : (a.theta =
                  a.theta > (Ce + De) / 2 ? Math.max(Ce, a.theta) : Math.min(De, a.theta))),
            (a.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, a.phi))),
            a.makeSafe(),
            i.enableDamping === !0 ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u),
            (i.zoomToCursor && C) || i.object.isOrthographicCamera
              ? (a.radius = se(a.radius))
              : (a.radius = se(a.radius * c)),
            $.setFromSpherical(a),
            $.applyQuaternion(Ue),
            Ze.copy(i.target).add($),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((l.theta *= 1 - i.dampingFactor),
                (l.phi *= 1 - i.dampingFactor),
                u.multiplyScalar(1 - i.dampingFactor))
              : (l.set(0, 0, 0), u.set(0, 0, 0)))
          let Xe = !1
          if (i.zoomToCursor && C) {
            let et = null
            if (i.object.isPerspectiveCamera) {
              const _t = $.length()
              et = se(_t * c)
              const hn = _t - et
              ;(i.object.position.addScaledVector(_, hn), i.object.updateMatrixWorld())
            } else if (i.object.isOrthographicCamera) {
              const _t = new Y(S.x, S.y, 0)
              ;(_t.unproject(i.object),
                (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c))),
                i.object.updateProjectionMatrix(),
                (Xe = !0))
              const hn = new Y(S.x, S.y, 0)
              ;(hn.unproject(i.object),
                i.object.position.sub(hn).add(_t),
                i.object.updateMatrixWorld(),
                (et = $.length()))
            } else
              (console.warn(
                'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.'
              ),
                (i.zoomToCursor = !1))
            et !== null &&
              (this.screenSpacePanning
                ? i.target
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix)
                    .multiplyScalar(et)
                    .add(i.object.position)
                : (Yf.origin.copy(i.object.position),
                  Yf.direction.set(0, 0, -1).transformDirection(i.object.matrix),
                  Math.abs(i.object.up.dot(Yf.direction)) < SU
                    ? e.lookAt(i.target)
                    : (JA.setFromNormalAndCoplanarPoint(i.object.up, i.target),
                      Yf.intersectPlane(JA, i.target))))
          } else
            i.object.isOrthographicCamera &&
              ((i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c))),
              i.object.updateProjectionMatrix(),
              (Xe = !0))
          return (
            (c = 1),
            (C = !1),
            Xe ||
            Le.distanceToSquared(i.object.position) > o ||
            8 * (1 - Ve.dot(i.object.quaternion)) > o ||
            Je.distanceToSquared(i.target) > 0
              ? (i.dispatchEvent(YA),
                Le.copy(i.object.position),
                Ve.copy(i.object.quaternion),
                Je.copy(i.target),
                (Xe = !1),
                !0)
              : !1
          )
        }
      })()),
      (this.dispose = function () {
        ;(i.domElement.removeEventListener('contextmenu', z),
          i.domElement.removeEventListener('pointerdown', P),
          i.domElement.removeEventListener('pointercancel', j),
          i.domElement.removeEventListener('wheel', Q),
          i.domElement.removeEventListener('pointermove', k),
          i.domElement.removeEventListener('pointerup', j),
          i._domElementKeyEvents !== null &&
            (i._domElementKeyEvents.removeEventListener('keydown', G),
            (i._domElementKeyEvents = null)))
      }))
    const i = this,
      r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      }
    let s = r.NONE
    const o = 1e-6,
      a = new cA(),
      l = new cA()
    let c = 1
    const u = new Y(),
      d = new je(),
      h = new je(),
      f = new je(),
      p = new je(),
      g = new je(),
      y = new je(),
      m = new je(),
      v = new je(),
      x = new je(),
      _ = new Y(),
      S = new je()
    let C = !1
    const A = [],
      R = {}
    function w() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed
    }
    function M() {
      return Math.pow(0.95, i.zoomSpeed)
    }
    function I($) {
      l.theta -= $
    }
    function L($) {
      l.phi -= $
    }
    const U = (function () {
        const $ = new Y()
        return function (Ue, Le) {
          ;($.setFromMatrixColumn(Le, 0), $.multiplyScalar(-Ue), u.add($))
        }
      })(),
      T = (function () {
        const $ = new Y()
        return function (Ue, Le) {
          ;(i.screenSpacePanning === !0
            ? $.setFromMatrixColumn(Le, 1)
            : ($.setFromMatrixColumn(Le, 0), $.crossVectors(i.object.up, $)),
            $.multiplyScalar(Ue),
            u.add($))
        }
      })(),
      F = (function () {
        const $ = new Y()
        return function (Ue, Le) {
          const Ve = i.domElement
          if (i.object.isPerspectiveCamera) {
            const Je = i.object.position
            $.copy(Je).sub(i.target)
            let rt = $.length()
            ;((rt *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              U((2 * Ue * rt) / Ve.clientHeight, i.object.matrix),
              T((2 * Le * rt) / Ve.clientHeight, i.object.matrix))
          } else
            i.object.isOrthographicCamera
              ? (U(
                  (Ue * (i.object.right - i.object.left)) / i.object.zoom / Ve.clientWidth,
                  i.object.matrix
                ),
                T(
                  (Le * (i.object.top - i.object.bottom)) / i.object.zoom / Ve.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
                ),
                (i.enablePan = !1))
        }
      })()
    function V($) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera
        ? (c /= $)
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
          ),
          (i.enableZoom = !1))
    }
    function W($) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera
        ? (c *= $)
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
          ),
          (i.enableZoom = !1))
    }
    function ee($) {
      if (!i.zoomToCursor) return
      C = !0
      const ae = i.domElement.getBoundingClientRect(),
        Ue = $.clientX - ae.left,
        Le = $.clientY - ae.top,
        Ve = ae.width,
        Je = ae.height
      ;((S.x = (Ue / Ve) * 2 - 1),
        (S.y = -(Le / Je) * 2 + 1),
        _.set(S.x, S.y, 1).unproject(e).sub(e.position).normalize())
    }
    function se($) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, $))
    }
    function he($) {
      d.set($.clientX, $.clientY)
    }
    function ne($) {
      ;(ee($), m.set($.clientX, $.clientY))
    }
    function ie($) {
      p.set($.clientX, $.clientY)
    }
    function be($) {
      ;(h.set($.clientX, $.clientY), f.subVectors(h, d).multiplyScalar(i.rotateSpeed))
      const ae = i.domElement
      ;(I((2 * Math.PI * f.x) / ae.clientHeight),
        L((2 * Math.PI * f.y) / ae.clientHeight),
        d.copy(h),
        i.update())
    }
    function le($) {
      ;(v.set($.clientX, $.clientY),
        x.subVectors(v, m),
        x.y > 0 ? V(M()) : x.y < 0 && W(M()),
        m.copy(v),
        i.update())
    }
    function fe($) {
      ;(g.set($.clientX, $.clientY),
        y.subVectors(g, p).multiplyScalar(i.panSpeed),
        F(y.x, y.y),
        p.copy(g),
        i.update())
    }
    function we($) {
      ;(ee($), $.deltaY < 0 ? W(M()) : $.deltaY > 0 && V(M()), i.update())
    }
    function Ee($) {
      let ae = !1
      switch ($.code) {
        case i.keys.UP:
          ;($.ctrlKey || $.metaKey || $.shiftKey
            ? L((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : F(0, i.keyPanSpeed),
            (ae = !0))
          break
        case i.keys.BOTTOM:
          ;($.ctrlKey || $.metaKey || $.shiftKey
            ? L((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : F(0, -i.keyPanSpeed),
            (ae = !0))
          break
        case i.keys.LEFT:
          ;($.ctrlKey || $.metaKey || $.shiftKey
            ? I((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : F(i.keyPanSpeed, 0),
            (ae = !0))
          break
        case i.keys.RIGHT:
          ;($.ctrlKey || $.metaKey || $.shiftKey
            ? I((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : F(-i.keyPanSpeed, 0),
            (ae = !0))
          break
      }
      ae && ($.preventDefault(), i.update())
    }
    function Ie() {
      if (A.length === 1) d.set(A[0].pageX, A[0].pageY)
      else {
        const $ = 0.5 * (A[0].pageX + A[1].pageX),
          ae = 0.5 * (A[0].pageY + A[1].pageY)
        d.set($, ae)
      }
    }
    function ze() {
      if (A.length === 1) p.set(A[0].pageX, A[0].pageY)
      else {
        const $ = 0.5 * (A[0].pageX + A[1].pageX),
          ae = 0.5 * (A[0].pageY + A[1].pageY)
        p.set($, ae)
      }
    }
    function Be() {
      const $ = A[0].pageX - A[1].pageX,
        ae = A[0].pageY - A[1].pageY,
        Ue = Math.sqrt($ * $ + ae * ae)
      m.set(0, Ue)
    }
    function it() {
      ;(i.enableZoom && Be(), i.enablePan && ze())
    }
    function te() {
      ;(i.enableZoom && Be(), i.enableRotate && Ie())
    }
    function re($) {
      if (A.length == 1) h.set($.pageX, $.pageY)
      else {
        const Ue = Z($),
          Le = 0.5 * ($.pageX + Ue.x),
          Ve = 0.5 * ($.pageY + Ue.y)
        h.set(Le, Ve)
      }
      f.subVectors(h, d).multiplyScalar(i.rotateSpeed)
      const ae = i.domElement
      ;(I((2 * Math.PI * f.x) / ae.clientHeight),
        L((2 * Math.PI * f.y) / ae.clientHeight),
        d.copy(h))
    }
    function b($) {
      if (A.length === 1) g.set($.pageX, $.pageY)
      else {
        const ae = Z($),
          Ue = 0.5 * ($.pageX + ae.x),
          Le = 0.5 * ($.pageY + ae.y)
        g.set(Ue, Le)
      }
      ;(y.subVectors(g, p).multiplyScalar(i.panSpeed), F(y.x, y.y), p.copy(g))
    }
    function oe($) {
      const ae = Z($),
        Ue = $.pageX - ae.x,
        Le = $.pageY - ae.y,
        Ve = Math.sqrt(Ue * Ue + Le * Le)
      ;(v.set(0, Ve), x.set(0, Math.pow(v.y / m.y, i.zoomSpeed)), V(x.y), m.copy(v))
    }
    function J($) {
      ;(i.enableZoom && oe($), i.enablePan && b($))
    }
    function H($) {
      ;(i.enableZoom && oe($), i.enableRotate && re($))
    }
    function P($) {
      i.enabled !== !1 &&
        (A.length === 0 &&
          (i.domElement.setPointerCapture($.pointerId),
          i.domElement.addEventListener('pointermove', k),
          i.domElement.addEventListener('pointerup', j)),
        E($),
        $.pointerType === 'touch' ? X($) : B($))
    }
    function k($) {
      i.enabled !== !1 && ($.pointerType === 'touch' ? ue($) : D($))
    }
    function j($) {
      ;(N($),
        A.length === 0 &&
          (i.domElement.releasePointerCapture($.pointerId),
          i.domElement.removeEventListener('pointermove', k),
          i.domElement.removeEventListener('pointerup', j)),
        i.dispatchEvent(ZA),
        (s = r.NONE))
    }
    function B($) {
      let ae
      switch ($.button) {
        case 0:
          ae = i.mouseButtons.LEFT
          break
        case 1:
          ae = i.mouseButtons.MIDDLE
          break
        case 2:
          ae = i.mouseButtons.RIGHT
          break
        default:
          ae = -1
      }
      switch (ae) {
        case tc.DOLLY:
          if (i.enableZoom === !1) return
          ;(ne($), (s = r.DOLLY))
          break
        case tc.ROTATE:
          if ($.ctrlKey || $.metaKey || $.shiftKey) {
            if (i.enablePan === !1) return
            ;(ie($), (s = r.PAN))
          } else {
            if (i.enableRotate === !1) return
            ;(he($), (s = r.ROTATE))
          }
          break
        case tc.PAN:
          if ($.ctrlKey || $.metaKey || $.shiftKey) {
            if (i.enableRotate === !1) return
            ;(he($), (s = r.ROTATE))
          } else {
            if (i.enablePan === !1) return
            ;(ie($), (s = r.PAN))
          }
          break
        default:
          s = r.NONE
      }
      s !== r.NONE && i.dispatchEvent(qg)
    }
    function D($) {
      switch (s) {
        case r.ROTATE:
          if (i.enableRotate === !1) return
          be($)
          break
        case r.DOLLY:
          if (i.enableZoom === !1) return
          le($)
          break
        case r.PAN:
          if (i.enablePan === !1) return
          fe($)
          break
      }
    }
    function Q($) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        s !== r.NONE ||
        ($.preventDefault(), i.dispatchEvent(qg), we($), i.dispatchEvent(ZA))
    }
    function G($) {
      i.enabled === !1 || i.enablePan === !1 || Ee($)
    }
    function X($) {
      switch ((q($), A.length)) {
        case 1:
          switch (i.touches.ONE) {
            case nc.ROTATE:
              if (i.enableRotate === !1) return
              ;(Ie(), (s = r.TOUCH_ROTATE))
              break
            case nc.PAN:
              if (i.enablePan === !1) return
              ;(ze(), (s = r.TOUCH_PAN))
              break
            default:
              s = r.NONE
          }
          break
        case 2:
          switch (i.touches.TWO) {
            case nc.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return
              ;(it(), (s = r.TOUCH_DOLLY_PAN))
              break
            case nc.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return
              ;(te(), (s = r.TOUCH_DOLLY_ROTATE))
              break
            default:
              s = r.NONE
          }
          break
        default:
          s = r.NONE
      }
      s !== r.NONE && i.dispatchEvent(qg)
    }
    function ue($) {
      switch ((q($), s)) {
        case r.TOUCH_ROTATE:
          if (i.enableRotate === !1) return
          ;(re($), i.update())
          break
        case r.TOUCH_PAN:
          if (i.enablePan === !1) return
          ;(b($), i.update())
          break
        case r.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return
          ;(J($), i.update())
          break
        case r.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return
          ;(H($), i.update())
          break
        default:
          s = r.NONE
      }
    }
    function z($) {
      i.enabled !== !1 && $.preventDefault()
    }
    function E($) {
      A.push($)
    }
    function N($) {
      delete R[$.pointerId]
      for (let ae = 0; ae < A.length; ae++)
        if (A[ae].pointerId == $.pointerId) {
          A.splice(ae, 1)
          return
        }
    }
    function q($) {
      let ae = R[$.pointerId]
      ;(ae === void 0 && ((ae = new je()), (R[$.pointerId] = ae)), ae.set($.pageX, $.pageY))
    }
    function Z($) {
      const ae = $.pointerId === A[0].pointerId ? A[1] : A[0]
      return R[ae.pointerId]
    }
    ;(i.domElement.addEventListener('contextmenu', z),
      i.domElement.addEventListener('pointerdown', P),
      i.domElement.addEventListener('pointercancel', j),
      i.domElement.addEventListener('wheel', Q, { passive: !1 }),
      this.update())
  }
}
const AU = (n, e, t, i, r) => {
    const s = performance.now()
    let o = n.style.display === 'none' ? 0 : parseFloat(n.style.opacity)
    isNaN(o) && (o = 1)
    const a = window.setInterval(() => {
      const c = performance.now() - s
      let u = Math.min(c / i, 1)
      u > 0.999 && (u = 1)
      let d
      ;(e ? ((d = (1 - u) * o), d < 1e-4 && (d = 0)) : (d = (1 - o) * u + o),
        d > 0 ? ((n.style.display = t), (n.style.opacity = d)) : (n.style.display = 'none'),
        u >= 1 && (r && r(), window.clearInterval(a)))
    }, 16)
    return a
  },
  bU = 500,
  Gm = class Gm {
    constructor(e, t) {
      ;((this.taskIDGen = 0),
        (this.elementID = Gm.elementIDGen++),
        (this.tasks = []),
        (this.message = e || 'Loading...'),
        (this.container = t || document.body),
        (this.spinnerContainerOuter = document.createElement('div')),
        (this.spinnerContainerOuter.className = 'spinnerOuterContainer'.concat(this.elementID)),
        (this.spinnerContainerOuter.style.display = 'none'),
        (this.spinnerContainerPrimary = document.createElement('div')),
        (this.spinnerContainerPrimary.className = 'spinnerContainerPrimary'.concat(this.elementID)),
        (this.spinnerPrimary = document.createElement('div')),
        this.spinnerPrimary.classList.add(
          'spinner'.concat(this.elementID),
          'spinnerPrimary'.concat(this.elementID)
        ),
        (this.messageContainerPrimary = document.createElement('div')),
        this.messageContainerPrimary.classList.add(
          'messageContainer'.concat(this.elementID),
          'messageContainerPrimary'.concat(this.elementID)
        ),
        (this.messageContainerPrimary.innerHTML = this.message),
        (this.spinnerContainerMin = document.createElement('div')),
        (this.spinnerContainerMin.className = 'spinnerContainerMin'.concat(this.elementID)),
        (this.spinnerMin = document.createElement('div')),
        this.spinnerMin.classList.add(
          'spinner'.concat(this.elementID),
          'spinnerMin'.concat(this.elementID)
        ),
        (this.messageContainerMin = document.createElement('div')),
        this.messageContainerMin.classList.add(
          'messageContainer'.concat(this.elementID),
          'messageContainerMin'.concat(this.elementID)
        ),
        (this.messageContainerMin.innerHTML = this.message),
        this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),
        this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),
        this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),
        this.spinnerContainerMin.appendChild(this.spinnerMin),
        this.spinnerContainerMin.appendChild(this.messageContainerMin),
        this.spinnerContainerOuter.appendChild(this.spinnerContainerMin))
      const i = document.createElement('style')
      ;((i.innerHTML = '\n\n            .spinnerOuterContainer'
        .concat(
          this.elementID,
          ' {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer'
        )
        .concat(
          this.elementID,
          ' {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner'
        )
        .concat(
          this.elementID,
          ' {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary'
        )
        .concat(
          this.elementID,
          ' {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary'
        )
        .concat(
          this.elementID,
          ' {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary'
        )
        .concat(
          this.elementID,
          ' {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin'
        )
        .concat(
          this.elementID,
          ' {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin'
        )
        .concat(
          this.elementID,
          ' {\n                margin-right: 15px;\n            }\n\n            .spinnerMin'
        )
        .concat(
          this.elementID,
          ' {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin'
        )
        .concat(
          this.elementID,
          ' {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        '
        )),
        this.spinnerContainerOuter.appendChild(i),
        this.container.appendChild(this.spinnerContainerOuter),
        this.setMinimized(!1, !0),
        (this.fadeTransitions = []))
    }
    addTask(e) {
      const t = { message: e, id: this.taskIDGen++ }
      return (this.tasks.push(t), this.update(), t.id)
    }
    removeTask(e) {
      let t = 0
      for (let i of this.tasks) {
        if (i.id === e) {
          this.tasks.splice(t, 1)
          break
        }
        t++
      }
      this.update()
    }
    removeAllTasks() {
      ;((this.tasks = []), this.update())
    }
    setMessageForTask(e, t) {
      for (let i of this.tasks)
        if (i.id === e) {
          i.message = t
          break
        }
      this.update()
    }
    update() {
      this.tasks.length > 0
        ? (this.show(), this.setMessage(this.tasks[this.tasks.length - 1].message))
        : this.hide()
    }
    show() {
      ;((this.spinnerContainerOuter.style.display = 'block'), (this.visible = !0))
    }
    hide() {
      ;((this.spinnerContainerOuter.style.display = 'none'), (this.visible = !1))
    }
    setContainer(e) {
      ;(this.container &&
        this.spinnerContainerOuter.parentElement === this.container &&
        this.container.removeChild(this.spinnerContainerOuter),
        e &&
          ((this.container = e),
          this.container.appendChild(this.spinnerContainerOuter),
          (this.spinnerContainerOuter.style.zIndex = this.container.style.zIndex + 1)))
    }
    setMinimized(e, t) {
      const i = (r, s, o, a, l) => {
        o
          ? (r.style.display = s ? a : 'none')
          : (this.fadeTransitions[l] = AU(r, !s, a, bU, () => {
              this.fadeTransitions[l] = null
            }))
      }
      ;(i(this.spinnerContainerPrimary, !e, t, 'block', 0),
        i(this.spinnerContainerMin, e, t, 'flex', 1),
        (this.minimized = e))
    }
    setMessage(e) {
      ;((this.messageContainerPrimary.innerHTML = e), (this.messageContainerMin.innerHTML = e))
    }
  }
xe(Gm, 'elementIDGen', 0)
let Qy = Gm
class TU {
  constructor(e) {
    ;((this.idGen = 0),
      (this.tasks = []),
      (this.container = e || document.body),
      (this.progressBarContainerOuter = document.createElement('div')),
      (this.progressBarContainerOuter.className = 'progressBarOuterContainer'),
      (this.progressBarContainerOuter.style.display = 'none'),
      (this.progressBarBox = document.createElement('div')),
      (this.progressBarBox.className = 'progressBarBox'),
      (this.progressBarBackground = document.createElement('div')),
      (this.progressBarBackground.className = 'progressBarBackground'),
      (this.progressBar = document.createElement('div')),
      (this.progressBar.className = 'progressBar'),
      this.progressBarBackground.appendChild(this.progressBar),
      this.progressBarBox.appendChild(this.progressBarBackground),
      this.progressBarContainerOuter.appendChild(this.progressBarBox))
    const t = document.createElement('style')
    ;((t.innerHTML =
      '\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        '),
      this.progressBarContainerOuter.appendChild(t),
      this.container.appendChild(this.progressBarContainerOuter))
  }
  show() {
    this.progressBarContainerOuter.style.display = 'block'
  }
  hide() {
    this.progressBarContainerOuter.style.display = 'none'
  }
  setProgress(e) {
    this.progressBar.style.width = e + '%'
  }
  setContainer(e) {
    ;(this.container &&
      this.progressBarContainerOuter.parentElement === this.container &&
      this.container.removeChild(this.progressBarContainerOuter),
      e &&
        ((this.container = e),
        this.container.appendChild(this.progressBarContainerOuter),
        (this.progressBarContainerOuter.style.zIndex = this.container.style.zIndex + 1)))
  }
}
const eb = new Y()
class wU extends sn {
  constructor(
    e = new Y(0, 0, 1),
    t = new Y(0, 0, 0),
    i = 1,
    r = 0.1,
    s = 16776960,
    o = i * 0.2,
    a = o * 0.2
  ) {
    ;(super(), (this.type = 'ArrowHelper'))
    const l = new ph(r, r, i, 32)
    l.translate(0, i / 2, 0)
    const c = new ph(0, a, o, 32)
    ;(c.translate(0, i, 0),
      this.position.copy(t),
      (this.line = new pn(l, new Yr({ color: s, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new pn(c, new Yr({ color: s, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e))
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
    else {
      eb.set(e.z, 0, -e.x).normalize()
      const t = Math.acos(e.y)
      this.quaternion.setFromAxisAngle(eb, t)
    }
  }
  setColor(e) {
    ;(this.line.material.color.set(e), this.cone.material.color.set(e))
  }
  copy(e) {
    return (super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this)
  }
  dispose() {
    ;(this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose())
  }
}
class Vd {
  constructor(e) {
    xe(
      this,
      'updateFocusMarker',
      (function () {
        const e = new Y(),
          t = new qe(),
          i = new Y()
        return function (r, s, o) {
          ;(t.copy(s.matrixWorld).invert(),
            e.copy(r).applyMatrix4(t),
            e.normalize().multiplyScalar(10),
            e.applyMatrix4(s.matrixWorld),
            i.copy(s.position).sub(r))
          const a = i.length()
          ;(this.focusMarker.position.copy(r),
            this.focusMarker.scale.set(a, a, a),
            this.focusMarker.material.uniforms.realFocusPosition.value.copy(r),
            this.focusMarker.material.uniforms.viewport.value.copy(o),
            (this.focusMarker.material.uniformsNeedUpdate = !0))
        }
      })()
    )
    xe(
      this,
      'positionAndOrientControlPlane',
      (function () {
        const e = new Qt(),
          t = new Y(0, 1, 0)
        return function (i, r) {
          ;(e.setFromUnitVectors(t, r),
            this.controlPlane.position.copy(i),
            this.controlPlane.quaternion.copy(e))
        }
      })()
    )
    ;((this.threeScene = e),
      (this.splatRenderTarget = null),
      (this.renderTargetCopyQuad = null),
      (this.renderTargetCopyCamera = null),
      (this.meshCursor = null),
      (this.focusMarker = null),
      (this.controlPlane = null),
      (this.debugRoot = null),
      (this.secondaryDebugRoot = null))
  }
  updateSplatRenderTargetForRenderDimensions(e, t) {
    ;(this.destroySplatRendertarget(),
      (this.splatRenderTarget = new Ua(e, t, { format: Fi, stencilBuffer: !1, depthBuffer: !0 })),
      (this.splatRenderTarget.depthTexture = new Ha(e, t)),
      (this.splatRenderTarget.depthTexture.format = Nl),
      (this.splatRenderTarget.depthTexture.type = Ni))
  }
  destroySplatRendertarget() {
    this.splatRenderTarget && (this.splatRenderTarget = null)
  }
  setupRenderTargetCopyObjects() {
    const e = {
        sourceColorTexture: { type: 't', value: null },
        sourceDepthTexture: { type: 't', value: null },
      },
      t = new Nr({
        vertexShader:
          '\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ',
        fragmentShader:
          '\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ',
        uniforms: e,
        depthWrite: !1,
        depthTest: !1,
        transparent: !0,
        blending: v5,
        blendSrc: sh,
        blendSrcAlpha: sh,
        blendDst: oh,
        blendDstAlpha: oh,
      })
    ;((t.extensions.fragDepth = !0),
      (this.renderTargetCopyQuad = new pn(new mu(2, 2), t)),
      (this.renderTargetCopyCamera = new Bu(-1, 1, 1, -1, 0, 1)))
  }
  destroyRenderTargetCopyObjects() {
    this.renderTargetCopyQuad && (Cc(this.renderTargetCopyQuad), (this.renderTargetCopyQuad = null))
  }
  setupMeshCursor() {
    if (!this.meshCursor) {
      const e = new M_(0.5, 1.5, 32),
        t = new Yr({ color: 16777215 }),
        i = new pn(e, t)
      ;(i.rotation.set(0, 0, Math.PI), i.position.set(0, 1, 0))
      const r = new pn(e, t)
      r.position.set(0, -1, 0)
      const s = new pn(e, t)
      ;(s.rotation.set(0, 0, Math.PI / 2), s.position.set(1, 0, 0))
      const o = new pn(e, t)
      ;(o.rotation.set(0, 0, -Math.PI / 2),
        o.position.set(-1, 0, 0),
        (this.meshCursor = new sn()),
        this.meshCursor.add(i),
        this.meshCursor.add(r),
        this.meshCursor.add(s),
        this.meshCursor.add(o),
        this.meshCursor.scale.set(0.1, 0.1, 0.1),
        this.threeScene.add(this.meshCursor),
        (this.meshCursor.visible = !1))
    }
  }
  destroyMeshCursor() {
    this.meshCursor &&
      (Cc(this.meshCursor), this.threeScene.remove(this.meshCursor), (this.meshCursor = null))
  }
  setMeshCursorVisibility(e) {
    this.meshCursor.visible = e
  }
  getMeschCursorVisibility() {
    return this.meshCursor.visible
  }
  setMeshCursorPosition(e) {
    this.meshCursor.position.copy(e)
  }
  positionAndOrientMeshCursor(e, t) {
    ;(this.meshCursor.position.copy(e),
      this.meshCursor.up.copy(t.up),
      this.meshCursor.lookAt(t.position))
  }
  setupFocusMarker() {
    if (!this.focusMarker) {
      const e = new _m(0.5, 32, 32),
        t = Vd.buildFocusMarkerMaterial()
      ;((t.depthTest = !1),
        (t.depthWrite = !1),
        (t.transparent = !0),
        (this.focusMarker = new pn(e, t)))
    }
  }
  destroyFocusMarker() {
    this.focusMarker && (Cc(this.focusMarker), (this.focusMarker = null))
  }
  setFocusMarkerVisibility(e) {
    this.focusMarker.visible = e
  }
  setFocusMarkerOpacity(e) {
    ;((this.focusMarker.material.uniforms.opacity.value = e),
      (this.focusMarker.material.uniformsNeedUpdate = !0))
  }
  getFocusMarkerOpacity() {
    return this.focusMarker.material.uniforms.opacity.value
  }
  setupControlPlane() {
    if (!this.controlPlane) {
      const e = new mu(1, 1)
      e.rotateX(-Math.PI / 2)
      const t = new Yr({ color: 16777215 })
      ;((t.transparent = !0),
        (t.opacity = 0.6),
        (t.depthTest = !1),
        (t.depthWrite = !1),
        (t.side = wr))
      const i = new pn(e, t),
        r = new Y(0, 1, 0)
      r.normalize()
      const s = new Y(0, 0, 0),
        o = 0.5,
        a = 0.01,
        l = 56576,
        c = new wU(r, s, o, a, l, 0.1, 0.03)
      ;((this.controlPlane = new sn()), this.controlPlane.add(i), this.controlPlane.add(c))
    }
  }
  destroyControlPlane() {
    this.controlPlane && (Cc(this.controlPlane), (this.controlPlane = null))
  }
  setControlPlaneVisibility(e) {
    this.controlPlane.visible = e
  }
  addDebugMeshes() {
    ;((this.debugRoot = this.createDebugMeshes()),
      (this.secondaryDebugRoot = this.createSecondaryDebugMeshes()),
      this.threeScene.add(this.debugRoot),
      this.threeScene.add(this.secondaryDebugRoot))
  }
  destroyDebugMeshes() {
    for (let e of [this.debugRoot, this.secondaryDebugRoot]) e && (Cc(e), this.threeScene.remove(e))
    ;((this.debugRoot = null), (this.secondaryDebugRoot = null))
  }
  createDebugMeshes(e) {
    const t = new _m(1, 32, 32),
      i = new sn(),
      r = (s, o) => {
        let a = new pn(t, Vd.buildDebugMaterial(s))
        ;((a.renderOrder = e), i.add(a), a.position.fromArray(o))
      }
    return (
      r(16711680, [-50, 0, 0]),
      r(16711680, [50, 0, 0]),
      r(65280, [0, 0, -50]),
      r(65280, [0, 0, 50]),
      r(16755200, [5, 0, 5]),
      i
    )
  }
  createSecondaryDebugMeshes(e) {
    const t = new Lu(3, 3, 3),
      i = new sn()
    let r = 12303291
    const s = (a) => {
      let l = new pn(t, Vd.buildDebugMaterial(r))
      ;((l.renderOrder = e), i.add(l), l.position.fromArray(a))
    }
    let o = 10
    return (s([-o, 0, -o]), s([-o, 0, o]), s([o, 0, -o]), s([o, 0, o]), i)
  }
  static buildDebugMaterial(e) {
    const t =
        '\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ',
      i =
        '\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ',
      r = { color: { type: 'v3', value: new gt(e) } },
      s = new Nr({
        uniforms: r,
        vertexShader: t,
        fragmentShader: i,
        transparent: !1,
        depthTest: !0,
        depthWrite: !0,
        side: Ts,
      })
    return ((s.extensions.fragDepth = !0), s)
  }
  static buildFocusMarkerMaterial(e) {
    const t =
        '\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ',
      i =
        '\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ',
      r = {
        color: { type: 'v3', value: new gt(e) },
        realFocusPosition: { type: 'v3', value: new Y() },
        viewport: { type: 'v2', value: new je() },
        opacity: { value: 0 },
      }
    return new Nr({
      uniforms: r,
      vertexShader: t,
      fragmentShader: i,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      side: Ts,
    })
  }
  dispose() {
    ;(this.destroyMeshCursor(),
      this.destroyFocusMarker(),
      this.destroyDebugMeshes(),
      this.destroyControlPlane(),
      this.destroyRenderTargetCopyObjects(),
      this.destroySplatRendertarget())
  }
}
const CU = new Y(1, 0, 0),
  EU = new Y(0, 1, 0),
  MU = new Y(0, 0, 1)
class Xg {
  constructor(e = new Y(), t = new Y()) {
    xe(
      this,
      'intersectBox',
      (function () {
        const e = new Y(),
          t = [],
          i = [],
          r = []
        return function (s, o) {
          if (
            ((i[0] = this.origin.x),
            (i[1] = this.origin.y),
            (i[2] = this.origin.z),
            (r[0] = this.direction.x),
            (r[1] = this.direction.y),
            (r[2] = this.direction.z),
            this.boxContainsPoint(s, this.origin, 1e-4))
          )
            return (o && (o.origin.copy(this.origin), o.normal.set(0, 0, 0), (o.distance = -1)), !0)
          for (let a = 0; a < 3; a++) {
            if (r[a] == 0) continue
            const l = a == 0 ? CU : a == 1 ? EU : MU,
              c = r[a] < 0 ? s.max : s.min
            let u = -Math.sign(r[a])
            t[0] = a == 0 ? c.x : a == 1 ? c.y : c.z
            let d = t[0] - i[a]
            if (d * u < 0) {
              const h = (a + 1) % 3,
                f = (a + 2) % 3
              if (
                ((t[2] = (r[h] / r[a]) * d + i[h]),
                (t[1] = (r[f] / r[a]) * d + i[f]),
                e.set(t[a], t[f], t[h]),
                this.boxContainsPoint(s, e, 1e-4))
              )
                return (
                  o &&
                    (o.origin.copy(e),
                    o.normal.copy(l).multiplyScalar(u),
                    (o.distance = e.sub(this.origin).length())),
                  !0
                )
            }
          }
          return !1
        }
      })()
    )
    xe(
      this,
      'intersectSphere',
      (function () {
        const e = new Y()
        return function (t, i, r) {
          e.copy(t).sub(this.origin)
          const s = e.dot(this.direction),
            o = s * s,
            l = e.dot(e) - o,
            c = i * i
          if (l > c) return !1
          const u = Math.sqrt(c - l),
            d = s - u,
            h = s + u
          if (h < 0) return !1
          let f = d < 0 ? h : d
          return (
            r &&
              (r.origin.copy(this.origin).addScaledVector(this.direction, f),
              r.normal.copy(r.origin).sub(t).normalize(),
              (r.distance = f)),
            !0
          )
        }
      })()
    )
    ;((this.origin = new Y()), (this.direction = new Y()), this.setParameters(e, t))
  }
  setParameters(e, t) {
    ;(this.origin.copy(e), this.direction.copy(t).normalize())
  }
  boxContainsPoint(e, t, i) {
    return !(
      t.x < e.min.x - i ||
      t.x > e.max.x + i ||
      t.y < e.min.y - i ||
      t.y > e.max.y + i ||
      t.z < e.min.z - i ||
      t.z > e.max.z + i
    )
  }
}
class q_ {
  constructor() {
    ;((this.origin = new Y()), (this.normal = new Y()), (this.distance = 0), (this.splatIndex = 0))
  }
  set(e, t, i, r) {
    ;(this.origin.copy(e), this.normal.copy(t), (this.distance = i), (this.splatIndex = r))
  }
  clone() {
    const e = new q_()
    return (
      e.origin.copy(this.origin),
      e.normal.copy(this.normal),
      (e.distance = this.distance),
      (e.splatIndex = this.splatIndex),
      e
    )
  }
}
const Mo = { ThreeD: 0, TwoD: 1 }
class RU {
  constructor(e, t, i = !1) {
    xe(this, 'ndcCoords', new je())
    xe(this, 'setFromCameraAndScreenPosition', (e, t, i) => {
      if (
        ((this.ndcCoords.x = (t.x / i.x) * 2 - 1),
        (this.ndcCoords.y = ((i.y - t.y) / i.y) * 2 - 1),
        e.isPerspectiveCamera)
      )
        (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
          this.ray.direction
            .set(this.ndcCoords.x, this.ndcCoords.y, 0.5)
            .unproject(e)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = e))
      else if (e.isOrthographicCamera)
        (this.ray.origin
          .set(this.ndcCoords.x, this.ndcCoords.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          (this.camera = e))
      else throw new Error('Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type')
    })
    xe(
      this,
      'intersectSplatMesh',
      (function () {
        const e = new qe(),
          t = new qe(),
          i = new qe(),
          r = new Xg(),
          s = new Y()
        return function (o, a = []) {
          const l = o.getSplatTree()
          if (l) {
            for (let c = 0; c < l.subTrees.length; c++) {
              const u = l.subTrees[c]
              ;(t.copy(o.matrixWorld),
                o.dynamicMode && (o.getSceneTransform(c, i), t.multiply(i)),
                e.copy(t).invert(),
                r.origin.copy(this.ray.origin).applyMatrix4(e),
                r.direction.copy(this.ray.origin).add(this.ray.direction),
                r.direction.applyMatrix4(e).sub(r.origin).normalize())
              const d = []
              ;(u.rootNode && this.castRayAtSplatTreeNode(r, l, u.rootNode, d),
                d.forEach((h) => {
                  ;(h.origin.applyMatrix4(t),
                    h.normal.applyMatrix4(t).normalize(),
                    (h.distance = s.copy(h.origin).sub(this.ray.origin).length()))
                }),
                a.push(...d))
            }
            return (a.sort((c, u) => (c.distance > u.distance ? 1 : -1)), a)
          }
        }
      })()
    )
    xe(
      this,
      'castRayAtSplatTreeNode',
      (function () {
        const e = new Mt(),
          t = new Y(),
          i = new Y(),
          r = new Qt(),
          s = new q_(),
          o = 1e-7,
          a = new Y(0, 0, 0),
          l = new qe(),
          c = new qe(),
          u = new qe(),
          d = new qe(),
          h = new qe(),
          f = new Xg()
        return function (p, g, y, m = []) {
          if (p.intersectBox(y.boundingBox)) {
            if (y.data && y.data.indexes && y.data.indexes.length > 0)
              for (let v = 0; v < y.data.indexes.length; v++) {
                const x = y.data.indexes[v],
                  _ = g.splatMesh.getSceneIndexForSplat(x)
                if (
                  g.splatMesh.getScene(_).visible &&
                  (g.splatMesh.getSplatColor(x, e),
                  g.splatMesh.getSplatCenter(x, t),
                  g.splatMesh.getSplatScaleAndRotation(x, i, r),
                  !(
                    i.x <= o ||
                    i.y <= o ||
                    (g.splatMesh.splatRenderMode === Mo.ThreeD && i.z <= o)
                  ))
                )
                  if (this.raycastAgainstTrueSplatEllipsoid) {
                    ;(c.makeScale(i.x, i.y, i.z), u.makeRotationFromQuaternion(r))
                    const C = Math.log10(e.w) * 2
                    if (
                      (l.makeScale(C, C, C),
                      h.copy(l).multiply(u).multiply(c),
                      d.copy(h).invert(),
                      f.origin.copy(p.origin).sub(t).applyMatrix4(d),
                      f.direction.copy(p.origin).add(p.direction).sub(t),
                      f.direction.applyMatrix4(d).sub(f.origin).normalize(),
                      f.intersectSphere(a, 1, s))
                    ) {
                      const A = s.clone()
                      ;((A.splatIndex = x), A.origin.applyMatrix4(h).add(t), m.push(A))
                    }
                  } else {
                    let C = i.x + i.y,
                      A = 2
                    if (
                      (g.splatMesh.splatRenderMode === Mo.ThreeD && ((C += i.z), (A = 3)),
                      (C = C / A),
                      p.intersectSphere(t, C, s))
                    ) {
                      const R = s.clone()
                      ;((R.splatIndex = x), m.push(R))
                    }
                  }
              }
            if (y.children && y.children.length > 0)
              for (let v of y.children) this.castRayAtSplatTreeNode(p, g, v, m)
            return m
          }
        }
      })()
    )
    ;((this.ray = new Xg(e, t)), (this.raycastAgainstTrueSplatEllipsoid = i))
  }
}
class Qc {
  static buildVertexShaderBase(e = !1, t = !1, i = 0, r = '', s = !0) {
    let o = ''
    return (
      s == !0 ? (o += '#define USE_FLAME') : (o += '#define USE_SKINNING'),
      (o +=
        '\n        precision highp float;\n        #include <common>\n\n        attribute uint splatIndex;\n        uniform highp usampler2D flameModelTexture;\n        uniform highp usampler2D boneTexture;\n        uniform highp usampler2D boneWeightTexture;\n\n\n        uniform highp usampler2D centersColorsTexture;\n        uniform highp sampler2D sphericalHarmonicsTexture;\n        uniform highp sampler2D sphericalHarmonicsTextureR;\n        uniform highp sampler2D sphericalHarmonicsTextureG;\n        uniform highp sampler2D sphericalHarmonicsTextureB;\n\n        uniform highp usampler2D sceneIndexesTexture;\n        uniform vec2 sceneIndexesTextureSize;\n        uniform int sceneCount;\n        uniform int gaussianSplatCount;\n        uniform int bsCount;\n        uniform float headBoneIndex;\n        #ifdef USE_SKINNING\n            attribute vec4 skinIndex;\n            attribute vec4 skinWeight;\n        #endif\n    '),
      t &&
        (o += '\n            uniform float sceneOpacity['
          .concat(Ft.MaxScenes, '];\n            uniform int sceneVisibility[')
          .concat(Ft.MaxScenes, '];\n        ')),
      e &&
        (o += '\n            uniform highp mat4 transforms['.concat(Ft.MaxScenes, '];\n        ')),
      (o += '\n        '
        .concat(
          r,
          '\n        uniform vec2 focal;\n        uniform float orthoZoom;\n        uniform int orthographicMode;\n        uniform int pointCloudModeEnabled;\n        uniform float inverseFocalAdjustment;\n        uniform vec2 viewport;\n        uniform vec2 basisViewport;\n        uniform vec2 centersColorsTextureSize;\n        uniform vec2 flameModelTextureSize;\n        uniform vec2 boneWeightTextureSize;\n        uniform vec2 boneTextureSize;\n\n        uniform int sphericalHarmonicsDegree;\n        uniform vec2 sphericalHarmonicsTextureSize;\n        uniform int sphericalHarmonics8BitMode;\n        uniform int sphericalHarmonicsMultiTextureMode;\n        uniform float visibleRegionRadius;\n        uniform float visibleRegionFadeStartRadius;\n        uniform float firstRenderTime;\n        uniform float currentTime;\n        uniform int fadeInComplete;\n        uniform vec3 sceneCenter;\n        uniform float splatScale;\n        uniform float sphericalHarmonics8BitCompressionRangeMin['
        )
        .concat(
          Ft.MaxScenes,
          '];\n        uniform float sphericalHarmonics8BitCompressionRangeMax['
        )
        .concat(
          Ft.MaxScenes,
          '];\n\n        varying vec4 vColor;\n        varying vec2 vUv;\n        varying vec2 vPosition;\n        varying vec2 vSplatIndex;\n        #ifdef USE_SKINNING\n            uniform mat4 bindMatrix;\n            uniform mat4 bindMatrixInverse;\n            uniform highp sampler2D boneTexture0;\n            mat4 getBoneMatrix0( const in float i ) {\n                int size = textureSize( boneTexture0, 0 ).x;\n                int j = int( i ) * 4;\n                int x = j % size;\n                int y = j / size;\n                vec4 v1 = texelFetch( boneTexture0, ivec2( x, y ), 0 );\n                vec4 v2 = texelFetch( boneTexture0, ivec2( x + 1, y ), 0 );\n                vec4 v3 = texelFetch( boneTexture0, ivec2( x + 2, y ), 0 );\n                vec4 v4 = texelFetch( boneTexture0, ivec2( x + 3, y ), 0 );\n                return mat4( v1, v2, v3, v4 );\n            }\n        #endif\n\n        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {\n            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);\n        \n            return mat3(\n                1. - 2. * (y * y + z * z),\n                2. * (x * y + w * z),\n                2. * (x * z - w * y),\n                2. * (x * y - w * z),\n                1. - 2. * (x * x + z * z),\n                2. * (y * z + w * x),\n                2. * (x * z + w * y),\n                2. * (y * z - w * x),\n                1. - 2. * (x * x + y * y)\n            );\n        }\n\n        const float sqrt8 = sqrt(8.0);\n        const float minAlpha = 1.0 / 255.0;\n\n        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n        const uvec4 shift4 = uvec4(0, 8, 16, 24);\n        int internal = 1;//show a gaussian splatting point every internal points.\n        vec4 uintToRGBAVec (uint u) {\n           uvec4 urgba = mask4 & u;\n           urgba = urgba >> shift4;\n           vec4 rgba = vec4(urgba) * encodeNorm4;\n           return rgba;\n        }\n        float getRealIndex(int sIndex, int reducedFactor) {\n            int remainder = sIndex % reducedFactor;\n\n            if(remainder == int(0)) {\n                return float(sIndex);\n            }\n            else\n            {\n                return float(sIndex - remainder);\n            }\n        }\n\n        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(getRealIndex(int(splatIndex), internal)) * uint(stride) + uint(offset)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getFlameDataUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(int(splatIndex) / internal) * uint(stride) + uint(offset) + uint(gaussianSplatCount * bsCount)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getBoneWeightUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(int(splatIndex) / internal) * uint(stride) + uint(offset)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getBSFlameDataUV(in int bsInedex, in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(int(splatIndex) / internal) * uint(stride) + uint(offset) + uint(gaussianSplatCount * bsInedex)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(float(getRealIndex(int(sIndex), internal)) * stride) + offset) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        const float SH_C1 = 0.4886025119029199f;\n        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\n\n        mat4 getBoneMatrix( float i ) {\n            float y = i;\n            float x = 0.0;\n\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(i * 4.0) / boneTextureSize.x;//4\n            samplerUV.y = float(floor(d)) / boneTextureSize.y;//5\n            samplerUV.x = fract(d);\n\n            vec4 v1 = uintBitsToFloat(texture( boneTexture, samplerUV ));\n            vec4 v2 = uintBitsToFloat(texture( boneTexture, vec2(samplerUV.x + 1.0 / boneTextureSize.x, samplerUV.y)));\n            vec4 v3 = uintBitsToFloat(texture( boneTexture, vec2(samplerUV.x + 2.0 / boneTextureSize.x, samplerUV.y) ));\n            vec4 v4 = uintBitsToFloat(texture( boneTexture, vec2(samplerUV.x + 3.0 / boneTextureSize.x, samplerUV.y)));\n\n            return mat4( v1, v2, v3, v4 );\n        }\n\n        void main () {\n\n            uint oddOffset = splatIndex & uint(0x00000001);\n            uint doubleOddOffset = oddOffset * uint(2);\n            bool isEven = oddOffset == uint(0);\n            uint nearestEvenIndex = splatIndex - oddOffset;\n            float fOddOffset = float(oddOffset);\n\n            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n            // vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n\n            uvec3 sampledCenter = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize)).gba;\n            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenter));\n\n            vec2 flameTextureUV = getBSFlameDataUV(bsCount, 1, 0, flameModelTextureSize);\n            uvec3 sampledflamePos = texture(flameModelTexture, flameTextureUV).rgb;\n            // splatCenter += uintBitsToFloat(uvec3(sampledflamePos.rgb));\n\n            for(int i = 0; i < bsCount; ++i) {\n                vec2 flameBSTextureUV = getBSFlameDataUV(i, 1, 0, flameModelTextureSize);\n                uvec3 sampledBSPos = texture(flameModelTexture, flameBSTextureUV).rgb;\n\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(i / 4 + 5 * 4) / boneTextureSize.x;//4\n                samplerUV.y = float(floor(d)) / boneTextureSize.y;//32\n                samplerUV.x = fract(d);\n\n                vec4 bsWeight = uintBitsToFloat(texture(boneTexture, samplerUV));\n                float weight = bsWeight.r;\n                if(i % 4 == 1) {\n                    weight = bsWeight.g;\n                }\n                if(i % 4 == 2) {\n                    weight = bsWeight.b;\n                }\n                if(i % 4 == 3) {\n                    weight = bsWeight.a;\n                }\n\n                splatCenter = splatCenter + weight * uintBitsToFloat(sampledBSPos);\n            }\n\n\n            #ifdef USE_SKINNING\n                mat4 boneMatX = getBoneMatrix0( skinIndex.x );\n                mat4 boneMatY = getBoneMatrix0( skinIndex.y );\n                mat4 boneMatZ = getBoneMatrix0( skinIndex.z );\n                mat4 boneMatW = getBoneMatrix0( skinIndex.w );\n            #endif\n            #ifdef USE_SKINNING\n                mat4 skinMatrix = mat4( 0.0 );\n                skinMatrix += skinWeight.x * boneMatX;\n                skinMatrix += skinWeight.y * boneMatY;\n                skinMatrix += skinWeight.z * boneMatZ;\n                skinMatrix += skinWeight.w * boneMatW;\n                // skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n            #endif\n            vec3 transformed = vec3(splatCenter.xyz);\n            #ifdef USE_SKINNING\n                // vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n                vec4 skinVertex = vec4( transformed, 1.0 );\n\n                vec4 skinned = vec4( 0.0 );\n                // There is an offset between the Gaussian point and the mesh vertex,\n                // which will cause defects in the skeletal animation driving the Gaussian point. \n                //In order to circumvent this problem, only the head bone(index is 110 currently) is used to drive\n\n                if (headBoneIndex >= 0.0)\n                {\n                    mat4 boneMat = getBoneMatrix0( headBoneIndex );\n                    skinned += boneMat * skinVertex * 1.0;\n                }\n\n                // skinned += boneMatX * skinVertex * skinWeight.x;\n                // skinned += boneMatY * skinVertex * skinWeight.y;\n                // skinned += boneMatZ * skinVertex * skinWeight.z;\n                // skinned += boneMatW * skinVertex * skinWeight.w;\n\n                // transformed = ( bindMatrixInverse * skinned ).xyz;\n                transformed = skinned.xyz;\n\n            #endif\n            splatCenter = transformed.xyz;\n\n            #ifdef USE_FLAME\n                mat4 boneMatX = getBoneMatrix( 0.0 );\n                mat4 boneMatY = getBoneMatrix( 1.0 );\n                mat4 boneMatZ = getBoneMatrix( 2.0 );\n                mat4 boneMatW = getBoneMatrix( 3.0 );   \n                mat4 boneMat0 = getBoneMatrix( 4.0 );   \n                \n                vec2 boneWeightUV0 = getBoneWeightUV(2, 0, boneWeightTextureSize);\n                vec2 boneWeightUV1 = getBoneWeightUV(2, 1, boneWeightTextureSize);\n\n                uvec4 sampledBoneMatrixValue = texture(boneWeightTexture, boneWeightUV0);\n                uvec4 sampledBoneMatrixValue0 = texture(boneWeightTexture, boneWeightUV1);\n\n                vec4 boneMatrixValue = uintBitsToFloat(sampledBoneMatrixValue);\n                vec4 boneMatrixValue0 = uintBitsToFloat(sampledBoneMatrixValue0);\n\n                vec4 skinVertex = vec4( splatCenter, 1.0 );\n                vec4 skinned = vec4( 0.0 );\n                float minWeight = min(boneMatrixValue.x,min(boneMatrixValue.y, min(boneMatrixValue.z, min(boneMatrixValue.w, boneMatrixValue0.x))));\n                \n                if(boneMatrixValue.x > 0.0 && boneMatrixValue.x > minWeight)\n                    skinned += boneMatX * skinVertex * boneMatrixValue.x;\n                \n                if(boneMatrixValue.y > 0.0 && boneMatrixValue.y > minWeight)\n                    skinned += boneMatY * skinVertex * boneMatrixValue.y;\n                \n                if(boneMatrixValue.z > 0.0 && boneMatrixValue.z > minWeight)\n                    skinned += boneMatZ * skinVertex * boneMatrixValue.z;\n                \n                if(boneMatrixValue.w > 0.0 && boneMatrixValue.w > minWeight)\n                    skinned += boneMatW * skinVertex * boneMatrixValue.w;\n                \n                if(boneMatrixValue0.x > 0.0 && boneMatrixValue0.x > minWeight)\n                    skinned += boneMat0 * skinVertex * boneMatrixValue0.x;\n                \n                splatCenter = skinned.xyz;\n            #endif\n\n            uint sceneIndex = uint(0);\n            if (sceneCount > 1) {\n                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;\n            }\n            '
        )),
      t &&
        (o +=
          '\n                float splatOpacityFromScene = sceneOpacity[sceneIndex];\n                int sceneVisible = sceneVisibility[sceneIndex];\n                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n            '),
      e
        ? (o +=
            '\n                mat4 transform = transforms[sceneIndex];\n                mat4 transformModelViewMatrix = viewMatrix * transform;\n                #ifdef USE_SKINNING\n                    transformModelViewMatrix = transformModelViewMatrix * skinMatrix;\n                #endif\n            ')
        : (o += 'mat4 transformModelViewMatrix = modelViewMatrix;'),
      (o +=
        '\n            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];\n            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];\n            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;\n            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;\n            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);\n\n            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n            vec4 clipCenter = projectionMatrix * viewCenter;\n\n            float clip = 1.2 * clipCenter.w;\n            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                return;\n            }\n\n            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n            vPosition = position.xy;\n            vSplatIndex = vec2(splatIndex, splatIndex);\n\n            vColor = uintToRGBAVec(sampledCenterColor.r);\n        '),
      i >= 1 &&
        ((o += '   \n            if (sphericalHarmonicsDegree >= 1) {\n            '),
        e
          ? (o +=
              '\n                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));\n                ')
          : (o +=
              '\n                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);\n                '),
        (o +=
          '\n                vec3 sh1;\n                vec3 sh2;\n                vec3 sh3;\n            '),
        i >= 2 &&
          (o +=
            '\n                    vec3 sh4;\n                    vec3 sh5;\n                    vec3 sh6;\n                    vec3 sh7;\n                    vec3 sh8;\n                '),
        i === 1
          ? (o +=
              '\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);\n                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);\n                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;\n                    } else {\n                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);\n                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);\n                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);\n                    }\n                ')
          : i === 2 &&
            (o +=
              '\n                    vec4 sampledSH0123;\n                    vec4 sampledSH4567;\n                    vec4 sampledSH891011;\n\n                    vec4 sampledSH0123R;\n                    vec4 sampledSH0123G;\n                    vec4 sampledSH0123B;\n\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));\n                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));\n                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));\n                        sh1 = sampledSH0123.rgb;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);\n                    } else {\n                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sh1 = vec3(sampledSH0123R.rgb);\n                        sh2 = vec3(sampledSH0123G.rgb);\n                        sh3 = vec3(sampledSH0123B.rgb);\n                    }\n                '),
        (o +=
          '\n                    if (sphericalHarmonics8BitMode == 1) {\n                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                    }\n                    float x = worldViewDir.x;\n                    float y = worldViewDir.y;\n                    float z = worldViewDir.z;\n                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n            '),
        i >= 2 &&
          ((o +=
            '\n                    if (sphericalHarmonicsDegree >= 2) {\n                        float xx = x * x;\n                        float yy = y * y;\n                        float zz = z * z;\n                        float xy = x * y;\n                        float yz = y * z;\n                        float xz = x * z;\n                '),
          i === 2 &&
            (o +=
              '\n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));\n                            sh4 = sampledSH891011.gba;\n                            sh5 = sampledSH12131415.rgb;\n                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);\n                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);\n                            sh8 = sampledSH20212223.gba;\n                        } else {\n                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);\n                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);\n                            sh6 = vec3(sampledSH4567G.rgb);\n                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);\n                            sh8 = vec3(sampledSH4567B.gba);\n                        }\n                    '),
          (o +=
            '\n                        if (sphericalHarmonics8BitMode == 1) {\n                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        }\n\n                        vColor.rgb +=\n                            (SH_C2[0] * xy) * sh4 +\n                            (SH_C2[1] * yz) * sh5 +\n                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\n                            (SH_C2[3] * xz) * sh7 +\n                            (SH_C2[4] * (xx - yy)) * sh8;\n                    }\n                ')),
        (o +=
          '\n\n                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\n\n            }\n\n            ')),
      o
    )
  }
  static getVertexShaderFadeIn() {
    return '\n            if (fadeInComplete == 0) {\n                float opacityAdjust = 1.0;\n                float centerDist = length(splatCenter - sceneCenter);\n                float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                float fadeDistance = 0.75;\n                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                        distanceLoadFadeInFactor;\n                opacityAdjust *= distanceLoadFadeInFactor;\n                vColor.a *= opacityAdjust;\n            }\n        '
  }
  static getUniforms(e = !1, t = !1, i = 0, r = 1, s = !1) {
    const o = {
      sceneCenter: { type: 'v3', value: new Y() },
      fadeInComplete: { type: 'i', value: 0 },
      orthographicMode: { type: 'i', value: 0 },
      visibleRegionFadeStartRadius: { type: 'f', value: 0 },
      visibleRegionRadius: { type: 'f', value: 0 },
      bindMatrix: { type: 'm4', value: new qe() },
      bindMatrixInverse: { type: 'm4', value: new qe() },
      currentTime: { type: 'f', value: 0 },
      firstRenderTime: { type: 'f', value: 0 },
      centersColorsTexture: { type: 't', value: null },
      flameModelTexture: { type: 't', value: null },
      boneTexture: { type: 't', value: null },
      boneTexture0: { type: 't', value: null },
      boneWeightTexture: { type: 't', value: null },
      sphericalHarmonicsTexture: { type: 't', value: null },
      sphericalHarmonicsTextureR: { type: 't', value: null },
      sphericalHarmonicsTextureG: { type: 't', value: null },
      sphericalHarmonicsTextureB: { type: 't', value: null },
      sphericalHarmonics8BitCompressionRangeMin: { type: 'f', value: [] },
      sphericalHarmonics8BitCompressionRangeMax: { type: 'f', value: [] },
      focal: { type: 'v2', value: new je() },
      orthoZoom: { type: 'f', value: 1 },
      inverseFocalAdjustment: { type: 'f', value: 1 },
      viewport: { type: 'v2', value: new je() },
      basisViewport: { type: 'v2', value: new je() },
      debugColor: { type: 'v3', value: new gt() },
      centersColorsTextureSize: { type: 'v2', value: new je(1024, 1024) },
      flameModelTextureSize: { type: 'v2', value: new je(4096, 2048) },
      boneTextureSize: { type: 'v2', value: new je(4, 32) },
      boneWeightTextureSize: { type: 'v2', value: new je(512, 512) },
      sphericalHarmonicsDegree: { type: 'i', value: i },
      sphericalHarmonicsTextureSize: { type: 'v2', value: new je(1024, 1024) },
      sphericalHarmonics8BitMode: { type: 'i', value: 0 },
      sphericalHarmonicsMultiTextureMode: { type: 'i', value: 0 },
      splatScale: { type: 'f', value: r },
      pointCloudModeEnabled: { type: 'i', value: s ? 1 : 0 },
      sceneIndexesTexture: { type: 't', value: null },
      sceneIndexesTextureSize: { type: 'v2', value: new je(1024, 1024) },
      sceneCount: { type: 'i', value: 1 },
      gaussianSplatCount: { type: 'i', value: 1 },
      bsCount: { type: 'i', value: 1 },
      headBoneIndex: { type: 'f', value: -1 },
    }
    for (let a = 0; a < Ft.MaxScenes; a++)
      (o.sphericalHarmonics8BitCompressionRangeMin.value.push(-3 / 2),
        o.sphericalHarmonics8BitCompressionRangeMax.value.push(
          Ft.SphericalHarmonics8BitCompressionRange / 2
        ))
    if (t) {
      const a = []
      for (let c = 0; c < Ft.MaxScenes; c++) a.push(1)
      o.sceneOpacity = { type: 'f', value: a }
      const l = []
      for (let c = 0; c < Ft.MaxScenes; c++) l.push(1)
      o.sceneVisibility = { type: 'i', value: l }
    }
    if (e) {
      const a = []
      for (let l = 0; l < Ft.MaxScenes; l++) a.push(new qe())
      o.transforms = { type: 'mat4', value: a }
    }
    return o
  }
}
class Sm {
  static build(e = !1, t = !1, i = !1, r = 2048, s = 1, o = !1, a = 0, l = 0.3, c = !0) {
    let d = Qc.buildVertexShaderBase(
      e,
      t,
      a,
      '\n            uniform vec2 covariancesTextureSize;\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D covariancesTextureHalfFloat;\n            uniform int covariancesAreHalfFloat;\n\n            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {\n                vec2 r = unpackHalf2x16(val.r);\n                vec2 g = unpackHalf2x16(val.g);\n                vec2 b = unpackHalf2x16(val.b);\n\n                first = vec4(r.x, r.y, g.x, g.y);\n                second = vec4(b.x, b.y, 0.0, 0.0);\n            }\n        ',
      c
    )
    d += Sm.buildVertexShaderProjection(i, t, r, l)
    const h = Sm.buildFragmentShader(),
      f = Qc.getUniforms(e, t, a, s, o)
    return (
      (f.covariancesTextureSize = { type: 'v2', value: new je(1024, 1024) }),
      (f.covariancesTexture = { type: 't', value: null }),
      (f.covariancesTextureHalfFloat = { type: 't', value: null }),
      (f.covariancesAreHalfFloat = { type: 'i', value: 0 }),
      new Nr({
        uniforms: f,
        vertexShader: d,
        fragmentShader: h,
        transparent: !0,
        alphaTest: 1,
        blending: zo,
        depthTest: !0,
        depthWrite: !1,
        side: wr,
      })
    )
  }
  static buildVertexShaderProjection(e, t, i, r) {
    let s =
      "\n\n            vec4 sampledCovarianceA;\n            vec4 sampledCovarianceB;\n            vec3 cov3D_M11_M12_M13;\n            vec3 cov3D_M22_M23_M33;\n            if (covariancesAreHalfFloat == 0) {\n                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,\n                                                                            covariancesTextureSize));\n                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),\n                                                                            covariancesTextureSize));\n\n                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceB.gba) * fOddOffset;\n            } else {\n                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));\n                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);\n                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);\n            }\n        \n            // Construct the 3D covariance matrix\n            mat3 Vrk = mat3(\n                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n            );\n\n            mat3 J;\n            if (orthographicMode == 1) {\n                // Since the projection is linear, we don't need an approximation\n                J = transpose(mat3(orthoZoom, 0.0, 0.0,\n                                0.0, orthoZoom, 0.0,\n                                0.0, 0.0, 0.0));\n            } else {\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result.\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n            }\n\n            // Concatenate the projection approximation with the model-view transformation\n            mat3 W = transpose(mat3(transformModelViewMatrix));\n            mat3 T = W * J;\n\n            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n            mat3 cov2Dm = transpose(T) * Vrk * T;\n            "
    return (
      e
        ? (s +=
            '\n                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                cov2Dm[0][0] += '
              .concat(r, ';\n                cov2Dm[1][1] += ')
              .concat(
                r,
                ';\n                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));\n                if (vColor.a < minAlpha) return;\n            '
              ))
        : (s += '\n                cov2Dm[0][0] += '
            .concat(r, ';\n                cov2Dm[1][1] += ')
            .concat(r, ';\n            ')),
      (s +=
        "\n\n            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n            // need cov2Dm[1][0] because it is a symetric matrix.\n            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n            // so that we can determine the 2D basis for the splat. This is done using the method described\n            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is\n            // equal to scaling them by sqrt(8) standard deviations.\n            //\n            // This is a different approach than in the original work at INRIA. In that work they compute the\n            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse\n            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by\n            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n            float a = cov2Dv.x;\n            float d = cov2Dv.z;\n            float b = cov2Dv.y;\n            float D = a * d - b * b;\n            float trace = a + d;\n            float traceOver2 = 0.5 * trace;\n            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n            float eigenValue1 = traceOver2 + term2;\n            float eigenValue2 = traceOver2 - term2;\n\n            if (pointCloudModeEnabled == 1) {\n                eigenValue1 = eigenValue2 = 0.2;\n            }\n\n            if (eigenValue2 <= 0.0) return;\n\n            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n            // since the eigen vectors are orthogonal, we derive the second one from the first\n            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), "
          .concat(
            parseInt(i),
            '.0);\n            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), '
          )
          .concat(parseInt(i), '.0);\n            ')),
      t && (s += '\n                vColor.a *= splatOpacityFromScene;\n            '),
      (s +=
        '\n            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                             basisViewport * 2.0 * inverseFocalAdjustment;\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            // Scale the position data we send to the fragment shader\n            vPosition *= sqrt8;\n        '),
      (s += Qc.getVertexShaderFadeIn()),
      (s += '}'),
      s
    )
  }
  static buildFragmentShader() {
    let e =
      '\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying vec2 vSplatIndex;\n\n        '
    return (
      (e +=
        "\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n\n                // if(vSplatIndex.x > 20000.0) discard;\n                // if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp( -0.5*A) * vColor.a;\n                if(opacity < 1.0 / 255.0)\n                    discard;\n\n                // uint a = uint(255);\n                // vec3 c = vec3(vSplatIndex.x / 256.0 / 256.0, float(uint(vSplatIndex.x / 256.0 )% a) / 256.0, float(uint(vSplatIndex.x)% a) / 256.0);\n                // gl_FragColor = vec4(c, 1.0);\n                gl_FragColor = vec4(color, opacity);\n\n\n            }\n        "),
      e
    )
  }
}
class Am {
  static build(e = !1, t = !1, i = 1, r = !1, s = 0) {
    let a = Qc.buildVertexShaderBase(
      e,
      t,
      s,
      '\n            uniform vec2 scaleRotationsTextureSize;\n            uniform highp sampler2D scaleRotationsTexture;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n        '
    )
    a += Am.buildVertexShaderProjection()
    const l = Am.buildFragmentShader(),
      c = Qc.getUniforms(e, t, s, i, r)
    return (
      (c.scaleRotationsTexture = { type: 't', value: null }),
      (c.scaleRotationsTextureSize = { type: 'v2', value: new je(1024, 1024) }),
      new Nr({
        uniforms: c,
        vertexShader: a,
        fragmentShader: l,
        transparent: !0,
        alphaTest: 1,
        blending: zo,
        depthTest: !0,
        depthWrite: !1,
        side: wr,
      })
    )
  }
  static buildVertexShaderProjection() {
    let e =
      '\n\n            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset, scaleRotationsTextureSize));\n            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset + uint(1), scaleRotationsTextureSize));\n\n            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;\n            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationB.gba) * fOddOffset;\n\n            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *\n                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);\n            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);\n            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,\n                            0.0, scaleRotation123.g, 0.0,\n                            0.0, 0.0, scaleRotation123.b);\n            \n            mat3 L = R * S;\n\n            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);\n\n            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),\n                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),\n                                    vec4(0.0, 0.0, 0.0, 1.0));\n\n            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;\n            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));\n        '
    return (
      (e +=
        '\n\n                mat4 splat2World4 = mat4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(L[2], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);\n\n                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);\n                tempPoint1 /= tempPoint1.w;\n\n                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);\n                tempPoint2 /= tempPoint2.w;\n\n                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);\n                center /= center.w;\n\n                vec2 basisVector1 = tempPoint1.xy - center.xy;\n                vec2 basisVector2 = tempPoint2.xy - center.xy;\n\n                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;\n                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;\n\n                const float minPix = 1.;\n                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {\n                    '.concat(
          '\n            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);\n            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);\n            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);\n\n            vec3 tempPoint = vec3(1.0, 1.0, -1.0);\n            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);\n            vec3 f = (1.0 / distance) * tempPoint;\n            if (abs(distance) < 0.00001) return;\n\n            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);\n            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);\n            vec2 pointImage = vec2(pointImageX, pointImageY);\n\n            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);\n            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);\n            vec2 temp = vec2(tempX, tempY);\n\n            vec2 halfExtend = pointImage * pointImage - temp;\n            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));\n            float radius = max(extent.x, extent.y);\n\n            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            vT = T;\n            vQuadCenter = pointImage;\n            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n        ',
          '\n                } else {\n                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;\n                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                    gl_Position = quadPos;\n\n                    vT = T;\n                    vQuadCenter = center.xy;\n                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n                }\n            '
        )),
      (e += Qc.getVertexShaderFadeIn()),
      (e += '}'),
      e
    )
  }
  static buildFragmentShader() {
    return '\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n\n            void main () {\n\n                const float FilterInvSquare = 2.0;\n                const float near_n = 0.2;\n                const float T = 1.0;\n\n                vec2 xy = vQuadCenter;\n                vec3 Tu = vT[0];\n                vec3 Tv = vT[1];\n                vec3 Tw = vT[2];\n                vec3 k = vFragCoord.x * Tw - Tu;\n                vec3 l = vFragCoord.y * Tw - Tv;\n                vec3 p = cross(k, l);\n                if (p.z == 0.0) discard;\n                vec2 s = vec2(p.x / p.z, p.y / p.z);\n                float rho3d = (s.x * s.x + s.y * s.y); \n                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);\n                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); \n\n                // compute intersection and depth\n                float rho = min(rho3d, rho2d);\n                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; \n                if (depth < near_n) discard;\n                //  vec4 nor_o = collected_normal_opacity[j];\n                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n                float opa = vColor.a;\n\n                float power = -0.5f * rho;\n                if (power > 0.0f) discard;\n\n                // Eq. (2) from 3D Gaussian splatting paper.\n                // Obtain alpha by multiplying with Gaussian opacity\n                // and its exponential falloff from mean.\n                // Avoid numerical instabilities (see paper appendix). \n                float alpha = min(0.99f, opa * exp(power));\n                if (alpha < 1.0f / 255.0f) discard;\n                float test_T = T * (1.0 - alpha);\n                if (test_T < 0.0001)discard;\n\n                float w = alpha * T;\n                gl_FragColor = vec4(vColor.rgb, w);\n            }\n        '
  }
}
class IU {
  static build(e) {
    const t = new ki()
    t.setIndex([0, 1, 2, 0, 2, 3])
    const i = new Float32Array(12),
      r = new _i(i, 3)
    ;(t.setAttribute('position', r),
      r.setXYZ(0, -1, -1, 0),
      r.setXYZ(1, -1, 1, 0),
      r.setXYZ(2, 1, 1, 0),
      r.setXYZ(3, 1, -1, 0),
      (r.needsUpdate = !0))
    const s = new zL().copy(t),
      o = new Uint32Array(e),
      a = new Ko(o, 1, !1)
    return (a.setUsage(Ca), s.setAttribute('splatIndex', a), (s.instanceCount = 0), s)
  }
}
class NU extends sn {
  constructor(e, t = new Y(), i = new Qt(), r = new Y(1, 1, 1), s = 1, o = 1, a = !0) {
    ;(super(),
      (this.splatBuffer = e),
      this.position.copy(t),
      this.quaternion.copy(i),
      this.scale.copy(r),
      (this.transform = new qe()),
      (this.minimumAlpha = s),
      (this.opacity = o),
      (this.visible = a))
  }
  copyTransformData(e) {
    ;(this.position.copy(e.position),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.transform.copy(e.transform))
  }
  updateTransform(e) {
    e
      ? (this.matrixWorldAutoUpdate && this.updateWorldMatrix(!0, !1),
        this.transform.copy(this.matrixWorld))
      : (this.matrixAutoUpdate && this.updateMatrix(), this.transform.copy(this.matrix))
  }
}
const Wm = class Wm {
  constructor(e, t, i, r) {
    ;((this.min = new Y().copy(e)),
      (this.max = new Y().copy(t)),
      (this.boundingBox = new ir(this.min, this.max)),
      (this.center = new Y().copy(this.max).sub(this.min).multiplyScalar(0.5).add(this.min)),
      (this.depth = i),
      (this.children = []),
      (this.data = null),
      (this.id = r || Wm.idGen++))
  }
}
xe(Wm, 'idGen', 0)
let jy = Wm
class Hd {
  constructor(e, t) {
    ;((this.maxDepth = e),
      (this.maxCentersPerNode = t),
      (this.sceneDimensions = new Y()),
      (this.sceneMin = new Y()),
      (this.sceneMax = new Y()),
      (this.rootNode = null),
      (this.nodesWithIndexes = []),
      (this.splatMesh = null))
  }
  static convertWorkerSubTreeNode(e) {
    const t = new Y().fromArray(e.min),
      i = new Y().fromArray(e.max),
      r = new jy(t, i, e.depth, e.id)
    if (e.data.indexes) {
      r.data = { indexes: [] }
      for (let s of e.data.indexes) r.data.indexes.push(s)
    }
    if (e.children) for (let s of e.children) r.children.push(Hd.convertWorkerSubTreeNode(s))
    return r
  }
  static convertWorkerSubTree(e, t) {
    const i = new Hd(e.maxDepth, e.maxCentersPerNode)
    ;((i.sceneMin = new Y().fromArray(e.sceneMin)),
      (i.sceneMax = new Y().fromArray(e.sceneMax)),
      (i.splatMesh = t),
      (i.rootNode = Hd.convertWorkerSubTreeNode(e.rootNode)))
    const r = (s, o) => {
      s.children.length === 0 && o(s)
      for (let a of s.children) r(a, o)
    }
    return (
      (i.nodesWithIndexes = []),
      r(i.rootNode, (s) => {
        s.data && s.data.indexes && s.data.indexes.length > 0 && i.nodesWithIndexes.push(s)
      }),
      i
    )
  }
}
function PU(n) {
  let e = 0
  class t {
    constructor(l, c) {
      ;((this.min = [l[0], l[1], l[2]]), (this.max = [c[0], c[1], c[2]]))
    }
    containsPoint(l) {
      return (
        l[0] >= this.min[0] &&
        l[0] <= this.max[0] &&
        l[1] >= this.min[1] &&
        l[1] <= this.max[1] &&
        l[2] >= this.min[2] &&
        l[2] <= this.max[2]
      )
    }
  }
  class i {
    constructor(l, c) {
      ;((this.maxDepth = l),
        (this.maxCentersPerNode = c),
        (this.sceneDimensions = []),
        (this.sceneMin = []),
        (this.sceneMax = []),
        (this.rootNode = null),
        (this.addedIndexes = {}),
        (this.nodesWithIndexes = []),
        (this.splatMesh = null),
        (this.disposed = !1))
    }
  }
  class r {
    constructor(l, c, u, d) {
      ;((this.min = [l[0], l[1], l[2]]),
        (this.max = [c[0], c[1], c[2]]),
        (this.center = [
          (c[0] - l[0]) * 0.5 + l[0],
          (c[1] - l[1]) * 0.5 + l[1],
          (c[2] - l[2]) * 0.5 + l[2],
        ]),
        (this.depth = u),
        (this.children = []),
        (this.data = null),
        (this.id = d || e++))
    }
  }
  processSplatTreeNode = function (a, l, c, u) {
    const d = l.data.indexes.length
    if (d < a.maxCentersPerNode || l.depth > a.maxDepth) {
      const v = []
      for (let x = 0; x < l.data.indexes.length; x++)
        a.addedIndexes[l.data.indexes[x]] ||
          (v.push(l.data.indexes[x]), (a.addedIndexes[l.data.indexes[x]] = !0))
      ;((l.data.indexes = v),
        l.data.indexes.sort((x, _) => (x > _ ? 1 : -1)),
        a.nodesWithIndexes.push(l))
      return
    }
    const h = [l.max[0] - l.min[0], l.max[1] - l.min[1], l.max[2] - l.min[2]],
      f = [h[0] * 0.5, h[1] * 0.5, h[2] * 0.5],
      p = [l.min[0] + f[0], l.min[1] + f[1], l.min[2] + f[2]],
      g = [
        new t([p[0] - f[0], p[1], p[2] - f[2]], [p[0], p[1] + f[1], p[2]]),
        new t([p[0], p[1], p[2] - f[2]], [p[0] + f[0], p[1] + f[1], p[2]]),
        new t([p[0], p[1], p[2]], [p[0] + f[0], p[1] + f[1], p[2] + f[2]]),
        new t([p[0] - f[0], p[1], p[2]], [p[0], p[1] + f[1], p[2] + f[2]]),
        new t([p[0] - f[0], p[1] - f[1], p[2] - f[2]], [p[0], p[1], p[2]]),
        new t([p[0], p[1] - f[1], p[2] - f[2]], [p[0] + f[0], p[1], p[2]]),
        new t([p[0], p[1] - f[1], p[2]], [p[0] + f[0], p[1], p[2] + f[2]]),
        new t([p[0] - f[0], p[1] - f[1], p[2]], [p[0], p[1], p[2] + f[2]]),
      ],
      y = []
    for (let v = 0; v < g.length; v++) y[v] = []
    const m = [0, 0, 0]
    for (let v = 0; v < d; v++) {
      const x = l.data.indexes[v],
        _ = c[x]
      ;((m[0] = u[_]), (m[1] = u[_ + 1]), (m[2] = u[_ + 2]))
      for (let S = 0; S < g.length; S++) g[S].containsPoint(m) && y[S].push(x)
    }
    for (let v = 0; v < g.length; v++) {
      const x = new r(g[v].min, g[v].max, l.depth + 1)
      ;((x.data = { indexes: y[v] }), l.children.push(x))
    }
    l.data = {}
    for (let v of l.children) processSplatTreeNode(a, v, c, u)
  }
  const s = (a, l, c) => {
    const u = [0, 0, 0],
      d = [0, 0, 0],
      h = [],
      f = Math.floor(a.length / 4)
    for (let g = 0; g < f; g++) {
      const y = g * 4,
        m = a[y],
        v = a[y + 1],
        x = a[y + 2],
        _ = Math.round(a[y + 3])
      ;((g === 0 || m < u[0]) && (u[0] = m),
        (g === 0 || m > d[0]) && (d[0] = m),
        (g === 0 || v < u[1]) && (u[1] = v),
        (g === 0 || v > d[1]) && (d[1] = v),
        (g === 0 || x < u[2]) && (u[2] = x),
        (g === 0 || x > d[2]) && (d[2] = x),
        h.push(_))
    }
    const p = new i(l, c)
    return (
      (p.sceneMin = u),
      (p.sceneMax = d),
      (p.rootNode = new r(p.sceneMin, p.sceneMax, 0)),
      (p.rootNode.data = { indexes: h }),
      p
    )
  }
  function o(a, l, c) {
    const u = []
    for (let h of a) {
      const f = Math.floor(h.length / 4)
      for (let p = 0; p < f; p++) {
        const g = p * 4,
          y = Math.round(h[g + 3])
        u[y] = g
      }
    }
    const d = []
    for (let h of a) {
      const f = s(h, l, c)
      ;(d.push(f), processSplatTreeNode(f, f.rootNode, u, h))
    }
    n.postMessage({ subTrees: d })
  }
  n.onmessage = (a) => {
    a.data.process &&
      o(a.data.process.centers, a.data.process.maxDepth, a.data.process.maxCentersPerNode)
  }
}
function LU(n, e, t, i, r) {
  n.postMessage({ process: { centers: e, maxDepth: i, maxCentersPerNode: r } }, t)
}
function DU() {
  return new Worker(
    URL.createObjectURL(
      new Blob(['(', PU.toString(), ')(self)'], { type: 'application/javascript' })
    )
  )
}
class FU {
  constructor(e, t) {
    xe(this, 'processSplatMesh', (e, t = () => !0, i, r) => {
      ;(this.splatTreeWorker || (this.splatTreeWorker = DU()),
        (this.splatMesh = e),
        (this.subTrees = []))
      const s = new Y(),
        o = (a, l) => {
          const c = new Float32Array(l * 4)
          let u = 0
          for (let d = 0; d < l; d++) {
            const h = d + a
            if (t(h)) {
              e.getSplatCenter(h, s)
              const f = u * 4
              ;((c[f] = s.x), (c[f + 1] = s.y), (c[f + 2] = s.z), (c[f + 3] = h), u++)
            }
          }
          return c
        }
      return new Promise((a) => {
        const l = () => (this.disposed ? (this.diposeSplatTreeWorker(), a(), !0) : !1)
        ;(i && i(!1),
          ms(() => {
            if (l()) return
            const c = []
            if (e.dynamicMode) {
              let u = 0
              for (let d = 0; d < e.scenes.length; d++) {
                const f = e.getScene(d).splatBuffer.getSplatCount(),
                  p = o(u, f)
                ;(c.push(p), (u += f))
              }
            } else {
              const u = o(0, e.getSplatCount())
              c.push(u)
            }
            ;((this.splatTreeWorker.onmessage = (u) => {
              l() ||
                (u.data.subTrees &&
                  (r && r(!1),
                  ms(() => {
                    if (!l()) {
                      for (let d of u.data.subTrees) {
                        const h = Hd.convertWorkerSubTree(d, e)
                        this.subTrees.push(h)
                      }
                      ;(this.diposeSplatTreeWorker(),
                        r && r(!0),
                        ms(() => {
                          a()
                        }))
                    }
                  })))
            }),
              ms(() => {
                if (l()) return
                i && i(!0)
                const u = c.map((d) => d.buffer)
                LU(this.splatTreeWorker, c, u, this.maxDepth, this.maxCentersPerNode)
              }))
          }))
      })
    })
    ;((this.maxDepth = e),
      (this.maxCentersPerNode = t),
      (this.subTrees = []),
      (this.splatMesh = null))
  }
  dispose() {
    ;(this.diposeSplatTreeWorker(), (this.disposed = !0))
  }
  diposeSplatTreeWorker() {
    ;(this.splatTreeWorker && this.splatTreeWorker.terminate(), (this.splatTreeWorker = null))
  }
  countLeaves() {
    let e = 0
    return (
      this.visitLeaves(() => {
        e++
      }),
      e
    )
  }
  visitLeaves(e) {
    const t = (i, r) => {
      i.children.length === 0 && r(i)
      for (let s of i.children) t(s, r)
    }
    for (let i of this.subTrees) t(i.rootNode, e)
  }
}
function OU(n) {
  const e = {}
  function t(i) {
    if (e[i] !== void 0) return e[i]
    let r
    switch (i) {
      case 'WEBGL_depth_texture':
        r =
          n.getExtension('WEBGL_depth_texture') ||
          n.getExtension('MOZ_WEBGL_depth_texture') ||
          n.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        r =
          n.getExtension('EXT_texture_filter_anisotropic') ||
          n.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          n.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        r =
          n.getExtension('WEBGL_compressed_texture_s3tc') ||
          n.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        r =
          n.getExtension('WEBGL_compressed_texture_pvrtc') ||
          n.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        r = n.getExtension(i)
    }
    return ((e[i] = r), r)
  }
  return {
    has: function (i) {
      return t(i) !== null
    },
    init: function (i) {
      ;(i.isWebGL2
        ? (t('EXT_color_buffer_float'), t('WEBGL_clip_cull_distance'))
        : (t('WEBGL_depth_texture'),
          t('OES_texture_float'),
          t('OES_texture_half_float'),
          t('OES_texture_half_float_linear'),
          t('OES_standard_derivatives'),
          t('OES_element_index_uint'),
          t('OES_vertex_array_object'),
          t('ANGLE_instanced_arrays')),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture'))
    },
    get: function (i) {
      const r = t(i)
      return (
        r === null && console.warn('THREE.WebGLRenderer: ' + i + ' extension not supported.'),
        r
      )
    },
  }
}
function BU(n, e, t) {
  let i
  function r() {
    if (i !== void 0) return i
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const A = e.get('EXT_texture_filter_anisotropic')
      i = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else i = 0
    return i
  }
  function s(A) {
    if (A === 'highp') {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0
      )
        return 'highp'
      A = 'mediump'
    }
    return A === 'mediump' &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0
      ? 'mediump'
      : 'lowp'
  }
  const o = typeof WebGL2RenderingContext < 'u' && n.constructor.name === 'WebGL2RenderingContext'
  let a = t.precision !== void 0 ? t.precision : 'highp'
  const l = s(a)
  l !== a &&
    (console.warn('THREE.WebGLRenderer:', a, 'not supported, using', l, 'instead.'), (a = l))
  const c = o || e.has('WEBGL_draw_buffers'),
    u = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    h = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    f = n.getParameter(n.MAX_TEXTURE_SIZE),
    p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    g = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    y = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    m = n.getParameter(n.MAX_VARYING_VECTORS),
    v = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    x = h > 0,
    _ = o || e.has('OES_texture_float'),
    S = x && _,
    C = o ? n.getParameter(n.MAX_SAMPLES) : 0
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: u,
    maxTextures: d,
    maxVertexTextures: h,
    maxTextureSize: f,
    maxCubemapSize: p,
    maxAttributes: g,
    maxVertexUniforms: y,
    maxVaryings: m,
    maxFragmentUniforms: v,
    vertexTextures: x,
    floatFragmentTextures: _,
    floatVertexTextures: S,
    maxSamples: C,
  }
}
const $d = { Default: 0, Instant: 2 },
  jc = { None: 0, Info: 3 },
  tb = new ki(),
  UU = new Yr(),
  Jf = 6,
  Kg = 4,
  kU = 4,
  zU = 4,
  VU = 6,
  HU = 8,
  Yg = 4,
  ud = 4,
  nb = 1,
  $U = 0.012,
  GU = 0.003,
  ib = 1,
  rb = 16777216
class li extends pn {
  constructor(
    t = Mo.ThreeD,
    i = !1,
    r = !1,
    s = !1,
    o = 1,
    a = !0,
    l = !1,
    c = !1,
    u = 1024,
    d = jc.None,
    h = 0,
    f = 1,
    p = 0.3
  ) {
    super(tb, UU)
    xe(
      this,
      'buildSplatTree',
      (t = [], i, r) =>
        new Promise((s) => {
          ;(this.disposeSplatTree(), (this.baseSplatTree = new FU(8, 1e3)))
          const o = performance.now(),
            a = new Mt()
          this.baseSplatTree
            .processSplatMesh(
              this,
              (l) => {
                this.getSplatColor(l, a)
                const c = this.getSceneIndexForSplat(l),
                  u = t[c] || 1
                return a.w >= u
              },
              i,
              r
            )
            .then(() => {
              const l = performance.now() - o
              if (
                (this.logLevel >= jc.Info && console.log('SplatTree build: ' + l + ' ms'),
                this.disposed)
              )
                s()
              else {
                ;((this.splatTree = this.baseSplatTree), (this.baseSplatTree = null))
                let c = 0,
                  u = 0,
                  d = 0
                ;(this.splatTree.visitLeaves((h) => {
                  const f = h.data.indexes.length
                  f > 0 && ((u += f), d++, c++)
                }),
                  this.logLevel >= jc.Info &&
                    (console.log('SplatTree leaves: '.concat(this.splatTree.countLeaves())),
                    console.log('SplatTree leaves with splats:'.concat(c)),
                    (u = u / d),
                    console.log('Avg splat count per node: '.concat(u)),
                    console.log('Total splat count: '.concat(this.getSplatCount()))),
                  s())
              }
            })
        })
    )
    xe(
      this,
      'updateUniforms',
      (function () {
        const t = new je()
        return function (i, r, s, o, a, l) {
          if (this.getSplatCount() > 0) {
            if (
              (t.set(i.x * this.devicePixelRatio, i.y * this.devicePixelRatio),
              this.material.uniforms.viewport.value.copy(t),
              this.material.uniforms.basisViewport.value.set(1 / t.x, 1 / t.y),
              this.material.uniforms.focal.value.set(r, s),
              (this.material.uniforms.orthographicMode.value = o ? 1 : 0),
              (this.material.uniforms.orthoZoom.value = a),
              (this.material.uniforms.inverseFocalAdjustment.value = l),
              this.dynamicMode)
            )
              for (let u = 0; u < this.scenes.length; u++)
                this.material.uniforms.transforms.value[u].copy(this.getScene(u).transform)
            if (this.enableOptionalEffects)
              for (let u = 0; u < this.scenes.length; u++)
                ((this.material.uniforms.sceneOpacity.value[u] = gi(
                  this.getScene(u).opacity,
                  0,
                  1
                )),
                  (this.material.uniforms.sceneVisibility.value[u] = this.getScene(u).visible
                    ? 1
                    : 0),
                  (this.material.uniformsNeedUpdate = !0))
            this.material.uniformsNeedUpdate = !0
          }
        }
      })()
    )
    xe(
      this,
      'setupDistancesComputationTransformFeedback',
      (function () {
        let t
        return () => {
          const i = this.getMaxSplatCount()
          if (!this.renderer) return
          const r = this.lastRenderer !== this.renderer,
            s = t !== i
          if (!r && !s) return
          r
            ? this.disposeDistancesComputationGPUResources()
            : s && this.disposeDistancesComputationGPUBufferResources()
          const o = this.renderer.getContext(),
            a = (f, p, g) => {
              const y = f.createShader(p)
              if (!y)
                return (console.error('Fatal error: gl could not create a shader object.'), null)
              if (
                (f.shaderSource(y, g),
                f.compileShader(y),
                !f.getShaderParameter(y, f.COMPILE_STATUS))
              ) {
                let v = 'unknown'
                p === f.VERTEX_SHADER
                  ? (v = 'vertex shader')
                  : p === f.FRAGMENT_SHADER && (v = 'fragement shader')
                const x = f.getShaderInfoLog(y)
                return (
                  console.error('Failed to compile ' + v + ' with these errors:' + x),
                  f.deleteShader(y),
                  null
                )
              }
              return y
            }
          let l
          this.integerBasedDistancesComputation
            ? ((l =
                '#version 300 es\n                in ivec4 center;\n                flat out int distance;'),
              this.dynamicMode
                ? (l +=
                    '\n                        in uint sceneIndex;\n                        uniform ivec4 transforms['.concat(
                      Ft.MaxScenes,
                      '];\n                        void main(void) {\n                            ivec4 transform = transforms[sceneIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    '
                    ))
                : (l +=
                    '\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    '))
            : ((l =
                '#version 300 es\n                in vec4 center;\n                flat out float distance;'),
              this.dynamicMode
                ? (l +=
                    '\n                        in uint sceneIndex;\n                        uniform mat4 transforms['.concat(
                      Ft.MaxScenes,
                      '];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    '
                    ))
                : (l +=
                    '\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    '))
          const c =
              '#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ',
            u = o.getParameter(o.VERTEX_ARRAY_BINDING),
            d = o.getParameter(o.CURRENT_PROGRAM),
            h = d ? o.getProgramParameter(d, o.DELETE_STATUS) : !1
          if (
            (r && (this.distancesTransformFeedback.vao = o.createVertexArray()),
            o.bindVertexArray(this.distancesTransformFeedback.vao),
            r)
          ) {
            const f = o.createProgram(),
              p = a(o, o.VERTEX_SHADER, l),
              g = a(o, o.FRAGMENT_SHADER, c)
            if (!p || !g)
              throw new Error('Could not compile shaders for distances computation on GPU.')
            if (
              (o.attachShader(f, p),
              o.attachShader(f, g),
              o.transformFeedbackVaryings(f, ['distance'], o.SEPARATE_ATTRIBS),
              o.linkProgram(f),
              !o.getProgramParameter(f, o.LINK_STATUS))
            ) {
              const m = o.getProgramInfoLog(f)
              throw (
                console.error('Fatal error: Failed to link program: ' + m),
                o.deleteProgram(f),
                o.deleteShader(g),
                o.deleteShader(p),
                new Error('Could not link shaders for distances computation on GPU.')
              )
            }
            ;((this.distancesTransformFeedback.program = f),
              (this.distancesTransformFeedback.vertexShader = p),
              (this.distancesTransformFeedback.vertexShader = g))
          }
          if (
            (o.useProgram(this.distancesTransformFeedback.program),
            (this.distancesTransformFeedback.centersLoc = o.getAttribLocation(
              this.distancesTransformFeedback.program,
              'center'
            )),
            this.dynamicMode)
          ) {
            this.distancesTransformFeedback.sceneIndexesLoc = o.getAttribLocation(
              this.distancesTransformFeedback.program,
              'sceneIndex'
            )
            for (let f = 0; f < this.scenes.length; f++)
              this.distancesTransformFeedback.transformsLocs[f] = o.getUniformLocation(
                this.distancesTransformFeedback.program,
                'transforms['.concat(f, ']')
              )
          } else
            this.distancesTransformFeedback.modelViewProjLoc = o.getUniformLocation(
              this.distancesTransformFeedback.program,
              'modelViewProj'
            )
          ;((r || s) &&
            ((this.distancesTransformFeedback.centersBuffer = o.createBuffer()),
            o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer),
            o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),
            this.integerBasedDistancesComputation
              ? o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, o.INT, 0, 0)
              : o.vertexAttribPointer(
                  this.distancesTransformFeedback.centersLoc,
                  4,
                  o.FLOAT,
                  !1,
                  0,
                  0
                ),
            this.dynamicMode &&
              ((this.distancesTransformFeedback.sceneIndexesBuffer = o.createBuffer()),
              o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer),
              o.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),
              o.vertexAttribIPointer(
                this.distancesTransformFeedback.sceneIndexesLoc,
                1,
                o.UNSIGNED_INT,
                0,
                0
              ))),
            (r || s) && (this.distancesTransformFeedback.outDistancesBuffer = o.createBuffer()),
            o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer),
            o.bufferData(o.ARRAY_BUFFER, i * 4, o.STATIC_READ),
            r && (this.distancesTransformFeedback.id = o.createTransformFeedback()),
            o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id),
            o.bindBufferBase(
              o.TRANSFORM_FEEDBACK_BUFFER,
              0,
              this.distancesTransformFeedback.outDistancesBuffer
            ),
            d && h !== !0 && o.useProgram(d),
            u && o.bindVertexArray(u),
            (this.lastRenderer = this.renderer),
            (t = i))
        }
      })()
    )
    xe(
      this,
      'fillTransformsArray',
      (function () {
        const t = []
        return function (i) {
          t.length !== i.length && (t.length = i.length)
          for (let r = 0; r < this.scenes.length; r++) {
            const o = this.getScene(r).transform.elements
            for (let a = 0; a < 16; a++) t[r * 16 + a] = o[a]
          }
          i.set(t)
        }
      })()
    )
    xe(
      this,
      'computeDistancesOnGPU',
      (function () {
        const t = new qe()
        return (i, r) => {
          if (!this.renderer) return
          const s = this.renderer.getContext(),
            o = s.getParameter(s.VERTEX_ARRAY_BINDING),
            a = s.getParameter(s.CURRENT_PROGRAM),
            l = a ? s.getProgramParameter(a, s.DELETE_STATUS) : !1
          if (
            (s.bindVertexArray(this.distancesTransformFeedback.vao),
            s.useProgram(this.distancesTransformFeedback.program),
            s.enable(s.RASTERIZER_DISCARD),
            this.dynamicMode)
          )
            for (let d = 0; d < this.scenes.length; d++)
              if (
                (t.copy(this.getScene(d).transform),
                t.premultiply(i),
                this.integerBasedDistancesComputation)
              ) {
                const h = li.getIntegerMatrixArray(t),
                  f = [h[2], h[6], h[10], h[14]]
                s.uniform4i(
                  this.distancesTransformFeedback.transformsLocs[d],
                  f[0],
                  f[1],
                  f[2],
                  f[3]
                )
              } else
                s.uniformMatrix4fv(
                  this.distancesTransformFeedback.transformsLocs[d],
                  !1,
                  t.elements
                )
          else if (this.integerBasedDistancesComputation) {
            const d = li.getIntegerMatrixArray(i),
              h = [d[2], d[6], d[10]]
            s.uniform3i(this.distancesTransformFeedback.modelViewProjLoc, h[0], h[1], h[2])
          } else {
            const d = [i.elements[2], i.elements[6], i.elements[10]]
            s.uniform3f(this.distancesTransformFeedback.modelViewProjLoc, d[0], d[1], d[2])
          }
          ;(s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer),
            s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),
            this.integerBasedDistancesComputation
              ? s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, s.INT, 0, 0)
              : s.vertexAttribPointer(
                  this.distancesTransformFeedback.centersLoc,
                  4,
                  s.FLOAT,
                  !1,
                  0,
                  0
                ),
            this.dynamicMode &&
              (s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer),
              s.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),
              s.vertexAttribIPointer(
                this.distancesTransformFeedback.sceneIndexesLoc,
                1,
                s.UNSIGNED_INT,
                0,
                0
              )),
            s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id),
            s.bindBufferBase(
              s.TRANSFORM_FEEDBACK_BUFFER,
              0,
              this.distancesTransformFeedback.outDistancesBuffer
            ),
            s.beginTransformFeedback(s.POINTS),
            s.drawArrays(s.POINTS, 0, this.getSplatCount()),
            s.endTransformFeedback(),
            s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, 0, null),
            s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null),
            s.disable(s.RASTERIZER_DISCARD))
          const c = s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE, 0)
          s.flush()
          const u = new Promise((d) => {
            const h = () => {
              if (this.disposed) d()
              else
                switch (s.clientWaitSync(c, 0, 0)) {
                  case s.TIMEOUT_EXPIRED:
                    return (
                      (this.computeDistancesOnGPUSyncTimeout = setTimeout(h)),
                      this.computeDistancesOnGPUSyncTimeout
                    )
                  case s.WAIT_FAILED:
                    throw new Error('should never get here')
                  default:
                    ;((this.computeDistancesOnGPUSyncTimeout = null), s.deleteSync(c))
                    const y = s.getParameter(s.VERTEX_ARRAY_BINDING)
                    ;(s.bindVertexArray(this.distancesTransformFeedback.vao),
                      s.bindBuffer(
                        s.ARRAY_BUFFER,
                        this.distancesTransformFeedback.outDistancesBuffer
                      ),
                      s.getBufferSubData(s.ARRAY_BUFFER, 0, r),
                      s.bindBuffer(s.ARRAY_BUFFER, null),
                      y && s.bindVertexArray(y),
                      d())
                }
            }
            this.computeDistancesOnGPUSyncTimeout = setTimeout(h)
          })
          return (a && l !== !0 && s.useProgram(a), o && s.bindVertexArray(o), u)
        }
      })()
    )
    xe(this, 'morphedMesh')
    xe(
      this,
      'getSplatCenter',
      (function () {
        const t = {}
        return function (i, r, s, o) {
          ;(this.getLocalSplatParameters(r, t, o),
            t.splatBuffer.getSplatCenter(i, t.localIndex, s, t.sceneTransform))
        }
      })()
    )
    xe(
      this,
      'getSplatScaleAndRotation',
      (function () {
        const t = {},
          i = new Y()
        return function (r, s, o, a) {
          ;(this.getLocalSplatParameters(r, t, a),
            (i.x = void 0),
            (i.y = void 0),
            (i.z = void 0),
            this.splatRenderMode === Mo.TwoD && (i.z = 0),
            t.splatBuffer.getSplatScaleAndRotation(t.localIndex, s, o, t.sceneTransform, i))
        }
      })()
    )
    xe(
      this,
      'getSplatColor',
      (function () {
        const t = {}
        return function (i, r) {
          ;(this.getLocalSplatParameters(i, t), t.splatBuffer.getSplatColor(t.localIndex, r))
        }
      })()
    )
    ;((this.renderer = void 0),
      (this.splatRenderMode = t),
      (this.dynamicMode = i),
      (this.enableOptionalEffects = r),
      (this.halfPrecisionCovariancesOnGPU = s),
      (this.devicePixelRatio = o),
      (this.enableDistancesComputationOnGPU = a),
      (this.integerBasedDistancesComputation = l),
      (this.antialiased = c),
      (this.kernel2DSize = p),
      (this.maxScreenSpaceSplatSize = u),
      (this.logLevel = d),
      (this.sphericalHarmonicsDegree = h),
      (this.minSphericalHarmonicsDegree = 0),
      (this.sceneFadeInRateMultiplier = f),
      (this.scenes = []),
      (this.splatTree = null),
      (this.baseSplatTree = null),
      (this.splatDataTextures = {}),
      (this.flameModel = null),
      (this.expressionBSNum = 0),
      (this.bsWeight = []),
      (this.bonesMatrix = null),
      (this.bonesNum = null),
      (this.bonesWeight = null),
      (this.gaussianSplatCount = null),
      (this.useFlameModel = !0),
      (this.morphTargetDictionary = null),
      (this.distancesTransformFeedback = {
        id: null,
        vertexShader: null,
        fragmentShader: null,
        program: null,
        centersBuffer: null,
        sceneIndexesBuffer: null,
        outDistancesBuffer: null,
        centersLoc: -1,
        modelViewProjLoc: -1,
        sceneIndexesLoc: -1,
        transformsLocs: [],
      }),
      (this.globalSplatIndexToLocalSplatIndexMap = []),
      (this.globalSplatIndexToSceneIndexMap = []),
      (this.lastBuildSplatCount = 0),
      (this.lastBuildScenes = []),
      (this.lastBuildMaxSplatCount = 0),
      (this.lastBuildSceneCount = 0),
      (this.firstRenderTime = -1),
      (this.finalBuild = !1),
      (this.webGLUtils = null),
      (this.boundingBox = new ir()),
      (this.calculatedSceneCenter = new Y()),
      (this.maxSplatDistanceFromSceneCenter = 0),
      (this.visibleRegionBufferRadius = 0),
      (this.visibleRegionRadius = 0),
      (this.visibleRegionFadeStartRadius = 0),
      (this.visibleRegionChanging = !1),
      (this.splatScale = 1),
      (this.pointCloudModeEnabled = !1),
      (this.disposed = !1),
      (this.lastRenderer = null),
      (this.visible = !1))
  }
  static buildScenes(t, i, r) {
    const s = []
    s.length = i.length
    for (let o = 0; o < i.length; o++) {
      const a = i[o],
        l = r[o] || {}
      let c = l.position || [0, 0, 0],
        u = l.rotation || [0, 0, 0, 1],
        d = l.scale || [1, 1, 1]
      const h = new Y().fromArray(c),
        f = new Qt().fromArray(u),
        p = new Y().fromArray(d),
        g = li.createScene(a, h, f, p, l.splatAlphaRemovalThreshold || 1, l.opacity, l.visible)
      ;(t.add(g), (s[o] = g))
    }
    return s
  }
  static createScene(t, i, r, s, o, a = 1, l = !0) {
    return new NU(t, i, r, s, o, a, l)
  }
  static buildSplatIndexMaps(t) {
    const i = [],
      r = []
    let s = 0
    for (let o = 0; o < t.length; o++) {
      const l = t[o].getMaxSplatCount()
      for (let c = 0; c < l; c++) ((i[s] = c), (r[s] = o), s++)
    }
    return { localSplatIndexMap: i, sceneIndexMap: r }
  }
  build(t, i, r = !0, s = !1, o, a, l = !0) {
    ;((this.sceneOptions = i), (this.finalBuild = s))
    const c = li.getTotalMaxSplatCountForSplatBuffers(t),
      u = li.buildScenes(this, t, i)
    if (r)
      for (let y = 0; y < this.scenes.length && y < u.length; y++) {
        const m = u[y],
          v = this.getScene(y)
        m.copyTransformData(v)
      }
    this.scenes = u
    let d = 3
    for (let y of t) {
      const m = y.getMinSphericalHarmonicsDegree()
      m < d && (d = m)
    }
    this.minSphericalHarmonicsDegree = Math.min(d, this.sphericalHarmonicsDegree)
    let h = !1
    if (t.length !== this.lastBuildScenes.length) h = !0
    else
      for (let y = 0; y < t.length; y++)
        if (t[y] !== this.lastBuildScenes[y].splatBuffer) {
          h = !0
          break
        }
    let f = !0
    if (
      ((this.scenes.length !== 1 ||
        this.lastBuildSceneCount !== this.scenes.length ||
        this.lastBuildMaxSplatCount !== c ||
        h) &&
        (f = !1),
      !f)
    ) {
      ;((this.boundingBox = new ir()),
        l ||
          ((this.maxSplatDistanceFromSceneCenter = 0),
          (this.visibleRegionBufferRadius = 0),
          (this.visibleRegionRadius = 0),
          (this.visibleRegionFadeStartRadius = 0),
          (this.firstRenderTime = -1)),
        (this.lastBuildScenes = []),
        (this.lastBuildSplatCount = 0),
        (this.lastBuildMaxSplatCount = 0),
        this.disposeMeshData(),
        (this.geometry = IU.build(c)),
        this.splatRenderMode === Mo.ThreeD
          ? (this.material = Sm.build(
              this.dynamicMode,
              this.enableOptionalEffects,
              this.antialiased,
              this.maxScreenSpaceSplatSize,
              this.splatScale,
              this.pointCloudModeEnabled,
              this.minSphericalHarmonicsDegree,
              this.kernel2DSize,
              this.useFlameModel
            ))
          : (this.material = Am.build(
              this.dynamicMode,
              this.enableOptionalEffects,
              this.splatScale,
              this.pointCloudModeEnabled,
              this.minSphericalHarmonicsDegree
            )))
      const y = li.buildSplatIndexMaps(t)
      ;((this.globalSplatIndexToLocalSplatIndexMap = y.localSplatIndexMap),
        (this.globalSplatIndexToSceneIndexMap = y.sceneIndexMap))
    }
    const p = this.getSplatCount(!0)
    this.enableDistancesComputationOnGPU && this.setupDistancesComputationTransformFeedback()
    const g = this.refreshGPUDataFromSplatBuffers(f)
    for (let y = 0; y < this.scenes.length; y++) this.lastBuildScenes[y] = this.scenes[y]
    return (
      (this.lastBuildSplatCount = p),
      (this.lastBuildMaxSplatCount = this.getMaxSplatCount()),
      (this.lastBuildSceneCount = this.scenes.length),
      (this.visible = this.scenes.length > 0),
      g
    )
  }
  freeIntermediateSplatData() {
    const t = (i) => {
      ;(delete i.source.data, delete i.image, (i.onUpdate = null))
    }
    ;(delete this.splatDataTextures.baseData.covariances,
      delete this.splatDataTextures.baseData.centers,
      delete this.splatDataTextures.baseData.colors,
      delete this.splatDataTextures.baseData.sphericalHarmonics,
      delete this.splatDataTextures.centerColors.data,
      delete this.splatDataTextures.covariances.data,
      this.splatDataTextures.sphericalHarmonics &&
        delete this.splatDataTextures.sphericalHarmonics.data,
      this.splatDataTextures.sceneIndexes && delete this.splatDataTextures.sceneIndexes.data,
      (this.splatDataTextures.centerColors.texture.needsUpdate = !0),
      (this.splatDataTextures.centerColors.texture.onUpdate = () => {
        t(this.splatDataTextures.centerColors.texture)
      }),
      (this.splatDataTextures.flameModelPosTexture.texture.needsUpdate = !0),
      (this.splatDataTextures.flameModelPosTexture.texture.onUpdate = () => {
        t(this.splatDataTextures.flameModelPosTexture.texture)
      }),
      (this.splatDataTextures.covariances.texture.needsUpdate = !0),
      (this.splatDataTextures.covariances.texture.onUpdate = () => {
        t(this.splatDataTextures.covariances.texture)
      }),
      this.splatDataTextures.sphericalHarmonics &&
        (this.splatDataTextures.sphericalHarmonics.texture
          ? ((this.splatDataTextures.sphericalHarmonics.texture.needsUpdate = !0),
            (this.splatDataTextures.sphericalHarmonics.texture.onUpdate = () => {
              t(this.splatDataTextures.sphericalHarmonics.texture)
            }))
          : this.splatDataTextures.sphericalHarmonics.textures.forEach((i) => {
              ;((i.needsUpdate = !0),
                (i.onUpdate = () => {
                  t(i)
                }))
            })),
      this.splatDataTextures.sceneIndexes &&
        ((this.splatDataTextures.sceneIndexes.texture.needsUpdate = !0),
        (this.splatDataTextures.sceneIndexes.texture.onUpdate = () => {
          t(this.splatDataTextures.sceneIndexes.texture)
        })))
  }
  dispose() {
    ;(this.disposeMeshData(),
      this.disposeTextures(),
      this.disposeSplatTree(),
      this.enableDistancesComputationOnGPU &&
        (this.computeDistancesOnGPUSyncTimeout &&
          (clearTimeout(this.computeDistancesOnGPUSyncTimeout),
          (this.computeDistancesOnGPUSyncTimeout = null)),
        this.disposeDistancesComputationGPUResources()),
      (this.scenes = []),
      (this.distancesTransformFeedback = {
        id: null,
        vertexShader: null,
        fragmentShader: null,
        program: null,
        centersBuffer: null,
        sceneIndexesBuffer: null,
        outDistancesBuffer: null,
        centersLoc: -1,
        modelViewProjLoc: -1,
        sceneIndexesLoc: -1,
        transformsLocs: [],
      }),
      (this.renderer = null),
      (this.globalSplatIndexToLocalSplatIndexMap = []),
      (this.globalSplatIndexToSceneIndexMap = []),
      (this.lastBuildSplatCount = 0),
      (this.lastBuildScenes = []),
      (this.lastBuildMaxSplatCount = 0),
      (this.lastBuildSceneCount = 0),
      (this.firstRenderTime = -1),
      (this.finalBuild = !1),
      (this.webGLUtils = null),
      (this.boundingBox = new ir()),
      (this.calculatedSceneCenter = new Y()),
      (this.maxSplatDistanceFromSceneCenter = 0),
      (this.visibleRegionBufferRadius = 0),
      (this.visibleRegionRadius = 0),
      (this.visibleRegionFadeStartRadius = 0),
      (this.visibleRegionChanging = !1),
      (this.splatScale = 1),
      (this.pointCloudModeEnabled = !1),
      (this.disposed = !0),
      (this.lastRenderer = null),
      (this.visible = !1))
  }
  disposeMeshData() {
    ;(this.geometry && this.geometry !== tb && (this.geometry.dispose(), (this.geometry = null)),
      this.material && (this.material.dispose(), (this.material = null)))
  }
  disposeTextures() {
    for (let t in this.splatDataTextures)
      if (this.splatDataTextures.hasOwnProperty(t)) {
        const i = this.splatDataTextures[t]
        i.texture && (i.texture.dispose(), (i.texture = null))
      }
    this.splatDataTextures = null
  }
  disposeSplatTree() {
    ;(this.splatTree && (this.splatTree.dispose(), (this.splatTree = null)),
      this.baseSplatTree && (this.baseSplatTree.dispose(), (this.baseSplatTree = null)))
  }
  getSplatTree() {
    return this.splatTree
  }
  onSplatTreeReady(t) {
    this.onSplatTreeReadyCallback = t
  }
  getDataForDistancesComputation(t, i) {
    const r = this.integerBasedDistancesComputation
        ? this.getIntegerCenters(t, i, !0)
        : this.getFloatCenters(t, i, !0),
      s = this.getSceneIndexes(t, i)
    return { centers: r, sceneIndexes: s }
  }
  refreshGPUDataFromSplatBuffers(t) {
    const i = this.getSplatCount(!0)
    this.refreshDataTexturesFromSplatBuffers(t)
    const r = t ? this.lastBuildSplatCount : 0,
      { centers: s, sceneIndexes: o } = this.getDataForDistancesComputation(r, i - 1)
    return (
      this.enableDistancesComputationOnGPU &&
        this.refreshGPUBuffersForDistancesComputation(s, o, t),
      { from: r, to: i - 1, count: i - r, centers: s, sceneIndexes: o }
    )
  }
  refreshGPUBuffersForDistancesComputation(t, i, r = !1) {
    const s = r ? this.lastBuildSplatCount : 0
    ;(this.updateGPUCentersBufferForDistancesComputation(r, t, s),
      this.updateGPUTransformIndexesBufferForDistancesComputation(r, i, s))
  }
  refreshDataTexturesFromSplatBuffers(t) {
    const i = this.getSplatCount(!0),
      r = this.lastBuildSplatCount,
      s = i - 1
    ;(t
      ? this.updateBaseDataFromSplatBuffers(r, s)
      : (this.setupDataTextures(), this.updateBaseDataFromSplatBuffers()),
      this.updateDataTexturesFromBaseData(r, s),
      this.updateVisibleRegion(t))
  }
  setupDataTextures() {
    const t = this.getMaxSplatCount(),
      i = this.getSplatCount(!0)
    this.disposeTextures()
    const r = (R, w) => {
        const M = new je(4096, 1024)
        for (; M.x * M.y * R < t * w; ) M.y *= 2
        return M
      },
      s = (R) => (R >= 1 ? VU : kU),
      o = (R) => {
        const w = s(R),
          M = r(w, 6)
        return { elementsPerTexelStored: w, texSize: M }
      }
    let a = this.getTargetCovarianceCompressionLevel()
    const l = 0,
      c = this.getTargetSphericalHarmonicsCompressionLevel()
    let u, d, h
    if (this.splatRenderMode === Mo.ThreeD) {
      const R = o(a)
      ;(R.texSize.x * R.texSize.y > rb && a === 0 && (a = 1), (u = new Float32Array(t * Jf)))
    } else ((d = new Float32Array(t * 3)), (h = new Float32Array(t * 4)))
    const f = new Float32Array(t * 3),
      p = new Uint8Array(t * 4)
    let g = Float32Array
    c === 1 ? (g = Uint16Array) : c === 2 && (g = Uint8Array)
    const y = Gc(this.minSphericalHarmonicsDegree),
      m = this.minSphericalHarmonicsDegree ? new g(t * y) : void 0,
      v = r(ud, 4),
      x = new Uint32Array(v.x * v.y * ud)
    li.updateCenterColorsPaddedData(0, i - 1, f, p, x)
    const _ = new vr(x, v.x, v.y, Co, Ni)
    if (
      ((_.internalFormat = 'RGBA32UI'),
      (_.needsUpdate = !0),
      (this.material.uniforms.centersColorsTexture.value = _),
      this.material.uniforms.centersColorsTextureSize.value.copy(v),
      (this.material.uniformsNeedUpdate = !0),
      (this.splatDataTextures = {
        baseData: {
          covariances: u,
          scales: d,
          rotations: h,
          centers: f,
          colors: p,
          sphericalHarmonics: m,
        },
        centerColors: { data: x, texture: _, size: v },
      }),
      this.splatRenderMode === Mo.ThreeD)
    ) {
      const R = o(a),
        w = R.elementsPerTexelStored,
        M = R.texSize
      let I = a >= 1 ? Uint32Array : Float32Array
      const L = a >= 1 ? HU : zU,
        U = new I(M.x * M.y * L)
      a === 0 ? U.set(u) : li.updatePaddedCompressedCovariancesTextureData(u, U, 0, 0, u.length)
      let T
      if (a >= 1)
        ((T = new vr(U, M.x, M.y, Co, Ni)),
          (T.internalFormat = 'RGBA32UI'),
          (this.material.uniforms.covariancesTextureHalfFloat.value = T))
      else {
        ;((T = new vr(U, M.x, M.y, Fi, nr)), (this.material.uniforms.covariancesTexture.value = T))
        const F = new vr(new Uint32Array(32), 2, 2, Co, Ni)
        ;((F.internalFormat = 'RGBA32UI'),
          (this.material.uniforms.covariancesTextureHalfFloat.value = F),
          (F.needsUpdate = !0))
      }
      ;((T.needsUpdate = !0),
        (this.material.uniforms.covariancesAreHalfFloat.value = a >= 1 ? 1 : 0),
        this.material.uniforms.covariancesTextureSize.value.copy(M),
        (this.splatDataTextures.covariances = {
          data: U,
          texture: T,
          size: M,
          compressionLevel: a,
          elementsPerTexelStored: w,
          elementsPerTexelAllocated: L,
        }))
    } else {
      const w = r(Yg, 6)
      let M = Float32Array,
        I = nr
      const L = new M(w.x * w.y * Yg)
      li.updateScaleRotationsPaddedData(0, i - 1, d, h, L)
      const U = new vr(L, w.x, w.y, Fi, I)
      ;((U.needsUpdate = !0),
        (this.material.uniforms.scaleRotationsTexture.value = U),
        this.material.uniforms.scaleRotationsTextureSize.value.copy(w),
        (this.splatDataTextures.scaleRotations = {
          data: L,
          texture: U,
          size: w,
          compressionLevel: l,
        }))
    }
    if (m) {
      const R = c === 2 ? eo : ws
      let w = y
      w % 2 !== 0 && w++
      const M = this.minSphericalHarmonicsDegree === 2 ? 4 : 2,
        I = M === 4 ? Fi : lh
      let L = r(M, w)
      if (L.x * L.y <= rb) {
        const U = L.x * L.y * M,
          T = new g(U)
        for (let V = 0; V < i; V++) {
          const W = y * V,
            ee = w * V
          for (let se = 0; se < y; se++) T[ee + se] = m[W + se]
        }
        const F = new vr(T, L.x, L.y, I, R)
        ;((F.needsUpdate = !0),
          (this.material.uniforms.sphericalHarmonicsTexture.value = F),
          (this.splatDataTextures.sphericalHarmonics = {
            componentCount: y,
            paddedComponentCount: w,
            data: T,
            textureCount: 1,
            texture: F,
            size: L,
            compressionLevel: c,
            elementsPerTexel: M,
          }))
      } else {
        const U = y / 3
        ;((w = U), w % 2 !== 0 && w++, (L = r(M, w)))
        const T = L.x * L.y * M,
          F = [
            this.material.uniforms.sphericalHarmonicsTextureR,
            this.material.uniforms.sphericalHarmonicsTextureG,
            this.material.uniforms.sphericalHarmonicsTextureB,
          ],
          V = [],
          W = []
        for (let ee = 0; ee < 3; ee++) {
          const se = new g(T)
          V.push(se)
          for (let ne = 0; ne < i; ne++) {
            const ie = y * ne,
              be = w * ne
            if (U >= 3) {
              for (let le = 0; le < 3; le++) se[be + le] = m[ie + ee * 3 + le]
              if (U >= 8) for (let le = 0; le < 5; le++) se[be + 3 + le] = m[ie + 9 + ee * 5 + le]
            }
          }
          const he = new vr(se, L.x, L.y, I, R)
          ;(W.push(he), (he.needsUpdate = !0), (F[ee].value = he))
        }
        ;((this.material.uniforms.sphericalHarmonicsMultiTextureMode.value = 1),
          (this.splatDataTextures.sphericalHarmonics = {
            componentCount: y,
            componentCountPerChannel: U,
            paddedComponentCount: w,
            data: V,
            textureCount: 3,
            textures: W,
            size: L,
            compressionLevel: c,
            elementsPerTexel: M,
          }))
      }
      ;(this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(L),
        (this.material.uniforms.sphericalHarmonics8BitMode.value = c === 2 ? 1 : 0))
      for (let U = 0; U < this.scenes.length; U++) {
        const T = this.scenes[U].splatBuffer
        ;((this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[U] =
          T.minSphericalHarmonicsCoeff),
          (this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[U] =
            T.maxSphericalHarmonicsCoeff))
      }
      this.material.uniformsNeedUpdate = !0
    }
    const S = r(nb, 4),
      C = new Uint32Array(S.x * S.y * nb)
    for (let R = 0; R < i; R++) C[R] = this.globalSplatIndexToSceneIndexMap[R]
    const A = new vr(C, S.x, S.y, a0, Ni)
    ;((A.internalFormat = 'R32UI'),
      (A.needsUpdate = !0),
      (this.material.uniforms.sceneIndexesTexture.value = A),
      this.material.uniforms.sceneIndexesTextureSize.value.copy(S),
      (this.material.uniformsNeedUpdate = !0),
      (this.splatDataTextures.sceneIndexes = { data: C, texture: A, size: S }),
      (this.material.uniforms.sceneCount.value = this.scenes.length),
      (this.expressionBSNum = this.flameModel.geometry.morphAttributes.position.length),
      (this.material.uniforms.bsCount.value = this.expressionBSNum),
      this.flameModel.skeleton.bones.forEach((R, w) => {
        R.name == 'head' && (this.material.uniforms.headBoneIndex.value = w)
      }),
      this.buildModelTexture(this.flameModel),
      this.buildBoneMatrixTexture(),
      this.useFlameModel && this.buildBoneWeightTexture(this.flameModel))
  }
  buildBoneMatrixTexture() {
    if (!this.bsWeight) return
    const t = new je(4, 32)
    let i = new Float32Array(this.bonesMatrix),
      r = new Uint32Array(t.x * t.y * 4)
    if (
      ((this.morphTargetDictionary = this.flameModel.morphTargetDictionary), this.useFlameModel)
    ) {
      for (let o = 0; o < this.bonesNum * 16; o++) r[o] = Hi(i[o])
      this.flameModel &&
        this.flameModel.skeleton &&
        ((this.material.uniforms.boneTexture0.value = this.flameModel.skeleton.boneTexture),
        (this.material.uniforms.bindMatrix.value = this.flameModel.bindMatrix),
        (this.material.uniforms.bindMatrixInverse.value = this.flameModel.bindMatrixInverse))
    }
    for (const o in this.bsWeight)
      if (this.bsWeight.hasOwnProperty(o)) {
        const a = this.bsWeight[o],
          l = this.morphTargetDictionary[o]
        r[l + this.bonesNum * 16] = Hi(a)
      }
    const s = new vr(r, t.x, t.y, Co, Ni)
    ;((s.internalFormat = 'RGBA32UI'),
      (s.needsUpdate = !0),
      (this.material.uniforms.boneTexture.value = s),
      this.material.uniforms.boneTextureSize.value.copy(t),
      (this.material.uniformsNeedUpdate = !0),
      (this.splatDataTextures.boneMatrix = { data: r, texture: s, size: t }),
      (this.splatDataTextures.baseData.boneMatrix = r))
  }
  updateBoneMatrixTexture(t = !1) {
    if (!(!this.bsWeight || !this.morphTargetDictionary)) {
      if (t == !0) {
        let i = new Float32Array(this.bonesMatrix)
        for (let r = 0; r < this.bonesNum * 16; r++)
          this.splatDataTextures.baseData.boneMatrix[r] = Hi(i[r])
      }
      for (const i in this.bsWeight)
        if (this.bsWeight.hasOwnProperty(i)) {
          const r = this.bsWeight[i],
            s = this.morphTargetDictionary[i]
          this.splatDataTextures.baseData.boneMatrix[s + this.bonesNum * 16] = Hi(r)
        }
      ;((this.splatDataTextures.boneMatrix.texture.data =
        this.splatDataTextures.baseData.boneMatrix),
        (this.splatDataTextures.boneMatrix.texture.needsUpdate = !0),
        (this.material.uniforms.boneTexture.value = this.splatDataTextures.boneMatrix.texture),
        this.flameModel.skeleton &&
          ((this.material.uniforms.boneTexture0.value = this.flameModel.skeleton.boneTexture),
          (this.material.uniforms.bindMatrix.value = this.flameModel.bindMatrix),
          (this.material.uniforms.bindMatrixInverse.value = this.flameModel.bindMatrixInverse)),
        (this.material.uniformsNeedUpdate = !0))
    }
  }
  buildBoneWeightTexture(t) {
    let r = t.geometry.attributes.position.array.length / 3
    const s = new je(512, 512)
    let o = new Float32Array(s.x * s.y * 4),
      a = new Uint32Array(s.x * s.y * 4)
    for (let c = 0; c < r; c++)
      ((o[c * 8 + 0] = this.bonesWeight[c][0]),
        (o[c * 8 + 1] = this.bonesWeight[c][1]),
        (o[c * 8 + 2] = this.bonesWeight[c][2]),
        (o[c * 8 + 3] = this.bonesWeight[c][3]),
        (o[c * 8 + 4] = this.bonesWeight[c][4]),
        (a[c * 8 + 0] = Hi(this.bonesWeight[c][0])),
        (a[c * 8 + 1] = Hi(this.bonesWeight[c][1])),
        (a[c * 8 + 2] = Hi(this.bonesWeight[c][2])),
        (a[c * 8 + 3] = Hi(this.bonesWeight[c][3])),
        (a[c * 8 + 4] = Hi(this.bonesWeight[c][4])))
    const l = new vr(a, s.x, s.y, Co, Ni)
    ;((l.internalFormat = 'RGBA32UI'),
      (l.needsUpdate = !0),
      (this.material.uniforms.boneWeightTexture.value = l),
      this.material.uniforms.boneWeightTextureSize.value.copy(s),
      (this.material.uniformsNeedUpdate = !0),
      (this.splatDataTextures.boneWeight = { data: a, texture: l, size: s }),
      (this.splatDataTextures.baseData.boneWeight = a))
  }
  buildModelTexture(t) {
    const i = new je(4096, 2048)
    var r = t.geometry.attributes.position.array,
      s = []
    let o = r.length / 3,
      a = t.geometry.morphAttributes.position.length
    ;(Object.keys(t.morphTargetDictionary).forEach((h, f) => {
      const p = t.morphTargetDictionary[h]
      var g = t.geometry.morphAttributes.position[p]
      s = s.concat(Array.from(g.array))
    }),
      (s = s.concat(Array.from(r))))
    let c = new Float32Array(i.x * i.y * 4),
      u = new Uint32Array(i.x * i.y * 4)
    for (let h = 0; h < o * (a + 1); h++)
      ((c[h * 4 + 0] = s[h * 3 + 0]),
        (c[h * 4 + 1] = s[h * 3 + 1]),
        (c[h * 4 + 2] = s[h * 3 + 2]),
        (u[h * 4 + 0] = Hi(c[h * 4 + 0])),
        (u[h * 4 + 1] = Hi(c[h * 4 + 1])),
        (u[h * 4 + 2] = Hi(c[h * 4 + 2])))
    const d = new vr(u, i.x, i.y, Co, Ni)
    ;((d.internalFormat = 'RGBA32UI'),
      (d.needsUpdate = !0),
      (this.material.uniforms.flameModelTexture.value = d),
      this.material.uniforms.flameModelTextureSize.value.copy(i),
      (this.material.uniformsNeedUpdate = !0),
      (this.material.uniforms.gaussianSplatCount.value = this.gaussianSplatCount),
      (this.splatDataTextures.flameModel = { data: u, texture: d, size: i }),
      (this.splatDataTextures.baseData.flameModelPos = c))
  }
  updateTetureAfterBSAndSkeleton(t, i, r = !0) {
    const s = new qe()
    ;(this.getSceneTransform(0, s),
      this.getScene(0).splatBuffer.fillSplatCenterArray(
        this.morphedMesh,
        this.splatDataTextures.baseData.centers,
        s,
        t,
        i,
        0
      ))
    const o = this.splatDataTextures.centerColors,
      a = o.data,
      l = o.texture
    li.updateCenterColorsPaddedData(
      t,
      i,
      this.splatDataTextures.baseData.centers,
      this.splatDataTextures.baseData.colors,
      a
    )
    const c = this.renderer ? this.renderer.properties.get(l) : null
    ;(!c || !c.__webglTexture
      ? (l.needsUpdate = !0)
      : this.updateDataTexture(a, o.texture, o.size, c, ud, Kg, 4, t, i),
      this.updateBoneMatrixTexture(r))
  }
  updateBaseDataFromSplatBuffers(t, i) {
    const r = this.splatDataTextures.covariances,
      s = r ? r.compressionLevel : void 0,
      o = this.splatDataTextures.scaleRotations,
      a = o ? o.compressionLevel : void 0,
      l = this.splatDataTextures.sphericalHarmonics,
      c = l ? l.compressionLevel : 0
    this.fillSplatDataArrays(
      this.splatDataTextures.baseData.covariances,
      this.splatDataTextures.baseData.scales,
      this.splatDataTextures.baseData.rotations,
      this.splatDataTextures.baseData.centers,
      this.splatDataTextures.baseData.colors,
      this.splatDataTextures.baseData.sphericalHarmonics,
      this.splatDataTextures.baseData.flameModelPos,
      void 0,
      s,
      a,
      c,
      t,
      i,
      t
    )
  }
  updateDataTexturesFromBaseData(t, i) {
    const r = this.splatDataTextures.covariances,
      s = r ? r.compressionLevel : void 0,
      o = this.splatDataTextures.scaleRotations,
      a = o ? o.compressionLevel : void 0,
      l = this.splatDataTextures.sphericalHarmonics,
      c = l ? l.compressionLevel : 0,
      u = this.splatDataTextures.flameModel,
      d = u.data,
      h = u.texture,
      f = this.renderer ? this.renderer.properties.get(h) : null
    !f || !f.__webglTexture
      ? (h.needsUpdate = !0)
      : this.updateDataTexture(d, u.texture, u.size, f, ud, Kg, 3, t, i)
    const p = this.splatDataTextures.centerColors,
      g = p.data,
      y = p.texture
    li.updateCenterColorsPaddedData(
      t,
      i,
      this.splatDataTextures.baseData.centers,
      this.splatDataTextures.baseData.colors,
      g
    )
    const m = this.renderer ? this.renderer.properties.get(y) : null
    if (
      (!m || !m.__webglTexture
        ? (y.needsUpdate = !0)
        : this.updateDataTexture(g, p.texture, p.size, m, ud, Kg, 4, t, i),
      r)
    ) {
      const A = r.texture,
        R = t * Jf,
        w = i * Jf
      if (s === 0)
        for (let I = R; I <= w; I++) {
          const L = this.splatDataTextures.baseData.covariances[I]
          r.data[I] = L
        }
      else
        li.updatePaddedCompressedCovariancesTextureData(
          this.splatDataTextures.baseData.covariances,
          r.data,
          t * r.elementsPerTexelAllocated,
          R,
          w
        )
      const M = this.renderer ? this.renderer.properties.get(A) : null
      !M || !M.__webglTexture
        ? (A.needsUpdate = !0)
        : s === 0
          ? this.updateDataTexture(
              r.data,
              r.texture,
              r.size,
              M,
              r.elementsPerTexelStored,
              Jf,
              4,
              t,
              i
            )
          : this.updateDataTexture(
              r.data,
              r.texture,
              r.size,
              M,
              r.elementsPerTexelAllocated,
              r.elementsPerTexelAllocated,
              2,
              t,
              i
            )
    }
    if (o) {
      const A = o.data,
        R = o.texture,
        w = 6,
        M = a === 0 ? 4 : 2
      li.updateScaleRotationsPaddedData(
        t,
        i,
        this.splatDataTextures.baseData.scales,
        this.splatDataTextures.baseData.rotations,
        A
      )
      const I = this.renderer ? this.renderer.properties.get(R) : null
      !I || !I.__webglTexture
        ? (R.needsUpdate = !0)
        : this.updateDataTexture(A, o.texture, o.size, I, Yg, w, M, t, i)
    }
    const v = this.splatDataTextures.baseData.sphericalHarmonics
    if (v) {
      let A = 4
      c === 1 ? (A = 2) : c === 2 && (A = 1)
      const R = (I, L, U, T, F) => {
          const V = this.renderer ? this.renderer.properties.get(I) : null
          !V || !V.__webglTexture
            ? (I.needsUpdate = !0)
            : this.updateDataTexture(T, I, L, V, U, F, A, t, i)
        },
        w = l.componentCount,
        M = l.paddedComponentCount
      if (l.textureCount === 1) {
        const I = l.data
        for (let L = t; L <= i; L++) {
          const U = w * L,
            T = M * L
          for (let F = 0; F < w; F++) I[T + F] = v[U + F]
        }
        R(l.texture, l.size, l.elementsPerTexel, I, M)
      } else {
        const I = l.componentCountPerChannel
        for (let L = 0; L < 3; L++) {
          const U = l.data[L]
          for (let T = t; T <= i; T++) {
            const F = w * T,
              V = M * T
            if (I >= 3) {
              for (let W = 0; W < 3; W++) U[V + W] = v[F + L * 3 + W]
              if (I >= 8) for (let W = 0; W < 5; W++) U[V + 3 + W] = v[F + 9 + L * 5 + W]
            }
          }
          R(l.textures[L], l.size, l.elementsPerTexel, U, M)
        }
      }
    }
    const x = this.splatDataTextures.sceneIndexes,
      _ = x.data
    for (let A = this.lastBuildSplatCount; A <= i; A++)
      _[A] = this.globalSplatIndexToSceneIndexMap[A]
    const S = x.texture,
      C = this.renderer ? this.renderer.properties.get(S) : null
    !C || !C.__webglTexture
      ? (S.needsUpdate = !0)
      : this.updateDataTexture(_, x.texture, x.size, C, 1, 1, 1, this.lastBuildSplatCount, i)
  }
  getTargetCovarianceCompressionLevel() {
    return this.halfPrecisionCovariancesOnGPU ? 1 : 0
  }
  getTargetSphericalHarmonicsCompressionLevel() {
    return Math.max(1, this.getMaximumSplatBufferCompressionLevel())
  }
  getMaximumSplatBufferCompressionLevel() {
    let t
    for (let i = 0; i < this.scenes.length; i++) {
      const s = this.getScene(i).splatBuffer
      ;(i === 0 || s.compressionLevel > t) && (t = s.compressionLevel)
    }
    return t
  }
  getMinimumSplatBufferCompressionLevel() {
    let t
    for (let i = 0; i < this.scenes.length; i++) {
      const s = this.getScene(i).splatBuffer
      ;(i === 0 || s.compressionLevel < t) && (t = s.compressionLevel)
    }
    return t
  }
  static computeTextureUpdateRegion(t, i, r, s, o) {
    const a = o / s,
      l = t * a,
      c = Math.floor(l / r),
      u = c * r * s,
      d = i * a,
      h = Math.floor(d / r),
      f = h * r * s + r * s
    return { dataStart: u, dataEnd: f, startRow: c, endRow: h }
  }
  updateDataTexture(t, i, r, s, o, a, l, c, u) {
    const d = this.renderer.getContext(),
      h = li.computeTextureUpdateRegion(c, u, r.x, o, a),
      f = h.dataEnd - h.dataStart,
      p = new t.constructor(t.buffer, h.dataStart * l, f),
      g = h.endRow - h.startRow + 1,
      y = this.webGLUtils.convert(i.type),
      m = this.webGLUtils.convert(i.format, i.colorSpace),
      v = d.getParameter(d.TEXTURE_BINDING_2D)
    ;(d.bindTexture(d.TEXTURE_2D, s.__webglTexture),
      d.texSubImage2D(d.TEXTURE_2D, 0, 0, h.startRow, r.x, g, m, y, p),
      d.bindTexture(d.TEXTURE_2D, v))
  }
  static updatePaddedCompressedCovariancesTextureData(t, i, r, s, o) {
    let a = new DataView(i.buffer),
      l = r,
      c = 0
    for (let u = s; u <= o; u += 2)
      (a.setUint16(l * 2, t[u], !0),
        a.setUint16(l * 2 + 2, t[u + 1], !0),
        (l += 2),
        c++,
        c >= 3 && ((l += 2), (c = 0)))
  }
  static updateCenterColorsPaddedData(t, i, r, s, o) {
    for (let a = t; a <= i; a++) {
      const l = a * 4,
        c = a * 3,
        u = a * 4
      ;((o[u] = CN(s, l)),
        (o[u + 1] = Hi(r[c])),
        (o[u + 2] = Hi(r[c + 1])),
        (o[u + 3] = Hi(r[c + 2])))
    }
  }
  static updateScaleRotationsPaddedData(t, i, r, s, o) {
    for (let l = t; l <= i; l++) {
      const c = l * 3,
        u = l * 4,
        d = l * 6
      ;((o[d] = r[c]),
        (o[d + 1] = r[c + 1]),
        (o[d + 2] = r[c + 2]),
        (o[d + 3] = s[u]),
        (o[d + 4] = s[u + 1]),
        (o[d + 5] = s[u + 2]))
    }
  }
  updateVisibleRegion(t) {
    const i = this.getSplatCount(!0),
      r = new Y()
    if (!t) {
      const o = new Y()
      ;(this.scenes.forEach((a) => {
        o.add(a.splatBuffer.sceneCenter)
      }),
        o.multiplyScalar(1 / this.scenes.length),
        this.calculatedSceneCenter.copy(o),
        this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),
        (this.material.uniformsNeedUpdate = !0))
    }
    const s = t ? this.lastBuildSplatCount : 0
    for (let o = s; o < i; o++) {
      this.getSplatCenter(this.morphedMesh, o, r, !0)
      const a = r.sub(this.calculatedSceneCenter).length()
      a > this.maxSplatDistanceFromSceneCenter && (this.maxSplatDistanceFromSceneCenter = a)
    }
    ;(this.maxSplatDistanceFromSceneCenter - this.visibleRegionBufferRadius > ib &&
      ((this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter),
      (this.visibleRegionRadius = Math.max(this.visibleRegionBufferRadius - ib, 0))),
      this.finalBuild &&
        (this.visibleRegionRadius = this.visibleRegionBufferRadius =
          this.maxSplatDistanceFromSceneCenter),
      this.updateVisibleRegionFadeDistance())
  }
  updateVisibleRegionFadeDistance(t = $d.Default) {
    const i = $U * this.sceneFadeInRateMultiplier,
      r = GU * this.sceneFadeInRateMultiplier,
      s = this.finalBuild ? i : r,
      o = t === $d.Default ? s : r
    this.visibleRegionFadeStartRadius =
      (this.visibleRegionRadius - this.visibleRegionFadeStartRadius) * o +
      this.visibleRegionFadeStartRadius
    const l =
        (this.visibleRegionBufferRadius > 0
          ? this.visibleRegionFadeStartRadius / this.visibleRegionBufferRadius
          : 0) > 0.99,
      c = l || t === $d.Instant ? 1 : 0
    ;((this.material.uniforms.visibleRegionFadeStartRadius.value =
      this.visibleRegionFadeStartRadius),
      (this.material.uniforms.visibleRegionRadius.value = this.visibleRegionRadius),
      (this.material.uniforms.firstRenderTime.value = this.firstRenderTime),
      (this.material.uniforms.currentTime.value = performance.now()),
      (this.material.uniforms.fadeInComplete.value = c),
      (this.material.uniformsNeedUpdate = !0),
      (this.visibleRegionChanging = !l))
  }
  updateRenderIndexes(t, i) {
    const r = this.geometry
    ;(r.attributes.splatIndex.set(t),
      (r.attributes.splatIndex.needsUpdate = !0),
      i > 0 && this.firstRenderTime === -1 && (this.firstRenderTime = performance.now()),
      (r.instanceCount = i),
      r.setDrawRange(0, i))
  }
  updateTransforms() {
    for (let t = 0; t < this.scenes.length; t++) this.getScene(t).updateTransform(this.dynamicMode)
  }
  setSplatScale(t = 1) {
    ;((this.splatScale = t),
      (this.material.uniforms.splatScale.value = t),
      (this.material.uniformsNeedUpdate = !0))
  }
  getSplatScale() {
    return this.splatScale
  }
  setPointCloudModeEnabled(t) {
    ;((this.pointCloudModeEnabled = t),
      (this.material.uniforms.pointCloudModeEnabled.value = t ? 1 : 0),
      (this.material.uniformsNeedUpdate = !0))
  }
  getPointCloudModeEnabled() {
    return this.pointCloudModeEnabled
  }
  getSplatDataTextures() {
    return this.splatDataTextures
  }
  getSplatCount(t = !1) {
    return t ? li.getTotalSplatCountForScenes(this.scenes) : this.lastBuildSplatCount
  }
  static getTotalSplatCountForScenes(t) {
    let i = 0
    for (let r of t) r && r.splatBuffer && (i += r.splatBuffer.getSplatCount())
    return i
  }
  static getTotalSplatCountForSplatBuffers(t) {
    let i = 0
    for (let r of t) i += r.getSplatCount()
    return i
  }
  getMaxSplatCount() {
    return li.getTotalMaxSplatCountForScenes(this.scenes)
  }
  static getTotalMaxSplatCountForScenes(t) {
    let i = 0
    for (let r of t) r && r.splatBuffer && (i += r.splatBuffer.getMaxSplatCount())
    return i
  }
  static getTotalMaxSplatCountForSplatBuffers(t) {
    let i = 0
    for (let r of t) i += r.getMaxSplatCount()
    return i
  }
  disposeDistancesComputationGPUResources() {
    if (!this.renderer) return
    const t = this.renderer.getContext()
    ;(this.distancesTransformFeedback.vao &&
      (t.deleteVertexArray(this.distancesTransformFeedback.vao),
      (this.distancesTransformFeedback.vao = null)),
      this.distancesTransformFeedback.program &&
        (t.deleteProgram(this.distancesTransformFeedback.program),
        t.deleteShader(this.distancesTransformFeedback.vertexShader),
        t.deleteShader(this.distancesTransformFeedback.fragmentShader),
        (this.distancesTransformFeedback.program = null),
        (this.distancesTransformFeedback.vertexShader = null),
        (this.distancesTransformFeedback.fragmentShader = null)),
      this.disposeDistancesComputationGPUBufferResources(),
      this.distancesTransformFeedback.id &&
        (t.deleteTransformFeedback(this.distancesTransformFeedback.id),
        (this.distancesTransformFeedback.id = null)))
  }
  disposeDistancesComputationGPUBufferResources() {
    if (!this.renderer) return
    const t = this.renderer.getContext()
    ;(this.distancesTransformFeedback.centersBuffer &&
      ((this.distancesTransformFeedback.centersBuffer = null),
      t.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),
      this.distancesTransformFeedback.outDistancesBuffer &&
        (t.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),
        (this.distancesTransformFeedback.outDistancesBuffer = null)))
  }
  setRenderer(t) {
    if (t !== this.renderer) {
      this.renderer = t
      const i = this.renderer.getContext(),
        r = new OU(i),
        s = new BU(i, r, {})
      if (
        (r.init(s),
        (this.webGLUtils = new eC(i, r)),
        this.enableDistancesComputationOnGPU && this.getSplatCount() > 0)
      ) {
        this.setupDistancesComputationTransformFeedback()
        const { centers: o, sceneIndexes: a } = this.getDataForDistancesComputation(
          0,
          this.getSplatCount() - 1
        )
        this.refreshGPUBuffersForDistancesComputation(o, a)
      }
    }
  }
  updateGPUCentersBufferForDistancesComputation(t, i, r) {
    if (!this.renderer) return
    const s = this.renderer.getContext(),
      o = s.getParameter(s.VERTEX_ARRAY_BINDING)
    s.bindVertexArray(this.distancesTransformFeedback.vao)
    const a = this.integerBasedDistancesComputation ? Uint32Array : Float32Array,
      l = 16,
      c = r * l
    if ((s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), t))
      s.bufferSubData(s.ARRAY_BUFFER, c, i)
    else {
      const u = new a(this.getMaxSplatCount() * l)
      ;(u.set(i), s.bufferData(s.ARRAY_BUFFER, u, s.STATIC_DRAW))
    }
    ;(s.bindBuffer(s.ARRAY_BUFFER, null), o && s.bindVertexArray(o))
  }
  updateGPUTransformIndexesBufferForDistancesComputation(t, i, r) {
    if (!this.renderer || !this.dynamicMode) return
    const s = this.renderer.getContext(),
      o = s.getParameter(s.VERTEX_ARRAY_BINDING)
    s.bindVertexArray(this.distancesTransformFeedback.vao)
    const a = r * 4
    if ((s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer), t))
      s.bufferSubData(s.ARRAY_BUFFER, a, i)
    else {
      const l = new Uint32Array(this.getMaxSplatCount() * 4)
      ;(l.set(i), s.bufferData(s.ARRAY_BUFFER, l, s.STATIC_DRAW))
    }
    ;(s.bindBuffer(s.ARRAY_BUFFER, null), o && s.bindVertexArray(o))
  }
  getSceneIndexes(t, i) {
    let r
    const s = i - t + 1
    r = new Uint32Array(s)
    for (let o = t; o <= i; o++) r[o] = this.globalSplatIndexToSceneIndexMap[o]
    return r
  }
  getLocalSplatParameters(t, i, r) {
    ;(r == null && (r = !this.dynamicMode),
      (i.splatBuffer = this.getSplatBufferForSplat(t)),
      (i.localIndex = this.getSplatLocalIndex(t)),
      (i.sceneTransform = r ? this.getSceneTransformForSplat(t) : null))
  }
  fillSplatDataArrays(t, i, r, s, o, a, l, c, u = 0, d = 0, h = 1, f, p, g = 0, y) {
    const m = new Y()
    ;((m.x = void 0),
      (m.y = void 0),
      this.splatRenderMode === Mo.ThreeD ? (m.z = void 0) : (m.z = 1))
    const v = new qe()
    let x = 0,
      _ = this.scenes.length - 1
    y != null && y >= 0 && y <= this.scenes.length && ((x = y), (_ = y))
    for (let S = x; S <= _; S++) {
      c == null && (c = !this.dynamicMode)
      const C = this.getScene(S),
        A = C.splatBuffer
      let R
      if (
        (c && (this.getSceneTransform(S, v), (R = v)),
        t && A.fillSplatCovarianceArray(t, R, f, p, g, u),
        i || r)
      ) {
        if (!i || !r)
          throw new Error(
            'SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.'
          )
        A.fillSplatScaleRotationArray(i, r, R, f, p, g, d, m)
      }
      ;(s && A.fillSplatCenterArray(this.morphedMesh, s, R, f, p, g),
        o && A.fillSplatColorArray(o, C.minimumAlpha, f, p, g),
        a && A.fillSphericalHarmonicsArray(a, this.minSphericalHarmonicsDegree, R, f, p, g, h),
        (g += A.getSplatCount()))
    }
  }
  getIntegerCenters(t, i, r = !1) {
    const s = i - t + 1,
      o = new Float32Array(s * 3)
    this.fillSplatDataArrays(null, null, null, o, null, null, void 0, void 0, void 0, void 0, t)
    let a,
      l = r ? 4 : 3
    a = new Int32Array(s * l)
    for (let c = 0; c < s; c++) {
      for (let u = 0; u < 3; u++) a[c * l + u] = Math.round(o[c * 3 + u] * 1e3)
      r && (a[c * l + 3] = 1e3)
    }
    return a
  }
  getFloatCenters(t, i, r = !1) {
    const s = i - t + 1,
      o = new Float32Array(s * 3)
    if (
      (this.fillSplatDataArrays(null, null, null, o, null, null, void 0, void 0, void 0, void 0, t),
      !r)
    )
      return o
    let a = new Float32Array(s * 4)
    for (let l = 0; l < s; l++) {
      for (let c = 0; c < 3; c++) a[l * 4 + c] = o[l * 3 + c]
      a[l * 4 + 3] = 1
    }
    return a
  }
  getSceneTransform(t, i) {
    const r = this.getScene(t)
    ;(r.updateTransform(this.dynamicMode), i.copy(r.transform))
  }
  getScene(t) {
    if (t < 0 || t >= this.scenes.length)
      throw new Error('SplatMesh::getScene() -> Invalid scene index.')
    return this.scenes[t]
  }
  getSceneCount() {
    return this.scenes.length
  }
  getSplatBufferForSplat(t) {
    return this.getScene(this.globalSplatIndexToSceneIndexMap[t]).splatBuffer
  }
  getSceneIndexForSplat(t) {
    return this.globalSplatIndexToSceneIndexMap[t]
  }
  getSceneTransformForSplat(t) {
    return this.getScene(this.globalSplatIndexToSceneIndexMap[t]).transform
  }
  getSplatLocalIndex(t) {
    return this.globalSplatIndexToLocalSplatIndexMap[t]
  }
  static getIntegerMatrixArray(t) {
    const i = t.elements,
      r = []
    for (let s = 0; s < 16; s++) r[s] = Math.round(i[s] * 1e3)
    return r
  }
  computeBoundingBox(t = !1, i) {
    let r = this.getSplatCount()
    if (i != null) {
      if (i < 0 || i >= this.scenes.length)
        throw new Error('SplatMesh::computeBoundingBox() -> Invalid scene index.')
      r = this.scenes[i].splatBuffer.getSplatCount()
    }
    const s = new Float32Array(r * 3)
    this.fillSplatDataArrays(null, null, null, s, null, null, t, void 0, void 0, void 0, void 0, i)
    const o = new Y(),
      a = new Y()
    for (let l = 0; l < r; l++) {
      const c = l * 3,
        u = s[c],
        d = s[c + 1],
        h = s[c + 2]
      ;((l === 0 || u < o.x) && (o.x = u),
        (l === 0 || d < o.y) && (o.y = d),
        (l === 0 || h < o.z) && (o.z = h),
        (l === 0 || u > a.x) && (a.x = u),
        (l === 0 || d > a.y) && (a.y = d),
        (l === 0 || h > a.z) && (a.z = h))
    }
    return new ir(o, a)
  }
}
var WU =
    'AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHVAQRX193YXNtX2NhbGxfY3RvcnMAABhfX3dhc21fYXBwbHlfZGF0YV9yZWxvY3MAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgqWEAMDAAELihAEAXwDewN/A30gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIAogBSAKSBshCiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiFWooAgAiFkECdGooAgAiFEcEQAJ/IAX9CQI4IAggFEEGdGoiDv0JAgwgDioCHP0gASAOKgIs/SACIA4qAjz9IAP95gEgBf0JAiggDv0JAgggDioCGP0gASAOKgIo/SACIA4qAjj9IAP95gEgBf0JAgggDv0JAgAgDioCEP0gASAOKgIg/SACIA4qAjD9IAP95gEgBf0JAhggDv0JAgQgDioCFP0gASAOKgIk/SACIA4qAjT9IAP95gH95AH95AH95AEiEf1f/QwAAAAAAECPQAAAAAAAQI9AIhL98gEiE/0hASIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDgJ/IBP9IQAiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgL/REgDv0cAQJ/IBEgEf0NCAkKCwwNDg8AAAAAAAAAAP1fIBL98gEiEf0hACIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAv9HAICfyAR/SEBIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4C/0cAyESIBQhDwsgAyAVaiABIBZBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmogEf0bA2oiDjYCACAOIAogCiAOShshCiAOIA0gDSAOSBshDSACQQFqIgIgC0cNAAsMAwsCfyAFKgIIu/0UIAUqAhi7/SIB/QwAAAAAAECPQAAAAAAAQI9A/fIBIhH9IQEiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQ4CfyAR/SEAIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQpBiICAgHghDSALIAxNDQIgAv0RIA79HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIAogAiAKSBshCiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAFBAWoiASALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIRcgBSoCGCEYIAUqAgghGUH4////ByEKQYiAgIB4IQ0gDCEFA0ACfyAXIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCAZIAIqAgCUIBggAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIUaigCAEECdCIVaigCACIORwRAIAX9CQI4IAggDkEGdGoiD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gEgBf0JAgggD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AH95AH95AEhESAOIQ8LIAMgFGoCfyAR/R8DIAEgFUECdCIOQQxyaioCAJQgEf0fAiABIA5BCHJqKgIAlCAR/R8AIAEgDmoqAgCUIBH9HwEgASAOQQRyaioCAJSSkpK7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAsiDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSACQQFqIgIgC0cNAAsMAQtBiICAgHghDUH4////ByEKCyALIAxLBEAgCUEBa7MgDbIgCrKTlSEXIAwhDQNAAn8gFyADIA1BAnRqIgEoAgAgCmuylCIYi0MAAABPXQRAIBioDAELQYCAgIB4CyEOIAEgDjYCACAEIA5BAnRqIgEgASgCAEEBajYCACANQQFqIg0gC0cNAAsLIAlBAk8EQCAEKAIAIQ1BASEKA0AgBCAKQQJ0aiIBIAEoAgAgDWoiDTYCACAKQQFqIgogCUcNAAsLIAxBAEoEQCAMIQoDQCAGIApBAWsiAUECdCICaiAAIAJqKAIANgIAIApBAUshAiABIQogAg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCwsEAEEACw==',
  sb =
    'AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACEgEDZW52Bm1lbW9yeQIDAICABAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQqiDwICAAucDwMBfAd9Bn8gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEFA0AgAyAFQQJ0IgFqIAIgACABaigCAEECdGooAgAiATYCACABIAogASAKSBshCiABIA0gASANShshDSAFQQFqIgUgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiGmooAgBBAnQiG2ooAgAiDkcEQAJ/IAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRgCfyARIA8qAiyUIBIgDyoCKJQgEyAPKgIglCAUIA8qAiSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRkCfyARIA8qAhyUIBIgDyoCGJQgEyAPKgIQlCAUIA8qAhSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRwCfyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIR0gDiEPCyADIBpqIAEgG0ECdGoiDigCBCAcbCAOKAIAIB1saiAOKAIIIBlsaiAOKAIMIBhsaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAii7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshAgJ/IAUqAhi7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshByALIAxNAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEPQfj///8HIQpBiICAgHghDQ0CIAwhBQNAIAMgBUECdCIIaiABIAAgCGooAgBBBHRqIggoAgQgB2wgCCgCACAPbGogCCgCCCACbGoiCDYCACAIIAogCCAKSBshCiAIIA0gCCANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEFA0AgAyAFQQJ0IgFqAn8gAiAAIAFqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAVBAWoiBSALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIREgBSoCGCESIAUqAgghE0H4////ByEKQYiAgIB4IQ0gDCEFA0ACfyARIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCATIAIqAgCUIBIgAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIYaigCAEECdCIZaigCACIORwRAIAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSIRUgESAPKgIslCASIA8qAiiUIBMgDyoCIJQgFCAPKgIklJKSkiEWIBEgDyoCHJQgEiAPKgIYlCATIA8qAhCUIBQgDyoCFJSSkpIhFyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSIREgDiEPCyADIBhqAn8gFSABIBlBAnRqIg4qAgyUIBYgDioCCJQgESAOKgIAlCAXIA4qAgSUkpKSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIg42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gAkEBaiICIAtHDQALDAELQYiAgIB4IQ1B+P///wchCgsgCyAMSwRAIAlBAWuzIA2yIAqyk5UhESAMIQ0DQAJ/IBEgAyANQQJ0aiIBKAIAIAprspQiEotDAAAAT10EQCASqAwBC0GAgICAeAshDiABIA42AgAgBCAOQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhCgNAIAQgCkECdGoiASABKAIAIA1qIg02AgAgCkEBaiIKIAlHDQALCyAMQQBKBEAgDCEKA0AgBiAKQQFrIgFBAnQiAmogACACaigCADYCACAKQQFLIAEhCg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCws=',
  QU =
    'AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQrrDwICAAvlDwQBfAN7B30DfyALIAprIQwCQAJAIA4EQCANBEBB+P///wchCkGIgICAeCENIAsgDE0NAyAMIQUDQCADIAVBAnQiAWogAiAAIAFqKAIAQQJ0aigCACIBNgIAIAEgCiABIApIGyEKIAEgDSABIA1KGyENIAVBAWoiBSALRw0ACwwDCyAPBEAgCyAMTQ0CQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIcaigCACIdQQJ0aigCACIbRwRAAn8gBf0JAjggCCAbQQZ0aiIO/QkCDCAOKgIc/SABIA4qAiz9IAIgDioCPP0gA/3mASAF/QkCKCAO/QkCCCAOKgIY/SABIA4qAij9IAIgDioCOP0gA/3mASAF/QkCCCAO/QkCACAOKgIQ/SABIA4qAiD9IAIgDioCMP0gA/3mASAF/QkCGCAO/QkCBCAOKgIU/SABIA4qAiT9IAIgDioCNP0gA/3mAf3kAf3kAf3kASIR/V/9DAAAAAAAQI9AAAAAAABAj0AiEv3yASIT/SEBIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOAn8gE/0hACIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAv9ESAO/RwBAn8gESAR/Q0ICQoLDA0ODwABAgMAAQID/V8gEv3yASIR/SEAIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4C/0cAgJ/IBH9IQEiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgL/RwDIRIgGyEPCyADIBxqIAEgHUEEdGr9AAAAIBL9tQEiEf0bACAR/RsBaiAR/RsCaiAR/RsDaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAgi7/RQgBSoCGLv9IgH9DAAAAAAAQI9AAAAAAABAj0D98gEiEf0hASIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDgJ/IBH9IQAiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQpBiICAgHghDSALIAxNDQL9ESAO/RwBIAX9HAIhEiAMIQUDQCADIAVBAnQiAmogASAAIAJqKAIAQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIgI2AgAgAiAKIAIgCkgbIQogAiANIAIgDUobIQ0gBUEBaiIFIAtHDQALDAILIA0EQEH4////ByEKQYiAgIB4IQ0gCyAMTQ0CIAwhBQNAIAMgBUECdCIBagJ/IAIgACABaigCAEECdGoqAgC7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAsiDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgD0UEQCALIAxNDQEgBSoCKCEUIAUqAhghFSAFKgIIIRZB+P///wchCkGIgICAeCENIAwhBQNAAn8gFCABIAAgBUECdCIHaigCAEEEdGoiAioCCJQgFiACKgIAlCAVIAIqAgSUkpK7RAAAAAAAALBAoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshDiADIAdqIA42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gBUEBaiIFIAtHDQALDAILIAsgDE0NAEF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiG2ooAgBBAnQiHGooAgAiDkcEQCAFKgI4IhQgCCAOQQZ0aiIPKgI8lCAFKgIoIhUgDyoCOJQgBSoCCCIWIA8qAjCUIAUqAhgiFyAPKgI0lJKSkiEYIBQgDyoCLJQgFSAPKgIolCAWIA8qAiCUIBcgDyoCJJSSkpIhGSAUIA8qAhyUIBUgDyoCGJQgFiAPKgIQlCAXIA8qAhSUkpKSIRogFCAPKgIMlCAVIA8qAgiUIBYgDyoCAJQgFyAPKgIElJKSkiEUIA4hDwsgAyAbagJ/IBggASAcQQJ0aiIOKgIMlCAZIA4qAgiUIBQgDioCAJQgGiAOKgIElJKSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAJBAWoiAiALRw0ACwwBC0GIgICAeCENQfj///8HIQoLIAsgDEsEQCAJQQFrsyANsiAKspOVIRQgDCENA0ACfyAUIAMgDUECdGoiASgCACAKa7KUIhWLQwAAAE9dBEAgFagMAQtBgICAgHgLIQ4gASAONgIAIAQgDkECdGoiASABKAIAQQFqNgIAIA1BAWoiDSALRw0ACwsgCUECTwRAIAQoAgAhDUEBIQoDQCAEIApBAnRqIgEgASgCACANaiINNgIAIApBAWoiCiAJRw0ACwsgDEEASgRAIAwhCgNAIAYgCkEBayIBQQJ0IgJqIAAgAmooAgA2AgAgCkEBSyABIQoNAAsLIAsgDEoEQCALIQoDQCAGIAsgBCADIApBAWsiCkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgCiAMSg0ACwsL',
  jU =
    'AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEXAmAAAGAQf39/f39/f39/f39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMDAgABBz4DEV9fd2FzbV9jYWxsX2N0b3JzAAAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAALc29ydEluZGV4ZXMAAQqiDwICAAucDwMBfAd9Bn8gCyAKayEMAkACQCAOBEAgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQMgDCEFA0AgAyAFQQJ0IgFqIAIgACABaigCAEECdGooAgAiATYCACABIAogASAKSBshCiABIA0gASANShshDSAFQQFqIgUgC0cNAAsMAwsgDwRAIAsgDE0NAkF/IQ9B+P///wchCkGIgICAeCENIAwhAgNAIA8gByAAIAJBAnQiGmooAgBBAnQiG2ooAgAiDkcEQAJ/IAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRgCfyARIA8qAiyUIBIgDyoCKJQgEyAPKgIglCAUIA8qAiSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRkCfyARIA8qAhyUIBIgDyoCGJQgEyAPKgIQlCAUIA8qAhSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIRwCfyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSu0QAAAAAAECPQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIR0gDiEPCyADIBpqIAEgG0ECdGoiDigCBCAcbCAOKAIAIB1saiAOKAIIIBlsaiAOKAIMIBhsaiIONgIAIA4gCiAKIA5KGyEKIA4gDSANIA5IGyENIAJBAWoiAiALRw0ACwwDCwJ/IAUqAii7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshAgJ/IAUqAhi7RAAAAAAAQI9AoiIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAshByALIAxNAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEPQfj///8HIQpBiICAgHghDQ0CIAwhBQNAIAMgBUECdCIIaiABIAAgCGooAgBBBHRqIggoAgQgB2wgCCgCACAPbGogCCgCCCACbGoiCDYCACAIIAogCCAKSBshCiAIIA0gCCANShshDSAFQQFqIgUgC0cNAAsMAgsgDQRAQfj///8HIQpBiICAgHghDSALIAxNDQIgDCEFA0AgAyAFQQJ0IgFqAn8gAiAAIAFqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIONgIAIAogDiAKIA5IGyEKIA0gDiANIA5KGyENIAVBAWoiBSALRw0ACwwCCyAPRQRAIAsgDE0NASAFKgIoIREgBSoCGCESIAUqAgghE0H4////ByEKQYiAgIB4IQ0gDCEFA0ACfyARIAEgACAFQQJ0IgdqKAIAQQR0aiICKgIIlCATIAIqAgCUIBIgAioCBJSSkrtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEOIAMgB2ogDjYCACAKIA4gCiAOSBshCiANIA4gDSAOShshDSAFQQFqIgUgC0cNAAsMAgsgCyAMTQ0AQX8hD0H4////ByEKQYiAgIB4IQ0gDCECA0AgDyAHIAAgAkECdCIYaigCAEECdCIZaigCACIORwRAIAUqAjgiESAIIA5BBnRqIg8qAjyUIAUqAigiEiAPKgI4lCAFKgIIIhMgDyoCMJQgBSoCGCIUIA8qAjSUkpKSIRUgESAPKgIslCASIA8qAiiUIBMgDyoCIJQgFCAPKgIklJKSkiEWIBEgDyoCHJQgEiAPKgIYlCATIA8qAhCUIBQgDyoCFJSSkpIhFyARIA8qAgyUIBIgDyoCCJQgEyAPKgIAlCAUIA8qAgSUkpKSIREgDiEPCyADIBhqAn8gFSABIBlBAnRqIg4qAgyUIBYgDioCCJQgESAOKgIAlCAXIA4qAgSUkpKSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIg42AgAgCiAOIAogDkgbIQogDSAOIA0gDkobIQ0gAkEBaiICIAtHDQALDAELQYiAgIB4IQ1B+P///wchCgsgCyAMSwRAIAlBAWuzIA2yIAqyk5UhESAMIQ0DQAJ/IBEgAyANQQJ0aiIBKAIAIAprspQiEotDAAAAT10EQCASqAwBC0GAgICAeAshDiABIA42AgAgBCAOQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhCgNAIAQgCkECdGoiASABKAIAIA1qIg02AgAgCkEBaiIKIAlHDQALCyAMQQBKBEAgDCEKA0AgBiAKQQFrIgFBAnQiAmogACACaigCADYCACAKQQFLIAEhCg0ACwsgCyAMSgRAIAshCgNAIAYgCyAEIAMgCkEBayIKQQJ0IgFqKAIAQQJ0aiICKAIAIgVrQQJ0aiAAIAFqKAIANgIAIAIgBUEBazYCACAKIAxKDQALCws='
function qU(n) {
  let e, t, i, r, s, o, a, l, c, u, d, h, f, p, g, y, m, v, x, _
  function S(C, A, R, w, M, I, L) {
    const U = performance.now()
    if (
      !i &&
      (new Uint32Array(t, a, M.byteLength / _.BytesPerInt).set(M),
      new Float32Array(t, u, L.byteLength / _.BytesPerFloat).set(L),
      w)
    ) {
      let ee
      ;(r
        ? (ee = new Int32Array(t, d, I.byteLength / _.BytesPerInt))
        : (ee = new Float32Array(t, d, I.byteLength / _.BytesPerFloat)),
        ee.set(I))
    }
    ;(y || (y = new Uint32Array(v)),
      new Float32Array(t, g, 16).set(R),
      new Uint32Array(t, f, v).set(y),
      e.exports.sortIndexes(a, p, d, h, f, g, l, c, u, v, C, A, o, w, r, s))
    const T = { sortDone: !0, splatSortCount: C, splatRenderCount: A, sortTime: 0 }
    if (!i) {
      const V = new Uint32Array(t, l, A)
      ;((!m || m.length < A) && (m = new Uint32Array(A)), m.set(V), (T.sortedIndexes = m))
    }
    const F = performance.now()
    ;((T.sortTime = F - U), n.postMessage(T))
  }
  n.onmessage = (C) => {
    if (C.data.centers)
      ((centers = C.data.centers),
        (sceneIndexes = C.data.sceneIndexes),
        r
          ? new Int32Array(
              t,
              p + C.data.range.from * _.BytesPerInt * 4,
              C.data.range.count * 4
            ).set(new Int32Array(centers))
          : new Float32Array(
              t,
              p + C.data.range.from * _.BytesPerFloat * 4,
              C.data.range.count * 4
            ).set(new Float32Array(centers)),
        s &&
          new Uint32Array(t, c + C.data.range.from * 4, C.data.range.count).set(
            new Uint32Array(sceneIndexes)
          ),
        (x = C.data.range.from + C.data.range.count))
    else if (C.data.sort) {
      const A = Math.min(C.data.sort.splatRenderCount || 0, x),
        R = Math.min(C.data.sort.splatSortCount || 0, x),
        w = C.data.sort.usePrecomputedDistances
      let M, I, L
      ;(i ||
        ((M = C.data.sort.indexesToSort),
        (L = C.data.sort.transforms),
        w && (I = C.data.sort.precomputedDistances)),
        S(R, A, C.data.sort.modelViewProj, w, M, I, L))
    } else if (C.data.init) {
      ;((_ = C.data.init.Constants),
        (o = C.data.init.splatCount),
        (i = C.data.init.useSharedMemory),
        (r = C.data.init.integerBasedSort),
        (s = C.data.init.dynamicMode),
        (v = C.data.init.distanceMapRange),
        (x = 0))
      const A = r ? _.BytesPerInt * 4 : _.BytesPerFloat * 4,
        R = new Uint8Array(C.data.init.sorterWasmBytes),
        w = 16 * _.BytesPerFloat,
        M = o * _.BytesPerInt,
        I = o * A,
        L = w,
        U = r ? o * _.BytesPerInt : o * _.BytesPerFloat,
        T = o * _.BytesPerInt,
        F = o * _.BytesPerInt,
        V = r ? v * _.BytesPerInt * 2 : v * _.BytesPerFloat * 2,
        W = s ? o * _.BytesPerInt : 0,
        ee = s ? _.MaxScenes * w : 0,
        se = _.MemoryPageSize * 32,
        he = M + I + L + U + T + V + F + W + ee + se,
        ne = Math.floor(he / _.MemoryPageSize) + 1,
        ie = {
          module: {},
          env: { memory: new WebAssembly.Memory({ initial: ne, maximum: ne, shared: !0 }) },
        }
      WebAssembly.compile(R)
        .then((be) => WebAssembly.instantiate(be, ie))
        .then((be) => {
          ;((e = be),
            (a = 0),
            (p = a + M),
            (g = p + I),
            (d = g + L),
            (h = d + U),
            (f = h + T),
            (l = f + V),
            (c = l + F),
            (u = c + W),
            (t = ie.env.memory.buffer),
            i
              ? n.postMessage({
                  sortSetupPhase1Complete: !0,
                  indexesToSortBuffer: t,
                  indexesToSortOffset: a,
                  sortedIndexesBuffer: t,
                  sortedIndexesOffset: l,
                  precomputedDistancesBuffer: t,
                  precomputedDistancesOffset: d,
                  transformsBuffer: t,
                  transformsOffset: u,
                })
              : n.postMessage({ sortSetupPhase1Complete: !0 }))
        })
    }
  }
}
function XU(n, e, t, i, r, s = Ft.DefaultSplatSortDistanceMapPrecision) {
  const o = new Worker(
    URL.createObjectURL(
      new Blob(['(', qU.toString(), ')(self)'], { type: 'application/javascript' })
    )
  )
  let a = WU
  const l = m_() ? g5() : null
  !t && !e
    ? ((a = sb), l && l.major <= 16 && l.minor < 4 && (a = jU))
    : t
      ? e || (l && l.major <= 16 && l.minor < 4 && (a = QU))
      : (a = sb)
  const c = atob(a),
    u = new Uint8Array(c.length)
  for (let d = 0; d < c.length; d++) u[d] = c.charCodeAt(d)
  return (
    o.postMessage({
      init: {
        sorterWasmBytes: u.buffer,
        splatCount: n,
        useSharedMemory: e,
        integerBasedSort: i,
        dynamicMode: r,
        distanceMapRange: 1 << s,
        Constants: {
          BytesPerFloat: Ft.BytesPerFloat,
          BytesPerInt: Ft.BytesPerInt,
          MemoryPageSize: Ft.MemoryPageSize,
          MaxScenes: Ft.MaxScenes,
        },
      },
    }),
    o
  )
}
const xc = { None: 0, VR: 1, AR: 2 }
class _u {
  static createButton(e, t = {}) {
    const i = document.createElement('button')
    function r() {
      let c = null
      async function u(f) {
        ;(f.addEventListener('end', d),
          await e.xr.setSession(f),
          (i.textContent = 'EXIT VR'),
          (c = f))
      }
      function d() {
        ;(c.removeEventListener('end', d), (i.textContent = 'ENTER VR'), (c = null))
      }
      ;((i.style.display = ''),
        (i.style.cursor = 'pointer'),
        (i.style.left = 'calc(50% - 50px)'),
        (i.style.width = '100px'),
        (i.textContent = 'ENTER VR'))
      const h = {
        ...t,
        optionalFeatures: ['local-floor', 'bounded-floor', 'layers', ...(t.optionalFeatures || [])],
      }
      ;((i.onmouseenter = function () {
        i.style.opacity = '1.0'
      }),
        (i.onmouseleave = function () {
          i.style.opacity = '0.5'
        }),
        (i.onclick = function () {
          c === null
            ? navigator.xr.requestSession('immersive-vr', h).then(u)
            : (c.end(),
              navigator.xr.offerSession !== void 0 &&
                navigator.xr
                  .offerSession('immersive-vr', h)
                  .then(u)
                  .catch((f) => {
                    console.warn(f)
                  }))
        }),
        navigator.xr.offerSession !== void 0 &&
          navigator.xr
            .offerSession('immersive-vr', h)
            .then(u)
            .catch((f) => {
              console.warn(f)
            }))
    }
    function s() {
      ;((i.style.display = ''),
        (i.style.cursor = 'auto'),
        (i.style.left = 'calc(50% - 75px)'),
        (i.style.width = '150px'),
        (i.onmouseenter = null),
        (i.onmouseleave = null),
        (i.onclick = null))
    }
    function o() {
      ;(s(), (i.textContent = 'VR NOT SUPPORTED'))
    }
    function a(c) {
      ;(s(),
        console.warn('Exception when trying to call xr.isSessionSupported', c),
        (i.textContent = 'VR NOT ALLOWED'))
    }
    function l(c) {
      ;((c.style.position = 'absolute'),
        (c.style.bottom = '20px'),
        (c.style.padding = '12px 6px'),
        (c.style.border = '1px solid #fff'),
        (c.style.borderRadius = '4px'),
        (c.style.background = 'rgba(0,0,0,0.1)'),
        (c.style.color = '#fff'),
        (c.style.font = 'normal 13px sans-serif'),
        (c.style.textAlign = 'center'),
        (c.style.opacity = '0.5'),
        (c.style.outline = 'none'),
        (c.style.zIndex = '999'))
    }
    if ('xr' in navigator)
      return (
        (i.id = 'VRButton'),
        (i.style.display = 'none'),
        l(i),
        navigator.xr
          .isSessionSupported('immersive-vr')
          .then(function (c) {
            ;(c ? r() : o(), c && _u.xrSessionIsGranted && i.click())
          })
          .catch(a),
        i
      )
    {
      const c = document.createElement('a')
      return (
        window.isSecureContext === !1
          ? ((c.href = document.location.href.replace(/^http:/, 'https:')),
            (c.innerHTML = 'WEBXR NEEDS HTTPS'))
          : ((c.href = 'https://immersiveweb.dev/'), (c.innerHTML = 'WEBXR NOT AVAILABLE')),
        (c.style.left = 'calc(50% - 90px)'),
        (c.style.width = '180px'),
        (c.style.textDecoration = 'none'),
        l(c),
        c
      )
    }
  }
  static registerSessionGrantedListener() {
    if (typeof navigator < 'u' && 'xr' in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent)) return
      navigator.xr.addEventListener('sessiongranted', () => {
        _u.xrSessionIsGranted = !0
      })
    }
  }
}
_u.xrSessionIsGranted = !1
_u.registerSessionGrantedListener()
class KU {
  static createButton(e, t = {}) {
    const i = document.createElement('button')
    function r() {
      if (t.domOverlay === void 0) {
        const h = document.createElement('div')
        ;((h.style.display = 'none'), document.body.appendChild(h))
        const f = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
        ;(f.setAttribute('width', 38),
          f.setAttribute('height', 38),
          (f.style.position = 'absolute'),
          (f.style.right = '20px'),
          (f.style.top = '20px'),
          f.addEventListener('click', function () {
            c.end()
          }),
          h.appendChild(f))
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
        ;(p.setAttribute('d', 'M 12,12 L 28,28 M 28,12 12,28'),
          p.setAttribute('stroke', '#fff'),
          p.setAttribute('stroke-width', 2),
          f.appendChild(p),
          t.optionalFeatures === void 0 && (t.optionalFeatures = []),
          t.optionalFeatures.push('dom-overlay'),
          (t.domOverlay = { root: h }))
      }
      let c = null
      async function u(h) {
        ;(h.addEventListener('end', d),
          e.xr.setReferenceSpaceType('local'),
          await e.xr.setSession(h),
          (i.textContent = 'STOP AR'),
          (t.domOverlay.root.style.display = ''),
          (c = h))
      }
      function d() {
        ;(c.removeEventListener('end', d),
          (i.textContent = 'START AR'),
          (t.domOverlay.root.style.display = 'none'),
          (c = null))
      }
      ;((i.style.display = ''),
        (i.style.cursor = 'pointer'),
        (i.style.left = 'calc(50% - 50px)'),
        (i.style.width = '100px'),
        (i.textContent = 'START AR'),
        (i.onmouseenter = function () {
          i.style.opacity = '1.0'
        }),
        (i.onmouseleave = function () {
          i.style.opacity = '0.5'
        }),
        (i.onclick = function () {
          c === null
            ? navigator.xr.requestSession('immersive-ar', t).then(u)
            : (c.end(),
              navigator.xr.offerSession !== void 0 &&
                navigator.xr
                  .offerSession('immersive-ar', t)
                  .then(u)
                  .catch((h) => {
                    console.warn(h)
                  }))
        }),
        navigator.xr.offerSession !== void 0 &&
          navigator.xr
            .offerSession('immersive-ar', t)
            .then(u)
            .catch((h) => {
              console.warn(h)
            }))
    }
    function s() {
      ;((i.style.display = ''),
        (i.style.cursor = 'auto'),
        (i.style.left = 'calc(50% - 75px)'),
        (i.style.width = '150px'),
        (i.onmouseenter = null),
        (i.onmouseleave = null),
        (i.onclick = null))
    }
    function o() {
      ;(s(), (i.textContent = 'AR NOT SUPPORTED'))
    }
    function a(c) {
      ;(s(),
        console.warn('Exception when trying to call xr.isSessionSupported', c),
        (i.textContent = 'AR NOT ALLOWED'))
    }
    function l(c) {
      ;((c.style.position = 'absolute'),
        (c.style.bottom = '20px'),
        (c.style.padding = '12px 6px'),
        (c.style.border = '1px solid #fff'),
        (c.style.borderRadius = '4px'),
        (c.style.background = 'rgba(0,0,0,0.1)'),
        (c.style.color = '#fff'),
        (c.style.font = 'normal 13px sans-serif'),
        (c.style.textAlign = 'center'),
        (c.style.opacity = '0.5'),
        (c.style.outline = 'none'),
        (c.style.zIndex = '999'))
    }
    if ('xr' in navigator)
      return (
        (i.id = 'ARButton'),
        (i.style.display = 'none'),
        l(i),
        navigator.xr
          .isSessionSupported('immersive-ar')
          .then(function (c) {
            c ? r() : o()
          })
          .catch(a),
        i
      )
    {
      const c = document.createElement('a')
      return (
        window.isSecureContext === !1
          ? ((c.href = document.location.href.replace(/^http:/, 'https:')),
            (c.innerHTML = 'WEBXR NEEDS HTTPS'))
          : ((c.href = 'https://immersiveweb.dev/'), (c.innerHTML = 'WEBXR NOT AVAILABLE')),
        (c.style.left = 'calc(50% - 90px)'),
        (c.style.width = '180px'),
        (c.style.textDecoration = 'none'),
        l(c),
        c
      )
    }
  }
}
const Zg = { Always: 0, Never: 2 }
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const YU = [
  'alphaMap',
  'alphaTest',
  'anisotropy',
  'anisotropyMap',
  'anisotropyRotation',
  'aoMap',
  'attenuationColor',
  'attenuationDistance',
  'bumpMap',
  'clearcoat',
  'clearcoatMap',
  'clearcoatNormalMap',
  'clearcoatNormalScale',
  'clearcoatRoughness',
  'color',
  'dispersion',
  'displacementMap',
  'emissive',
  'emissiveMap',
  'envMap',
  'gradientMap',
  'ior',
  'iridescence',
  'iridescenceIOR',
  'iridescenceMap',
  'iridescenceThicknessMap',
  'lightMap',
  'map',
  'matcap',
  'metalness',
  'metalnessMap',
  'normalMap',
  'normalScale',
  'opacity',
  'roughness',
  'roughnessMap',
  'sheen',
  'sheenColor',
  'sheenColorMap',
  'sheenRoughnessMap',
  'shininess',
  'specular',
  'specularColor',
  'specularColorMap',
  'specularIntensity',
  'specularIntensityMap',
  'specularMap',
  'thickness',
  'transmission',
  'transmissionMap',
]
class ZU {
  constructor(e) {
    ;((this.renderObjects = new WeakMap()),
      (this.hasNode = this.containsNode(e)),
      (this.hasAnimation = e.object.isSkinnedMesh === !0),
      (this.refreshUniforms = YU),
      (this.renderId = 0))
  }
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1
  }
  getRenderObjectData(e) {
    let t = this.renderObjects.get(e)
    if (t === void 0) {
      const { geometry: i, material: r, object: s } = e
      if (
        ((t = {
          material: this.getMaterialData(r),
          geometry: {
            id: i.id,
            attributes: this.getAttributesData(i.attributes),
            indexVersion: i.index ? i.index.version : null,
            drawRange: { start: i.drawRange.start, count: i.drawRange.count },
          },
          worldMatrix: s.matrixWorld.clone(),
        }),
        s.center && (t.center = s.center.clone()),
        s.morphTargetInfluences && (t.morphTargetInfluences = s.morphTargetInfluences.slice()),
        e.bundle !== null && (t.version = e.bundle.version),
        t.material.transmission > 0)
      ) {
        const { width: o, height: a } = e.context
        ;((t.bufferWidth = o), (t.bufferHeight = a))
      }
      this.renderObjects.set(e, t)
    }
    return t
  }
  getAttributesData(e) {
    const t = {}
    for (const i in e) {
      const r = e[i]
      t[i] = { version: r.version }
    }
    return t
  }
  containsNode(e) {
    const t = e.material
    for (const i in t) if (t[i] && t[i].isNode) return !0
    return (
      e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null
    )
  }
  getMaterialData(e) {
    const t = {}
    for (const i of this.refreshUniforms) {
      const r = e[i]
      r != null &&
        (typeof r == 'object' && r.clone !== void 0
          ? r.isTexture === !0
            ? (t[i] = { id: r.id, version: r.version })
            : (t[i] = r.clone())
          : (t[i] = r))
    }
    return t
  }
  equals(e) {
    const { object: t, material: i, geometry: r } = e,
      s = this.getRenderObjectData(e)
    if (s.worldMatrix.equals(t.matrixWorld) !== !0) return (s.worldMatrix.copy(t.matrixWorld), !1)
    const o = s.material
    for (const g in o) {
      const y = o[g],
        m = i[g]
      if (y.equals !== void 0) {
        if (y.equals(m) === !1) return (y.copy(m), !1)
      } else if (m.isTexture === !0) {
        if (y.id !== m.id || y.version !== m.version)
          return ((y.id = m.id), (y.version = m.version), !1)
      } else if (y !== m) return ((o[g] = m), !1)
    }
    if (o.transmission > 0) {
      const { width: g, height: y } = e.context
      if (s.bufferWidth !== g || s.bufferHeight !== y)
        return ((s.bufferWidth = g), (s.bufferHeight = y), !1)
    }
    const a = s.geometry,
      l = r.attributes,
      c = a.attributes,
      u = Object.keys(c),
      d = Object.keys(l)
    if (a.id !== r.id) return ((a.id = r.id), !1)
    if (u.length !== d.length) return ((s.geometry.attributes = this.getAttributesData(l)), !1)
    for (const g of u) {
      const y = c[g],
        m = l[g]
      if (m === void 0) return (delete c[g], !1)
      if (y.version !== m.version) return ((y.version = m.version), !1)
    }
    const h = r.index,
      f = a.indexVersion,
      p = h ? h.version : null
    if (f !== p) return ((a.indexVersion = p), !1)
    if (a.drawRange.start !== r.drawRange.start || a.drawRange.count !== r.drawRange.count)
      return ((a.drawRange.start = r.drawRange.start), (a.drawRange.count = r.drawRange.count), !1)
    if (s.morphTargetInfluences) {
      let g = !1
      for (let y = 0; y < s.morphTargetInfluences.length; y++)
        s.morphTargetInfluences[y] !== t.morphTargetInfluences[y] && (g = !0)
      if (g) return !0
    }
    return s.center && s.center.equals(t.center) === !1
      ? (s.center.copy(t.center), !0)
      : (e.bundle !== null && (s.version = e.bundle.version), !0)
  }
  needsRefresh(e, t) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e)) return !0
    const { renderId: i } = t
    if (this.renderId !== i) return ((this.renderId = i), !0)
    const r = e.object.static === !0,
      s =
        e.bundle !== null &&
        e.bundle.static === !0 &&
        this.getRenderObjectData(e).version === e.bundle.version
    return r || s ? !1 : this.equals(e) !== !0
  }
}
function mh(n, e = 0) {
  let t = 3735928559 ^ e,
    i = 1103547991 ^ e
  if (n instanceof Array)
    for (let r = 0, s; r < n.length; r++)
      ((s = n[r]), (t = Math.imul(t ^ s, 2654435761)), (i = Math.imul(i ^ s, 1597334677)))
  else
    for (let r = 0, s; r < n.length; r++)
      ((s = n.charCodeAt(r)),
        (t = Math.imul(t ^ s, 2654435761)),
        (i = Math.imul(i ^ s, 1597334677)))
  return (
    (t = Math.imul(t ^ (t >>> 16), 2246822507)),
    (t ^= Math.imul(i ^ (i >>> 13), 3266489909)),
    (i = Math.imul(i ^ (i >>> 16), 2246822507)),
    (i ^= Math.imul(t ^ (t >>> 13), 3266489909)),
    4294967296 * (2097151 & i) + (t >>> 0)
  )
}
const JU = (n) => mh(n),
  lC = (n) => mh(n),
  cC = (...n) => mh(n)
function uC(n, e = !1) {
  const t = []
  n.isNode === !0 && (t.push(n.id), (n = n.getSelf()))
  for (const { property: i, childNode: r } of bm(n)) t.push(mh(i.slice(0, -4)), r.getCacheKey(e))
  return mh(t)
}
function* bm(n, e = !1) {
  for (const t in n) {
    if (t.startsWith('_') === !0) continue
    const i = n[t]
    if (Array.isArray(i) === !0)
      for (let r = 0; r < i.length; r++) {
        const s = i[r]
        s &&
          (s.isNode === !0 || (e && typeof s.toJSON == 'function')) &&
          (yield { property: t, index: r, childNode: s })
      }
    else if (i && i.isNode === !0) yield { property: t, childNode: i }
    else if (typeof i == 'object')
      for (const r in i) {
        const s = i[r]
        s &&
          (s.isNode === !0 || (e && typeof s.toJSON == 'function')) &&
          (yield { property: t, index: r, childNode: s })
      }
  }
}
const ek = new Map([
    [1, 'float'],
    [2, 'vec2'],
    [3, 'vec3'],
    [4, 'vec4'],
    [9, 'mat3'],
    [16, 'mat4'],
  ]),
  ob = new WeakMap()
function tk(n) {
  return ek.get(n)
}
function Tm(n) {
  if (/[iu]?vec\d/.test(n))
    return n.startsWith('ivec') ? Int32Array : n.startsWith('uvec') ? Uint32Array : Float32Array
  if (/mat\d/.test(n) || /float/.test(n)) return Float32Array
  if (/uint/.test(n)) return Uint32Array
  if (/int/.test(n)) return Int32Array
  throw new Error('THREE.NodeUtils: Unsupported type: '.concat(n))
}
function X_(n) {
  if (/float|int|uint/.test(n)) return 1
  if (/vec2/.test(n)) return 2
  if (/vec3/.test(n)) return 3
  if (/vec4/.test(n) || /mat2/.test(n)) return 4
  if (/mat3/.test(n)) return 9
  if (/mat4/.test(n)) return 16
  console.error('THREE.TSL: Unsupported type:', n)
}
function Ra(n) {
  if (n == null) return null
  const e = typeof n
  return n.isNode === !0
    ? 'node'
    : e === 'number'
      ? 'float'
      : e === 'boolean'
        ? 'bool'
        : e === 'string'
          ? 'string'
          : e === 'function'
            ? 'shader'
            : n.isVector2 === !0
              ? 'vec2'
              : n.isVector3 === !0
                ? 'vec3'
                : n.isVector4 === !0
                  ? 'vec4'
                  : n.isMatrix2 === !0
                    ? 'mat2'
                    : n.isMatrix3 === !0
                      ? 'mat3'
                      : n.isMatrix4 === !0
                        ? 'mat4'
                        : n.isColor === !0
                          ? 'color'
                          : n instanceof ArrayBuffer
                            ? 'ArrayBuffer'
                            : null
}
function dC(n, ...e) {
  const t = n ? n.slice(-4) : void 0
  return (
    e.length === 1 &&
      (t === 'vec2'
        ? (e = [e[0], e[0]])
        : t === 'vec3'
          ? (e = [e[0], e[0], e[0]])
          : t === 'vec4' && (e = [e[0], e[0], e[0], e[0]])),
    n === 'color'
      ? new gt(...e)
      : t === 'vec2'
        ? new je(...e)
        : t === 'vec3'
          ? new Y(...e)
          : t === 'vec4'
            ? new Mt(...e)
            : t === 'mat2'
              ? new D_(...e)
              : t === 'mat3'
                ? new pt(...e)
                : t === 'mat4'
                  ? new qe(...e)
                  : n === 'bool'
                    ? e[0] || !1
                    : n === 'float' || n === 'int' || n === 'uint'
                      ? e[0] || 0
                      : n === 'string'
                        ? e[0] || ''
                        : n === 'ArrayBuffer'
                          ? pC(e[0])
                          : null
  )
}
function hC(n) {
  let e = ob.get(n)
  return (e === void 0 && ((e = {}), ob.set(n, e)), e)
}
function fC(n) {
  let e = ''
  const t = new Uint8Array(n)
  for (let i = 0; i < t.length; i++) e += String.fromCharCode(t[i])
  return btoa(e)
}
function pC(n) {
  return Uint8Array.from(atob(n), (e) => e.charCodeAt(0)).buffer
}
const qy = { VERTEX: 'vertex', FRAGMENT: 'fragment' },
  Wt = { NONE: 'none', FRAME: 'frame', RENDER: 'render', OBJECT: 'object' },
  nk = {
    BOOLEAN: 'bool',
    INTEGER: 'int',
    FLOAT: 'float',
    VECTOR2: 'vec2',
    VECTOR3: 'vec3',
    VECTOR4: 'vec4',
    MATRIX2: 'mat2',
    MATRIX3: 'mat3',
    MATRIX4: 'mat4',
  },
  js = { READ_ONLY: 'readOnly', WRITE_ONLY: 'writeOnly', READ_WRITE: 'readWrite' },
  mC = ['fragment', 'vertex'],
  ik = ['setup', 'analyze', 'generate'],
  rk = [...mC, 'compute'],
  ku = ['x', 'y', 'z', 'w']
let sk = 0
class ut extends so {
  static get type() {
    return 'Node'
  }
  constructor(e = null) {
    ;(super(),
      (this.nodeType = e),
      (this.updateType = Wt.NONE),
      (this.updateBeforeType = Wt.NONE),
      (this.updateAfterType = Wt.NONE),
      (this.uuid = Ea.generateUUID()),
      (this.version = 0),
      (this.global = !1),
      (this.isNode = !0),
      (this._cacheKey = null),
      (this._cacheKeyVersion = 0),
      Object.defineProperty(this, 'id', { value: sk++ }))
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  get type() {
    return this.constructor.type
  }
  onUpdate(e, t) {
    return ((this.updateType = t), (this.update = e.bind(this.getSelf())), this)
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, Wt.FRAME)
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, Wt.RENDER)
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, Wt.OBJECT)
  }
  onReference(e) {
    return ((this.updateReference = e.bind(this.getSelf())), this)
  }
  getSelf() {
    return this.self || this
  }
  updateReference() {
    return this
  }
  isGlobal() {
    return this.global
  }
  *getChildren() {
    for (const { childNode: e } of bm(this)) yield e
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  traverse(e) {
    e(this)
    for (const t of this.getChildren()) t.traverse(e)
  }
  getCacheKey(e = !1) {
    return (
      (e = e || this.version !== this._cacheKeyVersion),
      (e === !0 || this._cacheKey === null) &&
        ((this._cacheKey = cC(uC(this, e), this.customCacheKey())),
        (this._cacheKeyVersion = this.version)),
      this._cacheKey
    )
  }
  customCacheKey() {
    return 0
  }
  getScope() {
    return this
  }
  getHash() {
    return this.uuid
  }
  getUpdateType() {
    return this.updateType
  }
  getUpdateBeforeType() {
    return this.updateBeforeType
  }
  getUpdateAfterType() {
    return this.updateAfterType
  }
  getElementType(e) {
    const t = this.getNodeType(e)
    return e.getElementType(t)
  }
  getMemberType() {
    return 'void'
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this)
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType
  }
  getShared(e) {
    const t = this.getHash(e)
    return e.getNodeFromHash(t) || this
  }
  setup(e) {
    const t = e.getNodeProperties(this)
    let i = 0
    for (const r of this.getChildren()) t['node' + i++] = r
    return t.outputNode || null
  }
  analyze(e) {
    if (e.increaseUsage(this) === 1) {
      const i = e.getNodeProperties(this)
      for (const r of Object.values(i)) r && r.isNode === !0 && r.build(e)
    }
  }
  generate(e, t) {
    const { outputNode: i } = e.getNodeProperties(this)
    if (i && i.isNode === !0) return i.build(e, t)
  }
  updateBefore() {
    console.warn('Abstract function.')
  }
  updateAfter() {
    console.warn('Abstract function.')
  }
  update() {
    console.warn('Abstract function.')
  }
  build(e, t = null) {
    const i = this.getShared(e)
    if (this !== i) return i.build(e, t)
    ;(e.addNode(this), e.addChain(this))
    let r = null
    const s = e.getBuildStage()
    if (s === 'setup') {
      this.updateReference(e)
      const o = e.getNodeProperties(this)
      if (o.initialized !== !0) {
        o.initialized = !0
        const a = this.setup(e),
          l = a && a.isNode === !0
        for (const c of Object.values(o)) c && c.isNode === !0 && c.build(e)
        ;(l && a.build(e), (o.outputNode = a))
      }
    } else if (s === 'analyze') this.analyze(e)
    else if (s === 'generate')
      if (this.generate.length === 1) {
        const a = this.getNodeType(e),
          l = e.getDataFromNode(this)
        ;((r = l.snippet),
          r === void 0
            ? ((r = this.generate(e) || ''), (l.snippet = r))
            : l.flowCodes !== void 0 &&
              e.context.nodeBlock !== void 0 &&
              e.addFlowCodeHierarchy(this, e.context.nodeBlock),
          (r = e.format(r, a, t)))
      } else r = this.generate(e, t) || ''
    return (e.removeChain(this), e.addSequentialNode(this), r)
  }
  getSerializeChildren() {
    return bm(this)
  }
  serialize(e) {
    const t = this.getSerializeChildren(),
      i = {}
    for (const { property: r, index: s, childNode: o } of t)
      s !== void 0
        ? (i[r] === void 0 && (i[r] = Number.isInteger(s) ? [] : {}),
          (i[r][s] = o.toJSON(e.meta).uuid))
        : (i[r] = o.toJSON(e.meta).uuid)
    Object.keys(i).length > 0 && (e.inputNodes = i)
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes
      for (const i in e.inputNodes)
        if (Array.isArray(e.inputNodes[i])) {
          const r = []
          for (const s of e.inputNodes[i]) r.push(t[s])
          this[i] = r
        } else if (typeof e.inputNodes[i] == 'object') {
          const r = {}
          for (const s in e.inputNodes[i]) {
            const o = e.inputNodes[i][s]
            r[s] = t[o]
          }
          this[i] = r
        } else {
          const r = e.inputNodes[i]
          this[i] = t[r]
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: i } = this,
      r = e === void 0 || typeof e == 'string'
    r && (e = { textures: {}, images: {}, nodes: {} })
    let s = e.nodes[t]
    s === void 0 &&
      ((s = {
        uuid: t,
        type: i,
        meta: e,
        metadata: { version: 4.6, type: 'Node', generator: 'Node.toJSON' },
      }),
      r !== !0 && (e.nodes[s.uuid] = s),
      this.serialize(s),
      delete s.meta)
    function o(a) {
      const l = []
      for (const c in a) {
        const u = a[c]
        ;(delete u.metadata, l.push(u))
      }
      return l
    }
    if (r) {
      const a = o(e.textures),
        l = o(e.images),
        c = o(e.nodes)
      ;(a.length > 0 && (s.textures = a),
        l.length > 0 && (s.images = l),
        c.length > 0 && (s.nodes = c))
    }
    return s
  }
}
class jl extends ut {
  static get type() {
    return 'ArrayElementNode'
  }
  constructor(e, t) {
    ;(super(), (this.node = e), (this.indexNode = t), (this.isArrayElementNode = !0))
  }
  getNodeType(e) {
    return this.node.getElementType(e)
  }
  generate(e) {
    const t = this.node.build(e),
      i = this.indexNode.build(e, 'uint')
    return ''.concat(t, '[ ').concat(i, ' ]')
  }
}
class gC extends ut {
  static get type() {
    return 'ConvertNode'
  }
  constructor(e, t) {
    ;(super(), (this.node = e), (this.convertTo = t))
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e)
    let i = null
    for (const r of this.convertTo.split('|'))
      (i === null || e.getTypeLength(t) === e.getTypeLength(r)) && (i = r)
    return i
  }
  serialize(e) {
    ;(super.serialize(e), (e.convertTo = this.convertTo))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.convertTo = e.convertTo))
  }
  generate(e, t) {
    const i = this.node,
      r = this.getNodeType(e),
      s = i.build(e, r)
    return e.format(s, r, t)
  }
}
class Un extends ut {
  static get type() {
    return 'TempNode'
  }
  constructor(e = null) {
    ;(super(e), (this.isTempNode = !0))
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1
  }
  build(e, t) {
    if (e.getBuildStage() === 'generate') {
      const r = e.getVectorType(this.getNodeType(e, t)),
        s = e.getDataFromNode(this)
      if (s.propertyName !== void 0) return e.format(s.propertyName, r, t)
      if (r !== 'void' && t !== 'void' && this.hasDependencies(e)) {
        const o = super.build(e, r),
          a = e.getVarFromNode(this, null, r),
          l = e.getPropertyName(a)
        return (
          e.addLineFlowCode(''.concat(l, ' = ').concat(o), this),
          (s.snippet = o),
          (s.propertyName = l),
          e.format(s.propertyName, r, t)
        )
      }
    }
    return super.build(e, t)
  }
}
class ok extends Un {
  static get type() {
    return 'JoinNode'
  }
  constructor(e = [], t = null) {
    ;(super(t), (this.nodes = e))
  }
  getNodeType(e) {
    return this.nodeType !== null
      ? e.getVectorType(this.nodeType)
      : e.getTypeFromLength(this.nodes.reduce((t, i) => t + e.getTypeLength(i.getNodeType(e)), 0))
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      r = this.nodes,
      s = e.getComponentType(i),
      o = []
    for (const l of r) {
      let c = l.build(e)
      const u = e.getComponentType(l.getNodeType(e))
      ;(u !== s && (c = e.format(c, u, s)), o.push(c))
    }
    const a = ''.concat(e.getType(i), '( ').concat(o.join(', '), ' )')
    return e.format(a, i, t)
  }
}
const ak = ku.join('')
class Xy extends ut {
  static get type() {
    return 'SplitNode'
  }
  constructor(e, t = 'x') {
    ;(super(), (this.node = e), (this.components = t), (this.isSplitNode = !0))
  }
  getVectorLength() {
    let e = this.components.length
    for (const t of this.components) e = Math.max(ku.indexOf(t) + 1, e)
    return e
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e))
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e))
  }
  generate(e, t) {
    const i = this.node,
      r = e.getTypeLength(i.getNodeType(e))
    let s = null
    if (r > 1) {
      let o = null
      this.getVectorLength() >= r &&
        (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)))
      const l = i.build(e, o)
      this.components.length === r && this.components === ak.slice(0, this.components.length)
        ? (s = e.format(l, o, t))
        : (s = e.format(''.concat(l, '.').concat(this.components), this.getNodeType(e), t))
    } else s = i.build(e, t)
    return s
  }
  serialize(e) {
    ;(super.serialize(e), (e.components = this.components))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.components = e.components))
  }
}
class lk extends Un {
  static get type() {
    return 'SetNode'
  }
  constructor(e, t, i) {
    ;(super(), (this.sourceNode = e), (this.components = t), (this.targetNode = i))
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e)
  }
  generate(e) {
    const { sourceNode: t, components: i, targetNode: r } = this,
      s = this.getNodeType(e),
      o = e.getComponentType(r.getNodeType(e)),
      a = e.getTypeFromLength(i.length, o),
      l = r.build(e, a),
      c = t.build(e, s),
      u = e.getTypeLength(s),
      d = []
    for (let h = 0; h < u; h++) {
      const f = ku[h]
      f === i[0] ? (d.push(l), (h += i.length - 1)) : d.push(c + '.' + f)
    }
    return ''.concat(e.getType(s), '( ').concat(d.join(', '), ' )')
  }
}
class ck extends Un {
  static get type() {
    return 'FlipNode'
  }
  constructor(e, t) {
    ;(super(), (this.sourceNode = e), (this.components = t))
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e)
  }
  generate(e) {
    const { components: t, sourceNode: i } = this,
      r = this.getNodeType(e),
      s = i.build(e),
      o = e.getVarFromNode(this),
      a = e.getPropertyName(o)
    e.addLineFlowCode(a + ' = ' + s, this)
    const l = e.getTypeLength(r),
      c = []
    let u = 0
    for (let d = 0; d < l; d++) {
      const h = ku[d]
      h === t[u] ? (c.push('1.0 - ' + (a + '.' + h)), u++) : c.push(a + '.' + h)
    }
    return ''.concat(e.getType(r), '( ').concat(c.join(', '), ' )')
  }
}
class K_ extends ut {
  static get type() {
    return 'InputNode'
  }
  constructor(e, t = null) {
    ;(super(t), (this.isInputNode = !0), (this.value = e), (this.precision = null))
  }
  getNodeType() {
    return this.nodeType === null ? Ra(this.value) : this.nodeType
  }
  getInputType(e) {
    return this.getNodeType(e)
  }
  setPrecision(e) {
    return ((this.precision = e), this)
  }
  serialize(e) {
    ;(super.serialize(e),
      (e.value = this.value),
      this.value && this.value.toArray && (e.value = this.value.toArray()),
      (e.valueType = Ra(this.value)),
      (e.nodeType = this.nodeType),
      e.valueType === 'ArrayBuffer' && (e.value = fC(e.value)),
      (e.precision = this.precision))
  }
  deserialize(e) {
    ;(super.deserialize(e),
      (this.nodeType = e.nodeType),
      (this.value = Array.isArray(e.value) ? dC(e.valueType, ...e.value) : e.value),
      (this.precision = e.precision || null),
      this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value)))
  }
  generate() {
    console.warn('Abstract function.')
  }
}
const ab = /float|u?int/
class Es extends K_ {
  static get type() {
    return 'ConstNode'
  }
  constructor(e, t = null) {
    ;(super(e, t), (this.isConstNode = !0))
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value)
  }
  generate(e, t) {
    const i = this.getNodeType(e)
    return ab.test(i) && ab.test(t)
      ? e.generateConst(t, this.value)
      : e.format(this.generateConst(e), i, t)
  }
}
class uk extends ut {
  static get type() {
    return 'MemberNode'
  }
  constructor(e, t) {
    ;(super(), (this.node = e), (this.property = t), (this.isMemberNode = !0))
  }
  getNodeType(e) {
    return this.node.getMemberType(e, this.property)
  }
  generate(e) {
    return this.node.build(e) + '.' + this.property
  }
}
let xu = null
const Oc = new Map()
function Ne(n, e) {
  if (Oc.has(n)) {
    console.warn('Redefinition of method chaining '.concat(n))
    return
  }
  if (typeof e != 'function') throw new Error('Node element '.concat(n, ' is not a function'))
  Oc.set(n, e)
}
const yC = (n) =>
    n.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w'),
  lb = (n) => yC(n).split('').sort().join(''),
  vC = {
    setup(n, e) {
      const t = e.shift()
      return n(zh(t), ...e)
    },
    get(n, e, t) {
      if (typeof e == 'string' && n[e] === void 0) {
        if (n.isStackNode !== !0 && e === 'assign') return (...i) => (xu.assign(t, ...i), t)
        if (Oc.has(e)) {
          const i = Oc.get(e)
          return n.isStackNode ? (...r) => t.add(i(...r)) : (...r) => i(t, ...r)
        } else {
          if (e === 'self') return n
          if (e.endsWith('Assign') && Oc.has(e.slice(0, e.length - 6))) {
            const i = Oc.get(e.slice(0, e.length - 6))
            return n.isStackNode
              ? (...r) => t.assign(r[0], i(...r))
              : (...r) => t.assign(i(t, ...r))
          } else {
            if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0) return ((e = yC(e)), Fe(new Xy(t, e)))
            if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
              return ((e = lb(e.slice(3).toLowerCase())), (i) => Fe(new lk(n, e, i)))
            if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
              return ((e = lb(e.slice(4).toLowerCase())), () => Fe(new ck(Fe(n), e)))
            if (e === 'width' || e === 'height' || e === 'depth')
              return (
                e === 'width' ? (e = 'x') : e === 'height' ? (e = 'y') : e === 'depth' && (e = 'z'),
                Fe(new Xy(n, e))
              )
            if (/^\d+$/.test(e) === !0) return Fe(new jl(t, new Es(Number(e), 'uint')))
            if (/^get$/.test(e) === !0) return (i) => Fe(new uk(t, i))
          }
        }
      }
      return Reflect.get(n, e, t)
    },
    set(n, e, t, i) {
      return typeof e == 'string' &&
        n[e] === void 0 &&
        (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 ||
          e === 'width' ||
          e === 'height' ||
          e === 'depth' ||
          /^\d+$/.test(e) === !0)
        ? (i[e].assign(t), !0)
        : Reflect.set(n, e, t, i)
    },
  },
  Jg = new WeakMap(),
  cb = new WeakMap(),
  dk = function (n, e = null) {
    const t = Ra(n)
    if (t === 'node') {
      let i = Jg.get(n)
      return (i === void 0 && ((i = new Proxy(n, vC)), Jg.set(n, i), Jg.set(i, i)), i)
    } else {
      if (
        (e === null && (t === 'float' || t === 'boolean')) ||
        (t && t !== 'shader' && t !== 'string')
      )
        return Fe(Ky(n, e))
      if (t === 'shader') return _e(n)
    }
    return n
  },
  hk = function (n, e = null) {
    for (const t in n) n[t] = Fe(n[t], e)
    return n
  },
  fk = function (n, e = null) {
    const t = n.length
    for (let i = 0; i < t; i++) n[i] = Fe(n[i], e)
    return n
  },
  pk = function (n, e = null, t = null, i = null) {
    const r = (s) => Fe(i !== null ? Object.assign(s, i) : s)
    return e === null
      ? (...s) => r(new n(...Pl(s)))
      : t !== null
        ? ((t = Fe(t)), (...s) => r(new n(e, ...Pl(s), t)))
        : (...s) => r(new n(e, ...Pl(s)))
  },
  mk = function (n, ...e) {
    return Fe(new n(...Pl(e)))
  }
class gk extends ut {
  constructor(e, t) {
    ;(super(), (this.shaderNode = e), (this.inputNodes = t))
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e)
  }
  getMemberType(e, t) {
    return this.getOutputNode(e).getMemberType(e, t)
  }
  call(e) {
    const { shaderNode: t, inputNodes: i } = this,
      r = e.getNodeProperties(t)
    if (r.onceOutput) return r.onceOutput
    let s = null
    if (t.layout) {
      let o = cb.get(e.constructor)
      o === void 0 && ((o = new WeakMap()), cb.set(e.constructor, o))
      let a = o.get(t)
      ;(a === void 0 && ((a = Fe(e.buildFunctionNode(t))), o.set(t, a)),
        e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(a),
        (s = Fe(a.call(i))))
    } else {
      const o = t.jsFunc,
        a = i !== null || o.length > 1 ? o(i || [], e) : o(e)
      s = Fe(a)
    }
    return (t.once && (r.onceOutput = s), s)
  }
  getOutputNode(e) {
    const t = e.getNodeProperties(this)
    return (t.outputNode === null && (t.outputNode = this.setupOutput(e)), t.outputNode)
  }
  setup(e) {
    return this.getOutputNode(e)
  }
  setupOutput(e) {
    return (e.addStack(), (e.stack.outputNode = this.call(e)), e.removeStack())
  }
  generate(e, t) {
    return this.getOutputNode(e).build(e, t)
  }
}
class yk extends ut {
  constructor(e, t) {
    ;(super(t), (this.jsFunc = e), (this.layout = null), (this.global = !0), (this.once = !1))
  }
  setLayout(e) {
    return ((this.layout = e), this)
  }
  call(e = null) {
    return (zh(e), Fe(new gk(this, e)))
  }
  setup() {
    return this.call()
  }
}
const vk = [!1, !0],
  _k = [0, 1, 2, 3],
  xk = [-1, -2],
  _C = [
    0.5,
    1.5,
    1 / 3,
    1e-6,
    1e6,
    Math.PI,
    Math.PI * 2,
    1 / Math.PI,
    2 / Math.PI,
    1 / (Math.PI * 2),
    Math.PI / 2,
  ],
  Y_ = new Map()
for (const n of vk) Y_.set(n, new Es(n))
const Z_ = new Map()
for (const n of _k) Z_.set(n, new Es(n, 'uint'))
const J_ = new Map([...Z_].map((n) => new Es(n.value, 'int')))
for (const n of xk) J_.set(n, new Es(n, 'int'))
const h0 = new Map([...J_].map((n) => new Es(n.value)))
for (const n of _C) h0.set(n, new Es(n))
for (const n of _C) h0.set(-n, new Es(-n))
const f0 = { bool: Y_, uint: Z_, ints: J_, float: h0 },
  ub = new Map([...Y_, ...h0]),
  Ky = (n, e) => (ub.has(n) ? ub.get(n) : n.isNode === !0 ? n : new Es(n, e)),
  Sk = (n) => {
    try {
      return n.getNodeType()
    } catch (e) {
      return
    }
  },
  Qn = function (n, e = null) {
    return (...t) => {
      if (
        ((t.length === 0 ||
          (!['bool', 'float', 'int', 'uint'].includes(n) &&
            t.every((r) => typeof r != 'object'))) &&
          (t = [dC(n, ...t)]),
        t.length === 1 && e !== null && e.has(t[0]))
      )
        return Fe(e.get(t[0]))
      if (t.length === 1) {
        const r = Ky(t[0], n)
        return Sk(r) === n ? Fe(r) : Fe(new gC(r, n))
      }
      const i = t.map((r) => Ky(r))
      return Fe(new ok(i, n))
    }
  },
  gh = (n) => (typeof n == 'object' && n !== null ? n.value : n),
  xC = (n) => (n != null ? n.nodeType || n.convertTo || (typeof n == 'string' ? n : null) : null)
function Gd(n, e) {
  return new Proxy(new yk(n, e), vC)
}
const Fe = (n, e = null) => dk(n, e),
  zh = (n, e = null) => new hk(n, e),
  Pl = (n, e = null) => new fk(n, e),
  Pe = (...n) => new pk(...n),
  We = (...n) => new mk(...n),
  _e = (n, e) => {
    const t = new Gd(n, e),
      i = (...r) => {
        let s
        return (zh(r), r[0] && r[0].isNode ? (s = [...r]) : (s = r[0]), t.call(s))
      }
    return (
      (i.shaderNode = t),
      (i.setLayout = (r) => (t.setLayout(r), i)),
      (i.once = () => ((t.once = !0), i)),
      i
    )
  },
  Ak = (...n) => (console.warn('TSL.ShaderNode: tslFn() has been renamed to Fn().'), _e(...n))
Ne('toGlobal', (n) => ((n.global = !0), n))
const Yy = (n) => {
    xu = n
  },
  SC = () => xu,
  Dt = (...n) => xu.If(...n)
function AC(n) {
  return (xu && xu.add(n), n)
}
Ne('append', AC)
const bC = new Qn('color'),
  ce = new Qn('float', f0.float),
  de = new Qn('int', f0.ints),
  Ye = new Qn('uint', f0.uint),
  Yo = new Qn('bool', f0.bool),
  He = new Qn('vec2'),
  Xn = new Qn('ivec2'),
  TC = new Qn('uvec2'),
  wC = new Qn('bvec2'),
  ve = new Qn('vec3'),
  CC = new Qn('ivec3'),
  zu = new Qn('uvec3'),
  ex = new Qn('bvec3'),
  yt = new Qn('vec4'),
  EC = new Qn('ivec4'),
  MC = new Qn('uvec4'),
  RC = new Qn('bvec4'),
  p0 = new Qn('mat2'),
  is = new Qn('mat3'),
  Ll = new Qn('mat4'),
  bk = (n = '') => Fe(new Es(n, 'string')),
  Tk = (n) => Fe(new Es(n, 'ArrayBuffer'))
Ne('toColor', bC)
Ne('toFloat', ce)
Ne('toInt', de)
Ne('toUint', Ye)
Ne('toBool', Yo)
Ne('toVec2', He)
Ne('toIVec2', Xn)
Ne('toUVec2', TC)
Ne('toBVec2', wC)
Ne('toVec3', ve)
Ne('toIVec3', CC)
Ne('toUVec3', zu)
Ne('toBVec3', ex)
Ne('toVec4', yt)
Ne('toIVec4', EC)
Ne('toUVec4', MC)
Ne('toBVec4', RC)
Ne('toMat2', p0)
Ne('toMat3', is)
Ne('toMat4', Ll)
const IC = Pe(jl),
  NC = (n, e) => Fe(new gC(Fe(n), e)),
  wk = (n, e) => Fe(new Xy(Fe(n), e))
Ne('element', IC)
Ne('convert', NC)
class db extends Un {
  static get type() {
    return 'ArrayNode'
  }
  constructor(e, t, i = null) {
    ;(super(e), (this.count = t), (this.values = i), (this.isArrayNode = !0))
  }
  getNodeType(e) {
    return (
      this.nodeType === null && (this.nodeType = this.values[0].getNodeType(e)),
      this.nodeType
    )
  }
  getElementType(e) {
    return this.getNodeType(e)
  }
  generate(e) {
    const t = this.getNodeType(e)
    return e.generateArray(t, this.count, this.values)
  }
}
const PC = (...n) => {
  let e
  if (n.length === 1) {
    const t = n[0]
    e = new db(null, t.length, t)
  } else {
    const t = n[0],
      i = n[1]
    e = new db(t, i)
  }
  return Fe(e)
}
Ne('toArray', (n, e) => PC(Array(e).fill(n)))
class LC extends ut {
  static get type() {
    return 'UniformGroupNode'
  }
  constructor(e, t = !1, i = 1) {
    ;(super('string'),
      (this.name = e),
      (this.shared = t),
      (this.order = i),
      (this.isUniformGroup = !0))
  }
  serialize(e) {
    ;(super.serialize(e),
      (e.name = this.name),
      (e.version = this.version),
      (e.shared = this.shared))
  }
  deserialize(e) {
    ;(super.deserialize(e),
      (this.name = e.name),
      (this.version = e.version),
      (this.shared = e.shared))
  }
}
const DC = (n) => new LC(n),
  m0 = (n, e = 0) => new LC(n, !0, e),
  Ck = m0('frame'),
  Ut = m0('render'),
  FC = DC('object')
class Vh extends K_ {
  static get type() {
    return 'UniformNode'
  }
  constructor(e, t = null) {
    ;(super(e, t), (this.isUniformNode = !0), (this.name = ''), (this.groupNode = FC))
  }
  label(e) {
    return ((this.name = e), this)
  }
  setGroup(e) {
    return ((this.groupNode = e), this)
  }
  getGroup() {
    return this.groupNode
  }
  getUniformHash(e) {
    return this.getHash(e)
  }
  onUpdate(e, t) {
    const i = this.getSelf()
    return (
      (e = e.bind(i)),
      super.onUpdate((r) => {
        const s = e(r, i)
        s !== void 0 && (this.value = s)
      }, t)
    )
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      r = this.getUniformHash(e)
    let s = e.getNodeFromHash(r)
    s === void 0 && (e.setHashNode(this, r), (s = this))
    const o = s.getInputType(e),
      a = e.getUniformFromNode(s, o, e.shaderStage, this.name || e.context.label),
      l = e.getPropertyName(a)
    return (e.context.label !== void 0 && delete e.context.label, e.format(l, i, t))
  }
}
const Rt = (n, e) => {
  const t = xC(e || n),
    i = n && n.isNode === !0 ? (n.node && n.node.value) || n.value : n
  return Fe(new Vh(i, t))
}
class Xt extends ut {
  static get type() {
    return 'PropertyNode'
  }
  constructor(e, t = null, i = !1) {
    ;(super(e), (this.name = t), (this.varying = i), (this.isPropertyNode = !0))
  }
  getHash(e) {
    return this.name || super.getHash(e)
  }
  isGlobal() {
    return !0
  }
  generate(e) {
    let t
    return (
      this.varying === !0
        ? ((t = e.getVaryingFromNode(this, this.name)), (t.needsInterpolation = !0))
        : (t = e.getVarFromNode(this, this.name)),
      e.getPropertyName(t)
    )
  }
}
const OC = (n, e) => Fe(new Xt(n, e)),
  yh = (n, e) => Fe(new Xt(n, e, !0)),
  hs = We(Xt, 'vec4', 'DiffuseColor'),
  Zy = We(Xt, 'vec3', 'EmissiveColor'),
  BC = We(Xt, 'float', 'Roughness'),
  Ek = We(Xt, 'float', 'Metalness'),
  Mk = We(Xt, 'float', 'Clearcoat'),
  Rk = We(Xt, 'float', 'ClearcoatRoughness'),
  Ik = We(Xt, 'vec3', 'Sheen'),
  Nk = We(Xt, 'float', 'SheenRoughness'),
  UC = We(Xt, 'float', 'Iridescence'),
  Pk = We(Xt, 'float', 'IridescenceIOR'),
  Lk = We(Xt, 'float', 'IridescenceThickness'),
  Jy = We(Xt, 'float', 'AlphaT'),
  kC = We(Xt, 'float', 'Anisotropy'),
  Dp = We(Xt, 'vec3', 'AnisotropyT'),
  qc = We(Xt, 'vec3', 'AnisotropyB'),
  Dk = We(Xt, 'color', 'SpecularColor'),
  Fk = We(Xt, 'float', 'SpecularF90'),
  Ok = We(Xt, 'float', 'Shininess'),
  vh = We(Xt, 'vec4', 'Output'),
  Bk = We(Xt, 'float', 'dashSize'),
  Uk = We(Xt, 'float', 'gapSize'),
  kk = We(Xt, 'float', 'pointWidth'),
  zk = We(Xt, 'float', 'IOR'),
  Vk = We(Xt, 'float', 'Transmission'),
  Hk = We(Xt, 'float', 'Thickness'),
  $k = We(Xt, 'float', 'AttenuationDistance'),
  Gk = We(Xt, 'color', 'AttenuationColor'),
  Wk = We(Xt, 'float', 'Dispersion')
class Qk extends Un {
  static get type() {
    return 'AssignNode'
  }
  constructor(e, t) {
    ;(super(), (this.targetNode = e), (this.sourceNode = t))
  }
  hasDependencies() {
    return !1
  }
  getNodeType(e, t) {
    return t !== 'void' ? this.targetNode.getNodeType(e) : 'void'
  }
  needsSplitAssign(e) {
    const { targetNode: t } = this
    if (e.isAvailable('swizzleAssign') === !1 && t.isSplitNode && t.components.length > 1) {
      const i = e.getTypeLength(t.node.getNodeType(e))
      return ku.join('').slice(0, i) !== t.components
    }
    return !1
  }
  generate(e, t) {
    const { targetNode: i, sourceNode: r } = this,
      s = this.needsSplitAssign(e),
      o = i.getNodeType(e),
      a = i.context({ assign: !0 }).build(e),
      l = r.build(e, o),
      c = r.getNodeType(e),
      u = e.getDataFromNode(this)
    let d
    if (u.initialized === !0) t !== 'void' && (d = a)
    else if (s) {
      const h = e.getVarFromNode(this, null, o),
        f = e.getPropertyName(h)
      e.addLineFlowCode(''.concat(f, ' = ').concat(l), this)
      const p = i.node.context({ assign: !0 }).build(e)
      for (let g = 0; g < i.components.length; g++) {
        const y = i.components[g]
        e.addLineFlowCode(''.concat(p, '.').concat(y, ' = ').concat(f, '[ ').concat(g, ' ]'), this)
      }
      t !== 'void' && (d = a)
    } else
      ((d = ''.concat(a, ' = ').concat(l)),
        (t === 'void' || c === 'void') && (e.addLineFlowCode(d, this), t !== 'void' && (d = a)))
    return ((u.initialized = !0), e.format(d, o, t))
  }
}
const zC = Pe(Qk)
Ne('assign', zC)
class jk extends Un {
  static get type() {
    return 'FunctionCallNode'
  }
  constructor(e = null, t = {}) {
    ;(super(), (this.functionNode = e), (this.parameters = t))
  }
  setParameters(e) {
    return ((this.parameters = e), this)
  }
  getParameters() {
    return this.parameters
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e)
  }
  generate(e) {
    const t = [],
      i = this.functionNode,
      r = i.getInputs(e),
      s = this.parameters,
      o = (l, c) => {
        const u = c.type,
          d = u === 'pointer'
        let h
        return (d ? (h = '&' + l.build(e)) : (h = l.build(e, u)), h)
      }
    if (Array.isArray(s)) for (let l = 0; l < s.length; l++) t.push(o(s[l], r[l]))
    else
      for (const l of r) {
        const c = s[l.name]
        if (c !== void 0) t.push(o(c, l))
        else
          throw new Error(
            "FunctionCallNode: Input '".concat(l.name, "' not found in FunctionNode.")
          )
      }
    const a = i.build(e, 'property')
    return ''.concat(a, '( ').concat(t.join(', '), ' )')
  }
}
const VC = (n, ...e) => (
  (e = e.length > 1 || (e[0] && e[0].isNode === !0) ? Pl(e) : zh(e[0])),
  Fe(new jk(Fe(n), e))
)
Ne('call', VC)
class Tn extends Un {
  static get type() {
    return 'OperatorNode'
  }
  constructor(e, t, i, ...r) {
    if ((super(), r.length > 0)) {
      let s = new Tn(e, t, i)
      for (let o = 0; o < r.length - 1; o++) s = new Tn(e, s, r[o])
      ;((t = s), (i = r[r.length - 1]))
    }
    ;((this.op = e), (this.aNode = t), (this.bNode = i), (this.isOperatorNode = !0))
  }
  getNodeType(e, t) {
    const i = this.op,
      r = this.aNode,
      s = this.bNode,
      o = r.getNodeType(e),
      a = typeof s < 'u' ? s.getNodeType(e) : null
    if (o === 'void' || a === 'void') return 'void'
    if (i === '%') return o
    if (i === '~' || i === '&' || i === '|' || i === '^' || i === '>>' || i === '<<')
      return e.getIntegerType(o)
    if (i === '!' || i === '==' || i === '&&' || i === '||' || i === '^^') return 'bool'
    if (i === '<' || i === '>' || i === '<=' || i === '>=') {
      const l = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(o), e.getTypeLength(a))
      return l > 1 ? 'bvec'.concat(l) : 'bool'
    } else {
      if (e.isMatrix(o)) {
        if (a === 'float') return o
        if (e.isVector(a)) return e.getVectorFromMatrix(o)
        if (e.isMatrix(a)) return o
      } else if (e.isMatrix(a)) {
        if (o === 'float') return a
        if (e.isVector(o)) return e.getVectorFromMatrix(a)
      }
      return e.getTypeLength(a) > e.getTypeLength(o) ? a : o
    }
  }
  generate(e, t) {
    const i = this.op,
      r = this.aNode,
      s = this.bNode,
      o = this.getNodeType(e, t)
    let a = null,
      l = null
    o !== 'void'
      ? ((a = r.getNodeType(e)),
        (l = typeof s < 'u' ? s.getNodeType(e) : null),
        i === '<' || i === '>' || i === '<=' || i === '>=' || i === '=='
          ? e.isVector(a)
            ? (l = a)
            : a !== l && (a = l = 'float')
          : i === '>>' || i === '<<'
            ? ((a = o), (l = e.changeComponentType(l, 'uint')))
            : e.isMatrix(a)
              ? l === 'float'
                ? (l = 'float')
                : e.isVector(l)
                  ? (l = e.getVectorFromMatrix(a))
                  : e.isMatrix(l) || (a = l = o)
              : e.isMatrix(l)
                ? a === 'float'
                  ? (a = 'float')
                  : e.isVector(a)
                    ? (a = e.getVectorFromMatrix(l))
                    : (a = l = o)
                : (a = l = o))
      : (a = l = o)
    const c = r.build(e, a),
      u = typeof s < 'u' ? s.build(e, l) : null,
      d = e.getTypeLength(t),
      h = e.getFunctionOperator(i)
    if (t !== 'void')
      return i === '<' && d > 1
        ? e.useComparisonMethod
          ? e.format(
              ''.concat(e.getMethod('lessThan', t), '( ').concat(c, ', ').concat(u, ' )'),
              o,
              t
            )
          : e.format('( '.concat(c, ' < ').concat(u, ' )'), o, t)
        : i === '<=' && d > 1
          ? e.useComparisonMethod
            ? e.format(
                ''.concat(e.getMethod('lessThanEqual', t), '( ').concat(c, ', ').concat(u, ' )'),
                o,
                t
              )
            : e.format('( '.concat(c, ' <= ').concat(u, ' )'), o, t)
          : i === '>' && d > 1
            ? e.useComparisonMethod
              ? e.format(
                  ''.concat(e.getMethod('greaterThan', t), '( ').concat(c, ', ').concat(u, ' )'),
                  o,
                  t
                )
              : e.format('( '.concat(c, ' > ').concat(u, ' )'), o, t)
            : i === '>=' && d > 1
              ? e.useComparisonMethod
                ? e.format(
                    ''
                      .concat(e.getMethod('greaterThanEqual', t), '( ')
                      .concat(c, ', ')
                      .concat(u, ' )'),
                    o,
                    t
                  )
                : e.format('( '.concat(c, ' >= ').concat(u, ' )'), o, t)
              : i === '!' || i === '~'
                ? e.format('('.concat(i).concat(c, ')'), a, t)
                : h
                  ? e.format(''.concat(h, '( ').concat(c, ', ').concat(u, ' )'), o, t)
                  : e.isMatrix(a) && l === 'float'
                    ? e.format('( '.concat(u, ' ').concat(i, ' ').concat(c, ' )'), o, t)
                    : a === 'float' && e.isMatrix(l)
                      ? e.format(''.concat(c, ' ').concat(i, ' ').concat(u), o, t)
                      : e.format('( '.concat(c, ' ').concat(i, ' ').concat(u, ' )'), o, t)
    if (a !== 'void')
      return h
        ? e.format(''.concat(h, '( ').concat(c, ', ').concat(u, ' )'), o, t)
        : e.isMatrix(a) && l === 'float'
          ? e.format(''.concat(u, ' ').concat(i, ' ').concat(c), o, t)
          : e.format(''.concat(c, ' ').concat(i, ' ').concat(u), o, t)
  }
  serialize(e) {
    ;(super.serialize(e), (e.op = this.op))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.op = e.op))
  }
}
const On = Pe(Tn, '+'),
  Bt = Pe(Tn, '-'),
  xt = Pe(Tn, '*'),
  Zo = Pe(Tn, '/'),
  tx = Pe(Tn, '%'),
  HC = Pe(Tn, '=='),
  $C = Pe(Tn, '!='),
  GC = Pe(Tn, '<'),
  nx = Pe(Tn, '>'),
  WC = Pe(Tn, '<='),
  QC = Pe(Tn, '>='),
  jC = Pe(Tn, '&&'),
  qC = Pe(Tn, '||'),
  XC = Pe(Tn, '!'),
  KC = Pe(Tn, '^^'),
  YC = Pe(Tn, '&'),
  ZC = Pe(Tn, '~'),
  JC = Pe(Tn, '|'),
  eE = Pe(Tn, '^'),
  tE = Pe(Tn, '<<'),
  nE = Pe(Tn, '>>')
Ne('add', On)
Ne('sub', Bt)
Ne('mul', xt)
Ne('div', Zo)
Ne('modInt', tx)
Ne('equal', HC)
Ne('notEqual', $C)
Ne('lessThan', GC)
Ne('greaterThan', nx)
Ne('lessThanEqual', WC)
Ne('greaterThanEqual', QC)
Ne('and', jC)
Ne('or', qC)
Ne('not', XC)
Ne('xor', KC)
Ne('bitAnd', YC)
Ne('bitNot', ZC)
Ne('bitOr', JC)
Ne('bitXor', eE)
Ne('shiftLeft', tE)
Ne('shiftRight', nE)
const iE = (...n) => (
  console.warn('TSL.OperatorNode: .remainder() has been renamed to .modInt().'),
  tx(...n)
)
Ne('remainder', iE)
class me extends Un {
  static get type() {
    return 'MathNode'
  }
  constructor(e, t, i = null, r = null) {
    ;(super(),
      (this.method = e),
      (this.aNode = t),
      (this.bNode = i),
      (this.cNode = r),
      (this.isMathNode = !0))
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e),
      i = this.bNode ? this.bNode.getNodeType(e) : null,
      r = this.cNode ? this.cNode.getNodeType(e) : null,
      s = e.isMatrix(t) ? 0 : e.getTypeLength(t),
      o = e.isMatrix(i) ? 0 : e.getTypeLength(i),
      a = e.isMatrix(r) ? 0 : e.getTypeLength(r)
    return s > o && s > a ? t : o > a ? i : a > s ? r : t
  }
  getNodeType(e) {
    const t = this.method
    return t === me.LENGTH || t === me.DISTANCE || t === me.DOT
      ? 'float'
      : t === me.CROSS
        ? 'vec3'
        : t === me.ALL
          ? 'bool'
          : t === me.EQUALS
            ? e.changeComponentType(this.aNode.getNodeType(e), 'bool')
            : t === me.MOD
              ? this.aNode.getNodeType(e)
              : this.getInputType(e)
  }
  generate(e, t) {
    let i = this.method
    const r = this.getNodeType(e),
      s = this.getInputType(e),
      o = this.aNode,
      a = this.bNode,
      l = this.cNode,
      c = e.renderer.coordinateSystem
    if (i === me.TRANSFORM_DIRECTION) {
      let u = o,
        d = a
      e.isMatrix(u.getNodeType(e)) ? (d = yt(ve(d), 0)) : (u = yt(ve(u), 0))
      const h = xt(u, d).xyz
      return ql(h).build(e, t)
    } else {
      if (i === me.NEGATE) return e.format('( - ' + o.build(e, s) + ' )', r, t)
      if (i === me.ONE_MINUS) return Bt(1, o).build(e, t)
      if (i === me.RECIPROCAL) return Zo(1, o).build(e, t)
      if (i === me.DIFFERENCE) return mn(Bt(o, a)).build(e, t)
      {
        const u = []
        return (
          i === me.CROSS || i === me.MOD
            ? u.push(o.build(e, r), a.build(e, r))
            : c === Ir && i === me.STEP
              ? u.push(
                  o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? 'float' : s),
                  a.build(e, s)
                )
              : (c === Ir && (i === me.MIN || i === me.MAX)) || i === me.MOD
                ? u.push(
                    o.build(e, s),
                    a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? 'float' : s)
                  )
                : i === me.REFRACT
                  ? u.push(o.build(e, s), a.build(e, s), l.build(e, 'float'))
                  : i === me.MIX
                    ? u.push(
                        o.build(e, s),
                        a.build(e, s),
                        l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? 'float' : s)
                      )
                    : (c === Xo && i === me.ATAN && a !== null && (i = 'atan2'),
                      u.push(o.build(e, s)),
                      a !== null && u.push(a.build(e, s)),
                      l !== null && u.push(l.build(e, s))),
          e.format(''.concat(e.getMethod(i, r), '( ').concat(u.join(', '), ' )'), r, t)
        )
      }
    }
  }
  serialize(e) {
    ;(super.serialize(e), (e.method = this.method))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.method = e.method))
  }
}
me.ALL = 'all'
me.ANY = 'any'
me.RADIANS = 'radians'
me.DEGREES = 'degrees'
me.EXP = 'exp'
me.EXP2 = 'exp2'
me.LOG = 'log'
me.LOG2 = 'log2'
me.SQRT = 'sqrt'
me.INVERSE_SQRT = 'inversesqrt'
me.FLOOR = 'floor'
me.CEIL = 'ceil'
me.NORMALIZE = 'normalize'
me.FRACT = 'fract'
me.SIN = 'sin'
me.COS = 'cos'
me.TAN = 'tan'
me.ASIN = 'asin'
me.ACOS = 'acos'
me.ATAN = 'atan'
me.ABS = 'abs'
me.SIGN = 'sign'
me.LENGTH = 'length'
me.NEGATE = 'negate'
me.ONE_MINUS = 'oneMinus'
me.DFDX = 'dFdx'
me.DFDY = 'dFdy'
me.ROUND = 'round'
me.RECIPROCAL = 'reciprocal'
me.TRUNC = 'trunc'
me.FWIDTH = 'fwidth'
me.TRANSPOSE = 'transpose'
me.BITCAST = 'bitcast'
me.EQUALS = 'equals'
me.MIN = 'min'
me.MAX = 'max'
me.MOD = 'mod'
me.STEP = 'step'
me.REFLECT = 'reflect'
me.DISTANCE = 'distance'
me.DIFFERENCE = 'difference'
me.DOT = 'dot'
me.CROSS = 'cross'
me.POW = 'pow'
me.TRANSFORM_DIRECTION = 'transformDirection'
me.MIX = 'mix'
me.CLAMP = 'clamp'
me.REFRACT = 'refract'
me.SMOOTHSTEP = 'smoothstep'
me.FACEFORWARD = 'faceforward'
const rE = ce(1e-6),
  qk = ce(1e6),
  wm = ce(Math.PI),
  Xk = ce(Math.PI * 2),
  ix = Pe(me, me.ALL),
  sE = Pe(me, me.ANY),
  oE = Pe(me, me.RADIANS),
  aE = Pe(me, me.DEGREES),
  lE = Pe(me, me.EXP),
  Su = Pe(me, me.EXP2),
  rx = Pe(me, me.LOG),
  Ho = Pe(me, me.LOG2),
  co = Pe(me, me.SQRT),
  sx = Pe(me, me.INVERSE_SQRT),
  Xs = Pe(me, me.FLOOR),
  g0 = Pe(me, me.CEIL),
  ql = Pe(me, me.NORMALIZE),
  sa = Pe(me, me.FRACT),
  Tr = Pe(me, me.SIN),
  Ro = Pe(me, me.COS),
  cE = Pe(me, me.TAN),
  uE = Pe(me, me.ASIN),
  dE = Pe(me, me.ACOS),
  ox = Pe(me, me.ATAN),
  mn = Pe(me, me.ABS),
  ax = Pe(me, me.SIGN),
  Cm = Pe(me, me.LENGTH),
  hE = Pe(me, me.NEGATE),
  fE = Pe(me, me.ONE_MINUS),
  lx = Pe(me, me.DFDX),
  cx = Pe(me, me.DFDY),
  pE = Pe(me, me.ROUND),
  mE = Pe(me, me.RECIPROCAL),
  ux = Pe(me, me.TRUNC),
  gE = Pe(me, me.FWIDTH),
  yE = Pe(me, me.TRANSPOSE),
  Kk = Pe(me, me.BITCAST),
  vE = Pe(me, me.EQUALS),
  Dr = Pe(me, me.MIN),
  ui = Pe(me, me.MAX),
  dx = Pe(me, me.MOD),
  y0 = Pe(me, me.STEP),
  _E = Pe(me, me.REFLECT),
  xE = Pe(me, me.DISTANCE),
  SE = Pe(me, me.DIFFERENCE),
  $a = Pe(me, me.DOT),
  v0 = Pe(me, me.CROSS),
  gs = Pe(me, me.POW),
  AE = Pe(me, me.POW, 2),
  bE = Pe(me, me.POW, 3),
  TE = Pe(me, me.POW, 4),
  wE = Pe(me, me.TRANSFORM_DIRECTION),
  CE = (n) => xt(ax(n), gs(mn(n), 1 / 3)),
  hx = (n) => $a(n, n),
  Ln = Pe(me, me.MIX),
  Jo = (n, e = 0, t = 1) => Fe(new me(me.CLAMP, Fe(n), Fe(e), Fe(t))),
  EE = (n) => Jo(n),
  ME = Pe(me, me.REFRACT),
  Hl = Pe(me, me.SMOOTHSTEP),
  fx = Pe(me, me.FACEFORWARD),
  RE = _e(([n]) => {
    const i = 43758.5453,
      r = $a(n.xy, He(12.9898, 78.233)),
      s = dx(r, wm)
    return sa(Tr(s).mul(i))
  }),
  IE = (n, e, t) => Ln(e, t, n),
  NE = (n, e, t) => Hl(e, t, n),
  PE = (n, e) => (console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'), ox(n, e)),
  Yk = fx,
  Zk = sx
Ne('all', ix)
Ne('any', sE)
Ne('equals', vE)
Ne('radians', oE)
Ne('degrees', aE)
Ne('exp', lE)
Ne('exp2', Su)
Ne('log', rx)
Ne('log2', Ho)
Ne('sqrt', co)
Ne('inverseSqrt', sx)
Ne('floor', Xs)
Ne('ceil', g0)
Ne('normalize', ql)
Ne('fract', sa)
Ne('sin', Tr)
Ne('cos', Ro)
Ne('tan', cE)
Ne('asin', uE)
Ne('acos', dE)
Ne('atan', ox)
Ne('abs', mn)
Ne('sign', ax)
Ne('length', Cm)
Ne('lengthSq', hx)
Ne('negate', hE)
Ne('oneMinus', fE)
Ne('dFdx', lx)
Ne('dFdy', cx)
Ne('round', pE)
Ne('reciprocal', mE)
Ne('trunc', ux)
Ne('fwidth', gE)
Ne('atan2', PE)
Ne('min', Dr)
Ne('max', ui)
Ne('mod', dx)
Ne('step', y0)
Ne('reflect', _E)
Ne('distance', xE)
Ne('dot', $a)
Ne('cross', v0)
Ne('pow', gs)
Ne('pow2', AE)
Ne('pow3', bE)
Ne('pow4', TE)
Ne('transformDirection', wE)
Ne('mix', IE)
Ne('clamp', Jo)
Ne('refract', ME)
Ne('smoothstep', NE)
Ne('faceForward', fx)
Ne('difference', SE)
Ne('saturate', EE)
Ne('cbrt', CE)
Ne('transpose', yE)
Ne('rand', RE)
class Jk extends ut {
  static get type() {
    return 'ConditionalNode'
  }
  constructor(e, t, i = null) {
    ;(super(), (this.condNode = e), (this.ifNode = t), (this.elseNode = i))
  }
  getNodeType(e) {
    const { ifNode: t, elseNode: i } = e.getNodeProperties(this)
    if (t === void 0) return (this.setup(e), this.getNodeType(e))
    const r = t.getNodeType(e)
    if (i !== null) {
      const s = i.getNodeType(e)
      if (e.getTypeLength(s) > e.getTypeLength(r)) return s
    }
    return r
  }
  setup(e) {
    const t = this.condNode.cache(),
      i = this.ifNode.cache(),
      r = this.elseNode ? this.elseNode.cache() : null,
      s = e.context.nodeBlock
    ;((e.getDataFromNode(i).parentNodeBlock = s),
      r !== null && (e.getDataFromNode(r).parentNodeBlock = s))
    const o = e.getNodeProperties(this)
    ;((o.condNode = t),
      (o.ifNode = i.context({ nodeBlock: i })),
      (o.elseNode = r ? r.context({ nodeBlock: r }) : null))
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      r = e.getDataFromNode(this)
    if (r.nodeProperty !== void 0) return r.nodeProperty
    const { condNode: s, ifNode: o, elseNode: a } = e.getNodeProperties(this),
      l = t !== 'void',
      c = l ? OC(i).build(e) : ''
    r.nodeProperty = c
    const u = s.build(e, 'bool')
    e.addFlowCode('\n'.concat(e.tab, 'if ( ').concat(u, ' ) {\n\n')).addFlowTab()
    let d = o.build(e, i)
    if (
      (d && (l ? (d = c + ' = ' + d + ';') : (d = 'return ' + d + ';')),
      e.removeFlowTab().addFlowCode(e.tab + '	' + d + '\n\n' + e.tab + '}'),
      a !== null)
    ) {
      e.addFlowCode(' else {\n\n').addFlowTab()
      let h = a.build(e, i)
      ;(h && (l ? (h = c + ' = ' + h + ';') : (h = 'return ' + h + ';')),
        e.removeFlowTab().addFlowCode(e.tab + '	' + h + '\n\n' + e.tab + '}\n\n'))
    } else e.addFlowCode('\n\n')
    return e.format(c, i, t)
  }
}
const rr = Pe(Jk)
Ne('select', rr)
const LE = (...n) => (
  console.warn('TSL.ConditionalNode: cond() has been renamed to select().'),
  rr(...n)
)
Ne('cond', LE)
class DE extends ut {
  static get type() {
    return 'ContextNode'
  }
  constructor(e, t = {}) {
    ;(super(), (this.isContextNode = !0), (this.node = e), (this.value = t))
  }
  getScope() {
    return this.node.getScope()
  }
  getNodeType(e) {
    return this.node.getNodeType(e)
  }
  analyze(e) {
    this.node.build(e)
  }
  setup(e) {
    const t = e.getContext()
    e.setContext({ ...e.context, ...this.value })
    const i = this.node.build(e)
    return (e.setContext(t), i)
  }
  generate(e, t) {
    const i = e.getContext()
    e.setContext({ ...e.context, ...this.value })
    const r = this.node.build(e, t)
    return (e.setContext(i), r)
  }
}
const px = Pe(DE),
  FE = (n, e) => px(n, { label: e })
Ne('context', px)
Ne('label', FE)
class ez extends ut {
  static get type() {
    return 'VarNode'
  }
  constructor(e, t = null, i = !1) {
    ;(super(),
      (this.node = e),
      (this.name = t),
      (this.global = !0),
      (this.isVarNode = !0),
      (this.readOnly = i))
  }
  getHash(e) {
    return this.name || super.getHash(e)
  }
  getMemberType(e, t) {
    return this.node.getMemberType(e, t)
  }
  getElementType(e) {
    return this.node.getElementType(e)
  }
  getNodeType(e) {
    return this.node.getNodeType(e)
  }
  generate(e) {
    const { node: t, name: i, readOnly: r } = this,
      { renderer: s } = e,
      o = s.backend.isWebGPUBackend === !0
    let a = !1,
      l = !1
    r && ((a = e.isDeterministic(t)), (l = o ? r : a))
    const c = e.getVectorType(this.getNodeType(e)),
      u = t.build(e, c),
      d = e.getVarFromNode(this, i, c, void 0, l),
      h = e.getPropertyName(d)
    let f = h
    if (l)
      if (o) f = a ? 'const '.concat(h) : 'let '.concat(h)
      else {
        const p = e.getArrayCount(t)
        f = 'const '.concat(e.getVar(d.type, h, p))
      }
    return (e.addLineFlowCode(''.concat(f, ' = ').concat(u), this), h)
  }
}
const mx = Pe(ez),
  OE = (n, e = null) => mx(n, e).append(),
  BE = (n, e = null) => mx(n, e, !0).append()
Ne('toVar', OE)
Ne('toConst', BE)
const UE = (n) => (
  console.warn('TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'),
  mx(n)
)
Ne('temp', UE)
class tz extends ut {
  static get type() {
    return 'VaryingNode'
  }
  constructor(e, t = null) {
    ;(super(), (this.node = e), (this.name = t), (this.isVaryingNode = !0))
  }
  isGlobal() {
    return !0
  }
  getHash(e) {
    return this.name || super.getHash(e)
  }
  getNodeType(e) {
    return this.node.getNodeType(e)
  }
  setupVarying(e) {
    const t = e.getNodeProperties(this)
    let i = t.varying
    if (i === void 0) {
      const r = this.name,
        s = this.getNodeType(e)
      ;((t.varying = i = e.getVaryingFromNode(this, r, s)), (t.node = this.node))
    }
    return (i.needsInterpolation || (i.needsInterpolation = e.shaderStage === 'fragment'), i)
  }
  setup(e) {
    this.setupVarying(e)
  }
  analyze(e) {
    return (this.setupVarying(e), this.node.analyze(e))
  }
  generate(e) {
    const t = e.getNodeProperties(this),
      i = this.setupVarying(e),
      r =
        e.shaderStage === 'fragment' && t.reassignPosition === !0 && e.context.needsPositionReassign
    if (t.propertyName === void 0 || r) {
      const s = this.getNodeType(e),
        o = e.getPropertyName(i, qy.VERTEX)
      ;(e.flowNodeFromShaderStage(qy.VERTEX, this.node, s, o),
        (t.propertyName = o),
        r
          ? (t.reassignPosition = !1)
          : t.reassignPosition === void 0 &&
            e.context.isPositionNodeInput &&
            (t.reassignPosition = !0))
    }
    return e.getPropertyName(i)
  }
}
const er = Pe(tz),
  kE = (n) => er(n)
Ne('toVarying', er)
Ne('toVertexStage', kE)
Ne(
  'varying',
  (...n) => (
    console.warn('TSL.VaryingNode: .varying() has been renamed to .toVarying().'),
    er(...n)
  )
)
Ne(
  'vertexStage',
  (...n) => (
    console.warn('TSL.VaryingNode: .vertexStage() has been renamed to .toVertexStage().'),
    er(...n)
  )
)
const zE = _e(([n]) => {
    const e = n.mul(0.9478672986).add(0.0521327014).pow(2.4),
      t = n.mul(0.0773993808),
      i = n.lessThanEqual(0.04045)
    return Ln(e, t, i)
  }).setLayout({
    name: 'sRGBTransferEOTF',
    type: 'vec3',
    inputs: [{ name: 'color', type: 'vec3' }],
  }),
  VE = _e(([n]) => {
    const e = n.pow(0.41666).mul(1.055).sub(0.055),
      t = n.mul(12.92),
      i = n.lessThanEqual(0.0031308)
    return Ln(e, t, i)
  }).setLayout({
    name: 'sRGBTransferOETF',
    type: 'vec3',
    inputs: [{ name: 'color', type: 'vec3' }],
  }),
  Hh = 'WorkingColorSpace',
  gx = 'OutputColorSpace'
class $h extends Un {
  static get type() {
    return 'ColorSpaceNode'
  }
  constructor(e, t, i) {
    ;(super('vec4'), (this.colorNode = e), (this.source = t), (this.target = i))
  }
  resolveColorSpace(e, t) {
    return t === Hh
      ? Tt.workingColorSpace
      : t === gx
        ? e.context.outputColorSpace || e.renderer.outputColorSpace
        : t
  }
  setup(e) {
    const { colorNode: t } = this,
      i = this.resolveColorSpace(e, this.source),
      r = this.resolveColorSpace(e, this.target)
    let s = t
    return (
      Tt.enabled === !1 ||
        i === r ||
        !i ||
        !r ||
        (Tt.getTransfer(i) === Jt && (s = yt(zE(s.rgb), s.a)),
        Tt.getPrimaries(i) !== Tt.getPrimaries(r) &&
          (s = yt(is(Tt._getMatrix(new pt(), i, r)).mul(s.rgb), s.a)),
        Tt.getTransfer(r) === Jt && (s = yt(VE(s.rgb), s.a))),
      s
    )
  }
}
const HE = (n) => Fe(new $h(Fe(n), Hh, gx)),
  $E = (n) => Fe(new $h(Fe(n), gx, Hh)),
  GE = (n, e) => Fe(new $h(Fe(n), Hh, e)),
  yx = (n, e) => Fe(new $h(Fe(n), e, Hh)),
  nz = (n, e, t) => Fe(new $h(Fe(n), e, t))
Ne('toOutputColorSpace', HE)
Ne('toWorkingColorSpace', $E)
Ne('workingToColorSpace', GE)
Ne('colorSpaceToWorking', yx)
let iz = class extends jl {
  static get type() {
    return 'ReferenceElementNode'
  }
  constructor(e, t) {
    ;(super(e, t), (this.referenceNode = e), (this.isReferenceElementNode = !0))
  }
  getNodeType() {
    return this.referenceNode.uniformType
  }
  generate(e) {
    const t = super.generate(e),
      i = this.referenceNode.getNodeType(),
      r = this.getNodeType()
    return e.format(t, i, r)
  }
}
class rz extends ut {
  static get type() {
    return 'ReferenceBaseNode'
  }
  constructor(e, t, i = null, r = null) {
    ;(super(),
      (this.property = e),
      (this.uniformType = t),
      (this.object = i),
      (this.count = r),
      (this.properties = e.split('.')),
      (this.reference = i),
      (this.node = null),
      (this.group = null),
      (this.updateType = Wt.OBJECT))
  }
  setGroup(e) {
    return ((this.group = e), this)
  }
  element(e) {
    return Fe(new iz(this, Fe(e)))
  }
  setNodeType(e) {
    const t = Rt(null, e).getSelf()
    ;(this.group !== null && t.setGroup(this.group), (this.node = t))
  }
  getNodeType(e) {
    return (
      this.node === null && (this.updateReference(e), this.updateValue()),
      this.node.getNodeType(e)
    )
  }
  getValueFromReference(e = this.reference) {
    const { properties: t } = this
    let i = e[t[0]]
    for (let r = 1; r < t.length; r++) i = i[t[r]]
    return i
  }
  updateReference(e) {
    return ((this.reference = this.object !== null ? this.object : e.object), this.reference)
  }
  setup() {
    return (this.updateValue(), this.node)
  }
  update() {
    this.updateValue()
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType)
    const e = this.getValueFromReference()
    Array.isArray(e) ? (this.node.array = e) : (this.node.value = e)
  }
}
class sz extends rz {
  static get type() {
    return 'RendererReferenceNode'
  }
  constructor(e, t, i = null) {
    ;(super(e, t, i), (this.renderer = i), this.setGroup(Ut))
  }
  updateReference(e) {
    return ((this.reference = this.renderer !== null ? this.renderer : e.renderer), this.reference)
  }
}
const WE = (n, e, t = null) => Fe(new sz(n, e, t))
class oz extends Un {
  static get type() {
    return 'ToneMappingNode'
  }
  constructor(e, t = jE, i = null) {
    ;(super('vec3'), (this.toneMapping = e), (this.exposureNode = t), (this.colorNode = i))
  }
  customCacheKey() {
    return cC(this.toneMapping)
  }
  setup(e) {
    const t = this.colorNode || e.context.color,
      i = this.toneMapping
    if (i === _s) return t
    let r = null
    const s = e.renderer.library.getToneMappingFunction(i)
    return (
      s !== null
        ? (r = yt(s(t.rgb, this.exposureNode), t.a))
        : (console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', i), (r = t)),
      r
    )
  }
}
const QE = (n, e, t) => Fe(new oz(n, Fe(e), Fe(t))),
  jE = WE('toneMappingExposure', 'float')
Ne('toneMapping', (n, e, t) => QE(e, t, n))
class az extends K_ {
  static get type() {
    return 'BufferAttributeNode'
  }
  constructor(e, t = null, i = 0, r = 0) {
    ;(super(e, t),
      (this.isBufferNode = !0),
      (this.bufferType = t),
      (this.bufferStride = i),
      (this.bufferOffset = r),
      (this.usage = gm),
      (this.instanced = !1),
      (this.attribute = null),
      (this.global = !0),
      e &&
        e.isBufferAttribute === !0 &&
        ((this.attribute = e),
        (this.usage = e.usage),
        (this.instanced = e.isInstancedBufferAttribute)))
  }
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let t = e.globalCache.getData(this.value)
      return (
        t === void 0 && ((t = { node: this }), e.globalCache.setData(this.value, t)),
        t.node.uuid
      )
    }
    return this.uuid
  }
  getNodeType(e) {
    return (
      this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)),
      this.bufferType
    )
  }
  setup(e) {
    if (this.attribute !== null) return
    const t = this.getNodeType(e),
      i = this.value,
      r = e.getTypeLength(t),
      s = this.bufferStride || r,
      o = this.bufferOffset,
      a = i.isInterleavedBuffer === !0 ? i : new w_(i, s),
      l = new l0(a, r, o)
    ;(a.setUsage(this.usage),
      (this.attribute = l),
      (this.attribute.isInstancedBufferAttribute = this.instanced))
  }
  generate(e) {
    const t = this.getNodeType(e),
      i = e.getBufferAttributeFromNode(this, t),
      r = e.getPropertyName(i)
    let s = null
    return (
      e.shaderStage === 'vertex' || e.shaderStage === 'compute'
        ? ((this.name = r), (s = r))
        : (s = er(this).build(e, t)),
      s
    )
  }
  getInputType() {
    return 'bufferAttribute'
  }
  setUsage(e) {
    return (
      (this.usage = e),
      this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e),
      this
    )
  }
  setInstanced(e) {
    return ((this.instanced = e), this)
  }
}
const Gh = (n, e = null, t = 0, i = 0) => Fe(new az(n, e, t, i)),
  qE = (n, e = null, t = 0, i = 0) => Gh(n, e, t, i).setUsage(Ca),
  Em = (n, e = null, t = 0, i = 0) => Gh(n, e, t, i).setInstanced(!0),
  ev = (n, e = null, t = 0, i = 0) => qE(n, e, t, i).setInstanced(!0)
Ne('toAttribute', (n) => Gh(n.value))
class lz extends ut {
  static get type() {
    return 'ComputeNode'
  }
  constructor(e, t, i = [64]) {
    ;(super('void'),
      (this.isComputeNode = !0),
      (this.computeNode = e),
      (this.count = t),
      (this.workgroupSize = i),
      (this.dispatchCount = 0),
      (this.version = 1),
      (this.name = ''),
      (this.updateBeforeType = Wt.OBJECT),
      (this.onInitFunction = null),
      this.updateDispatchCount())
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  label(e) {
    return ((this.name = e), this)
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this
    let i = t[0]
    for (let r = 1; r < t.length; r++) i *= t[r]
    this.dispatchCount = Math.ceil(e / i)
  }
  onInit(e) {
    return ((this.onInitFunction = e), this)
  }
  updateBefore({ renderer: e }) {
    e.compute(this)
  }
  generate(e) {
    const { shaderStage: t } = e
    if (t === 'compute') {
      const i = this.computeNode.build(e, 'void')
      i !== '' && e.addLineFlowCode(i, this)
    }
  }
}
const XE = (n, e, t) => Fe(new lz(Fe(n), e, t))
Ne('compute', XE)
class cz extends ut {
  static get type() {
    return 'CacheNode'
  }
  constructor(e, t = !0) {
    ;(super(), (this.node = e), (this.parent = t), (this.isCacheNode = !0))
  }
  getNodeType(e) {
    const t = e.getCache(),
      i = e.getCacheFromNode(this, this.parent)
    e.setCache(i)
    const r = this.node.getNodeType(e)
    return (e.setCache(t), r)
  }
  build(e, ...t) {
    const i = e.getCache(),
      r = e.getCacheFromNode(this, this.parent)
    e.setCache(r)
    const s = this.node.build(e, ...t)
    return (e.setCache(i), s)
  }
}
const KE = (n, e) => Fe(new cz(Fe(n), e))
Ne('cache', KE)
class uz extends ut {
  static get type() {
    return 'BypassNode'
  }
  constructor(e, t) {
    ;(super(), (this.isBypassNode = !0), (this.outputNode = e), (this.callNode = t))
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e)
  }
  generate(e) {
    const t = this.callNode.build(e, 'void')
    return (t !== '' && e.addLineFlowCode(t, this), this.outputNode.build(e))
  }
}
const YE = Pe(uz)
Ne('bypass', YE)
class ZE extends ut {
  static get type() {
    return 'RemapNode'
  }
  constructor(e, t, i, r = ce(0), s = ce(1)) {
    ;(super(),
      (this.node = e),
      (this.inLowNode = t),
      (this.inHighNode = i),
      (this.outLowNode = r),
      (this.outHighNode = s),
      (this.doClamp = !0))
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: i, outLowNode: r, outHighNode: s, doClamp: o } = this
    let a = e.sub(t).div(i.sub(t))
    return (o === !0 && (a = a.clamp()), a.mul(s.sub(r)).add(r))
  }
}
const JE = Pe(ZE, null, null, { doClamp: !1 }),
  eM = Pe(ZE)
Ne('remap', JE)
Ne('remapClamp', eM)
class dz extends ut {
  static get type() {
    return 'ExpressionNode'
  }
  constructor(e = '', t = 'void') {
    ;(super(t), (this.snippet = e))
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      r = this.snippet
    if (i === 'void') e.addLineFlowCode(r, this)
    else return e.format('( '.concat(r, ' )'), i, t)
  }
}
const ka = Pe(dz),
  tM = (n) => (n ? rr(n, ka('discard')) : ka('discard')).append(),
  hz = () => ka('return').append()
Ne('discard', tM)
class fz extends Un {
  static get type() {
    return 'RenderOutputNode'
  }
  constructor(e, t, i) {
    ;(super('vec4'),
      (this.colorNode = e),
      (this.toneMapping = t),
      (this.outputColorSpace = i),
      (this.isRenderOutputNode = !0))
  }
  setup({ context: e }) {
    let t = this.colorNode || e.color
    const i = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || _s,
      r = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || $s
    return (
      i !== _s && (t = t.toneMapping(i)),
      r !== $s && r !== Tt.workingColorSpace && (t = t.workingToColorSpace(r)),
      t
    )
  }
}
const nM = (n, e = null, t = null) => Fe(new fz(Fe(n), e, t))
Ne('renderOutput', nM)
function pz(n) {
  console.warn(
    'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add',
    n
  )
}
class iM extends ut {
  static get type() {
    return 'AttributeNode'
  }
  constructor(e, t = null) {
    ;(super(t), (this.global = !0), (this._attributeName = e))
  }
  getHash(e) {
    return this.getAttributeName(e)
  }
  getNodeType(e) {
    let t = this.nodeType
    if (t === null) {
      const i = this.getAttributeName(e)
      if (e.hasGeometryAttribute(i)) {
        const r = e.geometry.getAttribute(i)
        t = e.getTypeFromAttribute(r)
      } else t = 'float'
    }
    return t
  }
  setAttributeName(e) {
    return ((this._attributeName = e), this)
  }
  getAttributeName() {
    return this._attributeName
  }
  generate(e) {
    const t = this.getAttributeName(e),
      i = this.getNodeType(e)
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t),
        o = e.getTypeFromAttribute(s),
        a = e.getAttribute(t, o)
      return e.shaderStage === 'vertex' ? e.format(a.name, o, i) : er(this).build(e, i)
    } else
      return (
        console.warn('AttributeNode: Vertex attribute "'.concat(t, '" not found on geometry.')),
        e.generateConst(i)
      )
  }
  serialize(e) {
    ;(super.serialize(e), (e.global = this.global), (e._attributeName = this._attributeName))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.global = e.global), (this._attributeName = e._attributeName))
  }
}
const ea = (n, e) => Fe(new iM(n, e)),
  xn = (n = 0) => ea('uv' + (n > 0 ? n : ''), 'vec2')
class mz extends ut {
  static get type() {
    return 'TextureSizeNode'
  }
  constructor(e, t = null) {
    ;(super('uvec2'), (this.isTextureSizeNode = !0), (this.textureNode = e), (this.levelNode = t))
  }
  generate(e, t) {
    const i = this.textureNode.build(e, 'property'),
      r = this.levelNode === null ? '0' : this.levelNode.build(e, 'int')
    return e.format(
      ''.concat(e.getMethod('textureDimensions'), '( ').concat(i, ', ').concat(r, ' )'),
      this.getNodeType(e),
      t
    )
  }
}
const Fa = Pe(mz)
class gz extends Vh {
  static get type() {
    return 'MaxMipLevelNode'
  }
  constructor(e) {
    ;(super(0), (this._textureNode = e), (this.updateType = Wt.FRAME))
  }
  get textureNode() {
    return this._textureNode
  }
  get texture() {
    return this._textureNode.value
  }
  update() {
    const e = this.texture,
      t = e.images,
      i = t && t.length > 0 ? (t[0] && t[0].image) || t[0] : e.image
    if (i && i.width !== void 0) {
      const { width: r, height: s } = i
      this.value = Math.log2(Math.max(r, s))
    }
  }
}
const rM = Pe(gz)
class ta extends Vh {
  static get type() {
    return 'TextureNode'
  }
  constructor(e, t = null, i = null, r = null) {
    ;(super(e),
      (this.isTextureNode = !0),
      (this.uvNode = t),
      (this.levelNode = i),
      (this.biasNode = r),
      (this.compareNode = null),
      (this.depthNode = null),
      (this.gradNode = null),
      (this.sampler = !0),
      (this.updateMatrix = !1),
      (this.updateType = Wt.NONE),
      (this.referenceNode = null),
      (this._value = e),
      (this._matrixUniform = null),
      this.setUpdateMatrix(t === null))
  }
  set value(e) {
    this.referenceNode ? (this.referenceNode.value = e) : (this._value = e)
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value
  }
  getUniformHash() {
    return this.value.uuid
  }
  getNodeType() {
    return this.value.isDepthTexture === !0
      ? 'float'
      : this.value.type === Ni
        ? 'uvec4'
        : this.value.type === o0
          ? 'ivec4'
          : 'vec4'
  }
  getInputType() {
    return 'texture'
  }
  getDefaultUV() {
    return xn(this.value.channel)
  }
  updateReference() {
    return this.value
  }
  getTransformedUV(e) {
    return (
      this._matrixUniform === null && (this._matrixUniform = Rt(this.value.matrix)),
      this._matrixUniform.mul(ve(e, 1)).xy
    )
  }
  setUpdateMatrix(e) {
    return ((this.updateMatrix = e), (this.updateType = e ? Wt.RENDER : Wt.NONE), this)
  }
  setupUV(e, t) {
    const i = this.value
    return (
      e.isFlipY() &&
        ((i.image instanceof ImageBitmap && i.flipY === !0) ||
          i.isRenderTargetTexture === !0 ||
          i.isFramebufferTexture === !0 ||
          i.isDepthTexture === !0) &&
        (this.sampler
          ? (t = t.flipY())
          : (t = t.setY(de(Fa(this, this.levelNode).y).sub(t.y).sub(1)))),
      t
    )
  }
  setup(e) {
    const t = e.getNodeProperties(this)
    t.referenceNode = this.referenceNode
    const i = this.value
    if (!i || i.isTexture !== !0)
      throw new Error(
        'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().'
      )
    let r = this.uvNode
    ;((r === null || e.context.forceUVContext === !0) &&
      e.context.getUV &&
      (r = e.context.getUV(this)),
      r || (r = this.getDefaultUV()),
      this.updateMatrix === !0 && (r = this.getTransformedUV(r)),
      (r = this.setupUV(e, r)))
    let s = this.levelNode
    ;(s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)),
      (t.uvNode = r),
      (t.levelNode = s),
      (t.biasNode = this.biasNode),
      (t.compareNode = this.compareNode),
      (t.gradNode = this.gradNode),
      (t.depthNode = this.depthNode))
  }
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? 'vec2' : 'ivec2')
  }
  generateSnippet(e, t, i, r, s, o, a, l) {
    const c = this.value
    let u
    return (
      r
        ? (u = e.generateTextureLevel(c, t, i, r, o))
        : s
          ? (u = e.generateTextureBias(c, t, i, s, o))
          : l
            ? (u = e.generateTextureGrad(c, t, i, l, o))
            : a
              ? (u = e.generateTextureCompare(c, t, i, a, o))
              : this.sampler === !1
                ? (u = e.generateTextureLoad(c, t, i, o))
                : (u = e.generateTexture(c, t, i, o)),
      u
    )
  }
  generate(e, t) {
    const i = this.value,
      r = e.getNodeProperties(this),
      s = super.generate(e, 'property')
    if (t === 'sampler') return s + '_sampler'
    if (e.isReference(t)) return s
    {
      const o = e.getDataFromNode(this)
      let a = o.propertyName
      if (a === void 0) {
        const {
            uvNode: u,
            levelNode: d,
            biasNode: h,
            compareNode: f,
            depthNode: p,
            gradNode: g,
          } = r,
          y = this.generateUV(e, u),
          m = d ? d.build(e, 'float') : null,
          v = h ? h.build(e, 'float') : null,
          x = p ? p.build(e, 'int') : null,
          _ = f ? f.build(e, 'float') : null,
          S = g ? [g[0].build(e, 'vec2'), g[1].build(e, 'vec2')] : null,
          C = e.getVarFromNode(this)
        a = e.getPropertyName(C)
        const A = this.generateSnippet(e, s, y, m, v, x, _, S)
        ;(e.addLineFlowCode(''.concat(a, ' = ').concat(A), this),
          (o.snippet = A),
          (o.propertyName = a))
      }
      let l = a
      const c = this.getNodeType(e)
      return (
        e.needsToWorkingColorSpace(i) && (l = yx(ka(l, c), i.colorSpace).setup(e).build(e, c)),
        e.format(l, c, t)
      )
    }
  }
  setSampler(e) {
    return ((this.sampler = e), this)
  }
  getSampler() {
    return this.sampler
  }
  uv(e) {
    return (
      console.warn('THREE.TextureNode: .uv() has been renamed. Use .sample() instead.'),
      this.sample(e)
    )
  }
  sample(e) {
    const t = this.clone()
    return ((t.uvNode = Fe(e)), (t.referenceNode = this.getSelf()), Fe(t))
  }
  blur(e) {
    const t = this.clone()
    return ((t.biasNode = Fe(e).mul(rM(t))), (t.referenceNode = this.getSelf()), Fe(t))
  }
  level(e) {
    const t = this.clone()
    return ((t.levelNode = Fe(e)), (t.referenceNode = this.getSelf()), Fe(t))
  }
  size(e) {
    return Fa(this, e)
  }
  bias(e) {
    const t = this.clone()
    return ((t.biasNode = Fe(e)), (t.referenceNode = this.getSelf()), Fe(t))
  }
  compare(e) {
    const t = this.clone()
    return ((t.compareNode = Fe(e)), (t.referenceNode = this.getSelf()), Fe(t))
  }
  grad(e, t) {
    const i = this.clone()
    return ((i.gradNode = [Fe(e), Fe(t)]), (i.referenceNode = this.getSelf()), Fe(i))
  }
  depth(e) {
    const t = this.clone()
    return ((t.depthNode = Fe(e)), (t.referenceNode = this.getSelf()), Fe(t))
  }
  serialize(e) {
    ;(super.serialize(e),
      (e.value = this.value.toJSON(e.meta).uuid),
      (e.sampler = this.sampler),
      (e.updateMatrix = this.updateMatrix),
      (e.updateType = this.updateType))
  }
  deserialize(e) {
    ;(super.deserialize(e),
      (this.value = e.meta.textures[e.value]),
      (this.sampler = e.sampler),
      (this.updateMatrix = e.updateMatrix),
      (this.updateType = e.updateType))
  }
  update() {
    const e = this.value,
      t = this._matrixUniform
    ;(t !== null && (t.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix())
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode)
    return ((e.sampler = this.sampler), e)
  }
}
const Ji = Pe(ta),
  Rn = (...n) => Ji(...n).setSampler(!1),
  yz = (n) => (n.isNode === !0 ? n : Ji(n)).convert('sampler')
class vx extends Vh {
  static get type() {
    return 'BufferNode'
  }
  constructor(e, t, i = 0) {
    ;(super(e, t), (this.isBufferNode = !0), (this.bufferType = t), (this.bufferCount = i))
  }
  getElementType(e) {
    return this.getNodeType(e)
  }
  getInputType() {
    return 'buffer'
  }
}
const Wh = (n, e, t) => Fe(new vx(n, e, t))
class vz extends jl {
  static get type() {
    return 'UniformArrayElementNode'
  }
  constructor(e, t) {
    ;(super(e, t), (this.isArrayBufferElementNode = !0))
  }
  generate(e) {
    const t = super.generate(e),
      i = this.getNodeType(),
      r = this.node.getPaddedType()
    return e.format(t, r, i)
  }
}
class sM extends vx {
  static get type() {
    return 'UniformArrayNode'
  }
  constructor(e, t = null) {
    ;(super(null),
      (this.array = e),
      (this.elementType = t === null ? Ra(e[0]) : t),
      (this.paddedType = this.getPaddedType()),
      (this.updateType = Wt.RENDER),
      (this.isArrayBufferNode = !0))
  }
  getNodeType() {
    return this.paddedType
  }
  getElementType() {
    return this.elementType
  }
  getPaddedType() {
    const e = this.elementType
    let t = 'vec4'
    return (
      e === 'mat2'
        ? (t = 'mat2')
        : /mat/.test(e) === !0
          ? (t = 'mat4')
          : e.charAt(0) === 'i'
            ? (t = 'ivec4')
            : e.charAt(0) === 'u' && (t = 'uvec4'),
      t
    )
  }
  update() {
    const { array: e, value: t } = this,
      i = this.elementType
    if (i === 'float' || i === 'int' || i === 'uint')
      for (let r = 0; r < e.length; r++) {
        const s = r * 4
        t[s] = e[r]
      }
    else if (i === 'color')
      for (let r = 0; r < e.length; r++) {
        const s = r * 4,
          o = e[r]
        ;((t[s] = o.r), (t[s + 1] = o.g), (t[s + 2] = o.b || 0))
      }
    else if (i === 'mat2')
      for (let r = 0; r < e.length; r++) {
        const s = r * 4,
          o = e[r]
        ;((t[s] = o.elements[0]),
          (t[s + 1] = o.elements[1]),
          (t[s + 2] = o.elements[2]),
          (t[s + 3] = o.elements[3]))
      }
    else if (i === 'mat3')
      for (let r = 0; r < e.length; r++) {
        const s = r * 16,
          o = e[r]
        ;((t[s] = o.elements[0]),
          (t[s + 1] = o.elements[1]),
          (t[s + 2] = o.elements[2]),
          (t[s + 4] = o.elements[3]),
          (t[s + 5] = o.elements[4]),
          (t[s + 6] = o.elements[5]),
          (t[s + 8] = o.elements[6]),
          (t[s + 9] = o.elements[7]),
          (t[s + 10] = o.elements[8]),
          (t[s + 15] = 1))
      }
    else if (i === 'mat4')
      for (let r = 0; r < e.length; r++) {
        const s = r * 16,
          o = e[r]
        for (let a = 0; a < o.elements.length; a++) t[s + a] = o.elements[a]
      }
    else
      for (let r = 0; r < e.length; r++) {
        const s = r * 4,
          o = e[r]
        ;((t[s] = o.x), (t[s + 1] = o.y), (t[s + 2] = o.z || 0), (t[s + 3] = o.w || 0))
      }
  }
  setup(e) {
    const t = this.array.length,
      i = this.elementType
    let r = Float32Array
    const s = this.paddedType,
      o = e.getTypeLength(s)
    return (
      i.charAt(0) === 'i' && (r = Int32Array),
      i.charAt(0) === 'u' && (r = Uint32Array),
      (this.value = new r(t * o)),
      (this.bufferCount = t),
      (this.bufferType = s),
      super.setup(e)
    )
  }
  element(e) {
    return Fe(new vz(this, Fe(e)))
  }
}
const Fo = (n, e) => Fe(new sM(n, e)),
  _z = (n, e) => (
    console.warn('TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().'),
    Fe(new sM(n, e))
  ),
  _x = Rt(0, 'uint').setGroup(m0('cameraIndex')).toVarying('v_cameraIndex'),
  Sa = Rt('float')
    .label('cameraNear')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }) => n.near),
  Aa = Rt('float')
    .label('cameraFar')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }) => n.far),
  Qh = _e(({ camera: n }) => {
    let e
    if (n.isArrayCamera && n.cameras.length > 0) {
      const t = []
      for (const r of n.cameras) t.push(r.projectionMatrix)
      e = Fo(t)
        .setGroup(Ut)
        .label('cameraProjectionMatrices')
        .element(_x)
        .toVar('cameraProjectionMatrix')
    } else
      e = Rt('mat4')
        .label('cameraProjectionMatrix')
        .setGroup(Ut)
        .onRenderUpdate(({ camera: t }) => t.projectionMatrix)
    return e
  }).once()(),
  xz = Rt('mat4')
    .label('cameraProjectionMatrixInverse')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }) => n.projectionMatrixInverse),
  ss = _e(({ camera: n }) => {
    let e
    if (n.isArrayCamera && n.cameras.length > 0) {
      const t = []
      for (const r of n.cameras) t.push(r.matrixWorldInverse)
      e = Fo(t).setGroup(Ut).label('cameraViewMatrices').element(_x).toVar('cameraViewMatrix')
    } else
      e = Rt('mat4')
        .label('cameraViewMatrix')
        .setGroup(Ut)
        .onRenderUpdate(({ camera: t }) => t.matrixWorldInverse)
    return e
  }).once()(),
  Sz = Rt('mat4')
    .label('cameraWorldMatrix')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }) => n.matrixWorld),
  Az = Rt('mat3')
    .label('cameraNormalMatrix')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }) => n.normalMatrix),
  bz = Rt(new Y())
    .label('cameraPosition')
    .setGroup(Ut)
    .onRenderUpdate(({ camera: n }, e) => e.value.setFromMatrixPosition(n.matrixWorld))
class Ht extends ut {
  static get type() {
    return 'Object3DNode'
  }
  constructor(e, t = null) {
    ;(super(),
      (this.scope = e),
      (this.object3d = t),
      (this.updateType = Wt.OBJECT),
      (this._uniformNode = new Vh(null)))
  }
  getNodeType() {
    const e = this.scope
    if (e === Ht.WORLD_MATRIX) return 'mat4'
    if (e === Ht.POSITION || e === Ht.VIEW_POSITION || e === Ht.DIRECTION || e === Ht.SCALE)
      return 'vec3'
  }
  update(e) {
    const t = this.object3d,
      i = this._uniformNode,
      r = this.scope
    if (r === Ht.WORLD_MATRIX) i.value = t.matrixWorld
    else if (r === Ht.POSITION)
      ((i.value = i.value || new Y()), i.value.setFromMatrixPosition(t.matrixWorld))
    else if (r === Ht.SCALE)
      ((i.value = i.value || new Y()), i.value.setFromMatrixScale(t.matrixWorld))
    else if (r === Ht.DIRECTION) ((i.value = i.value || new Y()), t.getWorldDirection(i.value))
    else if (r === Ht.VIEW_POSITION) {
      const s = e.camera
      ;((i.value = i.value || new Y()),
        i.value.setFromMatrixPosition(t.matrixWorld),
        i.value.applyMatrix4(s.matrixWorldInverse))
    }
  }
  generate(e) {
    const t = this.scope
    return (
      t === Ht.WORLD_MATRIX
        ? (this._uniformNode.nodeType = 'mat4')
        : (t === Ht.POSITION || t === Ht.VIEW_POSITION || t === Ht.DIRECTION || t === Ht.SCALE) &&
          (this._uniformNode.nodeType = 'vec3'),
      this._uniformNode.build(e)
    )
  }
  serialize(e) {
    ;(super.serialize(e), (e.scope = this.scope))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.scope = e.scope))
  }
}
Ht.WORLD_MATRIX = 'worldMatrix'
Ht.POSITION = 'position'
Ht.SCALE = 'scale'
Ht.VIEW_POSITION = 'viewPosition'
Ht.DIRECTION = 'direction'
const Tz = Pe(Ht, Ht.DIRECTION),
  wz = Pe(Ht, Ht.WORLD_MATRIX),
  oM = Pe(Ht, Ht.POSITION),
  Cz = Pe(Ht, Ht.SCALE),
  Ez = Pe(Ht, Ht.VIEW_POSITION)
class to extends Ht {
  static get type() {
    return 'ModelNode'
  }
  constructor(e) {
    super(e)
  }
  update(e) {
    ;((this.object3d = e.object), super.update(e))
  }
}
const Mz = We(to, to.DIRECTION),
  Oo = We(to, to.WORLD_MATRIX),
  Rz = We(to, to.POSITION),
  Iz = We(to, to.SCALE),
  Nz = We(to, to.VIEW_POSITION),
  aM = Rt(new pt()).onObjectUpdate(({ object: n }, e) => e.value.getNormalMatrix(n.matrixWorld)),
  Pz = Rt(new qe()).onObjectUpdate(({ object: n }, e) => e.value.copy(n.matrixWorld).invert()),
  jh = _e((n) => n.renderer.nodes.modelViewMatrix || lM)
    .once()()
    .toVar('modelViewMatrix'),
  lM = ss.mul(Oo),
  Lz = _e(
    (n) => (
      (n.context.isHighPrecisionModelViewMatrix = !0),
      Rt('mat4').onObjectUpdate(({ object: e, camera: t }) =>
        e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld)
      )
    )
  )
    .once()()
    .toVar('highpModelViewMatrix'),
  Dz = _e((n) => {
    const e = n.context.isHighPrecisionModelViewMatrix
    return Rt('mat3').onObjectUpdate(
      ({ object: t, camera: i }) => (
        e !== !0 && t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix)
      )
    )
  })
    .once()()
    .toVar('highpModelNormalViewMatrix'),
  xx = ea('position', 'vec3'),
  Nn = xx.toVarying('positionLocal'),
  Mm = xx.toVarying('positionPrevious'),
  Dl = Oo.mul(Nn).xyz.toVarying('v_positionWorld').context({ needsPositionReassign: !0 }),
  cM = Nn.transformDirection(Oo)
    .toVarying('v_positionWorldDirection')
    .normalize()
    .toVar('positionWorldDirection')
    .context({ needsPositionReassign: !0 }),
  Yn = _e((n) => n.context.setupPositionView(), 'vec3')
    .once()()
    .toVarying('v_positionView')
    .context({ needsPositionReassign: !0 }),
  Cr = Yn.negate().toVarying('v_positionViewDirection').normalize().toVar('positionViewDirection')
class Fz extends ut {
  static get type() {
    return 'FrontFacingNode'
  }
  constructor() {
    ;(super('bool'), (this.isFrontFacingNode = !0))
  }
  generate(e) {
    const { renderer: t, material: i } = e
    return t.coordinateSystem === Ir && i.side === Oi ? 'false' : e.getFrontFacing()
  }
}
const uM = We(Fz),
  qh = ce(uM).mul(2).sub(1),
  Sx = ea('normal', 'vec3'),
  cr = _e(
    (n) =>
      n.geometry.hasAttribute('normal') === !1
        ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'),
          ve(0, 1, 0))
        : Sx,
    'vec3'
  )
    .once()()
    .toVar('normalLocal'),
  dM = Yn.dFdx().cross(Yn.dFdy()).normalize().toVar('normalFlat'),
  no = _e((n) => {
    let e
    return (
      n.material.flatShading === !0 ? (e = dM) : (e = er(Ax(cr), 'v_normalView').normalize()),
      e
    )
  }, 'vec3')
    .once()()
    .toVar('normalView'),
  hM = er(no.transformDirection(ss), 'v_normalWorld').normalize().toVar('normalWorld'),
  na = _e((n) => n.context.setupNormal().context({ getUV: null }), 'vec3')
    .once()()
    .mul(qh)
    .toVar('transformedNormalView'),
  fM = na.transformDirection(ss).toVar('transformedNormalWorld'),
  Oz = _e((n) => n.context.setupClearcoatNormal().context({ getUV: null }), 'vec3')
    .once()()
    .mul(qh)
    .toVar('transformedClearcoatNormalView'),
  pM = _e(([n, e = Oo]) => {
    const t = is(e),
      i = n.div(ve(t[0].dot(t[0]), t[1].dot(t[1]), t[2].dot(t[2])))
    return t.mul(i).xyz
  }),
  Ax = _e(([n], e) => {
    const t = e.renderer.nodes.modelNormalViewMatrix
    if (t !== null) return t.transformDirection(n)
    const i = aM.mul(n)
    return ss.transformDirection(i)
  }),
  mM = Rt(0)
    .onReference(({ material: n }) => n)
    .onRenderUpdate(({ material: n }) => n.refractionRatio),
  gM = Cr.negate().reflect(na),
  yM = Cr.negate().refract(na, mM),
  vM = gM.transformDirection(ss).toVar('reflectVector'),
  _M = yM.transformDirection(ss).toVar('reflectVector')
class Bz extends ta {
  static get type() {
    return 'CubeTextureNode'
  }
  constructor(e, t = null, i = null, r = null) {
    ;(super(e, t, i, r), (this.isCubeTextureNode = !0))
  }
  getInputType() {
    return 'cubeTexture'
  }
  getDefaultUV() {
    const e = this.value
    return e.mapping === kl
      ? vM
      : e.mapping === zl
        ? _M
        : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping),
          ve(0, 0, 0))
  }
  setUpdateMatrix() {}
  setupUV(e, t) {
    const i = this.value
    return e.renderer.coordinateSystem === Xo || !i.isRenderTargetTexture
      ? ve(t.x.negate(), t.yz)
      : t
  }
  generateUV(e, t) {
    return t.build(e, 'vec3')
  }
}
const xM = Pe(Bz)
class Uz extends jl {
  static get type() {
    return 'ReferenceElementNode'
  }
  constructor(e, t) {
    ;(super(e, t), (this.referenceNode = e), (this.isReferenceElementNode = !0))
  }
  getNodeType() {
    return this.referenceNode.uniformType
  }
  generate(e) {
    const t = super.generate(e),
      i = this.referenceNode.getNodeType(),
      r = this.getNodeType()
    return e.format(t, i, r)
  }
}
class _0 extends ut {
  static get type() {
    return 'ReferenceNode'
  }
  constructor(e, t, i = null, r = null) {
    ;(super(),
      (this.property = e),
      (this.uniformType = t),
      (this.object = i),
      (this.count = r),
      (this.properties = e.split('.')),
      (this.reference = i),
      (this.node = null),
      (this.group = null),
      (this.name = null),
      (this.updateType = Wt.OBJECT))
  }
  element(e) {
    return Fe(new Uz(this, Fe(e)))
  }
  setGroup(e) {
    return ((this.group = e), this)
  }
  label(e) {
    return ((this.name = e), this)
  }
  setNodeType(e) {
    let t = null
    ;(this.count !== null
      ? (t = Wh(null, e, this.count))
      : Array.isArray(this.getValueFromReference())
        ? (t = Fo(null, e))
        : e === 'texture'
          ? (t = Ji(null))
          : e === 'cubeTexture'
            ? (t = xM(null))
            : (t = Rt(null, e)),
      this.group !== null && t.setGroup(this.group),
      this.name !== null && t.label(this.name),
      (this.node = t.getSelf()))
  }
  getNodeType(e) {
    return (
      this.node === null && (this.updateReference(e), this.updateValue()),
      this.node.getNodeType(e)
    )
  }
  getValueFromReference(e = this.reference) {
    const { properties: t } = this
    let i = e[t[0]]
    for (let r = 1; r < t.length; r++) i = i[t[r]]
    return i
  }
  updateReference(e) {
    return ((this.reference = this.object !== null ? this.object : e.object), this.reference)
  }
  setup() {
    return (this.updateValue(), this.node)
  }
  update() {
    this.updateValue()
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType)
    const e = this.getValueFromReference()
    Array.isArray(e) ? (this.node.array = e) : (this.node.value = e)
  }
}
const Pn = (n, e, t) => Fe(new _0(n, e, t)),
  tv = (n, e, t, i) => Fe(new _0(n, e, i, t))
class kz extends _0 {
  static get type() {
    return 'MaterialReferenceNode'
  }
  constructor(e, t, i = null) {
    ;(super(e, t, i), (this.material = i), (this.isMaterialReferenceNode = !0))
  }
  updateReference(e) {
    return ((this.reference = this.material !== null ? this.material : e.material), this.reference)
  }
}
const _l = (n, e, t = null) => Fe(new kz(n, e, t)),
  x0 = _e(
    (n) => (
      n.geometry.hasAttribute('tangent') === !1 && n.geometry.computeTangents(),
      ea('tangent', 'vec4')
    )
  )(),
  Xh = x0.xyz.toVar('tangentLocal'),
  Kh = jh.mul(yt(Xh, 0)).xyz.toVarying('v_tangentView').normalize().toVar('tangentView'),
  SM = Kh.transformDirection(ss).toVarying('v_tangentWorld').normalize().toVar('tangentWorld'),
  bx = Kh.toVar('transformedTangentView'),
  zz = bx.transformDirection(ss).normalize().toVar('transformedTangentWorld'),
  Yh = (n) => n.mul(x0.w).xyz,
  Vz = er(Yh(Sx.cross(x0)), 'v_bitangentGeometry')
    .normalize()
    .toVar('bitangentGeometry'),
  Hz = er(Yh(cr.cross(Xh)), 'v_bitangentLocal')
    .normalize()
    .toVar('bitangentLocal'),
  AM = er(Yh(no.cross(Kh)), 'v_bitangentView')
    .normalize()
    .toVar('bitangentView'),
  $z = er(Yh(hM.cross(SM)), 'v_bitangentWorld')
    .normalize()
    .toVar('bitangentWorld'),
  bM = Yh(na.cross(bx)).normalize().toVar('transformedBitangentView'),
  Gz = bM.transformDirection(ss).normalize().toVar('transformedBitangentWorld'),
  Tx = is(Kh, AM, no),
  TM = Cr.mul(Tx),
  Wz = (n, e) => n.sub(TM.mul(e)),
  Qz = (() => {
    let n = qc.cross(Cr)
    return (
      (n = n.cross(qc).normalize()),
      (n = Ln(n, na, kC.mul(BC.oneMinus()).oneMinus().pow2().pow2()).normalize()),
      n
    )
  })(),
  jz = _e((n) => {
    const { eye_pos: e, surf_norm: t, mapN: i, uv: r } = n,
      s = e.dFdx(),
      o = e.dFdy(),
      a = r.dFdx(),
      l = r.dFdy(),
      c = t,
      u = o.cross(c),
      d = c.cross(s),
      h = u.mul(a.x).add(d.mul(l.x)),
      f = u.mul(a.y).add(d.mul(l.y)),
      p = h.dot(h).max(f.dot(f)),
      g = qh.mul(p.inverseSqrt())
    return On(h.mul(i.x, g), f.mul(i.y, g), c.mul(i.z)).normalize()
  })
class qz extends Un {
  static get type() {
    return 'NormalMapNode'
  }
  constructor(e, t = null) {
    ;(super('vec3'), (this.node = e), (this.scaleNode = t), (this.normalMapType = pm))
  }
  setup(e) {
    const { normalMapType: t, scaleNode: i } = this
    let r = this.node.mul(2).sub(1)
    i !== null && (r = ve(r.xy.mul(i), r.z))
    let s = null
    return (
      t === I5
        ? (s = Ax(r))
        : t === pm &&
          (e.hasGeometryAttribute('tangent') === !0
            ? (s = Tx.mul(r).normalize())
            : (s = jz({ eye_pos: Yn, surf_norm: no, mapN: r, uv: xn() }))),
      s
    )
  }
}
const nv = Pe(qz),
  Xz = _e(({ textureNode: n, bumpScale: e }) => {
    const t = (r) => n.cache().context({ getUV: (s) => r(s.uvNode || xn()), forceUVContext: !0 }),
      i = ce(t((r) => r))
    return He(ce(t((r) => r.add(r.dFdx()))).sub(i), ce(t((r) => r.add(r.dFdy()))).sub(i)).mul(e)
  }),
  Kz = _e((n) => {
    const { surf_pos: e, surf_norm: t, dHdxy: i } = n,
      r = e.dFdx().normalize(),
      s = e.dFdy().normalize(),
      o = t,
      a = s.cross(o),
      l = o.cross(r),
      c = r.dot(a).mul(qh),
      u = c.sign().mul(i.x.mul(a).add(i.y.mul(l)))
    return c.abs().mul(t).sub(u).normalize()
  })
class Yz extends Un {
  static get type() {
    return 'BumpMapNode'
  }
  constructor(e, t = null) {
    ;(super('vec3'), (this.textureNode = e), (this.scaleNode = t))
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1,
      t = Xz({ textureNode: this.textureNode, bumpScale: e })
    return Kz({ surf_pos: Yn, surf_norm: no, dHdxy: t })
  }
}
const wM = Pe(Yz),
  hb = new Map()
class Me extends ut {
  static get type() {
    return 'MaterialNode'
  }
  constructor(e) {
    ;(super(), (this.scope = e))
  }
  getCache(e, t) {
    let i = hb.get(e)
    return (i === void 0 && ((i = _l(e, t)), hb.set(e, i)), i)
  }
  getFloat(e) {
    return this.getCache(e, 'float')
  }
  getColor(e) {
    return this.getCache(e, 'color')
  }
  getTexture(e) {
    return this.getCache(e === 'map' ? 'map' : e + 'Map', 'texture')
  }
  setup(e) {
    const t = e.context.material,
      i = this.scope
    let r = null
    if (i === Me.COLOR) {
      const s = t.color !== void 0 ? this.getColor(i) : ve()
      t.map && t.map.isTexture === !0 ? (r = s.mul(this.getTexture('map'))) : (r = s)
    } else if (i === Me.OPACITY) {
      const s = this.getFloat(i)
      t.alphaMap && t.alphaMap.isTexture === !0 ? (r = s.mul(this.getTexture('alpha'))) : (r = s)
    } else if (i === Me.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0
        ? (r = this.getTexture('specular').r)
        : (r = ce(1))
    else if (i === Me.SPECULAR_INTENSITY) {
      const s = this.getFloat(i)
      t.specularIntensityMap && t.specularIntensityMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).a))
        : (r = s)
    } else if (i === Me.SPECULAR_COLOR) {
      const s = this.getColor(i)
      t.specularColorMap && t.specularColorMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).rgb))
        : (r = s)
    } else if (i === Me.ROUGHNESS) {
      const s = this.getFloat(i)
      t.roughnessMap && t.roughnessMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).g))
        : (r = s)
    } else if (i === Me.METALNESS) {
      const s = this.getFloat(i)
      t.metalnessMap && t.metalnessMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).b))
        : (r = s)
    } else if (i === Me.EMISSIVE) {
      const s = this.getFloat('emissiveIntensity'),
        o = this.getColor(i).mul(s)
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? (r = o.mul(this.getTexture(i))) : (r = o)
    } else if (i === Me.NORMAL)
      t.normalMap
        ? ((r = nv(this.getTexture('normal'), this.getCache('normalScale', 'vec2'))),
          (r.normalMapType = t.normalMapType))
        : t.bumpMap
          ? (r = wM(this.getTexture('bump').r, this.getFloat('bumpScale')))
          : (r = no)
    else if (i === Me.CLEARCOAT) {
      const s = this.getFloat(i)
      t.clearcoatMap && t.clearcoatMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).r))
        : (r = s)
    } else if (i === Me.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat(i)
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).r))
        : (r = s)
    } else if (i === Me.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap
        ? (r = nv(this.getTexture(i), this.getCache(i + 'Scale', 'vec2')))
        : (r = no)
    else if (i === Me.SHEEN) {
      const s = this.getColor('sheenColor').mul(this.getFloat('sheen'))
      t.sheenColorMap && t.sheenColorMap.isTexture === !0
        ? (r = s.mul(this.getTexture('sheenColor').rgb))
        : (r = s)
    } else if (i === Me.SHEEN_ROUGHNESS) {
      const s = this.getFloat(i)
      ;(t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0
        ? (r = s.mul(this.getTexture(i).a))
        : (r = s),
        (r = r.clamp(0.07, 1)))
    } else if (i === Me.ANISOTROPY)
      if (t.anisotropyMap && t.anisotropyMap.isTexture === !0) {
        const s = this.getTexture(i)
        r = p0(Mc.x, Mc.y, Mc.y.negate(), Mc.x).mul(s.rg.mul(2).sub(He(1)).normalize().mul(s.b))
      } else r = Mc
    else if (i === Me.IRIDESCENCE_THICKNESS) {
      const s = Pn('1', 'float', t.iridescenceThicknessRange)
      if (t.iridescenceThicknessMap) {
        const o = Pn('0', 'float', t.iridescenceThicknessRange)
        r = s.sub(o).mul(this.getTexture(i).g).add(o)
      } else r = s
    } else if (i === Me.TRANSMISSION) {
      const s = this.getFloat(i)
      t.transmissionMap ? (r = s.mul(this.getTexture(i).r)) : (r = s)
    } else if (i === Me.THICKNESS) {
      const s = this.getFloat(i)
      t.thicknessMap ? (r = s.mul(this.getTexture(i).g)) : (r = s)
    } else if (i === Me.IOR) r = this.getFloat(i)
    else if (i === Me.LIGHT_MAP) r = this.getTexture(i).rgb.mul(this.getFloat('lightMapIntensity'))
    else if (i === Me.AO)
      r = this.getTexture(i).r.sub(1).mul(this.getFloat('aoMapIntensity')).add(1)
    else {
      const s = this.getNodeType(e)
      r = this.getCache(i, s)
    }
    return r
  }
}
Me.ALPHA_TEST = 'alphaTest'
Me.COLOR = 'color'
Me.OPACITY = 'opacity'
Me.SHININESS = 'shininess'
Me.SPECULAR = 'specular'
Me.SPECULAR_STRENGTH = 'specularStrength'
Me.SPECULAR_INTENSITY = 'specularIntensity'
Me.SPECULAR_COLOR = 'specularColor'
Me.REFLECTIVITY = 'reflectivity'
Me.ROUGHNESS = 'roughness'
Me.METALNESS = 'metalness'
Me.NORMAL = 'normal'
Me.CLEARCOAT = 'clearcoat'
Me.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness'
Me.CLEARCOAT_NORMAL = 'clearcoatNormal'
Me.EMISSIVE = 'emissive'
Me.ROTATION = 'rotation'
Me.SHEEN = 'sheen'
Me.SHEEN_ROUGHNESS = 'sheenRoughness'
Me.ANISOTROPY = 'anisotropy'
Me.IRIDESCENCE = 'iridescence'
Me.IRIDESCENCE_IOR = 'iridescenceIOR'
Me.IRIDESCENCE_THICKNESS = 'iridescenceThickness'
Me.IOR = 'ior'
Me.TRANSMISSION = 'transmission'
Me.THICKNESS = 'thickness'
Me.ATTENUATION_DISTANCE = 'attenuationDistance'
Me.ATTENUATION_COLOR = 'attenuationColor'
Me.LINE_SCALE = 'scale'
Me.LINE_DASH_SIZE = 'dashSize'
Me.LINE_GAP_SIZE = 'gapSize'
Me.LINE_WIDTH = 'linewidth'
Me.LINE_DASH_OFFSET = 'dashOffset'
Me.POINT_SIZE = 'size'
Me.DISPERSION = 'dispersion'
Me.LIGHT_MAP = 'light'
Me.AO = 'ao'
const CM = We(Me, Me.ALPHA_TEST),
  EM = We(Me, Me.COLOR),
  Zz = We(Me, Me.SHININESS),
  MM = We(Me, Me.EMISSIVE),
  RM = We(Me, Me.OPACITY),
  Jz = We(Me, Me.SPECULAR),
  eV = We(Me, Me.SPECULAR_INTENSITY),
  tV = We(Me, Me.SPECULAR_COLOR),
  nV = We(Me, Me.SPECULAR_STRENGTH),
  iV = We(Me, Me.REFLECTIVITY),
  rV = We(Me, Me.ROUGHNESS),
  sV = We(Me, Me.METALNESS),
  IM = We(Me, Me.NORMAL),
  oV = We(Me, Me.CLEARCOAT),
  aV = We(Me, Me.CLEARCOAT_ROUGHNESS),
  lV = We(Me, Me.CLEARCOAT_NORMAL),
  cV = We(Me, Me.ROTATION),
  uV = We(Me, Me.SHEEN),
  dV = We(Me, Me.SHEEN_ROUGHNESS),
  hV = We(Me, Me.ANISOTROPY),
  fV = We(Me, Me.IRIDESCENCE),
  pV = We(Me, Me.IRIDESCENCE_IOR),
  mV = We(Me, Me.IRIDESCENCE_THICKNESS),
  gV = We(Me, Me.TRANSMISSION),
  yV = We(Me, Me.THICKNESS),
  vV = We(Me, Me.IOR),
  _V = We(Me, Me.ATTENUATION_DISTANCE),
  xV = We(Me, Me.ATTENUATION_COLOR),
  SV = We(Me, Me.LINE_SCALE),
  AV = We(Me, Me.LINE_DASH_SIZE),
  bV = We(Me, Me.LINE_GAP_SIZE),
  TV = We(Me, Me.LINE_WIDTH),
  wV = We(Me, Me.LINE_DASH_OFFSET),
  CV = We(Me, Me.POINT_SIZE),
  EV = We(Me, Me.DISPERSION),
  NM = We(Me, Me.LIGHT_MAP),
  PM = We(Me, Me.AO),
  Mc = Rt(new je())
    .onReference(function (n) {
      return n.material
    })
    .onRenderUpdate(function ({ material: n }) {
      this.value.set(
        n.anisotropy * Math.cos(n.anisotropyRotation),
        n.anisotropy * Math.sin(n.anisotropyRotation)
      )
    }),
  LM = _e((n) => n.context.setupModelViewProjection(), 'vec4')
    .once()()
    .toVarying('v_modelViewProjection')
class vn extends ut {
  static get type() {
    return 'IndexNode'
  }
  constructor(e) {
    ;(super('uint'), (this.scope = e), (this.isIndexNode = !0))
  }
  generate(e) {
    const t = this.getNodeType(e),
      i = this.scope
    let r
    if (i === vn.VERTEX) r = e.getVertexIndex()
    else if (i === vn.INSTANCE) r = e.getInstanceIndex()
    else if (i === vn.DRAW) r = e.getDrawIndex()
    else if (i === vn.INVOCATION_LOCAL) r = e.getInvocationLocalIndex()
    else if (i === vn.INVOCATION_SUBGROUP) r = e.getInvocationSubgroupIndex()
    else if (i === vn.SUBGROUP) r = e.getSubgroupIndex()
    else throw new Error('THREE.IndexNode: Unknown scope: ' + i)
    let s
    return (
      e.shaderStage === 'vertex' || e.shaderStage === 'compute'
        ? (s = r)
        : (s = er(this).build(e, t)),
      s
    )
  }
}
vn.VERTEX = 'vertex'
vn.INSTANCE = 'instance'
vn.SUBGROUP = 'subgroup'
vn.INVOCATION_LOCAL = 'invocationLocal'
vn.INVOCATION_SUBGROUP = 'invocationSubgroup'
vn.DRAW = 'draw'
const DM = We(vn, vn.VERTEX),
  Zh = We(vn, vn.INSTANCE),
  MV = We(vn, vn.SUBGROUP),
  RV = We(vn, vn.INVOCATION_SUBGROUP),
  IV = We(vn, vn.INVOCATION_LOCAL),
  FM = We(vn, vn.DRAW)
class OM extends ut {
  static get type() {
    return 'InstanceNode'
  }
  constructor(e, t, i) {
    ;(super('void'),
      (this.count = e),
      (this.instanceMatrix = t),
      (this.instanceColor = i),
      (this.instanceMatrixNode = null),
      (this.instanceColorNode = null),
      (this.updateType = Wt.FRAME),
      (this.buffer = null),
      (this.bufferColor = null))
  }
  setup(e) {
    const { count: t, instanceMatrix: i, instanceColor: r } = this
    let { instanceMatrixNode: s, instanceColorNode: o } = this
    if (s === null) {
      if (t <= 1e3) s = Wh(i.array, 'mat4', Math.max(t, 1)).element(Zh)
      else {
        const l = new iD(i.array, 16, 1)
        this.buffer = l
        const c = i.usage === Ca ? ev : Em,
          u = [c(l, 'vec4', 16, 0), c(l, 'vec4', 16, 4), c(l, 'vec4', 16, 8), c(l, 'vec4', 16, 12)]
        s = Ll(...u)
      }
      this.instanceMatrixNode = s
    }
    if (r && o === null) {
      const l = new Ko(r.array, 3),
        c = r.usage === Ca ? ev : Em
      ;((this.bufferColor = l), (o = ve(c(l, 'vec3', 3, 0))), (this.instanceColorNode = o))
    }
    const a = s.mul(Nn).xyz
    if ((Nn.assign(a), e.hasGeometryAttribute('normal'))) {
      const l = pM(cr, s)
      cr.assign(l)
    }
    this.instanceColorNode !== null && yh('vec3', 'vInstanceColor').assign(this.instanceColorNode)
  }
  update() {
    ;(this.instanceMatrix.usage !== Ca &&
      this.buffer !== null &&
      this.instanceMatrix.version !== this.buffer.version &&
      (this.buffer.version = this.instanceMatrix.version),
      this.instanceColor &&
        this.instanceColor.usage !== Ca &&
        this.bufferColor !== null &&
        this.instanceColor.version !== this.bufferColor.version &&
        (this.bufferColor.version = this.instanceColor.version))
  }
}
const NV = Pe(OM)
class PV extends OM {
  static get type() {
    return 'InstancedMeshNode'
  }
  constructor(e) {
    const { count: t, instanceMatrix: i, instanceColor: r } = e
    ;(super(t, i, r), (this.instancedMesh = e))
  }
}
const BM = Pe(PV)
class LV extends ut {
  static get type() {
    return 'BatchNode'
  }
  constructor(e) {
    ;(super('void'), (this.batchMesh = e), (this.batchingIdNode = null))
  }
  setup(e) {
    this.batchingIdNode === null &&
      (e.getDrawIndex() === null ? (this.batchingIdNode = Zh) : (this.batchingIdNode = FM))
    const i = _e(([p]) => {
        const g = de(Fa(Rn(this.batchMesh._indirectTexture), 0)),
          y = de(p).modInt(g),
          m = de(p).div(g)
        return Rn(this.batchMesh._indirectTexture, Xn(y, m)).x
      }).setLayout({
        name: 'getIndirectIndex',
        type: 'uint',
        inputs: [{ name: 'id', type: 'int' }],
      })(de(this.batchingIdNode)),
      r = this.batchMesh._matricesTexture,
      s = Fa(Rn(r), 0),
      o = ce(i).mul(4).toInt().toVar(),
      a = o.modInt(s),
      l = o.div(de(s)),
      c = Ll(
        Rn(r, Xn(a, l)),
        Rn(r, Xn(a.add(1), l)),
        Rn(r, Xn(a.add(2), l)),
        Rn(r, Xn(a.add(3), l))
      ),
      u = this.batchMesh._colorsTexture
    if (u !== null) {
      const g = _e(([y]) => {
        const m = Fa(Rn(u), 0).x,
          v = y,
          x = v.modInt(m),
          _ = v.div(m)
        return Rn(u, Xn(x, _)).rgb
      }).setLayout({
        name: 'getBatchingColor',
        type: 'vec3',
        inputs: [{ name: 'id', type: 'int' }],
      })(i)
      yh('vec3', 'vBatchColor').assign(g)
    }
    const d = is(c)
    Nn.assign(c.mul(Nn))
    const h = cr.div(ve(d[0].dot(d[0]), d[1].dot(d[1]), d[2].dot(d[2]))),
      f = d.mul(h).xyz
    ;(cr.assign(f), e.hasGeometryAttribute('tangent') && Xh.mulAssign(d))
  }
}
const UM = Pe(LV),
  fb = new WeakMap()
class kM extends ut {
  static get type() {
    return 'SkinningNode'
  }
  constructor(e, t = !1) {
    ;(super('void'),
      (this.skinnedMesh = e),
      (this.useReference = t),
      (this.updateType = Wt.OBJECT),
      (this.skinIndexNode = ea('skinIndex', 'uvec4')),
      (this.skinWeightNode = ea('skinWeight', 'vec4')))
    let i, r, s
    ;(t
      ? ((i = Pn('bindMatrix', 'mat4')),
        (r = Pn('bindMatrixInverse', 'mat4')),
        (s = tv('skeleton.boneMatrices', 'mat4', e.skeleton.bones.length)))
      : ((i = Rt(e.bindMatrix, 'mat4')),
        (r = Rt(e.bindMatrixInverse, 'mat4')),
        (s = Wh(e.skeleton.boneMatrices, 'mat4', e.skeleton.bones.length))),
      (this.bindMatrixNode = i),
      (this.bindMatrixInverseNode = r),
      (this.boneMatricesNode = s),
      (this.previousBoneMatricesNode = null))
  }
  getSkinnedPosition(e = this.boneMatricesNode, t = Nn) {
    const {
        skinIndexNode: i,
        skinWeightNode: r,
        bindMatrixNode: s,
        bindMatrixInverseNode: o,
      } = this,
      a = e.element(i.x),
      l = e.element(i.y),
      c = e.element(i.z),
      u = e.element(i.w),
      d = s.mul(t),
      h = On(a.mul(r.x).mul(d), l.mul(r.y).mul(d), c.mul(r.z).mul(d), u.mul(r.w).mul(d))
    return o.mul(h).xyz
  }
  getSkinnedNormal(e = this.boneMatricesNode, t = cr) {
    const {
        skinIndexNode: i,
        skinWeightNode: r,
        bindMatrixNode: s,
        bindMatrixInverseNode: o,
      } = this,
      a = e.element(i.x),
      l = e.element(i.y),
      c = e.element(i.z),
      u = e.element(i.w)
    let d = On(r.x.mul(a), r.y.mul(l), r.z.mul(c), r.w.mul(u))
    return ((d = o.mul(d).mul(s)), d.transformDirection(t).xyz)
  }
  getPreviousSkinnedPosition(e) {
    const t = e.object
    return (
      this.previousBoneMatricesNode === null &&
        ((t.skeleton.previousBoneMatrices = new Float32Array(t.skeleton.boneMatrices)),
        (this.previousBoneMatricesNode = tv(
          'skeleton.previousBoneMatrices',
          'mat4',
          t.skeleton.bones.length
        ))),
      this.getSkinnedPosition(this.previousBoneMatricesNode, Mm)
    )
  }
  needsPreviousBoneMatrices(e) {
    const t = e.renderer.getMRT()
    return (t && t.has('velocity')) || hC(e.object).useVelocity === !0
  }
  setup(e) {
    this.needsPreviousBoneMatrices(e) && Mm.assign(this.getPreviousSkinnedPosition(e))
    const t = this.getSkinnedPosition()
    if ((Nn.assign(t), e.hasGeometryAttribute('normal'))) {
      const i = this.getSkinnedNormal()
      ;(cr.assign(i), e.hasGeometryAttribute('tangent') && Xh.assign(i))
    }
  }
  generate(e, t) {
    if (t !== 'void') return Nn.build(e, t)
  }
  update(e) {
    const i = (this.useReference ? e.object : this.skinnedMesh).skeleton
    fb.get(i) !== e.frameId &&
      (fb.set(i, e.frameId),
      this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices),
      i.update())
  }
}
const DV = (n) => Fe(new kM(n)),
  zM = (n) => Fe(new kM(n, !0))
class FV extends ut {
  static get type() {
    return 'LoopNode'
  }
  constructor(e = []) {
    ;(super(), (this.params = e))
  }
  getVarName(e) {
    return String.fromCharCode(105 + e)
  }
  getProperties(e) {
    const t = e.getNodeProperties(this)
    if (t.stackNode !== void 0) return t
    const i = {}
    for (let s = 0, o = this.params.length - 1; s < o; s++) {
      const a = this.params[s],
        l = (a.isNode !== !0 && a.name) || this.getVarName(s),
        c = (a.isNode !== !0 && a.type) || 'int'
      i[l] = ka(l, c)
    }
    const r = e.addStack()
    return (
      (t.returnsNode = this.params[this.params.length - 1](i, r, e)),
      (t.stackNode = r),
      e.removeStack(),
      t
    )
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e)
    return t ? t.getNodeType(e) : 'void'
  }
  setup(e) {
    this.getProperties(e)
  }
  generate(e) {
    const t = this.getProperties(e),
      i = this.params,
      r = t.stackNode
    for (let a = 0, l = i.length - 1; a < l; a++) {
      const c = i[a]
      let u = null,
        d = null,
        h = null,
        f = null,
        p = null,
        g = null
      c.isNode
        ? ((f = 'int'), (h = this.getVarName(a)), (u = '0'), (d = c.build(e, f)), (p = '<'))
        : ((f = c.type || 'int'),
          (h = c.name || this.getVarName(a)),
          (u = c.start),
          (d = c.end),
          (p = c.condition),
          (g = c.update),
          typeof u == 'number' ? (u = e.generateConst(f, u)) : u && u.isNode && (u = u.build(e, f)),
          typeof d == 'number' ? (d = e.generateConst(f, d)) : d && d.isNode && (d = d.build(e, f)),
          u !== void 0 && d === void 0
            ? ((u = u + ' - 1'), (d = '0'), (p = '>='))
            : d !== void 0 && u === void 0 && ((u = '0'), (p = '<')),
          p === void 0 && (Number(u) > Number(d) ? (p = '>=') : (p = '<')))
      const y = { start: u, end: d },
        m = y.start,
        v = y.end
      let x = '',
        _ = '',
        S = ''
      ;(g ||
        (f === 'int' || f === 'uint'
          ? p.includes('<')
            ? (g = '++')
            : (g = '--')
          : p.includes('<')
            ? (g = '+= 1.')
            : (g = '-= 1.')),
        (x += e.getVar(f, h) + ' = ' + m),
        (_ += h + ' ' + p + ' ' + v),
        (S += h + ' ' + g))
      const C = 'for ( '.concat(x, '; ').concat(_, '; ').concat(S, ' )')
      e.addFlowCode((a === 0 ? '\n' : '') + e.tab + C + ' {\n\n').addFlowTab()
    }
    const s = r.build(e, 'void'),
      o = t.returnsNode ? t.returnsNode.build(e) : ''
    e.removeFlowTab().addFlowCode('\n' + e.tab + s)
    for (let a = 0, l = this.params.length - 1; a < l; a++)
      e.addFlowCode((a === 0 ? '' : e.tab) + '}\n\n').removeFlowTab()
    return (e.addFlowTab(), o)
  }
}
const cn = (...n) => Fe(new FV(Pl(n, 'int'))).append(),
  OV = () => ka('continue').append(),
  VM = () => ka('break').append(),
  BV = (...n) => (console.warn('TSL.LoopNode: loop() has been renamed to Loop().'), cn(...n)),
  e1 = new WeakMap(),
  pr = new Mt(),
  pb = _e(({ bufferMap: n, influence: e, stride: t, width: i, depth: r, offset: s }) => {
    const o = de(DM).mul(t).add(s),
      a = o.div(i),
      l = o.sub(a.mul(i))
    return Rn(n, Xn(l, a)).depth(r).mul(e)
  })
function UV(n) {
  const e = n.morphAttributes.position !== void 0,
    t = n.morphAttributes.normal !== void 0,
    i = n.morphAttributes.color !== void 0,
    r = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
    s = r !== void 0 ? r.length : 0
  let o = e1.get(n)
  if (o === void 0 || o.count !== s) {
    let m = function () {
      ;(g.dispose(), e1.delete(n), n.removeEventListener('dispose', m))
    }
    o !== void 0 && o.texture.dispose()
    const a = n.morphAttributes.position || [],
      l = n.morphAttributes.normal || [],
      c = n.morphAttributes.color || []
    let u = 0
    ;(e === !0 && (u = 1), t === !0 && (u = 2), i === !0 && (u = 3))
    let d = n.attributes.position.count * u,
      h = 1
    const f = 4096
    d > f && ((h = Math.ceil(d / f)), (d = f))
    const p = new Float32Array(d * h * 4 * s),
      g = new T_(p, d, h, s)
    ;((g.type = nr), (g.needsUpdate = !0))
    const y = u * 4
    for (let v = 0; v < s; v++) {
      const x = a[v],
        _ = l[v],
        S = c[v],
        C = d * h * 4 * v
      for (let A = 0; A < x.count; A++) {
        const R = A * y
        ;(e === !0 &&
          (pr.fromBufferAttribute(x, A),
          (p[C + R + 0] = pr.x),
          (p[C + R + 1] = pr.y),
          (p[C + R + 2] = pr.z),
          (p[C + R + 3] = 0)),
          t === !0 &&
            (pr.fromBufferAttribute(_, A),
            (p[C + R + 4] = pr.x),
            (p[C + R + 5] = pr.y),
            (p[C + R + 6] = pr.z),
            (p[C + R + 7] = 0)),
          i === !0 &&
            (pr.fromBufferAttribute(S, A),
            (p[C + R + 8] = pr.x),
            (p[C + R + 9] = pr.y),
            (p[C + R + 10] = pr.z),
            (p[C + R + 11] = S.itemSize === 4 ? pr.w : 1)))
      }
    }
    ;((o = { count: s, texture: g, stride: u, size: new je(d, h) }),
      e1.set(n, o),
      n.addEventListener('dispose', m))
  }
  return o
}
class kV extends ut {
  static get type() {
    return 'MorphNode'
  }
  constructor(e) {
    ;(super('void'),
      (this.mesh = e),
      (this.morphBaseInfluence = Rt(1)),
      (this.updateType = Wt.OBJECT))
  }
  setup(e) {
    const { geometry: t } = e,
      i = t.morphAttributes.position !== void 0,
      r = t.hasAttribute('normal') && t.morphAttributes.normal !== void 0,
      s = t.morphAttributes.position || t.morphAttributes.normal || t.morphAttributes.color,
      o = s !== void 0 ? s.length : 0,
      { texture: a, stride: l, size: c } = UV(t)
    ;(i === !0 && Nn.mulAssign(this.morphBaseInfluence),
      r === !0 && cr.mulAssign(this.morphBaseInfluence))
    const u = de(c.width)
    cn(o, ({ i: d }) => {
      const h = ce(0).toVar()
      ;(this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0
        ? h.assign(Rn(this.mesh.morphTexture, Xn(de(d).add(1), de(Zh))).r)
        : h.assign(Pn('morphTargetInfluences', 'float').element(d).toVar()),
        i === !0 &&
          Nn.addAssign(
            pb({ bufferMap: a, influence: h, stride: l, width: u, depth: d, offset: de(0) })
          ),
        r === !0 &&
          cr.addAssign(
            pb({ bufferMap: a, influence: h, stride: l, width: u, depth: d, offset: de(1) })
          ))
    })
  }
  update() {
    const e = this.morphBaseInfluence
    this.mesh.geometry.morphTargetsRelative
      ? (e.value = 1)
      : (e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, i) => t + i, 0))
  }
}
const HM = Pe(kV)
class $M extends ut {
  static get type() {
    return 'LightingNode'
  }
  constructor() {
    ;(super('vec3'), (this.isLightingNode = !0))
  }
}
class zV extends $M {
  static get type() {
    return 'AONode'
  }
  constructor(e = null) {
    ;(super(), (this.aoNode = e))
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode)
  }
}
class VV extends DE {
  static get type() {
    return 'LightingContextNode'
  }
  constructor(e, t = null, i = null, r = null) {
    ;(super(e),
      (this.lightingModel = t),
      (this.backdropNode = i),
      (this.backdropAlphaNode = r),
      (this._value = null))
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this,
      i = ve().toVar('directDiffuse'),
      r = ve().toVar('directSpecular'),
      s = ve().toVar('indirectDiffuse'),
      o = ve().toVar('indirectSpecular'),
      a = { directDiffuse: i, directSpecular: r, indirectDiffuse: s, indirectSpecular: o }
    return {
      radiance: ve().toVar('radiance'),
      irradiance: ve().toVar('irradiance'),
      iblIrradiance: ve().toVar('iblIrradiance'),
      ambientOcclusion: ce(1).toVar('ambientOcclusion'),
      reflectedLight: a,
      backdrop: e,
      backdropAlpha: t,
    }
  }
  setup(e) {
    return (
      (this.value = this._value || (this._value = this.getContext())),
      (this.value.lightingModel = this.lightingModel || e.context.lightingModel),
      super.setup(e)
    )
  }
}
const GM = Pe(VV)
class HV extends $M {
  static get type() {
    return 'IrradianceNode'
  }
  constructor(e) {
    ;(super(), (this.node = e))
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node)
  }
}
let dd, hd
class Vn extends ut {
  static get type() {
    return 'ScreenNode'
  }
  constructor(e) {
    ;(super(), (this.scope = e), (this.isViewportNode = !0))
  }
  getNodeType() {
    return this.scope === Vn.VIEWPORT ? 'vec4' : 'vec2'
  }
  getUpdateType() {
    let e = Wt.NONE
    return (
      (this.scope === Vn.SIZE || this.scope === Vn.VIEWPORT) && (e = Wt.RENDER),
      (this.updateType = e),
      e
    )
  }
  update({ renderer: e }) {
    const t = e.getRenderTarget()
    this.scope === Vn.VIEWPORT
      ? t !== null
        ? hd.copy(t.viewport)
        : (e.getViewport(hd), hd.multiplyScalar(e.getPixelRatio()))
      : t !== null
        ? ((dd.width = t.width), (dd.height = t.height))
        : e.getDrawingBufferSize(dd)
  }
  setup() {
    const e = this.scope
    let t = null
    return (
      e === Vn.SIZE
        ? (t = Rt(dd || (dd = new je())))
        : e === Vn.VIEWPORT
          ? (t = Rt(hd || (hd = new Mt())))
          : (t = He(Jh.div(Rm))),
      t
    )
  }
  generate(e) {
    if (this.scope === Vn.COORDINATE) {
      let t = e.getFragCoord()
      if (e.isFlipY()) {
        const i = e.getNodeProperties(Rm).outputNode.build(e)
        t = ''
          .concat(e.getType('vec2'), '( ')
          .concat(t, '.x, ')
          .concat(i, '.y - ')
          .concat(t, '.y )')
      }
      return t
    }
    return super.generate(e)
  }
}
Vn.COORDINATE = 'coordinate'
Vn.VIEWPORT = 'viewport'
Vn.SIZE = 'size'
Vn.UV = 'uv'
const Ga = We(Vn, Vn.UV),
  Rm = We(Vn, Vn.SIZE),
  Jh = We(Vn, Vn.COORDINATE),
  wx = We(Vn, Vn.VIEWPORT),
  WM = wx.zw,
  QM = Jh.sub(wx.xy),
  $V = QM.div(WM),
  GV = _e(
    () => (
      console.warn(
        'TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.'
      ),
      Rm
    ),
    'vec2'
  ).once()(),
  WV = _e(
    () => (
      console.warn('TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.'),
      Ga
    ),
    'vec2'
  ).once()(),
  QV = _e(
    () => (
      console.warn(
        'TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.'
      ),
      Ga.flipY()
    ),
    'vec2'
  ).once()(),
  fd = new je()
class S0 extends ta {
  static get type() {
    return 'ViewportTextureNode'
  }
  constructor(e = Ga, t = null, i = null) {
    ;(i === null && ((i = new G5()), (i.minFilter = Ws)),
      super(i, e, t),
      (this.generateMipmaps = !1),
      (this.isOutputTextureNode = !0),
      (this.updateBeforeType = Wt.FRAME))
  }
  updateBefore(e) {
    const t = e.renderer
    t.getDrawingBufferSize(fd)
    const i = this.value
    ;(i.image.width !== fd.width || i.image.height !== fd.height) &&
      ((i.image.width = fd.width), (i.image.height = fd.height), (i.needsUpdate = !0))
    const r = i.generateMipmaps
    ;((i.generateMipmaps = this.generateMipmaps),
      t.copyFramebufferToTexture(i),
      (i.generateMipmaps = r))
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value)
    return ((e.generateMipmaps = this.generateMipmaps), e)
  }
}
const jV = Pe(S0),
  qV = Pe(S0, null, null, { generateMipmaps: !0 })
let t1 = null
class XV extends S0 {
  static get type() {
    return 'ViewportDepthTextureNode'
  }
  constructor(e = Ga, t = null) {
    ;(t1 === null && (t1 = new Ha()), super(e, t, t1))
  }
}
const Cx = Pe(XV)
class sr extends ut {
  static get type() {
    return 'ViewportDepthNode'
  }
  constructor(e, t = null) {
    ;(super('float'), (this.scope = e), (this.valueNode = t), (this.isViewportDepthNode = !0))
  }
  generate(e) {
    const { scope: t } = this
    return t === sr.DEPTH_BASE ? e.getFragDepth() : super.generate(e)
  }
  setup({ camera: e }) {
    const { scope: t } = this,
      i = this.valueNode
    let r = null
    if (t === sr.DEPTH_BASE) i !== null && (r = qM().assign(i))
    else if (t === sr.DEPTH) e.isPerspectiveCamera ? (r = jM(Yn.z, Sa, Aa)) : (r = Xc(Yn.z, Sa, Aa))
    else if (t === sr.LINEAR_DEPTH)
      if (i !== null)
        if (e.isPerspectiveCamera) {
          const s = Ex(i, Sa, Aa)
          r = Xc(s, Sa, Aa)
        } else r = i
      else r = Xc(Yn.z, Sa, Aa)
    return r
  }
}
sr.DEPTH_BASE = 'depthBase'
sr.DEPTH = 'depth'
sr.LINEAR_DEPTH = 'linearDepth'
const Xc = (n, e, t) => n.add(e).div(e.sub(t)),
  KV = (n, e, t) => e.sub(t).mul(n).sub(e),
  jM = (n, e, t) => e.add(n).mul(t).div(t.sub(e).mul(n)),
  Ex = (n, e, t) => e.mul(t).div(t.sub(e).mul(n).sub(t)),
  Mx = (n, e, t) => {
    e = e.max(1e-6).toVar()
    const i = Ho(n.negate().div(e)),
      r = Ho(t.div(e))
    return i.div(r)
  },
  YV = (n, e, t) => {
    const i = n.mul(rx(t.div(e)))
    return ce(Math.E).pow(i).mul(e).negate()
  },
  qM = Pe(sr, sr.DEPTH_BASE),
  Rx = We(sr, sr.DEPTH),
  Im = Pe(sr, sr.LINEAR_DEPTH),
  ZV = Im(Cx())
Rx.assign = (n) => qM(n)
class JV extends ut {
  constructor(e) {
    ;(super('float'), (this.name = e), (this.isBuiltinNode = !0))
  }
  generate() {
    return this.name
  }
}
const eH = Pe(JV)
class ts extends ut {
  static get type() {
    return 'ClippingNode'
  }
  constructor(e = ts.DEFAULT) {
    ;(super(), (this.scope = e))
  }
  setup(e) {
    super.setup(e)
    const t = e.clippingContext,
      { intersectionPlanes: i, unionPlanes: r } = t
    return (
      (this.hardwareClipping = e.material.hardwareClipping),
      this.scope === ts.ALPHA_TO_COVERAGE
        ? this.setupAlphaToCoverage(i, r)
        : this.scope === ts.HARDWARE
          ? this.setupHardwareClipping(r, e)
          : this.setupDefault(i, r)
    )
  }
  setupAlphaToCoverage(e, t) {
    return _e(() => {
      const i = ce().toVar('distanceToPlane'),
        r = ce().toVar('distanceToGradient'),
        s = ce(1).toVar('clipOpacity'),
        o = t.length
      if (this.hardwareClipping === !1 && o > 0) {
        const l = Fo(t)
        cn(o, ({ i: c }) => {
          const u = l.element(c)
          ;(i.assign(Yn.dot(u.xyz).negate().add(u.w)),
            r.assign(i.fwidth().div(2)),
            s.mulAssign(Hl(r.negate(), r, i)))
        })
      }
      const a = e.length
      if (a > 0) {
        const l = Fo(e),
          c = ce(1).toVar('intersectionClipOpacity')
        ;(cn(a, ({ i: u }) => {
          const d = l.element(u)
          ;(i.assign(Yn.dot(d.xyz).negate().add(d.w)),
            r.assign(i.fwidth().div(2)),
            c.mulAssign(Hl(r.negate(), r, i).oneMinus()))
        }),
          s.mulAssign(c.oneMinus()))
      }
      ;(hs.a.mulAssign(s), hs.a.equal(0).discard())
    })()
  }
  setupDefault(e, t) {
    return _e(() => {
      const i = t.length
      if (this.hardwareClipping === !1 && i > 0) {
        const s = Fo(t)
        cn(i, ({ i: o }) => {
          const a = s.element(o)
          Yn.dot(a.xyz).greaterThan(a.w).discard()
        })
      }
      const r = e.length
      if (r > 0) {
        const s = Fo(e),
          o = Yo(!0).toVar('clipped')
        ;(cn(r, ({ i: a }) => {
          const l = s.element(a)
          o.assign(Yn.dot(l.xyz).greaterThan(l.w).and(o))
        }),
          o.discard())
      }
    })()
  }
  setupHardwareClipping(e, t) {
    const i = e.length
    return (
      t.enableHardwareClipping(i),
      _e(() => {
        const r = Fo(e),
          s = eH(t.getClipDistance())
        cn(i, ({ i: o }) => {
          const a = r.element(o),
            l = Yn.dot(a.xyz).sub(a.w).negate()
          s.element(o).assign(l)
        })
      })()
    )
  }
}
ts.ALPHA_TO_COVERAGE = 'alphaToCoverage'
ts.DEFAULT = 'default'
ts.HARDWARE = 'hardware'
const tH = () => Fe(new ts()),
  nH = () => Fe(new ts(ts.ALPHA_TO_COVERAGE)),
  iH = () => Fe(new ts(ts.HARDWARE)),
  rH = 0.05,
  mb = _e(([n]) =>
    sa(xt(1e4, Tr(xt(17, n.x).add(xt(0.1, n.y)))).mul(On(0.1, mn(Tr(xt(13, n.y).add(n.x))))))
  ),
  gb = _e(([n]) => mb(He(mb(n.xy), n.z))),
  sH = _e(([n]) => {
    const e = ui(Cm(lx(n.xyz)), Cm(cx(n.xyz))),
      t = ce(1).div(ce(rH).mul(e)).toVar('pixScale'),
      i = He(Su(Xs(Ho(t))), Su(g0(Ho(t)))),
      r = He(gb(Xs(i.x.mul(n.xyz))), gb(Xs(i.y.mul(n.xyz)))),
      s = sa(Ho(t)),
      o = On(xt(s.oneMinus(), r.x), xt(s, r.y)),
      a = Dr(s, s.oneMinus()),
      l = ve(
        o.mul(o).div(xt(2, a).mul(Bt(1, a))),
        o.sub(xt(0.5, a)).div(Bt(1, a)),
        Bt(
          1,
          Bt(1, o)
            .mul(Bt(1, o))
            .div(xt(2, a).mul(Bt(1, a)))
        )
      ),
      c = o.lessThan(a.oneMinus()).select(o.lessThan(a).select(l.x, l.y), l.z)
    return Jo(c, 1e-6, 1)
  }).setLayout({
    name: 'getAlphaHashThreshold',
    type: 'float',
    inputs: [{ name: 'position', type: 'vec3' }],
  })
class _h extends es {
  static get type() {
    return 'NodeMaterial'
  }
  get type() {
    return this.constructor.type
  }
  set type(e) {}
  constructor() {
    ;(super(),
      (this.isNodeMaterial = !0),
      (this.fog = !0),
      (this.lights = !1),
      (this.hardwareClipping = !1),
      (this.lightsNode = null),
      (this.envNode = null),
      (this.aoNode = null),
      (this.colorNode = null),
      (this.normalNode = null),
      (this.opacityNode = null),
      (this.backdropNode = null),
      (this.backdropAlphaNode = null),
      (this.alphaTestNode = null),
      (this.positionNode = null),
      (this.geometryNode = null),
      (this.depthNode = null),
      (this.shadowPositionNode = null),
      (this.receivedShadowNode = null),
      (this.castShadowNode = null),
      (this.outputNode = null),
      (this.mrtNode = null),
      (this.fragmentNode = null),
      (this.vertexNode = null))
  }
  customProgramCacheKey() {
    return this.type + uC(this)
  }
  build(e) {
    this.setup(e)
  }
  setupObserver(e) {
    return new ZU(e)
  }
  setup(e) {
    ;((e.context.setupNormal = () => this.setupNormal(e)),
      (e.context.setupPositionView = () => this.setupPositionView(e)),
      (e.context.setupModelViewProjection = () => this.setupModelViewProjection(e)))
    const t = e.renderer,
      i = t.getRenderTarget()
    e.addStack()
    const r = this.vertexNode || this.setupVertex(e)
    ;((e.stack.outputNode = r),
      this.setupHardwareClipping(e),
      this.geometryNode !== null &&
        (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)),
      e.addFlow('vertex', e.removeStack()),
      e.addStack())
    let s
    const o = this.setupClipping(e)
    if (
      ((this.depthWrite === !0 || this.depthTest === !0) &&
        (i !== null
          ? i.depthBuffer === !0 && this.setupDepth(e)
          : t.depth === !0 && this.setupDepth(e)),
      this.fragmentNode === null)
    ) {
      ;(this.setupDiffuseColor(e), this.setupVariants(e))
      const a = this.setupLighting(e)
      o !== null && e.stack.add(o)
      const l = yt(a, hs.a).max(0)
      if (
        ((s = this.setupOutput(e, l)),
        vh.assign(s),
        this.outputNode !== null && (s = this.outputNode),
        i !== null)
      ) {
        const c = t.getMRT(),
          u = this.mrtNode
        c !== null ? ((s = c), u !== null && (s = c.merge(u))) : u !== null && (s = u)
      }
    } else {
      let a = this.fragmentNode
      ;(a.isOutputStructNode !== !0 && (a = yt(a)), (s = this.setupOutput(e, a)))
    }
    ;((e.stack.outputNode = s),
      e.addFlow('fragment', e.removeStack()),
      (e.observer = this.setupObserver(e)))
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null
    const { unionPlanes: t, intersectionPlanes: i } = e.clippingContext
    let r = null
    if (t.length > 0 || i.length > 0) {
      const s = e.renderer.samples
      this.alphaToCoverage && s > 1 ? (r = nH()) : e.stack.add(tH())
    }
    return r
  }
  setupHardwareClipping(e) {
    if (((this.hardwareClipping = !1), e.clippingContext === null)) return
    const t = e.clippingContext.unionPlanes.length
    t > 0 &&
      t <= 8 &&
      e.isAvailable('clipDistance') &&
      (e.stack.add(iH()), (this.hardwareClipping = !0))
  }
  setupDepth(e) {
    const { renderer: t, camera: i } = e
    let r = this.depthNode
    if (r === null) {
      const s = t.getMRT()
      s && s.has('depth')
        ? (r = s.get('depth'))
        : t.logarithmicDepthBuffer === !0 &&
          (i.isPerspectiveCamera ? (r = Mx(Yn.z, Sa, Aa)) : (r = Xc(Yn.z, Sa, Aa)))
    }
    r !== null && Rx.assign(r).append()
  }
  setupPositionView() {
    return jh.mul(Nn).xyz
  }
  setupModelViewProjection() {
    return Qh.mul(Yn)
  }
  setupVertex(e) {
    return (e.addStack(), this.setupPosition(e), (e.context.vertex = e.removeStack()), LM)
  }
  setupPosition(e) {
    const { object: t, geometry: i } = e
    if (
      ((i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color) &&
        HM(t).append(),
      t.isSkinnedMesh === !0 && zM(t).append(),
      this.displacementMap)
    ) {
      const r = _l('displacementMap', 'texture'),
        s = _l('displacementScale', 'float'),
        o = _l('displacementBias', 'float')
      Nn.addAssign(cr.normalize().mul(r.x.mul(s).add(o)))
    }
    return (
      t.isBatchedMesh && UM(t).append(),
      t.isInstancedMesh &&
        t.instanceMatrix &&
        t.instanceMatrix.isInstancedBufferAttribute === !0 &&
        BM(t).append(),
      this.positionNode !== null &&
        Nn.assign(this.positionNode.context({ isPositionNodeInput: !0 })),
      Nn
    )
  }
  setupDiffuseColor({ object: e, geometry: t }) {
    let i = this.colorNode ? yt(this.colorNode) : EM
    ;(this.vertexColors === !0 &&
      t.hasAttribute('color') &&
      (i = yt(i.xyz.mul(ea('color', 'vec3')), i.a)),
      e.instanceColor && (i = yh('vec3', 'vInstanceColor').mul(i)),
      e.isBatchedMesh && e._colorsTexture && (i = yh('vec3', 'vBatchColor').mul(i)),
      hs.assign(i))
    const r = this.opacityNode ? ce(this.opacityNode) : RM
    if ((hs.a.assign(hs.a.mul(r)), this.alphaTestNode !== null || this.alphaTest > 0)) {
      const s = this.alphaTestNode !== null ? ce(this.alphaTestNode) : CM
      hs.a.lessThanEqual(s).discard()
    }
    ;(this.alphaHash === !0 && hs.a.lessThan(sH(Nn)).discard(),
      this.transparent === !1 &&
        this.blending === zo &&
        this.alphaToCoverage === !1 &&
        hs.a.assign(1))
  }
  setupVariants() {}
  setupOutgoingLight() {
    return this.lights === !0 ? ve(0) : hs.rgb
  }
  setupNormal() {
    return this.normalNode ? ve(this.normalNode) : IM
  }
  setupEnvironment() {
    let e = null
    return (
      this.envNode
        ? (e = this.envNode)
        : this.envMap &&
          (e = this.envMap.isCubeTexture ? _l('envMap', 'cubeTexture') : _l('envMap', 'texture')),
      e
    )
  }
  setupLightMap(e) {
    let t = null
    return (e.material.lightMap && (t = new HV(NM)), t)
  }
  setupLights(e) {
    const t = [],
      i = this.setupEnvironment(e)
    i && i.isLightingNode && t.push(i)
    const r = this.setupLightMap(e)
    if ((r && r.isLightingNode && t.push(r), this.aoNode !== null || e.material.aoMap)) {
      const o = this.aoNode !== null ? this.aoNode : PM
      t.push(new zV(o))
    }
    let s = this.lightsNode || e.lightsNode
    return (t.length > 0 && (s = e.renderer.lighting.createNode([...s.getLights(), ...t])), s)
  }
  setupLightingModel() {}
  setupLighting(e) {
    const { material: t } = e,
      { backdropNode: i, backdropAlphaNode: r, emissiveNode: s } = this,
      a = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null
    let l = this.setupOutgoingLight(e)
    if (a && a.getScope().hasLights) {
      const c = this.setupLightingModel(e)
      l = GM(a, c, i, r)
    } else i !== null && (l = ve(r !== null ? Ln(l, i, r) : i))
    return (
      ((s && s.isNode === !0) || (t.emissive && t.emissive.isColor === !0)) &&
        (Zy.assign(ve(s || MM)), (l = l.add(Zy))),
      l
    )
  }
  setupOutput(e, t) {
    if (this.fog === !0) {
      const i = e.fogNode
      i && (vh.assign(t), (t = yt(i)))
    }
    return t
  }
  setDefaultValues(e) {
    for (const i in e) {
      const r = e[i]
      this[i] === void 0 && ((this[i] = r), r && r.clone && (this[i] = r.clone()))
    }
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype)
    for (const i in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, i) === void 0 &&
        t[i].get !== void 0 &&
        Object.defineProperty(this.constructor.prototype, i, t[i])
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string'
    t && (e = { textures: {}, images: {}, nodes: {} })
    const i = es.prototype.toJSON.call(this, e),
      r = bm(this)
    i.inputNodes = {}
    for (const { property: o, childNode: a } of r) i.inputNodes[o] = a.toJSON(e).uuid
    function s(o) {
      const a = []
      for (const l in o) {
        const c = o[l]
        ;(delete c.metadata, a.push(c))
      }
      return a
    }
    if (t) {
      const o = s(e.textures),
        a = s(e.images),
        l = s(e.nodes)
      ;(o.length > 0 && (i.textures = o),
        a.length > 0 && (i.images = a),
        l.length > 0 && (i.nodes = l))
    }
    return i
  }
  copy(e) {
    return (
      (this.lightsNode = e.lightsNode),
      (this.envNode = e.envNode),
      (this.colorNode = e.colorNode),
      (this.normalNode = e.normalNode),
      (this.opacityNode = e.opacityNode),
      (this.backdropNode = e.backdropNode),
      (this.backdropAlphaNode = e.backdropAlphaNode),
      (this.alphaTestNode = e.alphaTestNode),
      (this.positionNode = e.positionNode),
      (this.geometryNode = e.geometryNode),
      (this.depthNode = e.depthNode),
      (this.shadowPositionNode = e.shadowPositionNode),
      (this.receivedShadowNode = e.receivedShadowNode),
      (this.castShadowNode = e.castShadowNode),
      (this.outputNode = e.outputNode),
      (this.mrtNode = e.mrtNode),
      (this.fragmentNode = e.fragmentNode),
      (this.vertexNode = e.vertexNode),
      super.copy(e)
    )
  }
}
let n1 = null
class oH extends S0 {
  static get type() {
    return 'ViewportSharedTextureNode'
  }
  constructor(e = Ga, t = null) {
    ;(n1 === null && (n1 = new G5()), super(e, t, n1))
  }
  updateReference() {
    return this
  }
}
const aH = Pe(oH),
  lH = (n) => Fe(n).mul(0.5).add(0.5),
  cH = (n) => Fe(n).mul(2).sub(1)
class uH extends Un {
  static get type() {
    return 'EquirectUVNode'
  }
  constructor(e = cM) {
    ;(super('vec2'), (this.dirNode = e))
  }
  setup() {
    const e = this.dirNode,
      t = e.z
        .atan(e.x)
        .mul(1 / (Math.PI * 2))
        .add(0.5),
      i = e.y
        .clamp(-1, 1)
        .asin()
        .mul(1 / Math.PI)
        .add(0.5)
    return He(t, i)
  }
}
const dH = Pe(uH),
  XM = _e(({ f0: n, f90: e, dotVH: t }) => {
    const i = t.mul(-5.55473).sub(6.98316).mul(t).exp2()
    return n.mul(i.oneMinus()).add(e.mul(i))
  }),
  hH = _e((n) => n.diffuseColor.mul(1 / Math.PI)),
  KM = _e((n) => {
    if (n.geometry.hasAttribute('normal') === !1) return ce(0)
    const e = no.dFdx().abs().max(no.dFdy().abs())
    return e.x.max(e.y).max(e.z)
  }),
  fH = _e((n) => {
    const { roughness: e } = n,
      t = KM()
    let i = e.max(0.0525)
    return ((i = i.add(t)), (i = i.min(1)), i)
  }),
  YM = _e(({ alpha: n, dotNL: e, dotNV: t }) => {
    const i = n.pow2(),
      r = e.mul(i.add(i.oneMinus().mul(t.pow2())).sqrt()),
      s = t.mul(i.add(i.oneMinus().mul(e.pow2())).sqrt())
    return Zo(0.5, r.add(s).max(rE))
  }).setLayout({
    name: 'V_GGX_SmithCorrelated',
    type: 'float',
    inputs: [
      { name: 'alpha', type: 'float' },
      { name: 'dotNL', type: 'float' },
      { name: 'dotNV', type: 'float' },
    ],
  }),
  pH = _e(
    ({ alphaT: n, alphaB: e, dotTV: t, dotBV: i, dotTL: r, dotBL: s, dotNV: o, dotNL: a }) => {
      const l = a.mul(ve(n.mul(t), e.mul(i), o).length()),
        c = o.mul(ve(n.mul(r), e.mul(s), a).length())
      return Zo(0.5, l.add(c)).saturate()
    }
  ).setLayout({
    name: 'V_GGX_SmithCorrelated_Anisotropic',
    type: 'float',
    inputs: [
      { name: 'alphaT', type: 'float', qualifier: 'in' },
      { name: 'alphaB', type: 'float', qualifier: 'in' },
      { name: 'dotTV', type: 'float', qualifier: 'in' },
      { name: 'dotBV', type: 'float', qualifier: 'in' },
      { name: 'dotTL', type: 'float', qualifier: 'in' },
      { name: 'dotBL', type: 'float', qualifier: 'in' },
      { name: 'dotNV', type: 'float', qualifier: 'in' },
      { name: 'dotNL', type: 'float', qualifier: 'in' },
    ],
  }),
  ZM = _e(({ alpha: n, dotNH: e }) => {
    const t = n.pow2(),
      i = e.pow2().mul(t.oneMinus()).oneMinus()
    return t.div(i.pow2()).mul(1 / Math.PI)
  }).setLayout({
    name: 'D_GGX',
    type: 'float',
    inputs: [
      { name: 'alpha', type: 'float' },
      { name: 'dotNH', type: 'float' },
    ],
  }),
  mH = ce(1 / Math.PI),
  gH = _e(({ alphaT: n, alphaB: e, dotNH: t, dotTH: i, dotBH: r }) => {
    const s = n.mul(e),
      o = ve(e.mul(i), n.mul(r), s.mul(t)),
      a = o.dot(o),
      l = s.div(a)
    return mH.mul(s.mul(l.pow2()))
  }).setLayout({
    name: 'D_GGX_Anisotropic',
    type: 'float',
    inputs: [
      { name: 'alphaT', type: 'float', qualifier: 'in' },
      { name: 'alphaB', type: 'float', qualifier: 'in' },
      { name: 'dotNH', type: 'float', qualifier: 'in' },
      { name: 'dotTH', type: 'float', qualifier: 'in' },
      { name: 'dotBH', type: 'float', qualifier: 'in' },
    ],
  }),
  yH = _e((n) => {
    const {
        lightDirection: e,
        f0: t,
        f90: i,
        roughness: r,
        f: s,
        USE_IRIDESCENCE: o,
        USE_ANISOTROPY: a,
      } = n,
      l = n.normalView || na,
      c = r.pow2(),
      u = e.add(Cr).normalize(),
      d = l.dot(e).clamp(),
      h = l.dot(Cr).clamp(),
      f = l.dot(u).clamp(),
      p = Cr.dot(u).clamp()
    let g = XM({ f0: t, f90: i, dotVH: p }),
      y,
      m
    if ((gh(o) && (g = UC.mix(g, s)), gh(a))) {
      const v = Dp.dot(e),
        x = Dp.dot(Cr),
        _ = Dp.dot(u),
        S = qc.dot(e),
        C = qc.dot(Cr),
        A = qc.dot(u)
      ;((y = pH({
        alphaT: Jy,
        alphaB: c,
        dotTV: x,
        dotBV: C,
        dotTL: v,
        dotBL: S,
        dotNV: h,
        dotNL: d,
      })),
        (m = gH({ alphaT: Jy, alphaB: c, dotNH: f, dotTH: _, dotBH: A })))
    } else ((y = YM({ alpha: c, dotNL: d, dotNV: h })), (m = ZM({ alpha: c, dotNH: f })))
    return g.mul(y).mul(m)
  }),
  vH = _e(({ roughness: n, dotNV: e }) => {
    const t = yt(-1, -0.0275, -0.572, 0.022),
      i = yt(1, 0.0425, 1.04, -0.04),
      r = n.mul(t).add(i),
      s = r.x.mul(r.x).min(e.mul(-9.28).exp2()).mul(r.x).add(r.y)
    return He(-1.04, 1.04).mul(s).add(r.zw)
  }).setLayout({
    name: 'DFGApprox',
    type: 'vec2',
    inputs: [
      { name: 'roughness', type: 'float' },
      { name: 'dotNV', type: 'vec3' },
    ],
  }),
  _H = _e(({ f: n, f90: e, dotVH: t }) => {
    const i = t.oneMinus().saturate(),
      r = i.mul(i),
      s = i.mul(r, r).clamp(0, 0.9999)
    return n.sub(ve(e).mul(s)).div(s.oneMinus())
  }).setLayout({
    name: 'Schlick_to_F0',
    type: 'vec3',
    inputs: [
      { name: 'f', type: 'vec3' },
      { name: 'f90', type: 'float' },
      { name: 'dotVH', type: 'float' },
    ],
  }),
  A0 = 1 / 6,
  JM = (n) => xt(A0, xt(n, xt(n, n.negate().add(3)).sub(3)).add(1)),
  iv = (n) => xt(A0, xt(n, xt(n, xt(3, n).sub(6))).add(4)),
  e4 = (n) => xt(A0, xt(n, xt(n, xt(-3, n).add(3)).add(3)).add(1)),
  rv = (n) => xt(A0, gs(n, 3)),
  yb = (n) => JM(n).add(iv(n)),
  vb = (n) => e4(n).add(rv(n)),
  _b = (n) => On(-1, iv(n).div(JM(n).add(iv(n)))),
  xb = (n) => On(1, rv(n).div(e4(n).add(rv(n)))),
  Sb = (n, e, t) => {
    const i = n.uvNode,
      r = xt(i, e.zw).add(0.5),
      s = Xs(r),
      o = sa(r),
      a = yb(o.x),
      l = vb(o.x),
      c = _b(o.x),
      u = xb(o.x),
      d = _b(o.y),
      h = xb(o.y),
      f = He(s.x.add(c), s.y.add(d)).sub(0.5).mul(e.xy),
      p = He(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy),
      g = He(s.x.add(c), s.y.add(h)).sub(0.5).mul(e.xy),
      y = He(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy),
      m = yb(o.y).mul(On(a.mul(n.sample(f).level(t)), l.mul(n.sample(p).level(t)))),
      v = vb(o.y).mul(On(a.mul(n.sample(g).level(t)), l.mul(n.sample(y).level(t))))
    return m.add(v)
  },
  xH = _e(([n, e = ce(3)]) => {
    const t = He(n.size(de(e))),
      i = He(n.size(de(e.add(1)))),
      r = Zo(1, t),
      s = Zo(1, i),
      o = Sb(n, yt(r, t), Xs(e)),
      a = Sb(n, yt(s, i), g0(e))
    return sa(e).mix(o, a)
  })
ve(0.04)
ce(1)
const Ab = ce(1),
  sv = ce(-2),
  ep = ce(0.8),
  i1 = ce(-1),
  tp = ce(0.4),
  r1 = ce(2),
  np = ce(0.305),
  s1 = ce(3),
  bb = ce(0.21),
  SH = ce(4),
  Tb = ce(4),
  AH = ce(16),
  bH = _e(([n]) => {
    const e = ve(mn(n)).toVar(),
      t = ce(-1).toVar()
    return (
      Dt(e.x.greaterThan(e.z), () => {
        Dt(e.x.greaterThan(e.y), () => {
          t.assign(rr(n.x.greaterThan(0), 0, 3))
        }).Else(() => {
          t.assign(rr(n.y.greaterThan(0), 1, 4))
        })
      }).Else(() => {
        Dt(e.z.greaterThan(e.y), () => {
          t.assign(rr(n.z.greaterThan(0), 2, 5))
        }).Else(() => {
          t.assign(rr(n.y.greaterThan(0), 1, 4))
        })
      }),
      t
    )
  }).setLayout({ name: 'getFace', type: 'float', inputs: [{ name: 'direction', type: 'vec3' }] }),
  TH = _e(([n, e]) => {
    const t = He().toVar()
    return (
      Dt(e.equal(0), () => {
        t.assign(He(n.z, n.y).div(mn(n.x)))
      })
        .ElseIf(e.equal(1), () => {
          t.assign(He(n.x.negate(), n.z.negate()).div(mn(n.y)))
        })
        .ElseIf(e.equal(2), () => {
          t.assign(He(n.x.negate(), n.y).div(mn(n.z)))
        })
        .ElseIf(e.equal(3), () => {
          t.assign(He(n.z.negate(), n.y).div(mn(n.x)))
        })
        .ElseIf(e.equal(4), () => {
          t.assign(He(n.x.negate(), n.z).div(mn(n.y)))
        })
        .Else(() => {
          t.assign(He(n.x, n.y).div(mn(n.z)))
        }),
      xt(0.5, t.add(1))
    )
  }).setLayout({
    name: 'getUV',
    type: 'vec2',
    inputs: [
      { name: 'direction', type: 'vec3' },
      { name: 'face', type: 'float' },
    ],
  }),
  wH = _e(([n]) => {
    const e = ce(0).toVar()
    return (
      Dt(n.greaterThanEqual(ep), () => {
        e.assign(Ab.sub(n).mul(i1.sub(sv)).div(Ab.sub(ep)).add(sv))
      })
        .ElseIf(n.greaterThanEqual(tp), () => {
          e.assign(ep.sub(n).mul(r1.sub(i1)).div(ep.sub(tp)).add(i1))
        })
        .ElseIf(n.greaterThanEqual(np), () => {
          e.assign(tp.sub(n).mul(s1.sub(r1)).div(tp.sub(np)).add(r1))
        })
        .ElseIf(n.greaterThanEqual(bb), () => {
          e.assign(np.sub(n).mul(SH.sub(s1)).div(np.sub(bb)).add(s1))
        })
        .Else(() => {
          e.assign(ce(-2).mul(Ho(xt(1.16, n))))
        }),
      e
    )
  }).setLayout({
    name: 'roughnessToMip',
    type: 'float',
    inputs: [{ name: 'roughness', type: 'float' }],
  }),
  t4 = _e(([n, e]) => {
    const t = n.toVar()
    t.assign(xt(2, t).sub(1))
    const i = ve(t, 1).toVar()
    return (
      Dt(e.equal(0), () => {
        i.assign(i.zyx)
      })
        .ElseIf(e.equal(1), () => {
          ;(i.assign(i.xzy), i.xz.mulAssign(-1))
        })
        .ElseIf(e.equal(2), () => {
          i.x.mulAssign(-1)
        })
        .ElseIf(e.equal(3), () => {
          ;(i.assign(i.zyx), i.xz.mulAssign(-1))
        })
        .ElseIf(e.equal(4), () => {
          ;(i.assign(i.xzy), i.xy.mulAssign(-1))
        })
        .ElseIf(e.equal(5), () => {
          i.z.mulAssign(-1)
        }),
      i
    )
  }).setLayout({
    name: 'getDirection',
    type: 'vec3',
    inputs: [
      { name: 'uv', type: 'vec2' },
      { name: 'face', type: 'float' },
    ],
  }),
  n4 = _e(([n, e, t, i, r, s]) => {
    const o = ce(t),
      a = ve(e),
      l = Jo(wH(o), sv, s),
      c = sa(l),
      u = Xs(l),
      d = ve(ov(n, a, u, i, r, s)).toVar()
    return (
      Dt(c.notEqual(0), () => {
        const h = ve(ov(n, a, u.add(1), i, r, s)).toVar()
        d.assign(Ln(d, h, c))
      }),
      d
    )
  }),
  ov = _e(([n, e, t, i, r, s]) => {
    const o = ce(t).toVar(),
      a = ve(e),
      l = ce(bH(a)).toVar(),
      c = ce(ui(Tb.sub(o), 0)).toVar()
    o.assign(ui(o, Tb))
    const u = ce(Su(o)).toVar(),
      d = He(TH(a, l).mul(u.sub(2)).add(1)).toVar()
    return (
      Dt(l.greaterThan(2), () => {
        ;(d.y.addAssign(u), l.subAssign(3))
      }),
      d.x.addAssign(l.mul(u)),
      d.x.addAssign(c.mul(xt(3, AH))),
      d.y.addAssign(xt(4, Su(s).sub(u))),
      d.x.mulAssign(i),
      d.y.mulAssign(r),
      n.sample(d).grad(He(), He())
    )
  }),
  o1 = _e(
    ({
      envMap: n,
      mipInt: e,
      outputDirection: t,
      theta: i,
      axis: r,
      CUBEUV_TEXEL_WIDTH: s,
      CUBEUV_TEXEL_HEIGHT: o,
      CUBEUV_MAX_MIP: a,
    }) => {
      const l = Ro(i),
        c = t
          .mul(l)
          .add(r.cross(t).mul(Tr(i)))
          .add(r.mul(r.dot(t).mul(l.oneMinus())))
      return ov(n, c, e, s, o, a)
    }
  ),
  CH = _e(
    ({
      n,
      latitudinal: e,
      poleAxis: t,
      outputDirection: i,
      weights: r,
      samples: s,
      dTheta: o,
      mipInt: a,
      envMap: l,
      CUBEUV_TEXEL_WIDTH: c,
      CUBEUV_TEXEL_HEIGHT: u,
      CUBEUV_MAX_MIP: d,
    }) => {
      const h = ve(rr(e, t, v0(t, i))).toVar()
      ;(Dt(ix(h.equals(ve(0))), () => {
        h.assign(ve(i.z, 0, i.x.negate()))
      }),
        h.assign(ql(h)))
      const f = ve().toVar()
      return (
        f.addAssign(
          r
            .element(0)
            .mul(
              o1({
                theta: 0,
                axis: h,
                outputDirection: i,
                mipInt: a,
                envMap: l,
                CUBEUV_TEXEL_WIDTH: c,
                CUBEUV_TEXEL_HEIGHT: u,
                CUBEUV_MAX_MIP: d,
              })
            )
        ),
        cn({ start: de(1), end: n }, ({ i: p }) => {
          Dt(p.greaterThanEqual(s), () => {
            VM()
          })
          const g = ce(o.mul(ce(p))).toVar()
          ;(f.addAssign(
            r
              .element(p)
              .mul(
                o1({
                  theta: g.mul(-1),
                  axis: h,
                  outputDirection: i,
                  mipInt: a,
                  envMap: l,
                  CUBEUV_TEXEL_WIDTH: c,
                  CUBEUV_TEXEL_HEIGHT: u,
                  CUBEUV_MAX_MIP: d,
                })
              )
          ),
            f.addAssign(
              r
                .element(p)
                .mul(
                  o1({
                    theta: g,
                    axis: h,
                    outputDirection: i,
                    mipInt: a,
                    envMap: l,
                    CUBEUV_TEXEL_WIDTH: c,
                    CUBEUV_TEXEL_HEIGHT: u,
                    CUBEUV_MAX_MIP: d,
                  })
                )
            ))
        }),
        yt(f, 1)
      )
    }
  )
let Nm = null
const wb = new WeakMap()
function EH(n) {
  const e = Math.log2(n) - 2,
    t = 1 / n
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 112)), texelHeight: t, maxMip: e }
}
function MH(n) {
  let e = wb.get(n)
  if ((e !== void 0 ? e.pmremVersion : -1) !== n.pmremVersion) {
    const i = n.image
    if (n.isCubeTexture)
      if (IH(i)) e = Nm.fromCubemap(n, e)
      else return null
    else if (NH(i)) e = Nm.fromEquirectangular(n, e)
    else return null
    ;((e.pmremVersion = n.pmremVersion), wb.set(n, e))
  }
  return e.texture
}
class RH extends Un {
  static get type() {
    return 'PMREMNode'
  }
  constructor(e, t = null, i = null) {
    ;(super('vec3'),
      (this._value = e),
      (this._pmrem = null),
      (this.uvNode = t),
      (this.levelNode = i),
      (this._generator = null))
    const r = new Wn()
    ;((r.isRenderTargetTexture = !0),
      (this._texture = Ji(r)),
      (this._width = Rt(0)),
      (this._height = Rt(0)),
      (this._maxMip = Rt(0)),
      (this.updateBeforeType = Wt.RENDER))
  }
  set value(e) {
    ;((this._value = e), (this._pmrem = null))
  }
  get value() {
    return this._value
  }
  updateFromTexture(e) {
    const t = EH(e.image.height)
    ;((this._texture.value = e),
      (this._width.value = t.texelWidth),
      (this._height.value = t.texelHeight),
      (this._maxMip.value = t.maxMip))
  }
  updateBefore() {
    let e = this._pmrem
    const t = e ? e.pmremVersion : -1,
      i = this._value
    t !== i.pmremVersion &&
      (i.isPMREMTexture === !0 ? (e = i) : (e = MH(i)),
      e !== null && ((this._pmrem = e), this.updateFromTexture(e)))
  }
  setup(e) {
    ;(Nm === null && (Nm = e.createPMREMGenerator()), this.updateBefore(e))
    let t = this.uvNode
    t === null && e.context.getUV && (t = e.context.getUV(this))
    const i = this.value
    ;(e.renderer.coordinateSystem === Ir &&
      i.isPMREMTexture !== !0 &&
      i.isRenderTargetTexture === !0 &&
      (t = ve(t.x.negate(), t.yz)),
      (t = ve(t.x, t.y.negate(), t.z)))
    let r = this.levelNode
    return (
      r === null && e.context.getTextureLevel && (r = e.context.getTextureLevel(this)),
      n4(this._texture, t, r, this._width, this._height, this._maxMip)
    )
  }
}
function IH(n) {
  if (n == null) return !1
  let e = 0
  const t = 6
  for (let i = 0; i < t; i++) n[i] !== void 0 && e++
  return e === t
}
function NH(n) {
  return n == null ? !1 : n.height > 0
}
const PH = Pe(RH)
class LH extends Un {
  static get type() {
    return 'MatcapUVNode'
  }
  constructor() {
    super('vec2')
  }
  setup() {
    const e = ve(Cr.z, 0, Cr.x.negate()).normalize(),
      t = Cr.cross(e)
    return He(e.dot(na), t.dot(na)).mul(0.495).add(0.5)
  }
}
const DH = We(LH)
class FH extends Un {
  static get type() {
    return 'RotateNode'
  }
  constructor(e, t) {
    ;(super(), (this.positionNode = e), (this.rotationNode = t))
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e)
  }
  setup(e) {
    const { rotationNode: t, positionNode: i } = this
    if (this.getNodeType(e) === 'vec2') {
      const s = t.cos(),
        o = t.sin()
      return p0(s, o, o.negate(), s).mul(i)
    } else {
      const s = t,
        o = Ll(
          yt(1, 0, 0, 0),
          yt(0, Ro(s.x), Tr(s.x).negate(), 0),
          yt(0, Tr(s.x), Ro(s.x), 0),
          yt(0, 0, 0, 1)
        ),
        a = Ll(
          yt(Ro(s.y), 0, Tr(s.y), 0),
          yt(0, 1, 0, 0),
          yt(Tr(s.y).negate(), 0, Ro(s.y), 0),
          yt(0, 0, 0, 1)
        ),
        l = Ll(
          yt(Ro(s.z), Tr(s.z).negate(), 0, 0),
          yt(Tr(s.z), Ro(s.z), 0, 0),
          yt(0, 0, 1, 0),
          yt(0, 0, 0, 1)
        )
      return o.mul(a).mul(l).mul(yt(i, 1)).xyz
    }
  }
}
const i4 = Pe(FH),
  OH = _e(({ texture: n, uv: e }) => {
    const i = ve().toVar()
    return (
      Dt(e.x.lessThan(1e-4), () => {
        i.assign(ve(1, 0, 0))
      })
        .ElseIf(e.y.lessThan(1e-4), () => {
          i.assign(ve(0, 1, 0))
        })
        .ElseIf(e.z.lessThan(1e-4), () => {
          i.assign(ve(0, 0, 1))
        })
        .ElseIf(e.x.greaterThan(1 - 1e-4), () => {
          i.assign(ve(-1, 0, 0))
        })
        .ElseIf(e.y.greaterThan(1 - 1e-4), () => {
          i.assign(ve(0, -1, 0))
        })
        .ElseIf(e.z.greaterThan(1 - 1e-4), () => {
          i.assign(ve(0, 0, -1))
        })
        .Else(() => {
          const s = n.sample(e.add(ve(-0.01, 0, 0))).r.sub(n.sample(e.add(ve(0.01, 0, 0))).r),
            o = n.sample(e.add(ve(0, -0.01, 0))).r.sub(n.sample(e.add(ve(0, 0.01, 0))).r),
            a = n.sample(e.add(ve(0, 0, -0.01))).r.sub(n.sample(e.add(ve(0, 0, 0.01))).r)
          i.assign(ve(s, o, a))
        }),
      i.normalize()
    )
  })
class BH extends ta {
  static get type() {
    return 'Texture3DNode'
  }
  constructor(e, t = null, i = null) {
    ;(super(e, t, i), (this.isTexture3DNode = !0))
  }
  getInputType() {
    return 'texture3D'
  }
  getDefaultUV() {
    return ve(0.5, 0.5, 0.5)
  }
  setUpdateMatrix() {}
  setupUV(e, t) {
    const i = this.value
    return (
      e.isFlipY() &&
        (i.isRenderTargetTexture === !0 || i.isFramebufferTexture === !0) &&
        (this.sampler
          ? (t = t.flipY())
          : (t = t.setY(de(Fa(this, this.levelNode).y).sub(t.y).sub(1)))),
      t
    )
  }
  generateUV(e, t) {
    return t.build(e, 'vec3')
  }
  normal(e) {
    return OH({ texture: this, uv: e })
  }
}
const UH = Pe(BH)
class kH extends Xt {
  static get type() {
    return 'ParameterNode'
  }
  constructor(e, t = null) {
    ;(super(e, t), (this.isParameterNode = !0))
  }
  getHash() {
    return this.uuid
  }
  generate() {
    return this.name
  }
}
const zH = (n, e) => Fe(new kH(n, e))
class VH extends ut {
  static get type() {
    return 'StackNode'
  }
  constructor(e = null) {
    ;(super(),
      (this.nodes = []),
      (this.outputNode = null),
      (this.parent = e),
      (this._currentCond = null),
      (this.isStackNode = !0))
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : 'void'
  }
  getMemberType(e, t) {
    return this.outputNode ? this.outputNode.getMemberType(e, t) : 'void'
  }
  add(e) {
    return (this.nodes.push(e), this)
  }
  If(e, t) {
    const i = new Gd(t)
    return ((this._currentCond = rr(e, i)), this.add(this._currentCond))
  }
  ElseIf(e, t) {
    const i = new Gd(t),
      r = rr(e, i)
    return ((this._currentCond.elseNode = r), (this._currentCond = r), this)
  }
  Else(e) {
    return ((this._currentCond.elseNode = new Gd(e)), this)
  }
  build(e, ...t) {
    const i = SC()
    Yy(this)
    for (const r of this.nodes) r.build(e, 'void')
    return (Yy(i), this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t))
  }
  else(...e) {
    return (console.warn('TSL.StackNode: .else() has been renamed to .Else().'), this.Else(...e))
  }
  elseif(...e) {
    return (
      console.warn('TSL.StackNode: .elseif() has been renamed to .ElseIf().'),
      this.ElseIf(...e)
    )
  }
}
const HH = Pe(VH)
function $H(n) {
  return Object.entries(n).map(([e, t]) =>
    typeof t == 'string'
      ? { name: e, type: t, atomic: !1 }
      : { name: e, type: t.type, atomic: t.atomic || !1 }
  )
}
class GH extends ut {
  static get type() {
    return 'StructTypeNode'
  }
  constructor(e, t = null) {
    ;(super('struct'),
      (this.membersLayout = $H(e)),
      (this.name = t),
      (this.isStructLayoutNode = !0))
  }
  getLength() {
    let e = 0
    for (const t of this.membersLayout) e += X_(t.type)
    return e
  }
  getMemberType(e, t) {
    const i = this.membersLayout.find((r) => r.name === t)
    return i ? i.type : 'void'
  }
  getNodeType(e) {
    return e.getStructTypeFromNode(this, this.membersLayout, this.name).name
  }
  generate(e) {
    return this.getNodeType(e)
  }
}
class WH extends ut {
  static get type() {
    return 'StructNode'
  }
  constructor(e, t) {
    ;(super('vec3'), (this.structLayoutNode = e), (this.values = t), (this.isStructNode = !0))
  }
  getNodeType(e) {
    return this.structLayoutNode.getNodeType(e)
  }
  getMemberType(e, t) {
    return this.structLayoutNode.getMemberType(e, t)
  }
  generate(e) {
    const t = e.getVarFromNode(this),
      i = t.type,
      r = e.getPropertyName(t)
    return (
      e.addLineFlowCode(
        ''
          .concat(r, ' = ')
          .concat(e.generateStruct(i, this.structLayoutNode.membersLayout, this.values)),
        this
      ),
      t.name
    )
  }
}
const QH = (n, e = null) => {
  const t = new GH(n, e),
    i = (...r) => {
      let s = null
      if (r.length > 0)
        if (r[0].isNode) {
          s = {}
          const o = Object.keys(n)
          for (let a = 0; a < r.length; a++) s[o[a]] = r[a]
        } else s = r[0]
      return Fe(new WH(t, s))
    }
  return ((i.layout = t), (i.isStruct = !0), i)
}
class r4 extends ut {
  static get type() {
    return 'OutputStructNode'
  }
  constructor(...e) {
    ;(super(), (this.members = e), (this.isOutputStructNode = !0))
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this)
    if (t.membersLayout === void 0) {
      const i = this.members,
        r = []
      for (let s = 0; s < i.length; s++) {
        const o = 'm' + s,
          a = i[s].getNodeType(e)
        r.push({ name: o, type: a, index: s })
      }
      ;((t.membersLayout = r),
        (t.structType = e.getOutputStructTypeFromNode(this, t.membersLayout)))
    }
    return t.structType.name
  }
  generate(e) {
    const t = e.getOutputStructName(),
      i = this.members,
      r = t !== '' ? t + '.' : ''
    for (let s = 0; s < i.length; s++) {
      const o = i[s].build(e)
      e.addLineFlowCode(''.concat(r, 'm').concat(s, ' = ').concat(o), this)
    }
    return t
  }
}
const jH = Pe(r4)
function s4(n, e) {
  for (let t = 0; t < n.length; t++) if (n[t].name === e) return t
  return -1
}
class qH extends r4 {
  static get type() {
    return 'MRTNode'
  }
  constructor(e) {
    ;(super(), (this.outputNodes = e), (this.isMRTNode = !0))
  }
  has(e) {
    return this.outputNodes[e] !== void 0
  }
  get(e) {
    return this.outputNodes[e]
  }
  merge(e) {
    const t = { ...this.outputNodes, ...e.outputNodes }
    return o4(t)
  }
  setup(e) {
    const t = this.outputNodes,
      i = e.renderer.getRenderTarget(),
      r = [],
      s = i.textures
    for (const o in t) {
      const a = s4(s, o)
      r[a] = yt(t[o])
    }
    return ((this.members = r), super.setup(e))
  }
}
const o4 = Pe(qH),
  XH = _e(([n]) => {
    const e = n.toUint().mul(747796405).add(2891336453),
      t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737)
    return t
      .shiftRight(22)
      .bitXor(t)
      .toFloat()
      .mul(1 / 2 ** 32)
  }),
  av = (n, e) => gs(xt(4, n.mul(Bt(1, n))), e),
  KH = (n, e) => (n.lessThan(0.5) ? av(n.mul(2), e).div(2) : Bt(1, av(xt(Bt(1, n), 2), e).div(2))),
  YH = (n, e, t) => gs(Zo(gs(n, e), On(gs(n, e), gs(Bt(1, n), t))), 1 / e),
  ZH = (n, e) => Tr(wm.mul(e.mul(n).sub(1))).div(wm.mul(e.mul(n).sub(1))),
  Io = _e(([n]) => n.fract().sub(0.5).abs()).setLayout({
    name: 'tri',
    type: 'float',
    inputs: [{ name: 'x', type: 'float' }],
  }),
  JH = _e(([n]) =>
    ve(Io(n.z.add(Io(n.y.mul(1)))), Io(n.z.add(Io(n.x.mul(1)))), Io(n.y.add(Io(n.x.mul(1)))))
  ).setLayout({ name: 'tri3', type: 'vec3', inputs: [{ name: 'p', type: 'vec3' }] }),
  e$ = _e(([n, e, t]) => {
    const i = ve(n).toVar(),
      r = ce(1.4).toVar(),
      s = ce(0).toVar(),
      o = ve(i).toVar()
    return (
      cn({ start: ce(0), end: ce(3), type: 'float', condition: '<=' }, () => {
        const a = ve(JH(o.mul(2))).toVar()
        ;(i.addAssign(a.add(t.mul(ce(0.1).mul(e)))),
          o.mulAssign(1.8),
          r.mulAssign(1.5),
          i.mulAssign(1.2))
        const l = ce(Io(i.z.add(Io(i.x.add(Io(i.y)))))).toVar()
        ;(s.addAssign(l.div(r)), o.addAssign(0.14))
      }),
      s
    )
  }).setLayout({
    name: 'triNoise3D',
    type: 'float',
    inputs: [
      { name: 'position', type: 'vec3' },
      { name: 'speed', type: 'float' },
      { name: 'time', type: 'float' },
    ],
  })
class t$ extends ut {
  static get type() {
    return 'FunctionOverloadingNode'
  }
  constructor(e = [], ...t) {
    ;(super(),
      (this.functionNodes = e),
      (this.parametersNodes = t),
      (this._candidateFnCall = null),
      (this.global = !0))
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type
  }
  setup(e) {
    const t = this.parametersNodes
    let i = this._candidateFnCall
    if (i === null) {
      let r = null,
        s = -1
      for (const o of this.functionNodes) {
        const l = o.shaderNode.layout
        if (l === null) throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.')
        const c = l.inputs
        if (t.length === c.length) {
          let u = 0
          for (let d = 0; d < t.length; d++) {
            const h = t[d],
              f = c[d]
            h.getNodeType(e) === f.type ? u++ : (u = 0)
          }
          u > s && ((r = o), (s = u))
        }
      }
      this._candidateFnCall = i = r(...t)
    }
    return i
  }
}
const n$ = Pe(t$),
  Ai =
    (n) =>
    (...e) =>
      n$(n, ...e),
  Xl = Rt(0)
    .setGroup(Ut)
    .onRenderUpdate((n) => n.time),
  a4 = Rt(0)
    .setGroup(Ut)
    .onRenderUpdate((n) => n.deltaTime),
  i$ = Rt(0, 'uint')
    .setGroup(Ut)
    .onRenderUpdate((n) => n.frameId),
  r$ = (n = 1) => (console.warn('TSL: timerLocal() is deprecated. Use "time" instead.'), Xl.mul(n)),
  s$ = (n = 1) => (
    console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.'),
    Xl.mul(n)
  ),
  o$ = (n = 1) => (
    console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.'),
    a4.mul(n)
  ),
  a$ = (n = Xl) =>
    n
      .add(0.75)
      .mul(Math.PI * 2)
      .sin()
      .mul(0.5)
      .add(0.5),
  l$ = (n = Xl) => n.fract().round(),
  c$ = (n = Xl) => n.add(0.5).fract().mul(2).sub(1).abs(),
  u$ = (n = Xl) => n.fract(),
  d$ = _e(([n, e, t = He(0.5)]) => i4(n.sub(t), e).add(t)),
  h$ = _e(([n, e, t = He(0.5)]) => {
    const i = n.sub(t),
      r = i.dot(i),
      o = r.mul(r).mul(e)
    return n.add(i.mul(o))
  }),
  f$ = _e(({ position: n = null, horizontal: e = !0, vertical: t = !1 }) => {
    let i
    n !== null ? ((i = Oo.toVar()), (i[3][0] = n.x), (i[3][1] = n.y), (i[3][2] = n.z)) : (i = Oo)
    const r = ss.mul(i)
    return (
      gh(e) && ((r[0][0] = Oo[0].length()), (r[0][1] = 0), (r[0][2] = 0)),
      gh(t) && ((r[1][0] = 0), (r[1][1] = Oo[1].length()), (r[1][2] = 0)),
      (r[2][0] = 0),
      (r[2][1] = 0),
      (r[2][2] = 1),
      Qh.mul(r).mul(Nn)
    )
  }),
  p$ = _e(([n = null]) => {
    const e = Im()
    return Im(Cx(n)).sub(e).lessThan(0).select(Ga, n)
  })
class m$ extends ut {
  static get type() {
    return 'SpriteSheetUVNode'
  }
  constructor(e, t = xn(), i = ce(0)) {
    ;(super('vec2'), (this.countNode = e), (this.uvNode = t), (this.frameNode = i))
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: i } = this,
      { width: r, height: s } = i,
      o = e.mod(r.mul(s)).floor(),
      a = o.mod(r),
      l = s.sub(o.add(1).div(r).ceil()),
      c = i.reciprocal(),
      u = He(a, l)
    return t.add(u).mul(c)
  }
}
const g$ = Pe(m$)
class y$ extends ut {
  static get type() {
    return 'TriplanarTexturesNode'
  }
  constructor(e, t = null, i = null, r = ce(1), s = Nn, o = cr) {
    ;(super('vec4'),
      (this.textureXNode = e),
      (this.textureYNode = t),
      (this.textureZNode = i),
      (this.scaleNode = r),
      (this.positionNode = s),
      (this.normalNode = o))
  }
  setup() {
    const {
      textureXNode: e,
      textureYNode: t,
      textureZNode: i,
      scaleNode: r,
      positionNode: s,
      normalNode: o,
    } = this
    let a = o.abs().normalize()
    a = a.div(a.dot(ve(1)))
    const l = s.yz.mul(r),
      c = s.zx.mul(r),
      u = s.xy.mul(r),
      d = e.value,
      h = t !== null ? t.value : d,
      f = i !== null ? i.value : d,
      p = Ji(d, l).mul(a.x),
      g = Ji(h, c).mul(a.y),
      y = Ji(f, u).mul(a.z)
    return On(p, g, y)
  }
}
const l4 = Pe(y$),
  v$ = (...n) => l4(...n),
  Sc = new Eo(),
  ol = new Y(),
  Ac = new Y(),
  a1 = new Y(),
  pd = new qe(),
  ip = new Y(0, 0, -1),
  Is = new Mt(),
  md = new Y(),
  rp = new Y(),
  gd = new Mt(),
  sp = new je(),
  Pm = new Bh(),
  _$ = Ga.flipX()
Pm.depthTexture = new Ha(1, 1)
let l1 = !1
class Ix extends ta {
  static get type() {
    return 'ReflectorNode'
  }
  constructor(e = {}) {
    ;(super(e.defaultTexture || Pm.texture, _$),
      (this._reflectorBaseNode = e.reflector || new x$(this, e)),
      (this._depthNode = null),
      this.setUpdateMatrix(!1))
  }
  get reflector() {
    return this._reflectorBaseNode
  }
  get target() {
    return this._reflectorBaseNode.target
  }
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== !0)
        throw new Error(
          'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. '
        )
      this._depthNode = Fe(
        new Ix({ defaultTexture: Pm.depthTexture, reflector: this._reflectorBaseNode })
      )
    }
    return this._depthNode
  }
  setup(e) {
    return (e.object.isQuadMesh || this._reflectorBaseNode.build(e), super.setup(e))
  }
  clone() {
    const e = new this.constructor(this.reflectorNode)
    return ((e._reflectorBaseNode = this._reflectorBaseNode), e)
  }
}
class x$ extends ut {
  static get type() {
    return 'ReflectorBaseNode'
  }
  constructor(e, t = {}) {
    super()
    const {
      target: i = new sn(),
      resolution: r = 1,
      generateMipmaps: s = !1,
      bounces: o = !0,
      depth: a = !1,
    } = t
    ;((this.textureNode = e),
      (this.target = i),
      (this.resolution = r),
      (this.generateMipmaps = s),
      (this.bounces = o),
      (this.depth = a),
      (this.updateBeforeType = o ? Wt.RENDER : Wt.FRAME),
      (this.virtualCameras = new WeakMap()),
      (this.renderTargets = new WeakMap()))
  }
  _updateResolution(e, t) {
    const i = this.resolution
    ;(t.getDrawingBufferSize(sp), e.setSize(Math.round(sp.width * i), Math.round(sp.height * i)))
  }
  setup(e) {
    return (this._updateResolution(Pm, e.renderer), super.setup(e))
  }
  getVirtualCamera(e) {
    let t = this.virtualCameras.get(e)
    return (t === void 0 && ((t = e.clone()), this.virtualCameras.set(e, t)), t)
  }
  getRenderTarget(e) {
    let t = this.renderTargets.get(e)
    return (
      t === void 0 &&
        ((t = new Bh(0, 0, { type: ws })),
        this.generateMipmaps === !0 &&
          ((t.texture.minFilter = sP), (t.texture.generateMipmaps = !0)),
        this.depth === !0 && (t.depthTexture = new Ha()),
        this.renderTargets.set(e, t)),
      t
    )
  }
  updateBefore(e) {
    if (this.bounces === !1 && l1) return !1
    l1 = !0
    const { scene: t, camera: i, renderer: r, material: s } = e,
      { target: o } = this,
      a = this.getVirtualCamera(i),
      l = this.getRenderTarget(a)
    if (
      (r.getDrawingBufferSize(sp),
      this._updateResolution(l, r),
      Ac.setFromMatrixPosition(o.matrixWorld),
      a1.setFromMatrixPosition(i.matrixWorld),
      pd.extractRotation(o.matrixWorld),
      ol.set(0, 0, 1),
      ol.applyMatrix4(pd),
      md.subVectors(Ac, a1),
      md.dot(ol) > 0)
    )
      return
    ;(md.reflect(ol).negate(),
      md.add(Ac),
      pd.extractRotation(i.matrixWorld),
      ip.set(0, 0, -1),
      ip.applyMatrix4(pd),
      ip.add(a1),
      rp.subVectors(Ac, ip),
      rp.reflect(ol).negate(),
      rp.add(Ac),
      (a.coordinateSystem = i.coordinateSystem),
      a.position.copy(md),
      a.up.set(0, 1, 0),
      a.up.applyMatrix4(pd),
      a.up.reflect(ol),
      a.lookAt(rp),
      (a.near = i.near),
      (a.far = i.far),
      a.updateMatrixWorld(),
      a.projectionMatrix.copy(i.projectionMatrix),
      Sc.setFromNormalAndCoplanarPoint(ol, Ac),
      Sc.applyMatrix4(a.matrixWorldInverse),
      Is.set(Sc.normal.x, Sc.normal.y, Sc.normal.z, Sc.constant))
    const c = a.projectionMatrix
    ;((gd.x = (Math.sign(Is.x) + c.elements[8]) / c.elements[0]),
      (gd.y = (Math.sign(Is.y) + c.elements[9]) / c.elements[5]),
      (gd.z = -1),
      (gd.w = (1 + c.elements[10]) / c.elements[14]),
      Is.multiplyScalar(1 / Is.dot(gd)))
    const u = 0
    ;((c.elements[2] = Is.x),
      (c.elements[6] = Is.y),
      (c.elements[10] = r.coordinateSystem === Xo ? Is.z - u : Is.z + 1 - u),
      (c.elements[14] = Is.w),
      (this.textureNode.value = l.texture),
      this.depth === !0 && (this.textureNode.getDepthNode().value = l.depthTexture),
      (s.visible = !1))
    const d = r.getRenderTarget(),
      h = r.getMRT(),
      f = r.autoClear
    ;(r.setMRT(null),
      r.setRenderTarget(l),
      (r.autoClear = !0),
      r.render(t, a),
      r.setMRT(h),
      r.setRenderTarget(d),
      (r.autoClear = f),
      (s.visible = !0),
      (l1 = !1))
  }
}
const S$ = (n) => Fe(new Ix(n)),
  c1 = new Bu(-1, 1, 1, -1, 0, 1)
class A$ extends ki {
  constructor(e = !1) {
    super()
    const t = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0]
    ;(this.setAttribute('position', new xi([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
      this.setAttribute('uv', new xi(t, 2)))
  }
}
const b$ = new A$()
class c4 extends pn {
  constructor(e = null) {
    ;(super(b$, e), (this.camera = c1), (this.isQuadMesh = !0))
  }
  async renderAsync(e) {
    return e.renderAsync(this, c1)
  }
  render(e) {
    e.render(this, c1)
  }
}
const T$ = new je()
class w$ extends ta {
  static get type() {
    return 'RTTNode'
  }
  constructor(e, t = null, i = null, r = { type: ws }) {
    const s = new Bh(t, i, r)
    ;(super(s.texture, xn()),
      (this.node = e),
      (this.width = t),
      (this.height = i),
      (this.pixelRatio = 1),
      (this.renderTarget = s),
      (this.textureNeedsUpdate = !0),
      (this.autoUpdate = !0),
      (this._rttNode = null),
      (this._quadMesh = new c4(new _h())),
      (this.updateBeforeType = Wt.RENDER))
  }
  get autoSize() {
    return this.width === null
  }
  setup(e) {
    return (
      (this._rttNode = this.node.context(e.getSharedContext())),
      (this._quadMesh.material.name = 'RTT'),
      (this._quadMesh.material.needsUpdate = !0),
      super.setup(e)
    )
  }
  setSize(e, t) {
    ;((this.width = e), (this.height = t))
    const i = e * this.pixelRatio,
      r = t * this.pixelRatio
    ;(this.renderTarget.setSize(i, r), (this.textureNeedsUpdate = !0))
  }
  setPixelRatio(e) {
    ;((this.pixelRatio = e), this.setSize(this.width, this.height))
  }
  updateBefore({ renderer: e }) {
    if (this.textureNeedsUpdate === !1 && this.autoUpdate === !1) return
    if (((this.textureNeedsUpdate = !1), this.autoSize === !0)) {
      this.pixelRatio = e.getPixelRatio()
      const i = e.getSize(T$)
      this.setSize(i.width, i.height)
    }
    this._quadMesh.material.fragmentNode = this._rttNode
    const t = e.getRenderTarget()
    ;(e.setRenderTarget(this.renderTarget), this._quadMesh.render(e), e.setRenderTarget(t))
  }
  clone() {
    const e = new ta(this.value, this.uvNode, this.levelNode)
    return ((e.sampler = this.sampler), (e.referenceNode = this), e)
  }
}
const u4 = (n, ...e) => Fe(new w$(Fe(n), ...e)),
  C$ = (n, ...e) => (n.isTextureNode ? n : n.isPassNode ? n.getTextureNode() : u4(n, ...e)),
  Rc = _e(([n, e, t], i) => {
    let r
    i.renderer.coordinateSystem === Xo
      ? ((n = He(n.x, n.y.oneMinus()).mul(2).sub(1)), (r = yt(ve(n, e), 1)))
      : (r = yt(ve(n.x, n.y.oneMinus(), e).mul(2).sub(1), 1))
    const s = yt(t.mul(r))
    return s.xyz.div(s.w)
  }),
  E$ = _e(([n, e]) => {
    const t = e.mul(yt(n, 1)),
      i = t.xy.div(t.w).mul(0.5).add(0.5).toVar()
    return He(i.x, i.y.oneMinus())
  }),
  M$ = _e(([n, e, t]) => {
    const i = Fa(Rn(e)),
      r = Xn(n.mul(i)).toVar(),
      s = Rn(e, r).toVar(),
      o = Rn(e, r.sub(Xn(2, 0))).toVar(),
      a = Rn(e, r.sub(Xn(1, 0))).toVar(),
      l = Rn(e, r.add(Xn(1, 0))).toVar(),
      c = Rn(e, r.add(Xn(2, 0))).toVar(),
      u = Rn(e, r.add(Xn(0, 2))).toVar(),
      d = Rn(e, r.add(Xn(0, 1))).toVar(),
      h = Rn(e, r.sub(Xn(0, 1))).toVar(),
      f = Rn(e, r.sub(Xn(0, 2))).toVar(),
      p = mn(Bt(ce(2).mul(a).sub(o), s)).toVar(),
      g = mn(Bt(ce(2).mul(l).sub(c), s)).toVar(),
      y = mn(Bt(ce(2).mul(d).sub(u), s)).toVar(),
      m = mn(Bt(ce(2).mul(h).sub(f), s)).toVar(),
      v = Rc(n, s, t).toVar(),
      x = p
        .lessThan(g)
        .select(
          v.sub(Rc(n.sub(He(ce(1).div(i.x), 0)), a, t)),
          v.negate().add(Rc(n.add(He(ce(1).div(i.x), 0)), l, t))
        ),
      _ = y
        .lessThan(m)
        .select(
          v.sub(Rc(n.add(He(0, ce(1).div(i.y))), d, t)),
          v.negate().add(Rc(n.sub(He(0, ce(1).div(i.y))), h, t))
        )
    return ql(v0(x, _))
  })
class R$ extends Ko {
  constructor(e, t, i = Float32Array) {
    const r = ArrayBuffer.isView(e) ? e : new i(e * t)
    ;(super(r, t), (this.isStorageInstancedBufferAttribute = !0))
  }
}
class I$ extends _i {
  constructor(e, t, i = Float32Array) {
    const r = ArrayBuffer.isView(e) ? e : new i(e * t)
    ;(super(r, t), (this.isStorageBufferAttribute = !0))
  }
}
class N$ extends jl {
  static get type() {
    return 'StorageArrayElementNode'
  }
  constructor(e, t) {
    ;(super(e, t), (this.isStorageArrayElementNode = !0))
  }
  set storageBufferNode(e) {
    this.node = e
  }
  get storageBufferNode() {
    return this.node
  }
  getMemberType(e, t) {
    const i = this.storageBufferNode.structTypeNode
    return i ? i.getMemberType(e, t) : 'void'
  }
  setup(e) {
    return (
      e.isAvailable('storageBuffer') === !1 && this.node.isPBO === !0 && e.setupPBO(this.node),
      super.setup(e)
    )
  }
  generate(e, t) {
    let i
    const r = e.context.assign
    if (
      (e.isAvailable('storageBuffer') === !1
        ? this.node.isPBO === !0 &&
          r !== !0 &&
          (this.node.value.isInstancedBufferAttribute || e.shaderStage !== 'compute')
          ? (i = e.generatePBO(this))
          : (i = this.node.build(e))
        : (i = super.generate(e)),
      r !== !0)
    ) {
      const s = this.getNodeType(e)
      i = e.format(i, s, t)
    }
    return i
  }
}
const P$ = Pe(N$)
class L$ extends vx {
  static get type() {
    return 'StorageBufferNode'
  }
  constructor(e, t = null, i = 0) {
    let r,
      s = null
    ;(t && t.isStruct
      ? ((r = 'struct'), (s = t.layout))
      : t === null && (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute)
        ? ((r = tk(e.itemSize)), (i = e.count))
        : (r = t),
      super(e, r, i),
      (this.isStorageBufferNode = !0),
      (this.structTypeNode = s),
      (this.access = js.READ_WRITE),
      (this.isAtomic = !1),
      (this.isPBO = !1),
      (this._attribute = null),
      (this._varying = null),
      (this.global = !0),
      e.isStorageBufferAttribute !== !0 &&
        e.isStorageInstancedBufferAttribute !== !0 &&
        (e.isInstancedBufferAttribute
          ? (e.isStorageInstancedBufferAttribute = !0)
          : (e.isStorageBufferAttribute = !0)))
  }
  getHash(e) {
    if (this.bufferCount === 0) {
      let t = e.globalCache.getData(this.value)
      return (
        t === void 0 && ((t = { node: this }), e.globalCache.setData(this.value, t)),
        t.node.uuid
      )
    }
    return this.uuid
  }
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer'
  }
  element(e) {
    return P$(this, e)
  }
  setPBO(e) {
    return ((this.isPBO = e), this)
  }
  getPBO() {
    return this.isPBO
  }
  setAccess(e) {
    return ((this.access = e), this)
  }
  toReadOnly() {
    return this.setAccess(js.READ_ONLY)
  }
  setAtomic(e) {
    return ((this.isAtomic = e), this)
  }
  toAtomic() {
    return this.setAtomic(!0)
  }
  getAttributeData() {
    return (
      this._attribute === null &&
        ((this._attribute = Gh(this.value)), (this._varying = er(this._attribute))),
      { attribute: this._attribute, varying: this._varying }
    )
  }
  getNodeType(e) {
    if (this.structTypeNode !== null) return this.structTypeNode.getNodeType(e)
    if (e.isAvailable('storageBuffer') || e.isAvailable('indirectStorageBuffer'))
      return super.getNodeType(e)
    const { attribute: t } = this.getAttributeData()
    return t.getNodeType(e)
  }
  generate(e) {
    if (
      (this.structTypeNode !== null && this.structTypeNode.build(e),
      e.isAvailable('storageBuffer') || e.isAvailable('indirectStorageBuffer'))
    )
      return super.generate(e)
    const { attribute: t, varying: i } = this.getAttributeData(),
      r = i.build(e)
    return (e.registerTransform(r, t), r)
  }
}
const b0 = (n, e = null, t = 0) => Fe(new L$(n, e, t)),
  D$ = (n, e, t) => (
    console.warn(
      'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'
    ),
    b0(n, e, t).setPBO(!0)
  ),
  F$ = (n, e = 'float') => {
    let t, i
    e.isStruct === !0 ? ((t = e.layout.getLength()), (i = Tm('float'))) : ((t = X_(e)), (i = Tm(e)))
    const r = new I$(n, t, i)
    return b0(r, e, n)
  },
  O$ = (n, e = 'float') => {
    let t, i
    e.isStruct === !0 ? ((t = e.layout.getLength()), (i = Tm('float'))) : ((t = X_(e)), (i = Tm(e)))
    const r = new R$(n, t, i)
    return b0(r, e, n)
  }
class B$ extends iM {
  static get type() {
    return 'VertexColorNode'
  }
  constructor(e = 0) {
    ;(super(null, 'vec4'), (this.isVertexColorNode = !0), (this.index = e))
  }
  getAttributeName() {
    const e = this.index
    return 'color' + (e > 0 ? e : '')
  }
  generate(e) {
    const t = this.getAttributeName(e),
      i = e.hasGeometryAttribute(t)
    let r
    return (
      i === !0 ? (r = super.generate(e)) : (r = e.generateConst(this.nodeType, new Mt(1, 1, 1, 1))),
      r
    )
  }
  serialize(e) {
    ;(super.serialize(e), (e.index = this.index))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.index = e.index))
  }
}
const U$ = (n) => Fe(new B$(n))
class k$ extends ut {
  static get type() {
    return 'PointUVNode'
  }
  constructor() {
    ;(super('vec2'), (this.isPointUVNode = !0))
  }
  generate() {
    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )'
  }
}
const z$ = We(k$),
  yd = new Cs(),
  u1 = new qe()
class or extends ut {
  static get type() {
    return 'SceneNode'
  }
  constructor(e = or.BACKGROUND_BLURRINESS, t = null) {
    ;(super(), (this.scope = e), (this.scene = t))
  }
  setup(e) {
    const t = this.scope,
      i = this.scene !== null ? this.scene : e.scene
    let r
    return (
      t === or.BACKGROUND_BLURRINESS
        ? (r = Pn('backgroundBlurriness', 'float', i))
        : t === or.BACKGROUND_INTENSITY
          ? (r = Pn('backgroundIntensity', 'float', i))
          : t === or.BACKGROUND_ROTATION
            ? (r = Rt('mat4')
                .label('backgroundRotation')
                .setGroup(Ut)
                .onRenderUpdate(() => {
                  const s = i.background
                  return (
                    s !== null && s.isTexture && s.mapping !== y_
                      ? (yd.copy(i.backgroundRotation),
                        (yd.x *= -1),
                        (yd.y *= -1),
                        (yd.z *= -1),
                        u1.makeRotationFromEuler(yd))
                      : u1.identity(),
                    u1
                  )
                }))
            : console.error('THREE.SceneNode: Unknown scope:', t),
      r
    )
  }
}
or.BACKGROUND_BLURRINESS = 'backgroundBlurriness'
or.BACKGROUND_INTENSITY = 'backgroundIntensity'
or.BACKGROUND_ROTATION = 'backgroundRotation'
const V$ = We(or, or.BACKGROUND_BLURRINESS),
  H$ = We(or, or.BACKGROUND_INTENSITY),
  $$ = We(or, or.BACKGROUND_ROTATION)
class G$ extends ta {
  static get type() {
    return 'StorageTextureNode'
  }
  constructor(e, t, i = null) {
    ;(super(e, t),
      (this.storeNode = i),
      (this.isStorageTextureNode = !0),
      (this.access = js.WRITE_ONLY))
  }
  getInputType() {
    return 'storageTexture'
  }
  setup(e) {
    super.setup(e)
    const t = e.getNodeProperties(this)
    t.storeNode = this.storeNode
  }
  setAccess(e) {
    return ((this.access = e), this)
  }
  generate(e, t) {
    let i
    return (this.storeNode !== null ? (i = this.generateStore(e)) : (i = super.generate(e, t)), i)
  }
  toReadWrite() {
    return this.setAccess(js.READ_WRITE)
  }
  toReadOnly() {
    return this.setAccess(js.READ_ONLY)
  }
  toWriteOnly() {
    return this.setAccess(js.WRITE_ONLY)
  }
  generateStore(e) {
    const t = e.getNodeProperties(this),
      { uvNode: i, storeNode: r } = t,
      s = super.generate(e, 'property'),
      o = i.build(e, 'uvec2'),
      a = r.build(e, 'vec4'),
      l = e.generateTextureStore(e, s, o, a)
    e.addLineFlowCode(l, this)
  }
}
const d4 = Pe(G$),
  W$ = (n, e, t) => {
    const i = d4(n, e, t)
    return (t !== null && i.append(), i)
  }
class Q$ extends _0 {
  static get type() {
    return 'UserDataNode'
  }
  constructor(e, t, i = null) {
    ;(super(e, t, i), (this.userData = i))
  }
  updateReference(e) {
    return (
      (this.reference = this.userData !== null ? this.userData : e.object.userData),
      this.reference
    )
  }
}
const j$ = (n, e, t) => Fe(new Q$(n, e, t)),
  Cb = new WeakMap()
class q$ extends Un {
  static get type() {
    return 'VelocityNode'
  }
  constructor() {
    ;(super('vec2'),
      (this.projectionMatrix = null),
      (this.updateType = Wt.OBJECT),
      (this.updateAfterType = Wt.OBJECT),
      (this.previousModelWorldMatrix = Rt(new qe())),
      (this.previousProjectionMatrix = Rt(new qe()).setGroup(Ut)),
      (this.previousCameraViewMatrix = Rt(new qe())))
  }
  setProjectionMatrix(e) {
    this.projectionMatrix = e
  }
  update({ frameId: e, camera: t, object: i }) {
    const r = Eb(i)
    this.previousModelWorldMatrix.value.copy(r)
    const s = h4(t)
    s.frameId !== e &&
      ((s.frameId = e),
      s.previousProjectionMatrix === void 0
        ? ((s.previousProjectionMatrix = new qe()),
          (s.previousCameraViewMatrix = new qe()),
          (s.currentProjectionMatrix = new qe()),
          (s.currentCameraViewMatrix = new qe()),
          s.previousProjectionMatrix.copy(this.projectionMatrix || t.projectionMatrix),
          s.previousCameraViewMatrix.copy(t.matrixWorldInverse))
        : (s.previousProjectionMatrix.copy(s.currentProjectionMatrix),
          s.previousCameraViewMatrix.copy(s.currentCameraViewMatrix)),
      s.currentProjectionMatrix.copy(this.projectionMatrix || t.projectionMatrix),
      s.currentCameraViewMatrix.copy(t.matrixWorldInverse),
      this.previousProjectionMatrix.value.copy(s.previousProjectionMatrix),
      this.previousCameraViewMatrix.value.copy(s.previousCameraViewMatrix))
  }
  updateAfter({ object: e }) {
    Eb(e).copy(e.matrixWorld)
  }
  setup() {
    const e = this.projectionMatrix === null ? Qh : Rt(this.projectionMatrix),
      t = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix),
      i = e.mul(jh).mul(Nn),
      r = this.previousProjectionMatrix.mul(t).mul(Mm),
      s = i.xy.div(i.w),
      o = r.xy.div(r.w)
    return Bt(s, o)
  }
}
function h4(n) {
  let e = Cb.get(n)
  return (e === void 0 && ((e = {}), Cb.set(n, e)), e)
}
function Eb(n, e = 0) {
  const t = h4(n)
  let i = t[e]
  return (i === void 0 && (t[e] = i = new qe()), i)
}
const X$ = We(q$),
  f4 = _e(([n, e]) => Dr(1, n.oneMinus().div(e)).oneMinus()).setLayout({
    name: 'blendBurn',
    type: 'vec3',
    inputs: [
      { name: 'base', type: 'vec3' },
      { name: 'blend', type: 'vec3' },
    ],
  }),
  p4 = _e(([n, e]) => Dr(n.div(e.oneMinus()), 1)).setLayout({
    name: 'blendDodge',
    type: 'vec3',
    inputs: [
      { name: 'base', type: 'vec3' },
      { name: 'blend', type: 'vec3' },
    ],
  }),
  m4 = _e(([n, e]) => n.oneMinus().mul(e.oneMinus()).oneMinus()).setLayout({
    name: 'blendScreen',
    type: 'vec3',
    inputs: [
      { name: 'base', type: 'vec3' },
      { name: 'blend', type: 'vec3' },
    ],
  }),
  g4 = _e(([n, e]) =>
    Ln(n.mul(2).mul(e), n.oneMinus().mul(2).mul(e.oneMinus()).oneMinus(), y0(0.5, n))
  ).setLayout({
    name: 'blendOverlay',
    type: 'vec3',
    inputs: [
      { name: 'base', type: 'vec3' },
      { name: 'blend', type: 'vec3' },
    ],
  }),
  K$ = _e(([n, e]) => {
    const t = e.a.add(n.a.mul(e.a.oneMinus()))
    return yt(e.rgb.mul(e.a).add(n.rgb.mul(n.a).mul(e.a.oneMinus())).div(t), t)
  }).setLayout({
    name: 'blendColor',
    type: 'vec4',
    inputs: [
      { name: 'base', type: 'vec4' },
      { name: 'blend', type: 'vec4' },
    ],
  }),
  Y$ = (...n) => (
    console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.'),
    f4(n)
  ),
  Z$ = (...n) => (
    console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'),
    p4(n)
  ),
  J$ = (...n) => (
    console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'),
    m4(n)
  ),
  eG = (...n) => (
    console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'),
    g4(n)
  ),
  tG = _e(([n]) => Nx(n.rgb)),
  nG = _e(([n, e = ce(1)]) => e.mix(Nx(n.rgb), n.rgb)),
  iG = _e(([n, e = ce(1)]) => {
    const t = On(n.r, n.g, n.b).div(3),
      i = n.r.max(n.g.max(n.b)),
      r = i.sub(t).mul(e).mul(-3)
    return Ln(n.rgb, i, r)
  }),
  rG = _e(([n, e = ce(1)]) => {
    const t = ve(0.57735, 0.57735, 0.57735),
      i = e.cos()
    return ve(
      n.rgb.mul(i).add(
        t
          .cross(n.rgb)
          .mul(e.sin())
          .add(t.mul($a(t, n.rgb).mul(i.oneMinus())))
      )
    )
  }),
  Nx = (n, e = ve(Tt.getLuminanceCoefficients(new Y()))) => $a(n, e),
  sG = _e(
    ([
      n,
      e = ve(1),
      t = ve(0),
      i = ve(1),
      r = ce(1),
      s = ve(Tt.getLuminanceCoefficients(new Y(), Ui)),
    ]) => {
      const o = n.rgb.dot(ve(s)),
        a = ui(n.rgb.mul(e).add(t), 0).toVar(),
        l = a.pow(i).toVar()
      return (
        Dt(a.r.greaterThan(0), () => {
          a.r.assign(l.r)
        }),
        Dt(a.g.greaterThan(0), () => {
          a.g.assign(l.g)
        }),
        Dt(a.b.greaterThan(0), () => {
          a.b.assign(l.b)
        }),
        a.assign(o.add(a.sub(o).mul(r))),
        yt(a.rgb, n.a)
      )
    }
  )
class oG extends Un {
  static get type() {
    return 'PosterizeNode'
  }
  constructor(e, t) {
    ;(super(), (this.sourceNode = e), (this.stepsNode = t))
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this
    return e.mul(t).floor().div(t)
  }
}
const aG = Pe(oG),
  lG = new je()
class y4 extends ta {
  static get type() {
    return 'PassTextureNode'
  }
  constructor(e, t) {
    ;(super(t), (this.passNode = e), this.setUpdateMatrix(!1))
  }
  setup(e) {
    return (e.object.isQuadMesh && this.passNode.build(e), super.setup(e))
  }
  clone() {
    return new this.constructor(this.passNode, this.value)
  }
}
class Mb extends y4 {
  static get type() {
    return 'PassMultipleTextureNode'
  }
  constructor(e, t, i = !1) {
    ;(super(e, null), (this.textureName = t), (this.previousTexture = i))
  }
  updateTexture() {
    this.value = this.previousTexture
      ? this.passNode.getPreviousTexture(this.textureName)
      : this.passNode.getTexture(this.textureName)
  }
  setup(e) {
    return (this.updateTexture(), super.setup(e))
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture)
  }
}
class io extends Un {
  static get type() {
    return 'PassNode'
  }
  constructor(e, t, i, r = {}) {
    ;(super('vec4'),
      (this.scope = e),
      (this.scene = t),
      (this.camera = i),
      (this.options = r),
      (this._pixelRatio = 1),
      (this._width = 1),
      (this._height = 1))
    const s = new Ha()
    ;((s.isRenderTargetTexture = !0), (s.name = 'depth'))
    const o = new Bh(this._width * this._pixelRatio, this._height * this._pixelRatio, {
      type: ws,
      ...r,
    })
    ;((o.texture.name = 'output'),
      (o.depthTexture = s),
      (this.renderTarget = o),
      (this._textures = { output: o.texture, depth: s }),
      (this._textureNodes = {}),
      (this._linearDepthNodes = {}),
      (this._viewZNodes = {}),
      (this._previousTextures = {}),
      (this._previousTextureNodes = {}),
      (this._cameraNear = Rt(0)),
      (this._cameraFar = Rt(0)),
      (this._mrt = null),
      (this.isPassNode = !0),
      (this.updateBeforeType = Wt.FRAME))
  }
  setMRT(e) {
    return ((this._mrt = e), this)
  }
  getMRT() {
    return this._mrt
  }
  isGlobal() {
    return !0
  }
  getTexture(e) {
    let t = this._textures[e]
    return (
      t === void 0 &&
        ((t = this.renderTarget.texture.clone()),
        (t.name = e),
        (this._textures[e] = t),
        this.renderTarget.textures.push(t)),
      t
    )
  }
  getPreviousTexture(e) {
    let t = this._previousTextures[e]
    return (t === void 0 && ((t = this.getTexture(e).clone()), (this._previousTextures[e] = t)), t)
  }
  toggleTexture(e) {
    const t = this._previousTextures[e]
    if (t !== void 0) {
      const i = this._textures[e],
        r = this.renderTarget.textures.indexOf(i)
      ;((this.renderTarget.textures[r] = t),
        (this._textures[e] = t),
        (this._previousTextures[e] = i),
        this._textureNodes[e].updateTexture(),
        this._previousTextureNodes[e].updateTexture())
    }
  }
  getTextureNode(e = 'output') {
    let t = this._textureNodes[e]
    return (
      t === void 0 && ((t = Fe(new Mb(this, e))), t.updateTexture(), (this._textureNodes[e] = t)),
      t
    )
  }
  getPreviousTextureNode(e = 'output') {
    let t = this._previousTextureNodes[e]
    return (
      t === void 0 &&
        (this._textureNodes[e] === void 0 && this.getTextureNode(e),
        (t = Fe(new Mb(this, e, !0))),
        t.updateTexture(),
        (this._previousTextureNodes[e] = t)),
      t
    )
  }
  getViewZNode(e = 'depth') {
    let t = this._viewZNodes[e]
    if (t === void 0) {
      const i = this._cameraNear,
        r = this._cameraFar
      this._viewZNodes[e] = t = Ex(this.getTextureNode(e), i, r)
    }
    return t
  }
  getLinearDepthNode(e = 'depth') {
    let t = this._linearDepthNodes[e]
    if (t === void 0) {
      const i = this._cameraNear,
        r = this._cameraFar,
        s = this.getViewZNode(e)
      this._linearDepthNodes[e] = t = Xc(s, i, r)
    }
    return t
  }
  setup({ renderer: e }) {
    return (
      (this.renderTarget.samples =
        this.options.samples === void 0 ? e.samples : this.options.samples),
      e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0),
      (this.renderTarget.texture.type = e.getColorBufferType()),
      this.scope === io.COLOR ? this.getTextureNode() : this.getLinearDepthNode()
    )
  }
  updateBefore(e) {
    const { renderer: t } = e,
      { scene: i, camera: r } = this
    this._pixelRatio = t.getPixelRatio()
    const s = t.getSize(lG)
    this.setSize(s.width, s.height)
    const o = t.getRenderTarget(),
      a = t.getMRT()
    ;((this._cameraNear.value = r.near), (this._cameraFar.value = r.far))
    for (const l in this._previousTextures) this.toggleTexture(l)
    ;(t.setRenderTarget(this.renderTarget),
      t.setMRT(this._mrt),
      t.render(i, r),
      t.setRenderTarget(o),
      t.setMRT(a))
  }
  setSize(e, t) {
    ;((this._width = e), (this._height = t))
    const i = this._width * this._pixelRatio,
      r = this._height * this._pixelRatio
    this.renderTarget.setSize(i, r)
  }
  setPixelRatio(e) {
    ;((this._pixelRatio = e), this.setSize(this._width, this._height))
  }
  dispose() {
    this.renderTarget.dispose()
  }
}
io.COLOR = 'color'
io.DEPTH = 'depth'
const cG = (n, e, t) => Fe(new io(io.COLOR, n, e, t)),
  uG = (n, e) => Fe(new y4(n, e)),
  dG = (n, e, t) => Fe(new io(io.DEPTH, n, e, t))
class hG extends io {
  static get type() {
    return 'ToonOutlinePassNode'
  }
  constructor(e, t, i, r, s) {
    ;(super(io.COLOR, e, t),
      (this.colorNode = i),
      (this.thicknessNode = r),
      (this.alphaNode = s),
      (this._materialCache = new WeakMap()))
  }
  updateBefore(e) {
    const { renderer: t } = e,
      i = t.getRenderObjectFunction()
    ;(t.setRenderObjectFunction((r, s, o, a, l, c, u, d) => {
      if ((l.isMeshToonMaterial || l.isMeshToonNodeMaterial) && l.wireframe === !1) {
        const h = this._getOutlineMaterial(l)
        t.renderObject(r, s, o, a, h, c, u, d)
      }
      t.renderObject(r, s, o, a, l, c, u, d)
    }),
      super.updateBefore(e),
      t.setRenderObjectFunction(i))
  }
  _createMaterial() {
    const e = new _h()
    ;((e.isMeshToonOutlineMaterial = !0), (e.name = 'Toon_Outline'), (e.side = Oi))
    const t = cr.negate(),
      i = Qh.mul(jh),
      r = ce(1),
      s = i.mul(yt(Nn, 1)),
      o = i.mul(yt(Nn.add(t), 1)),
      a = ql(s.sub(o))
    return (
      (e.vertexNode = s.add(a.mul(this.thicknessNode).mul(s.w).mul(r))),
      (e.colorNode = yt(this.colorNode, this.alphaNode)),
      e
    )
  }
  _getOutlineMaterial(e) {
    let t = this._materialCache.get(e)
    return (t === void 0 && ((t = this._createMaterial()), this._materialCache.set(e, t)), t)
  }
}
const fG = (n, e, t = new gt(0, 0, 0), i = 0.003, r = 1) => Fe(new hG(n, e, Fe(t), Fe(i), Fe(r))),
  pG = _e(([n, e]) => n.mul(e).clamp()).setLayout({
    name: 'linearToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  }),
  mG = _e(([n, e]) => ((n = n.mul(e)), n.div(n.add(1)).clamp())).setLayout({
    name: 'reinhardToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  }),
  gG = _e(([n, e]) => {
    ;((n = n.mul(e)), (n = n.sub(0.004).max(0)))
    const t = n.mul(n.mul(6.2).add(0.5)),
      i = n.mul(n.mul(6.2).add(1.7)).add(0.06)
    return t.div(i).pow(2.2)
  }).setLayout({
    name: 'cineonToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  }),
  yG = _e(([n]) => {
    const e = n.mul(n.add(0.0245786)).sub(90537e-9),
      t = n.mul(n.add(0.432951).mul(0.983729)).add(0.238081)
    return e.div(t)
  }),
  vG = _e(([n, e]) => {
    const t = is(0.59719, 0.35458, 0.04823, 0.076, 0.90834, 0.01566, 0.0284, 0.13383, 0.83777),
      i = is(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602)
    return ((n = n.mul(e).div(0.6)), (n = t.mul(n)), (n = yG(n)), (n = i.mul(n)), n.clamp())
  }).setLayout({
    name: 'acesFilmicToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  }),
  _G = is(ve(1.6605, -0.1246, -0.0182), ve(-0.5876, 1.1329, -0.1006), ve(-0.0728, -0.0083, 1.1187)),
  xG = is(ve(0.6274, 0.0691, 0.0164), ve(0.3293, 0.9195, 0.088), ve(0.0433, 0.0113, 0.8956)),
  SG = _e(([n]) => {
    const e = ve(n).toVar(),
      t = ve(e.mul(e)).toVar(),
      i = ve(t.mul(t)).toVar()
    return ce(15.5)
      .mul(i.mul(t))
      .sub(xt(40.14, i.mul(e)))
      .add(
        xt(31.96, i)
          .sub(xt(6.868, t.mul(e)))
          .add(xt(0.4298, t).add(xt(0.1191, e).sub(0.00232)))
      )
  }),
  AG = _e(([n, e]) => {
    const t = ve(n).toVar(),
      i = is(
        ve(0.856627153315983, 0.137318972929847, 0.11189821299995),
        ve(0.0951212405381588, 0.761241990602591, 0.0767994186031903),
        ve(0.0482516061458583, 0.101439036467562, 0.811302368396859)
      ),
      r = is(
        ve(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),
        ve(-0.11060664309660323, 1.157823702216272, -0.11060664309660294),
        ve(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)
      ),
      s = ce(-12.47393),
      o = ce(4.026069)
    return (
      t.mulAssign(e),
      t.assign(xG.mul(t)),
      t.assign(i.mul(t)),
      t.assign(ui(t, 1e-10)),
      t.assign(Ho(t)),
      t.assign(t.sub(s).div(o.sub(s))),
      t.assign(Jo(t, 0, 1)),
      t.assign(SG(t)),
      t.assign(r.mul(t)),
      t.assign(gs(ui(ve(0), t), ve(2.2))),
      t.assign(_G.mul(t)),
      t.assign(Jo(t, 0, 1)),
      t
    )
  }).setLayout({
    name: 'agxToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  }),
  bG = _e(([n, e]) => {
    const t = ce(0.76),
      i = ce(0.15)
    n = n.mul(e)
    const r = Dr(n.r, Dr(n.g, n.b)),
      s = rr(r.lessThan(0.08), r.sub(xt(6.25, r.mul(r))), 0.04)
    n.subAssign(s)
    const o = ui(n.r, ui(n.g, n.b))
    Dt(o.lessThan(t), () => n)
    const a = Bt(1, t),
      l = Bt(1, a.mul(a).div(o.add(a.sub(t))))
    n.mulAssign(l.div(o))
    const c = Bt(1, Zo(1, i.mul(o.sub(l)).add(1)))
    return Ln(n, ve(l), c)
  }).setLayout({
    name: 'neutralToneMapping',
    type: 'vec3',
    inputs: [
      { name: 'color', type: 'vec3' },
      { name: 'exposure', type: 'float' },
    ],
  })
class qn extends ut {
  static get type() {
    return 'CodeNode'
  }
  constructor(e = '', t = [], i = '') {
    ;(super('code'),
      (this.isCodeNode = !0),
      (this.code = e),
      (this.includes = t),
      (this.language = i))
  }
  isGlobal() {
    return !0
  }
  setIncludes(e) {
    return ((this.includes = e), this)
  }
  getIncludes() {
    return this.includes
  }
  generate(e) {
    const t = this.getIncludes(e)
    for (const r of t) r.build(e)
    const i = e.getCodeFromNode(this, this.getNodeType(e))
    return ((i.code = this.code), i.code)
  }
  serialize(e) {
    ;(super.serialize(e), (e.code = this.code), (e.language = this.language))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.code = e.code), (this.language = e.language))
  }
}
const T0 = Pe(qn),
  TG = (n, e) => T0(n, e, 'js'),
  wG = (n, e) => T0(n, e, 'wgsl'),
  CG = (n, e) => T0(n, e, 'glsl')
class EG extends qn {
  static get type() {
    return 'FunctionNode'
  }
  constructor(e = '', t = [], i = '') {
    super(e, t, i)
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this)
    let i = t.nodeFunction
    return (i === void 0 && ((i = e.parser.parseFunction(this.code)), (t.nodeFunction = i)), i)
  }
  generate(e, t) {
    super.generate(e)
    const i = this.getNodeFunction(e),
      r = i.name,
      s = i.type,
      o = e.getCodeFromNode(this, s)
    r !== '' && (o.name = r)
    const a = e.getPropertyName(o),
      l = this.getNodeFunction(e).getCode(a)
    return ((o.code = l + '\n'), t === 'property' ? a : e.format(''.concat(a, '()'), s, t))
  }
}
const v4 = (n, e = [], t = '') => {
    for (let s = 0; s < e.length; s++) {
      const o = e[s]
      typeof o == 'function' && (e[s] = o.functionNode)
    }
    const i = Fe(new EG(n, e, t)),
      r = (...s) => i.call(...s)
    return ((r.functionNode = i), r)
  },
  MG = (n, e) => v4(n, e, 'glsl'),
  RG = (n, e) => v4(n, e, 'wgsl')
class IG extends ut {
  static get type() {
    return 'ScriptableValueNode'
  }
  constructor(e = null) {
    ;(super(),
      (this._value = e),
      (this._cache = null),
      (this.inputType = null),
      (this.outputType = null),
      (this.events = new so()),
      (this.isScriptableValueNode = !0))
  }
  get isScriptableOutputNode() {
    return this.outputType !== null
  }
  set value(e) {
    this._value !== e &&
      (this._cache &&
        this.inputType === 'URL' &&
        this.value.value instanceof ArrayBuffer &&
        (URL.revokeObjectURL(this._cache), (this._cache = null)),
      (this._value = e),
      this.events.dispatchEvent({ type: 'change' }),
      this.refresh())
  }
  get value() {
    return this._value
  }
  refresh() {
    this.events.dispatchEvent({ type: 'refresh' })
  }
  getValue() {
    const e = this.value
    if (e && this._cache === null && this.inputType === 'URL' && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]))
    else if (
      e &&
      e.value !== null &&
      e.value !== void 0 &&
      (((this.inputType === 'URL' || this.inputType === 'String') && typeof e.value == 'string') ||
        (this.inputType === 'Number' && typeof e.value == 'number') ||
        (this.inputType === 'Vector2' && e.value.isVector2) ||
        (this.inputType === 'Vector3' && e.value.isVector3) ||
        (this.inputType === 'Vector4' && e.value.isVector4) ||
        (this.inputType === 'Color' && e.value.isColor) ||
        (this.inputType === 'Matrix3' && e.value.isMatrix3) ||
        (this.inputType === 'Matrix4' && e.value.isMatrix4))
    )
      return e.value
    return this._cache || e
  }
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : 'float'
  }
  setup() {
    return this.value && this.value.isNode ? this.value : ce()
  }
  serialize(e) {
    ;(super.serialize(e),
      this.value !== null
        ? this.inputType === 'ArrayBuffer'
          ? (e.value = fC(this.value))
          : (e.value = this.value ? this.value.toJSON(e.meta).uuid : null)
        : (e.value = null),
      (e.inputType = this.inputType),
      (e.outputType = this.outputType))
  }
  deserialize(e) {
    super.deserialize(e)
    let t = null
    ;(e.value !== null &&
      (e.inputType === 'ArrayBuffer'
        ? (t = pC(e.value))
        : e.inputType === 'Texture'
          ? (t = e.meta.textures[e.value])
          : (t = e.meta.nodes[e.value] || null)),
      (this.value = t),
      (this.inputType = e.inputType),
      (this.outputType = e.outputType))
  }
}
const Fp = Pe(IG)
class _4 extends Map {
  get(e, t = null, ...i) {
    if (this.has(e)) return super.get(e)
    if (t !== null) {
      const r = t(...i)
      return (this.set(e, r), r)
    }
  }
}
class NG {
  constructor(e) {
    this.scriptableNode = e
  }
  get parameters() {
    return this.scriptableNode.parameters
  }
  get layout() {
    return this.scriptableNode.getLayout()
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e)
  }
  get(e) {
    const t = this.parameters[e]
    return t ? t.getValue() : null
  }
}
const Op = new _4()
class PG extends ut {
  static get type() {
    return 'ScriptableNode'
  }
  constructor(e = null, t = {}) {
    ;(super(),
      (this.codeNode = e),
      (this.parameters = t),
      (this._local = new _4()),
      (this._output = Fp()),
      (this._outputs = {}),
      (this._source = this.source),
      (this._method = null),
      (this._object = null),
      (this._value = null),
      (this._needsOutputUpdate = !0),
      (this.onRefresh = this.onRefresh.bind(this)),
      (this.isScriptableNode = !0))
  }
  get source() {
    return this.codeNode ? this.codeNode.code : ''
  }
  setLocal(e, t) {
    return this._local.set(e, t)
  }
  getLocal(e) {
    return this._local.get(e)
  }
  onRefresh() {
    this._refresh()
  }
  getInputLayout(e) {
    for (const t of this.getLayout()) if (t.inputType && (t.id === e || t.name === e)) return t
  }
  getOutputLayout(e) {
    for (const t of this.getLayout()) if (t.outputType && (t.id === e || t.name === e)) return t
  }
  setOutput(e, t) {
    const i = this._outputs
    return (i[e] === void 0 ? (i[e] = Fp(t)) : (i[e].value = t), this)
  }
  getOutput(e) {
    return this._outputs[e]
  }
  getParameter(e) {
    return this.parameters[e]
  }
  setParameter(e, t) {
    const i = this.parameters
    return (
      t && t.isScriptableNode
        ? (this.deleteParameter(e),
          (i[e] = t),
          i[e].getDefaultOutput().events.addEventListener('refresh', this.onRefresh))
        : t && t.isScriptableValueNode
          ? (this.deleteParameter(e),
            (i[e] = t),
            i[e].events.addEventListener('refresh', this.onRefresh))
          : i[e] === void 0
            ? ((i[e] = Fp(t)), i[e].events.addEventListener('refresh', this.onRefresh))
            : (i[e].value = t),
      this
    )
  }
  getValue() {
    return this.getDefaultOutput().getValue()
  }
  deleteParameter(e) {
    let t = this.parameters[e]
    return (
      t &&
        (t.isScriptableNode && (t = t.getDefaultOutput()),
        t.events.removeEventListener('refresh', this.onRefresh)),
      this
    )
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters)) this.deleteParameter(e)
    return ((this.needsUpdate = !0), this)
  }
  call(e, ...t) {
    const r = this.getObject()[e]
    if (typeof r == 'function') return r(...t)
  }
  async callAsync(e, ...t) {
    const r = this.getObject()[e]
    if (typeof r == 'function')
      return r.constructor.name === 'AsyncFunction' ? await r(...t) : r(...t)
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e)
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh()
  }
  getObject() {
    if ((this.needsUpdate && this.dispose(), this._object !== null)) return this._object
    const e = () => this.refresh(),
      t = (c, u) => this.setOutput(c, u),
      i = new NG(this),
      r = Op.get('THREE'),
      s = Op.get('TSL'),
      o = this.getMethod(),
      a = [i, this._local, Op, e, t, r, s]
    this._object = o(...a)
    const l = this._object.layout
    if (
      l &&
      (l.cache === !1 && this._local.clear(),
      (this._output.outputType = l.outputType || null),
      Array.isArray(l.elements))
    )
      for (const c of l.elements) {
        const u = c.id || c.name
        ;(c.inputType &&
          (this.getParameter(u) === void 0 && this.setParameter(u, null),
          (this.getParameter(u).inputType = c.inputType)),
          c.outputType &&
            (this.getOutput(u) === void 0 && this.setOutput(u, null),
            (this.getOutput(u).outputType = c.outputType)))
      }
    return this._object
  }
  deserialize(e) {
    super.deserialize(e)
    for (const t in this.parameters) {
      let i = this.parameters[t]
      ;(i.isScriptableNode && (i = i.getDefaultOutput()),
        i.events.addEventListener('refresh', this.onRefresh))
    }
  }
  getLayout() {
    return this.getObject().layout
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value
    return e && e.isNode ? e : ce()
  }
  getDefaultOutput() {
    return this._exec()._output
  }
  getMethod() {
    if ((this.needsUpdate && this.dispose(), this._method !== null)) return this._method
    const e = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'],
      i = ['layout', 'init', 'main', 'dispose'].join(', '),
      r = 'var ' + i + '; var output = {};\n',
      s = '\nreturn { ...output, ' + i + ' };',
      o = r + this.codeNode.code + s
    return ((this._method = new Function(...e, o)), this._method)
  }
  dispose() {
    this._method !== null &&
      (this._object && typeof this._object.dispose == 'function' && this._object.dispose(),
      (this._method = null),
      (this._object = null),
      (this._source = null),
      (this._value = null),
      (this._needsOutputUpdate = !0),
      (this._output.value = null),
      (this._outputs = {}))
  }
  setup() {
    return this.getDefaultOutputNode()
  }
  getCacheKey(e) {
    const t = [JU(this.source), this.getDefaultOutputNode().getCacheKey(e)]
    for (const i in this.parameters) t.push(this.parameters[i].getCacheKey(e))
    return lC(t)
  }
  set needsUpdate(e) {
    e === !0 && this.dispose()
  }
  get needsUpdate() {
    return this.source !== this._source
  }
  _exec() {
    return this.codeNode === null
      ? this
      : (this._needsOutputUpdate === !0 &&
          ((this._value = this.call('main')), (this._needsOutputUpdate = !1)),
        (this._output.value = this._value),
        this)
  }
  _refresh() {
    ;((this.needsUpdate = !0), this._exec(), this._output.refresh())
  }
}
const LG = Pe(PG)
function x4(n) {
  let e
  const t = n.context.getViewZ
  return (t !== void 0 && (e = t(this)), (e || Yn.z).negate())
}
const S4 = _e(([n, e], t) => {
    const i = x4(t)
    return Hl(n, e, i)
  }),
  A4 = _e(([n], e) => {
    const t = x4(e)
    return n.mul(n, t, t).negate().exp().oneMinus()
  }),
  Px = _e(([n, e]) => yt(e.toFloat().mix(vh.rgb, n.toVec3()), vh.a))
function DG(n, e, t) {
  return (
    console.warn(
      'THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'
    ),
    Px(n, S4(e, t))
  )
}
function FG(n, e) {
  return (
    console.warn(
      'THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'
    ),
    Px(n, A4(e))
  )
}
let al = null,
  ll = null
class OG extends ut {
  static get type() {
    return 'RangeNode'
  }
  constructor(e = ce(), t = ce()) {
    ;(super(), (this.minNode = e), (this.maxNode = t))
  }
  getVectorLength(e) {
    const t = e.getTypeLength(Ra(this.minNode.value)),
      i = e.getTypeLength(Ra(this.maxNode.value))
    return t > i ? t : i
  }
  getNodeType(e) {
    return e.object.count > 1 ? e.getTypeFromLength(this.getVectorLength(e)) : 'float'
  }
  setup(e) {
    const t = e.object
    let i = null
    if (t.count > 1) {
      const r = this.minNode.value,
        s = this.maxNode.value,
        o = e.getTypeLength(Ra(r)),
        a = e.getTypeLength(Ra(s))
      ;((al = al || new Mt()),
        (ll = ll || new Mt()),
        al.setScalar(0),
        ll.setScalar(0),
        o === 1
          ? al.setScalar(r)
          : r.isColor
            ? al.set(r.r, r.g, r.b, 1)
            : al.set(r.x, r.y, r.z || 0, r.w || 0),
        a === 1
          ? ll.setScalar(s)
          : s.isColor
            ? ll.set(s.r, s.g, s.b, 1)
            : ll.set(s.x, s.y, s.z || 0, s.w || 0))
      const l = 4,
        c = l * t.count,
        u = new Float32Array(c)
      for (let h = 0; h < c; h++) {
        const f = h % l,
          p = al.getComponent(f),
          g = ll.getComponent(f)
        u[h] = Ea.lerp(p, g, Math.random())
      }
      const d = this.getNodeType(e)
      if (t.count <= 4096) i = Wh(u, 'vec4', t.count).element(Zh).convert(d)
      else {
        const h = new Ko(u, 4)
        ;(e.geometry.setAttribute('__range' + this.id, h), (i = Em(h).convert(d)))
      }
    } else i = ce(0)
    return i
  }
}
const BG = Pe(OG)
class UG extends ut {
  static get type() {
    return 'ComputeBuiltinNode'
  }
  constructor(e, t) {
    ;(super(t), (this._builtinName = e))
  }
  getHash(e) {
    return this.getBuiltinName(e)
  }
  getNodeType() {
    return this.nodeType
  }
  setBuiltinName(e) {
    return ((this._builtinName = e), this)
  }
  getBuiltinName() {
    return this._builtinName
  }
  hasBuiltin(e) {
    e.hasBuiltin(this._builtinName)
  }
  generate(e, t) {
    const i = this.getBuiltinName(e),
      r = this.getNodeType(e)
    return e.shaderStage === 'compute'
      ? e.format(i, r, t)
      : (console.warn(
          'ComputeBuiltinNode: Compute built-in value '
            .concat(i, ' can not be accessed in the ')
            .concat(e.shaderStage, ' stage')
        ),
        e.generateConst(r))
  }
  serialize(e) {
    ;(super.serialize(e), (e.global = this.global), (e._builtinName = this._builtinName))
  }
  deserialize(e) {
    ;(super.deserialize(e), (this.global = e.global), (this._builtinName = e._builtinName))
  }
}
const ef = (n, e) => Fe(new UG(n, e)),
  kG = ef('numWorkgroups', 'uvec3'),
  zG = ef('workgroupId', 'uvec3'),
  VG = ef('globalId', 'uvec3'),
  HG = ef('localId', 'uvec3'),
  $G = ef('subgroupSize', 'uint')
class GG extends ut {
  constructor(e) {
    ;(super(), (this.scope = e))
  }
  generate(e) {
    const { scope: t } = this,
      { renderer: i } = e
    i.backend.isWebGLBackend === !0
      ? e.addFlowCode('	// '.concat(t, 'Barrier \n'))
      : e.addLineFlowCode(''.concat(t, 'Barrier()'), this)
  }
}
const Lx = Pe(GG),
  WG = () => Lx('workgroup').append(),
  QG = () => Lx('storage').append(),
  jG = () => Lx('texture').append()
class qG extends jl {
  constructor(e, t) {
    ;(super(e, t), (this.isWorkgroupInfoElementNode = !0))
  }
  generate(e, t) {
    let i
    const r = e.context.assign
    if (((i = super.generate(e)), r !== !0)) {
      const s = this.getNodeType(e)
      i = e.format(i, s, t)
    }
    return i
  }
}
class XG extends ut {
  constructor(e, t, i = 0) {
    ;(super(t),
      (this.bufferType = t),
      (this.bufferCount = i),
      (this.isWorkgroupInfoNode = !0),
      (this.elementType = t),
      (this.scope = e))
  }
  label(e) {
    return ((this.name = e), this)
  }
  setScope(e) {
    return ((this.scope = e), this)
  }
  getElementType() {
    return this.elementType
  }
  getInputType() {
    return ''.concat(this.scope, 'Array')
  }
  element(e) {
    return Fe(new qG(this, e))
  }
  generate(e) {
    return e.getScopedArray(
      this.name || ''.concat(this.scope, 'Array_').concat(this.id),
      this.scope.toLowerCase(),
      this.bufferType,
      this.bufferCount
    )
  }
}
const KG = (n, e) => Fe(new XG('Workgroup', n, e))
class ri extends Un {
  static get type() {
    return 'AtomicFunctionNode'
  }
  constructor(e, t, i, r = null) {
    ;(super('uint'),
      (this.method = e),
      (this.pointerNode = t),
      (this.valueNode = i),
      (this.storeNode = r))
  }
  getInputType(e) {
    return this.pointerNode.getNodeType(e)
  }
  getNodeType(e) {
    return this.getInputType(e)
  }
  generate(e) {
    const t = this.method,
      i = this.getNodeType(e),
      r = this.getInputType(e),
      s = this.pointerNode,
      o = this.valueNode,
      a = []
    ;(a.push('&'.concat(s.build(e, r))), o !== null && a.push(o.build(e, r)))
    const l = ''.concat(e.getMethod(t, i), '( ').concat(a.join(', '), ' )')
    if (this.storeNode !== null) {
      const c = this.storeNode.build(e, r)
      e.addLineFlowCode(''.concat(c, ' = ').concat(l), this)
    } else e.addLineFlowCode(l, this)
  }
}
ri.ATOMIC_LOAD = 'atomicLoad'
ri.ATOMIC_STORE = 'atomicStore'
ri.ATOMIC_ADD = 'atomicAdd'
ri.ATOMIC_SUB = 'atomicSub'
ri.ATOMIC_MAX = 'atomicMax'
ri.ATOMIC_MIN = 'atomicMin'
ri.ATOMIC_AND = 'atomicAnd'
ri.ATOMIC_OR = 'atomicOr'
ri.ATOMIC_XOR = 'atomicXor'
const YG = Pe(ri),
  uo = (n, e, t, i = null) => {
    const r = YG(n, e, t, i)
    return (r.append(), r)
  },
  ZG = (n, e = null) => uo(ri.ATOMIC_LOAD, n, null, e),
  JG = (n, e, t = null) => uo(ri.ATOMIC_STORE, n, e, t),
  eW = (n, e, t = null) => uo(ri.ATOMIC_ADD, n, e, t),
  tW = (n, e, t = null) => uo(ri.ATOMIC_SUB, n, e, t),
  nW = (n, e, t = null) => uo(ri.ATOMIC_MAX, n, e, t),
  iW = (n, e, t = null) => uo(ri.ATOMIC_MIN, n, e, t),
  rW = (n, e, t = null) => uo(ri.ATOMIC_AND, n, e, t),
  sW = (n, e, t = null) => uo(ri.ATOMIC_OR, n, e, t),
  oW = (n, e, t = null) => uo(ri.ATOMIC_XOR, n, e, t)
let op
function tf(n) {
  op = op || new WeakMap()
  let e = op.get(n)
  return (e === void 0 && op.set(n, (e = {})), e)
}
function Dx(n) {
  const e = tf(n)
  return (
    e.shadowMatrix ||
    (e.shadowMatrix = Rt('mat4')
      .setGroup(Ut)
      .onRenderUpdate(() => (n.castShadow !== !0 && n.shadow.updateMatrices(n), n.shadow.matrix)))
  )
}
function aW(n) {
  const e = tf(n)
  if (e.projectionUV === void 0) {
    const t = Dx(n).mul(Dl)
    e.projectionUV = t.xyz.div(t.w)
  }
  return e.projectionUV
}
function b4(n) {
  const e = tf(n)
  return (
    e.position ||
    (e.position = Rt(new Y())
      .setGroup(Ut)
      .onRenderUpdate((t, i) => i.value.setFromMatrixPosition(n.matrixWorld)))
  )
}
function T4(n) {
  const e = tf(n)
  return (
    e.targetPosition ||
    (e.targetPosition = Rt(new Y())
      .setGroup(Ut)
      .onRenderUpdate((t, i) => i.value.setFromMatrixPosition(n.target.matrixWorld)))
  )
}
function lW(n) {
  const e = tf(n)
  return (
    e.viewPosition ||
    (e.viewPosition = Rt(new Y())
      .setGroup(Ut)
      .onRenderUpdate(({ camera: t }, i) => {
        ;((i.value = i.value || new Y()),
          i.value.setFromMatrixPosition(n.matrixWorld),
          i.value.applyMatrix4(t.matrixWorldInverse))
      }))
  )
}
const cW = (n) => ss.transformDirection(b4(n).sub(T4(n))),
  uW = (n) => n.sort((e, t) => e.id - t.id),
  dW = (n, e) => {
    for (const t of e) if (t.isAnalyticLightNode && t.light.id === n) return t
    return null
  },
  d1 = new WeakMap()
class hW extends ut {
  static get type() {
    return 'LightsNode'
  }
  constructor() {
    ;(super('vec3'),
      (this.totalDiffuseNode = ve().toVar('totalDiffuse')),
      (this.totalSpecularNode = ve().toVar('totalSpecular')),
      (this.outgoingLightNode = ve().toVar('outgoingLight')),
      (this._lights = []),
      (this._lightNodes = null),
      (this._lightNodesHash = null),
      (this.global = !0))
  }
  customCacheKey() {
    const e = [],
      t = this._lights
    for (let i = 0; i < t.length; i++) e.push(t[i].id)
    return lC(e)
  }
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e)
      const t = []
      for (const i of this._lightNodes) t.push(i.getSelf().getHash())
      this._lightNodesHash = 'lights-' + t.join(',')
    }
    return this._lightNodesHash
  }
  analyze(e) {
    const t = e.getDataFromNode(this)
    for (const i of t.nodes) i.build(e)
  }
  setupLightsNode(e) {
    const t = [],
      i = this._lightNodes,
      r = uW(this._lights),
      s = e.renderer.library
    for (const o of r)
      if (o.isNode) t.push(Fe(o))
      else {
        let a = null
        if ((i !== null && (a = dW(o.id, i)), a === null)) {
          const l = s.getLightNodeClass(o.constructor)
          if (l === null) {
            console.warn(
              'LightsNode.setupNodeLights: Light node not found for '.concat(o.constructor.name)
            )
            continue
          }
          let c = null
          ;(d1.has(o) ? (c = d1.get(o)) : ((c = Fe(new l(o))), d1.set(o, c)), t.push(c))
        }
      }
    this._lightNodes = t
  }
  setupLights(e, t) {
    for (const i of t) i.build(e)
  }
  setup(e) {
    this._lightNodes === null && this.setupLightsNode(e)
    const t = e.context,
      i = t.lightingModel
    let r = this.outgoingLightNode
    if (i) {
      const { _lightNodes: s, totalDiffuseNode: o, totalSpecularNode: a } = this
      t.outgoingLight = r
      const l = e.addStack(),
        c = e.getDataFromNode(this)
      ;((c.nodes = l.nodes), i.start(t, l, e), this.setupLights(e, s), i.indirect(t, l, e))
      const { backdrop: u, backdropAlpha: d } = t,
        {
          directDiffuse: h,
          directSpecular: f,
          indirectDiffuse: p,
          indirectSpecular: g,
        } = t.reflectedLight
      let y = h.add(p)
      ;(u !== null &&
        (d !== null ? (y = ve(d.mix(y, u))) : (y = ve(u)), (t.material.transparent = !0)),
        o.assign(y),
        a.assign(f.add(g)),
        r.assign(o.add(a)),
        i.finish(t, l, e),
        (r = r.bypass(e.removeStack())))
    }
    return r
  }
  setLights(e) {
    return ((this._lights = e), (this._lightNodes = null), (this._lightNodesHash = null), this)
  }
  getLights() {
    return this._lights
  }
  get hasLights() {
    return this._lights.length > 0
  }
}
const fW = (n = []) => Fe(new hW()).setLights(n)
class pW extends ut {
  static get type() {
    return 'ShadowBaseNode'
  }
  constructor(e) {
    ;(super(), (this.light = e), (this.updateBeforeType = Wt.RENDER), (this.isShadowBaseNode = !0))
  }
  setupShadowPosition({ material: e }) {
    Fx.assign(e.shadowPositionNode || Dl)
  }
  dispose() {
    this.updateBeforeType = Wt.NONE
  }
}
const Fx = ve().toVar('shadowPositionWorld')
function mW(n, e = {}) {
  return (
    (e.toneMapping = n.toneMapping),
    (e.toneMappingExposure = n.toneMappingExposure),
    (e.outputColorSpace = n.outputColorSpace),
    (e.renderTarget = n.getRenderTarget()),
    (e.activeCubeFace = n.getActiveCubeFace()),
    (e.activeMipmapLevel = n.getActiveMipmapLevel()),
    (e.renderObjectFunction = n.getRenderObjectFunction()),
    (e.pixelRatio = n.getPixelRatio()),
    (e.mrt = n.getMRT()),
    (e.clearColor = n.getClearColor(e.clearColor || new gt())),
    (e.clearAlpha = n.getClearAlpha()),
    (e.autoClear = n.autoClear),
    (e.scissorTest = n.getScissorTest()),
    e
  )
}
function gW(n, e) {
  return (
    (e = mW(n, e)),
    n.setMRT(null),
    n.setRenderObjectFunction(null),
    n.setClearColor(0, 1),
    (n.autoClear = !0),
    e
  )
}
function yW(n, e) {
  ;((n.toneMapping = e.toneMapping),
    (n.toneMappingExposure = e.toneMappingExposure),
    (n.outputColorSpace = e.outputColorSpace),
    n.setRenderTarget(e.renderTarget, e.activeCubeFace, e.activeMipmapLevel),
    n.setRenderObjectFunction(e.renderObjectFunction),
    n.setPixelRatio(e.pixelRatio),
    n.setMRT(e.mrt),
    n.setClearColor(e.clearColor, e.clearAlpha),
    (n.autoClear = e.autoClear),
    n.setScissorTest(e.scissorTest))
}
function vW(n, e = {}) {
  return (
    (e.background = n.background),
    (e.backgroundNode = n.backgroundNode),
    (e.overrideMaterial = n.overrideMaterial),
    e
  )
}
function _W(n, e) {
  return (
    (e = vW(n, e)),
    (n.background = null),
    (n.backgroundNode = null),
    (n.overrideMaterial = null),
    e
  )
}
function xW(n, e) {
  ;((n.background = e.background),
    (n.backgroundNode = e.backgroundNode),
    (n.overrideMaterial = e.overrideMaterial))
}
function SW(n, e, t) {
  return ((t = gW(n, t)), (t = _W(e, t)), t)
}
function AW(n, e, t) {
  ;(yW(n, t), xW(e, t))
}
const Rb = new WeakMap(),
  bW = _e(([n, e, t]) => {
    let i = Dl.sub(n).length()
    return ((i = i.sub(e).div(t.sub(e))), (i = i.saturate()), i)
  }),
  TW = (n) => {
    const e = n.shadow.camera,
      t = Pn('near', 'float', e).setGroup(Ut),
      i = Pn('far', 'float', e).setGroup(Ut),
      r = oM(n)
    return bW(r, t, i)
  },
  wW = (n) => {
    let e = Rb.get(n)
    if (e === void 0) {
      const t = n.isPointLight ? TW(n) : null
      ;((e = new _h()),
        (e.colorNode = yt(0, 0, 0, 1)),
        (e.depthNode = t),
        (e.isShadowPassMaterial = !0),
        (e.name = 'ShadowMaterial'),
        (e.fog = !1),
        Rb.set(n, e))
    }
    return e
  },
  w4 = _e(({ depthTexture: n, shadowCoord: e }) => Ji(n, e.xy).compare(e.z)),
  C4 = _e(({ depthTexture: n, shadowCoord: e, shadow: t }) => {
    const i = (g, y) => Ji(n, g).compare(y),
      r = Pn('mapSize', 'vec2', t).setGroup(Ut),
      s = Pn('radius', 'float', t).setGroup(Ut),
      o = He(1).div(r),
      a = o.x.negate().mul(s),
      l = o.y.negate().mul(s),
      c = o.x.mul(s),
      u = o.y.mul(s),
      d = a.div(2),
      h = l.div(2),
      f = c.div(2),
      p = u.div(2)
    return On(
      i(e.xy.add(He(a, l)), e.z),
      i(e.xy.add(He(0, l)), e.z),
      i(e.xy.add(He(c, l)), e.z),
      i(e.xy.add(He(d, h)), e.z),
      i(e.xy.add(He(0, h)), e.z),
      i(e.xy.add(He(f, h)), e.z),
      i(e.xy.add(He(a, 0)), e.z),
      i(e.xy.add(He(d, 0)), e.z),
      i(e.xy, e.z),
      i(e.xy.add(He(f, 0)), e.z),
      i(e.xy.add(He(c, 0)), e.z),
      i(e.xy.add(He(d, p)), e.z),
      i(e.xy.add(He(0, p)), e.z),
      i(e.xy.add(He(f, p)), e.z),
      i(e.xy.add(He(a, u)), e.z),
      i(e.xy.add(He(0, u)), e.z),
      i(e.xy.add(He(c, u)), e.z)
    ).mul(1 / 17)
  }),
  E4 = _e(({ depthTexture: n, shadowCoord: e, shadow: t }) => {
    const i = (u, d) => Ji(n, u).compare(d),
      r = Pn('mapSize', 'vec2', t).setGroup(Ut),
      s = He(1).div(r),
      o = s.x,
      a = s.y,
      l = e.xy,
      c = sa(l.mul(r).add(0.5))
    return (
      l.subAssign(c.mul(s)),
      On(
        i(l, e.z),
        i(l.add(He(o, 0)), e.z),
        i(l.add(He(0, a)), e.z),
        i(l.add(s), e.z),
        Ln(i(l.add(He(o.negate(), 0)), e.z), i(l.add(He(o.mul(2), 0)), e.z), c.x),
        Ln(i(l.add(He(o.negate(), a)), e.z), i(l.add(He(o.mul(2), a)), e.z), c.x),
        Ln(i(l.add(He(0, a.negate())), e.z), i(l.add(He(0, a.mul(2))), e.z), c.y),
        Ln(i(l.add(He(o, a.negate())), e.z), i(l.add(He(o, a.mul(2))), e.z), c.y),
        Ln(
          Ln(
            i(l.add(He(o.negate(), a.negate())), e.z),
            i(l.add(He(o.mul(2), a.negate())), e.z),
            c.x
          ),
          Ln(i(l.add(He(o.negate(), a.mul(2))), e.z), i(l.add(He(o.mul(2), a.mul(2))), e.z), c.x),
          c.y
        )
      ).mul(1 / 9)
    )
  }),
  M4 = _e(({ depthTexture: n, shadowCoord: e }) => {
    const t = ce(1).toVar(),
      i = Ji(n).sample(e.xy).rg,
      r = y0(e.z, i.x)
    return (
      Dt(r.notEqual(ce(1)), () => {
        const s = e.z.sub(i.x),
          o = ui(0, i.y.mul(i.y))
        let a = o.div(o.add(s.mul(s)))
        ;((a = Jo(Bt(a, 0.3).div(0.95 - 0.3))), t.assign(Jo(ui(r, a))))
      }),
      t
    )
  }),
  CW = _e(({ samples: n, radius: e, size: t, shadowPass: i }) => {
    const r = ce(0).toVar(),
      s = ce(0).toVar(),
      o = n.lessThanEqual(ce(1)).select(ce(0), ce(2).div(n.sub(1))),
      a = n.lessThanEqual(ce(1)).select(ce(0), ce(-1))
    ;(cn({ start: de(0), end: de(n), type: 'int', condition: '<' }, ({ i: c }) => {
      const u = a.add(ce(c).mul(o)),
        d = i.sample(On(Jh.xy, He(0, u).mul(e)).div(t)).x
      ;(r.addAssign(d), s.addAssign(d.mul(d)))
    }),
      r.divAssign(n),
      s.divAssign(n))
    const l = co(s.sub(r.mul(r)))
    return He(r, l)
  }),
  EW = _e(({ samples: n, radius: e, size: t, shadowPass: i }) => {
    const r = ce(0).toVar(),
      s = ce(0).toVar(),
      o = n.lessThanEqual(ce(1)).select(ce(0), ce(2).div(n.sub(1))),
      a = n.lessThanEqual(ce(1)).select(ce(0), ce(-1))
    ;(cn({ start: de(0), end: de(n), type: 'int', condition: '<' }, ({ i: c }) => {
      const u = a.add(ce(c).mul(o)),
        d = i.sample(On(Jh.xy, He(u, 0).mul(e)).div(t))
      ;(r.addAssign(d.x), s.addAssign(On(d.y.mul(d.y), d.x.mul(d.x))))
    }),
      r.divAssign(n),
      s.divAssign(n))
    const l = co(s.sub(r.mul(r)))
    return He(r, l)
  }),
  MW = [w4, C4, E4, M4]
let h1
const ap = new c4()
class RW extends pW {
  static get type() {
    return 'ShadowNode'
  }
  constructor(e, t = null) {
    ;(super(e),
      (this.shadow = t || e.shadow),
      (this.shadowMap = null),
      (this.vsmShadowMapVertical = null),
      (this.vsmShadowMapHorizontal = null),
      (this.vsmMaterialVertical = null),
      (this.vsmMaterialHorizontal = null),
      (this._node = null),
      (this.isShadowNode = !0))
  }
  setupShadowFilter(e, { filterFn: t, depthTexture: i, shadowCoord: r, shadow: s }) {
    const o = r.x
        .greaterThanEqual(0)
        .and(r.x.lessThanEqual(1))
        .and(r.y.greaterThanEqual(0))
        .and(r.y.lessThanEqual(1))
        .and(r.z.lessThanEqual(1)),
      a = t({ depthTexture: i, shadowCoord: r, shadow: s })
    return o.select(a, ce(1))
  }
  setupShadowCoord(e, t) {
    const { shadow: i } = this,
      { renderer: r } = e,
      s = Pn('bias', 'float', i).setGroup(Ut)
    let o = t,
      a
    if (i.camera.isOrthographicCamera || r.logarithmicDepthBuffer !== !0)
      ((o = o.xyz.div(o.w)), (a = o.z), r.coordinateSystem === Xo && (a = a.mul(2).sub(1)))
    else {
      const l = o.w
      o = o.xy.div(l)
      const c = Pn('near', 'float', i.camera).setGroup(Ut),
        u = Pn('far', 'float', i.camera).setGroup(Ut)
      a = Mx(l.negate(), c, u)
    }
    return ((o = ve(o.x, o.y.oneMinus(), a.add(s))), o)
  }
  getShadowFilterFn(e) {
    return MW[e]
  }
  setupShadow(e) {
    const { renderer: t } = e,
      { light: i, shadow: r } = this,
      s = t.shadowMap.type,
      o = new Ha(r.mapSize.width, r.mapSize.height)
    o.compareFunction = N5
    const a = e.createRenderTarget(r.mapSize.width, r.mapSize.height)
    if (((a.depthTexture = o), r.camera.updateProjectionMatrix(), s === Ar)) {
      ;((o.compareFunction = null),
        (this.vsmShadowMapVertical = e.createRenderTarget(r.mapSize.width, r.mapSize.height, {
          format: lh,
          type: ws,
        })),
        (this.vsmShadowMapHorizontal = e.createRenderTarget(r.mapSize.width, r.mapSize.height, {
          format: lh,
          type: ws,
        })))
      const m = Ji(o),
        v = Ji(this.vsmShadowMapVertical.texture),
        x = Pn('blurSamples', 'float', r).setGroup(Ut),
        _ = Pn('radius', 'float', r).setGroup(Ut),
        S = Pn('mapSize', 'vec2', r).setGroup(Ut)
      let C = this.vsmMaterialVertical || (this.vsmMaterialVertical = new _h())
      ;((C.fragmentNode = CW({ samples: x, radius: _, size: S, shadowPass: m }).context(
        e.getSharedContext()
      )),
        (C.name = 'VSMVertical'),
        (C = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new _h())),
        (C.fragmentNode = EW({ samples: x, radius: _, size: S, shadowPass: v }).context(
          e.getSharedContext()
        )),
        (C.name = 'VSMHorizontal'))
    }
    const l = Pn('intensity', 'float', r).setGroup(Ut),
      c = Pn('normalBias', 'float', r).setGroup(Ut),
      u = Dx(i).mul(Fx.add(fM.mul(c))),
      d = this.setupShadowCoord(e, u),
      h = r.filterNode || this.getShadowFilterFn(t.shadowMap.type) || null
    if (h === null) throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.')
    const f = s === Ar ? this.vsmShadowMapHorizontal.texture : o,
      p = this.setupShadowFilter(e, {
        filterFn: h,
        shadowTexture: a.texture,
        depthTexture: f,
        shadowCoord: d,
        shadow: r,
      }),
      g = Ji(a.texture, d),
      y = Ln(1, p.rgb.mix(g, 1), l.mul(g.a)).toVar()
    return ((this.shadowMap = a), (this.shadow.map = a), y)
  }
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return _e(() => {
        let t = this._node
        return (
          this.setupShadowPosition(e),
          t === null && (this._node = t = this.setupShadow(e)),
          e.material.shadowNode &&
            console.warn(
              'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'
            ),
          e.material.receivedShadowNode && (t = e.material.receivedShadowNode(t)),
          t
        )
      })()
  }
  renderShadow(e) {
    const { shadow: t, shadowMap: i, light: r } = this,
      { renderer: s, scene: o } = e
    ;(t.updateMatrices(r), i.setSize(t.mapSize.width, t.mapSize.height), s.render(o, t.camera))
  }
  updateShadow(e) {
    const { shadowMap: t, light: i, shadow: r } = this,
      { renderer: s, scene: o, camera: a } = e,
      l = s.shadowMap.type,
      c = t.depthTexture.version
    ;((this._depthVersionCached = c), (r.camera.layers.mask = a.layers.mask))
    const u = s.getRenderObjectFunction(),
      d = s.getMRT(),
      h = d ? d.has('velocity') : !1
    ;((h1 = SW(s, o, h1)),
      (o.overrideMaterial = wW(i)),
      s.setRenderObjectFunction((f, p, g, y, m, v, ...x) => {
        ;(f.castShadow === !0 || (f.receiveShadow && l === Ar)) &&
          (h && (hC(f).useVelocity = !0),
          f.onBeforeShadow(s, f, a, r.camera, y, p.overrideMaterial, v),
          s.renderObject(f, p, g, y, m, v, ...x),
          f.onAfterShadow(s, f, a, r.camera, y, p.overrideMaterial, v))
      }),
      s.setRenderTarget(t),
      this.renderShadow(e),
      s.setRenderObjectFunction(u),
      i.isPointLight !== !0 && l === Ar && this.vsmPass(s),
      AW(s, o, h1))
  }
  vsmPass(e) {
    const { shadow: t } = this
    ;(this.vsmShadowMapVertical.setSize(t.mapSize.width, t.mapSize.height),
      this.vsmShadowMapHorizontal.setSize(t.mapSize.width, t.mapSize.height),
      e.setRenderTarget(this.vsmShadowMapVertical),
      (ap.material = this.vsmMaterialVertical),
      ap.render(e),
      e.setRenderTarget(this.vsmShadowMapHorizontal),
      (ap.material = this.vsmMaterialHorizontal),
      ap.render(e))
  }
  dispose() {
    ;(this.shadowMap.dispose(),
      (this.shadowMap = null),
      this.vsmShadowMapVertical !== null &&
        (this.vsmShadowMapVertical.dispose(),
        (this.vsmShadowMapVertical = null),
        this.vsmMaterialVertical.dispose(),
        (this.vsmMaterialVertical = null)),
      this.vsmShadowMapHorizontal !== null &&
        (this.vsmShadowMapHorizontal.dispose(),
        (this.vsmShadowMapHorizontal = null),
        this.vsmMaterialHorizontal.dispose(),
        (this.vsmMaterialHorizontal = null)),
      super.dispose())
  }
  updateBefore(e) {
    const { shadow: t } = this
    ;(t.needsUpdate || t.autoUpdate) &&
      (this.updateShadow(e),
      this.shadowMap.depthTexture.version === this._depthVersionCached && (t.needsUpdate = !1))
  }
}
const IW = (n, e) => Fe(new RW(n, e)),
  R4 = _e((n) => {
    const { lightDistance: e, cutoffDistance: t, decayExponent: i } = n,
      r = e.pow(i).max(0.01).reciprocal()
    return t.greaterThan(0).select(r.mul(e.div(t).pow4().oneMinus().clamp().pow2()), r)
  }),
  NW = _e(({ color: n, lightViewPosition: e, cutoffDistance: t, decayExponent: i }, r) => {
    const s = r.context.lightingModel,
      o = e.sub(Yn),
      a = o.normalize(),
      l = o.length(),
      c = R4({ lightDistance: l, cutoffDistance: t, decayExponent: i }),
      u = n.mul(c),
      d = r.context.reflectedLight
    s.direct({ lightDirection: a, lightColor: u, reflectedLight: d }, r.stack, r)
  }),
  PW = _e(([n = xn()]) => {
    const e = n.mul(2),
      t = e.x.floor(),
      i = e.y.floor()
    return t.add(i).mod(2).sign()
  }),
  LW = _e(([n = xn()], { renderer: e, material: t }) => {
    const i = ce(1).toVar(),
      r = hx(n.mul(2).sub(1))
    if (t.alphaToCoverage && e.samples > 1) {
      const s = ce(r.fwidth()).toVar()
      i.assign(Hl(s.oneMinus(), s.add(1), r).oneMinus())
    } else r.greaterThan(1).discard()
    return i
  }),
  Wd = _e(([n, e, t]) => {
    const i = ce(t).toVar(),
      r = ce(e).toVar(),
      s = Yo(n).toVar()
    return rr(s, r, i)
  }).setLayout({
    name: 'mx_select',
    type: 'float',
    inputs: [
      { name: 'b', type: 'bool' },
      { name: 't', type: 'float' },
      { name: 'f', type: 'float' },
    ],
  }),
  Lm = _e(([n, e]) => {
    const t = Yo(e).toVar(),
      i = ce(n).toVar()
    return rr(t, i.negate(), i)
  }).setLayout({
    name: 'mx_negate_if',
    type: 'float',
    inputs: [
      { name: 'val', type: 'float' },
      { name: 'b', type: 'bool' },
    ],
  }),
  Fn = _e(([n]) => {
    const e = ce(n).toVar()
    return de(Xs(e))
  }).setLayout({ name: 'mx_floor', type: 'int', inputs: [{ name: 'x', type: 'float' }] }),
  _n = _e(([n, e]) => {
    const t = ce(n).toVar()
    return (e.assign(Fn(t)), t.sub(ce(e)))
  }),
  DW = _e(([n, e, t, i, r, s]) => {
    const o = ce(s).toVar(),
      a = ce(r).toVar(),
      l = ce(i).toVar(),
      c = ce(t).toVar(),
      u = ce(e).toVar(),
      d = ce(n).toVar(),
      h = ce(Bt(1, a)).toVar()
    return Bt(1, o)
      .mul(d.mul(h).add(u.mul(a)))
      .add(o.mul(c.mul(h).add(l.mul(a))))
  }).setLayout({
    name: 'mx_bilerp_0',
    type: 'float',
    inputs: [
      { name: 'v0', type: 'float' },
      { name: 'v1', type: 'float' },
      { name: 'v2', type: 'float' },
      { name: 'v3', type: 'float' },
      { name: 's', type: 'float' },
      { name: 't', type: 'float' },
    ],
  }),
  FW = _e(([n, e, t, i, r, s]) => {
    const o = ce(s).toVar(),
      a = ce(r).toVar(),
      l = ve(i).toVar(),
      c = ve(t).toVar(),
      u = ve(e).toVar(),
      d = ve(n).toVar(),
      h = ce(Bt(1, a)).toVar()
    return Bt(1, o)
      .mul(d.mul(h).add(u.mul(a)))
      .add(o.mul(c.mul(h).add(l.mul(a))))
  }).setLayout({
    name: 'mx_bilerp_1',
    type: 'vec3',
    inputs: [
      { name: 'v0', type: 'vec3' },
      { name: 'v1', type: 'vec3' },
      { name: 'v2', type: 'vec3' },
      { name: 'v3', type: 'vec3' },
      { name: 's', type: 'float' },
      { name: 't', type: 'float' },
    ],
  }),
  I4 = Ai([DW, FW]),
  OW = _e(([n, e, t, i, r, s, o, a, l, c, u]) => {
    const d = ce(u).toVar(),
      h = ce(c).toVar(),
      f = ce(l).toVar(),
      p = ce(a).toVar(),
      g = ce(o).toVar(),
      y = ce(s).toVar(),
      m = ce(r).toVar(),
      v = ce(i).toVar(),
      x = ce(t).toVar(),
      _ = ce(e).toVar(),
      S = ce(n).toVar(),
      C = ce(Bt(1, f)).toVar(),
      A = ce(Bt(1, h)).toVar()
    return ce(Bt(1, d))
      .toVar()
      .mul(A.mul(S.mul(C).add(_.mul(f))).add(h.mul(x.mul(C).add(v.mul(f)))))
      .add(d.mul(A.mul(m.mul(C).add(y.mul(f))).add(h.mul(g.mul(C).add(p.mul(f))))))
  }).setLayout({
    name: 'mx_trilerp_0',
    type: 'float',
    inputs: [
      { name: 'v0', type: 'float' },
      { name: 'v1', type: 'float' },
      { name: 'v2', type: 'float' },
      { name: 'v3', type: 'float' },
      { name: 'v4', type: 'float' },
      { name: 'v5', type: 'float' },
      { name: 'v6', type: 'float' },
      { name: 'v7', type: 'float' },
      { name: 's', type: 'float' },
      { name: 't', type: 'float' },
      { name: 'r', type: 'float' },
    ],
  }),
  BW = _e(([n, e, t, i, r, s, o, a, l, c, u]) => {
    const d = ce(u).toVar(),
      h = ce(c).toVar(),
      f = ce(l).toVar(),
      p = ve(a).toVar(),
      g = ve(o).toVar(),
      y = ve(s).toVar(),
      m = ve(r).toVar(),
      v = ve(i).toVar(),
      x = ve(t).toVar(),
      _ = ve(e).toVar(),
      S = ve(n).toVar(),
      C = ce(Bt(1, f)).toVar(),
      A = ce(Bt(1, h)).toVar()
    return ce(Bt(1, d))
      .toVar()
      .mul(A.mul(S.mul(C).add(_.mul(f))).add(h.mul(x.mul(C).add(v.mul(f)))))
      .add(d.mul(A.mul(m.mul(C).add(y.mul(f))).add(h.mul(g.mul(C).add(p.mul(f))))))
  }).setLayout({
    name: 'mx_trilerp_1',
    type: 'vec3',
    inputs: [
      { name: 'v0', type: 'vec3' },
      { name: 'v1', type: 'vec3' },
      { name: 'v2', type: 'vec3' },
      { name: 'v3', type: 'vec3' },
      { name: 'v4', type: 'vec3' },
      { name: 'v5', type: 'vec3' },
      { name: 'v6', type: 'vec3' },
      { name: 'v7', type: 'vec3' },
      { name: 's', type: 'float' },
      { name: 't', type: 'float' },
      { name: 'r', type: 'float' },
    ],
  }),
  N4 = Ai([OW, BW]),
  UW = _e(([n, e, t]) => {
    const i = ce(t).toVar(),
      r = ce(e).toVar(),
      s = Ye(n).toVar(),
      o = Ye(s.bitAnd(Ye(7))).toVar(),
      a = ce(Wd(o.lessThan(Ye(4)), r, i)).toVar(),
      l = ce(xt(2, Wd(o.lessThan(Ye(4)), i, r))).toVar()
    return Lm(a, Yo(o.bitAnd(Ye(1)))).add(Lm(l, Yo(o.bitAnd(Ye(2)))))
  }).setLayout({
    name: 'mx_gradient_float_0',
    type: 'float',
    inputs: [
      { name: 'hash', type: 'uint' },
      { name: 'x', type: 'float' },
      { name: 'y', type: 'float' },
    ],
  }),
  kW = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = ce(e).toVar(),
      a = Ye(n).toVar(),
      l = Ye(a.bitAnd(Ye(15))).toVar(),
      c = ce(Wd(l.lessThan(Ye(8)), o, s)).toVar(),
      u = ce(Wd(l.lessThan(Ye(4)), s, Wd(l.equal(Ye(12)).or(l.equal(Ye(14))), o, r))).toVar()
    return Lm(c, Yo(l.bitAnd(Ye(1)))).add(Lm(u, Yo(l.bitAnd(Ye(2)))))
  }).setLayout({
    name: 'mx_gradient_float_1',
    type: 'float',
    inputs: [
      { name: 'hash', type: 'uint' },
      { name: 'x', type: 'float' },
      { name: 'y', type: 'float' },
      { name: 'z', type: 'float' },
    ],
  }),
  ci = Ai([UW, kW]),
  zW = _e(([n, e, t]) => {
    const i = ce(t).toVar(),
      r = ce(e).toVar(),
      s = zu(n).toVar()
    return ve(ci(s.x, r, i), ci(s.y, r, i), ci(s.z, r, i))
  }).setLayout({
    name: 'mx_gradient_vec3_0',
    type: 'vec3',
    inputs: [
      { name: 'hash', type: 'uvec3' },
      { name: 'x', type: 'float' },
      { name: 'y', type: 'float' },
    ],
  }),
  VW = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = ce(e).toVar(),
      a = zu(n).toVar()
    return ve(ci(a.x, o, s, r), ci(a.y, o, s, r), ci(a.z, o, s, r))
  }).setLayout({
    name: 'mx_gradient_vec3_1',
    type: 'vec3',
    inputs: [
      { name: 'hash', type: 'uvec3' },
      { name: 'x', type: 'float' },
      { name: 'y', type: 'float' },
      { name: 'z', type: 'float' },
    ],
  }),
  Qr = Ai([zW, VW]),
  HW = _e(([n]) => {
    const e = ce(n).toVar()
    return xt(0.6616, e)
  }).setLayout({
    name: 'mx_gradient_scale2d_0',
    type: 'float',
    inputs: [{ name: 'v', type: 'float' }],
  }),
  $W = _e(([n]) => {
    const e = ce(n).toVar()
    return xt(0.982, e)
  }).setLayout({
    name: 'mx_gradient_scale3d_0',
    type: 'float',
    inputs: [{ name: 'v', type: 'float' }],
  }),
  GW = _e(([n]) => {
    const e = ve(n).toVar()
    return xt(0.6616, e)
  }).setLayout({
    name: 'mx_gradient_scale2d_1',
    type: 'vec3',
    inputs: [{ name: 'v', type: 'vec3' }],
  }),
  P4 = Ai([HW, GW]),
  WW = _e(([n]) => {
    const e = ve(n).toVar()
    return xt(0.982, e)
  }).setLayout({
    name: 'mx_gradient_scale3d_1',
    type: 'vec3',
    inputs: [{ name: 'v', type: 'vec3' }],
  }),
  L4 = Ai([$W, WW]),
  br = _e(([n, e]) => {
    const t = de(e).toVar(),
      i = Ye(n).toVar()
    return i.shiftLeft(t).bitOr(i.shiftRight(de(32).sub(t)))
  }).setLayout({
    name: 'mx_rotl32',
    type: 'uint',
    inputs: [
      { name: 'x', type: 'uint' },
      { name: 'k', type: 'int' },
    ],
  }),
  D4 = _e(([n, e, t]) => {
    ;(n.subAssign(t),
      n.bitXorAssign(br(t, de(4))),
      t.addAssign(e),
      e.subAssign(n),
      e.bitXorAssign(br(n, de(6))),
      n.addAssign(t),
      t.subAssign(e),
      t.bitXorAssign(br(e, de(8))),
      e.addAssign(n),
      n.subAssign(t),
      n.bitXorAssign(br(t, de(16))),
      t.addAssign(e),
      e.subAssign(n),
      e.bitXorAssign(br(n, de(19))),
      n.addAssign(t),
      t.subAssign(e),
      t.bitXorAssign(br(e, de(4))),
      e.addAssign(n))
  }),
  nf = _e(([n, e, t]) => {
    const i = Ye(t).toVar(),
      r = Ye(e).toVar(),
      s = Ye(n).toVar()
    return (
      i.bitXorAssign(r),
      i.subAssign(br(r, de(14))),
      s.bitXorAssign(i),
      s.subAssign(br(i, de(11))),
      r.bitXorAssign(s),
      r.subAssign(br(s, de(25))),
      i.bitXorAssign(r),
      i.subAssign(br(r, de(16))),
      s.bitXorAssign(i),
      s.subAssign(br(i, de(4))),
      r.bitXorAssign(s),
      r.subAssign(br(s, de(14))),
      i.bitXorAssign(r),
      i.subAssign(br(r, de(24))),
      i
    )
  }).setLayout({
    name: 'mx_bjfinal',
    type: 'uint',
    inputs: [
      { name: 'a', type: 'uint' },
      { name: 'b', type: 'uint' },
      { name: 'c', type: 'uint' },
    ],
  }),
  Bi = _e(([n]) => {
    const e = Ye(n).toVar()
    return ce(e).div(ce(Ye(de(4294967295))))
  }).setLayout({ name: 'mx_bits_to_01', type: 'float', inputs: [{ name: 'bits', type: 'uint' }] }),
  Ks = _e(([n]) => {
    const e = ce(n).toVar()
    return e
      .mul(e)
      .mul(e)
      .mul(e.mul(e.mul(6).sub(15)).add(10))
  }).setLayout({ name: 'mx_fade', type: 'float', inputs: [{ name: 't', type: 'float' }] }),
  QW = _e(([n]) => {
    const e = de(n).toVar(),
      t = Ye(Ye(1)).toVar(),
      i = Ye(
        Ye(de(3735928559))
          .add(t.shiftLeft(Ye(2)))
          .add(Ye(13))
      ).toVar()
    return nf(i.add(Ye(e)), i, i)
  }).setLayout({ name: 'mx_hash_int_0', type: 'uint', inputs: [{ name: 'x', type: 'int' }] }),
  jW = _e(([n, e]) => {
    const t = de(e).toVar(),
      i = de(n).toVar(),
      r = Ye(Ye(2)).toVar(),
      s = Ye().toVar(),
      o = Ye().toVar(),
      a = Ye().toVar()
    return (
      s.assign(
        o.assign(
          a.assign(
            Ye(de(3735928559))
              .add(r.shiftLeft(Ye(2)))
              .add(Ye(13))
          )
        )
      ),
      s.addAssign(Ye(i)),
      o.addAssign(Ye(t)),
      nf(s, o, a)
    )
  }).setLayout({
    name: 'mx_hash_int_1',
    type: 'uint',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
    ],
  }),
  qW = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = de(e).toVar(),
      s = de(n).toVar(),
      o = Ye(Ye(3)).toVar(),
      a = Ye().toVar(),
      l = Ye().toVar(),
      c = Ye().toVar()
    return (
      a.assign(
        l.assign(
          c.assign(
            Ye(de(3735928559))
              .add(o.shiftLeft(Ye(2)))
              .add(Ye(13))
          )
        )
      ),
      a.addAssign(Ye(s)),
      l.addAssign(Ye(r)),
      c.addAssign(Ye(i)),
      nf(a, l, c)
    )
  }).setLayout({
    name: 'mx_hash_int_2',
    type: 'uint',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'z', type: 'int' },
    ],
  }),
  XW = _e(([n, e, t, i]) => {
    const r = de(i).toVar(),
      s = de(t).toVar(),
      o = de(e).toVar(),
      a = de(n).toVar(),
      l = Ye(Ye(4)).toVar(),
      c = Ye().toVar(),
      u = Ye().toVar(),
      d = Ye().toVar()
    return (
      c.assign(
        u.assign(
          d.assign(
            Ye(de(3735928559))
              .add(l.shiftLeft(Ye(2)))
              .add(Ye(13))
          )
        )
      ),
      c.addAssign(Ye(a)),
      u.addAssign(Ye(o)),
      d.addAssign(Ye(s)),
      D4(c, u, d),
      c.addAssign(Ye(r)),
      nf(c, u, d)
    )
  }).setLayout({
    name: 'mx_hash_int_3',
    type: 'uint',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'z', type: 'int' },
      { name: 'xx', type: 'int' },
    ],
  }),
  KW = _e(([n, e, t, i, r]) => {
    const s = de(r).toVar(),
      o = de(i).toVar(),
      a = de(t).toVar(),
      l = de(e).toVar(),
      c = de(n).toVar(),
      u = Ye(Ye(5)).toVar(),
      d = Ye().toVar(),
      h = Ye().toVar(),
      f = Ye().toVar()
    return (
      d.assign(
        h.assign(
          f.assign(
            Ye(de(3735928559))
              .add(u.shiftLeft(Ye(2)))
              .add(Ye(13))
          )
        )
      ),
      d.addAssign(Ye(c)),
      h.addAssign(Ye(l)),
      f.addAssign(Ye(a)),
      D4(d, h, f),
      d.addAssign(Ye(o)),
      h.addAssign(Ye(s)),
      nf(d, h, f)
    )
  }).setLayout({
    name: 'mx_hash_int_4',
    type: 'uint',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'z', type: 'int' },
      { name: 'xx', type: 'int' },
      { name: 'yy', type: 'int' },
    ],
  }),
  rn = Ai([QW, jW, qW, XW, KW]),
  YW = _e(([n, e]) => {
    const t = de(e).toVar(),
      i = de(n).toVar(),
      r = Ye(rn(i, t)).toVar(),
      s = zu().toVar()
    return (
      s.x.assign(r.bitAnd(de(255))),
      s.y.assign(r.shiftRight(de(8)).bitAnd(de(255))),
      s.z.assign(r.shiftRight(de(16)).bitAnd(de(255))),
      s
    )
  }).setLayout({
    name: 'mx_hash_vec3_0',
    type: 'uvec3',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
    ],
  }),
  ZW = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = de(e).toVar(),
      s = de(n).toVar(),
      o = Ye(rn(s, r, i)).toVar(),
      a = zu().toVar()
    return (
      a.x.assign(o.bitAnd(de(255))),
      a.y.assign(o.shiftRight(de(8)).bitAnd(de(255))),
      a.z.assign(o.shiftRight(de(16)).bitAnd(de(255))),
      a
    )
  }).setLayout({
    name: 'mx_hash_vec3_1',
    type: 'uvec3',
    inputs: [
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'z', type: 'int' },
    ],
  }),
  jr = Ai([YW, ZW]),
  JW = _e(([n]) => {
    const e = He(n).toVar(),
      t = de().toVar(),
      i = de().toVar(),
      r = ce(_n(e.x, t)).toVar(),
      s = ce(_n(e.y, i)).toVar(),
      o = ce(Ks(r)).toVar(),
      a = ce(Ks(s)).toVar(),
      l = ce(
        I4(
          ci(rn(t, i), r, s),
          ci(rn(t.add(de(1)), i), r.sub(1), s),
          ci(rn(t, i.add(de(1))), r, s.sub(1)),
          ci(rn(t.add(de(1)), i.add(de(1))), r.sub(1), s.sub(1)),
          o,
          a
        )
      ).toVar()
    return P4(l)
  }).setLayout({
    name: 'mx_perlin_noise_float_0',
    type: 'float',
    inputs: [{ name: 'p', type: 'vec2' }],
  }),
  eQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = de().toVar(),
      i = de().toVar(),
      r = de().toVar(),
      s = ce(_n(e.x, t)).toVar(),
      o = ce(_n(e.y, i)).toVar(),
      a = ce(_n(e.z, r)).toVar(),
      l = ce(Ks(s)).toVar(),
      c = ce(Ks(o)).toVar(),
      u = ce(Ks(a)).toVar(),
      d = ce(
        N4(
          ci(rn(t, i, r), s, o, a),
          ci(rn(t.add(de(1)), i, r), s.sub(1), o, a),
          ci(rn(t, i.add(de(1)), r), s, o.sub(1), a),
          ci(rn(t.add(de(1)), i.add(de(1)), r), s.sub(1), o.sub(1), a),
          ci(rn(t, i, r.add(de(1))), s, o, a.sub(1)),
          ci(rn(t.add(de(1)), i, r.add(de(1))), s.sub(1), o, a.sub(1)),
          ci(rn(t, i.add(de(1)), r.add(de(1))), s, o.sub(1), a.sub(1)),
          ci(rn(t.add(de(1)), i.add(de(1)), r.add(de(1))), s.sub(1), o.sub(1), a.sub(1)),
          l,
          c,
          u
        )
      ).toVar()
    return L4(d)
  }).setLayout({
    name: 'mx_perlin_noise_float_1',
    type: 'float',
    inputs: [{ name: 'p', type: 'vec3' }],
  }),
  Ox = Ai([JW, eQ]),
  tQ = _e(([n]) => {
    const e = He(n).toVar(),
      t = de().toVar(),
      i = de().toVar(),
      r = ce(_n(e.x, t)).toVar(),
      s = ce(_n(e.y, i)).toVar(),
      o = ce(Ks(r)).toVar(),
      a = ce(Ks(s)).toVar(),
      l = ve(
        I4(
          Qr(jr(t, i), r, s),
          Qr(jr(t.add(de(1)), i), r.sub(1), s),
          Qr(jr(t, i.add(de(1))), r, s.sub(1)),
          Qr(jr(t.add(de(1)), i.add(de(1))), r.sub(1), s.sub(1)),
          o,
          a
        )
      ).toVar()
    return P4(l)
  }).setLayout({
    name: 'mx_perlin_noise_vec3_0',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'vec2' }],
  }),
  nQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = de().toVar(),
      i = de().toVar(),
      r = de().toVar(),
      s = ce(_n(e.x, t)).toVar(),
      o = ce(_n(e.y, i)).toVar(),
      a = ce(_n(e.z, r)).toVar(),
      l = ce(Ks(s)).toVar(),
      c = ce(Ks(o)).toVar(),
      u = ce(Ks(a)).toVar(),
      d = ve(
        N4(
          Qr(jr(t, i, r), s, o, a),
          Qr(jr(t.add(de(1)), i, r), s.sub(1), o, a),
          Qr(jr(t, i.add(de(1)), r), s, o.sub(1), a),
          Qr(jr(t.add(de(1)), i.add(de(1)), r), s.sub(1), o.sub(1), a),
          Qr(jr(t, i, r.add(de(1))), s, o, a.sub(1)),
          Qr(jr(t.add(de(1)), i, r.add(de(1))), s.sub(1), o, a.sub(1)),
          Qr(jr(t, i.add(de(1)), r.add(de(1))), s, o.sub(1), a.sub(1)),
          Qr(jr(t.add(de(1)), i.add(de(1)), r.add(de(1))), s.sub(1), o.sub(1), a.sub(1)),
          l,
          c,
          u
        )
      ).toVar()
    return L4(d)
  }).setLayout({
    name: 'mx_perlin_noise_vec3_1',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'vec3' }],
  }),
  Bx = Ai([tQ, nQ]),
  iQ = _e(([n]) => {
    const e = ce(n).toVar(),
      t = de(Fn(e)).toVar()
    return Bi(rn(t))
  }).setLayout({
    name: 'mx_cell_noise_float_0',
    type: 'float',
    inputs: [{ name: 'p', type: 'float' }],
  }),
  rQ = _e(([n]) => {
    const e = He(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar()
    return Bi(rn(t, i))
  }).setLayout({
    name: 'mx_cell_noise_float_1',
    type: 'float',
    inputs: [{ name: 'p', type: 'vec2' }],
  }),
  sQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar(),
      r = de(Fn(e.z)).toVar()
    return Bi(rn(t, i, r))
  }).setLayout({
    name: 'mx_cell_noise_float_2',
    type: 'float',
    inputs: [{ name: 'p', type: 'vec3' }],
  }),
  oQ = _e(([n]) => {
    const e = yt(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar(),
      r = de(Fn(e.z)).toVar(),
      s = de(Fn(e.w)).toVar()
    return Bi(rn(t, i, r, s))
  }).setLayout({
    name: 'mx_cell_noise_float_3',
    type: 'float',
    inputs: [{ name: 'p', type: 'vec4' }],
  }),
  aQ = Ai([iQ, rQ, sQ, oQ]),
  lQ = _e(([n]) => {
    const e = ce(n).toVar(),
      t = de(Fn(e)).toVar()
    return ve(Bi(rn(t, de(0))), Bi(rn(t, de(1))), Bi(rn(t, de(2))))
  }).setLayout({
    name: 'mx_cell_noise_vec3_0',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'float' }],
  }),
  cQ = _e(([n]) => {
    const e = He(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar()
    return ve(Bi(rn(t, i, de(0))), Bi(rn(t, i, de(1))), Bi(rn(t, i, de(2))))
  }).setLayout({
    name: 'mx_cell_noise_vec3_1',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'vec2' }],
  }),
  uQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar(),
      r = de(Fn(e.z)).toVar()
    return ve(Bi(rn(t, i, r, de(0))), Bi(rn(t, i, r, de(1))), Bi(rn(t, i, r, de(2))))
  }).setLayout({
    name: 'mx_cell_noise_vec3_2',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'vec3' }],
  }),
  dQ = _e(([n]) => {
    const e = yt(n).toVar(),
      t = de(Fn(e.x)).toVar(),
      i = de(Fn(e.y)).toVar(),
      r = de(Fn(e.z)).toVar(),
      s = de(Fn(e.w)).toVar()
    return ve(Bi(rn(t, i, r, s, de(0))), Bi(rn(t, i, r, s, de(1))), Bi(rn(t, i, r, s, de(2))))
  }).setLayout({
    name: 'mx_cell_noise_vec3_3',
    type: 'vec3',
    inputs: [{ name: 'p', type: 'vec4' }],
  }),
  F4 = Ai([lQ, cQ, uQ, dQ]),
  Dm = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = de(e).toVar(),
      a = ve(n).toVar(),
      l = ce(0).toVar(),
      c = ce(1).toVar()
    return (
      cn(o, () => {
        ;(l.addAssign(c.mul(Ox(a))), c.mulAssign(r), a.mulAssign(s))
      }),
      l
    )
  }).setLayout({
    name: 'mx_fractal_noise_float',
    type: 'float',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'octaves', type: 'int' },
      { name: 'lacunarity', type: 'float' },
      { name: 'diminish', type: 'float' },
    ],
  }),
  O4 = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = de(e).toVar(),
      a = ve(n).toVar(),
      l = ve(0).toVar(),
      c = ce(1).toVar()
    return (
      cn(o, () => {
        ;(l.addAssign(c.mul(Bx(a))), c.mulAssign(r), a.mulAssign(s))
      }),
      l
    )
  }).setLayout({
    name: 'mx_fractal_noise_vec3',
    type: 'vec3',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'octaves', type: 'int' },
      { name: 'lacunarity', type: 'float' },
      { name: 'diminish', type: 'float' },
    ],
  }),
  hQ = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = de(e).toVar(),
      a = ve(n).toVar()
    return He(Dm(a, o, s, r), Dm(a.add(ve(de(19), de(193), de(17))), o, s, r))
  }).setLayout({
    name: 'mx_fractal_noise_vec2',
    type: 'vec2',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'octaves', type: 'int' },
      { name: 'lacunarity', type: 'float' },
      { name: 'diminish', type: 'float' },
    ],
  }),
  fQ = _e(([n, e, t, i]) => {
    const r = ce(i).toVar(),
      s = ce(t).toVar(),
      o = de(e).toVar(),
      a = ve(n).toVar(),
      l = ve(O4(a, o, s, r)).toVar(),
      c = ce(Dm(a.add(ve(de(19), de(193), de(17))), o, s, r)).toVar()
    return yt(l, c)
  }).setLayout({
    name: 'mx_fractal_noise_vec4',
    type: 'vec4',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'octaves', type: 'int' },
      { name: 'lacunarity', type: 'float' },
      { name: 'diminish', type: 'float' },
    ],
  }),
  pQ = _e(([n, e, t, i, r, s, o]) => {
    const a = de(o).toVar(),
      l = ce(s).toVar(),
      c = de(r).toVar(),
      u = de(i).toVar(),
      d = de(t).toVar(),
      h = de(e).toVar(),
      f = He(n).toVar(),
      p = ve(F4(He(h.add(u), d.add(c)))).toVar(),
      g = He(p.x, p.y).toVar()
    ;(g.subAssign(0.5), g.mulAssign(l), g.addAssign(0.5))
    const y = He(He(ce(h), ce(d)).add(g)).toVar(),
      m = He(y.sub(f)).toVar()
    return (
      Dt(a.equal(de(2)), () => mn(m.x).add(mn(m.y))),
      Dt(a.equal(de(3)), () => ui(mn(m.x), mn(m.y))),
      $a(m, m)
    )
  }).setLayout({
    name: 'mx_worley_distance_0',
    type: 'float',
    inputs: [
      { name: 'p', type: 'vec2' },
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'xoff', type: 'int' },
      { name: 'yoff', type: 'int' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  mQ = _e(([n, e, t, i, r, s, o, a, l]) => {
    const c = de(l).toVar(),
      u = ce(a).toVar(),
      d = de(o).toVar(),
      h = de(s).toVar(),
      f = de(r).toVar(),
      p = de(i).toVar(),
      g = de(t).toVar(),
      y = de(e).toVar(),
      m = ve(n).toVar(),
      v = ve(F4(ve(y.add(f), g.add(h), p.add(d)))).toVar()
    ;(v.subAssign(0.5), v.mulAssign(u), v.addAssign(0.5))
    const x = ve(ve(ce(y), ce(g), ce(p)).add(v)).toVar(),
      _ = ve(x.sub(m)).toVar()
    return (
      Dt(c.equal(de(2)), () => mn(_.x).add(mn(_.y)).add(mn(_.z))),
      Dt(c.equal(de(3)), () => ui(ui(mn(_.x), mn(_.y)), mn(_.z))),
      $a(_, _)
    )
  }).setLayout({
    name: 'mx_worley_distance_1',
    type: 'float',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'x', type: 'int' },
      { name: 'y', type: 'int' },
      { name: 'z', type: 'int' },
      { name: 'xoff', type: 'int' },
      { name: 'yoff', type: 'int' },
      { name: 'zoff', type: 'int' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  Vu = Ai([pQ, mQ]),
  gQ = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = He(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = He(_n(s.x, o), _n(s.y, a)).toVar(),
      c = ce(1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: u }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: d }) => {
          const h = ce(Vu(l, u, d, o, a, r, i)).toVar()
          c.assign(Dr(c, h))
        })
      }),
      Dt(i.equal(de(0)), () => {
        c.assign(co(c))
      }),
      c
    )
  }).setLayout({
    name: 'mx_worley_noise_float_0',
    type: 'float',
    inputs: [
      { name: 'p', type: 'vec2' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  yQ = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = He(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = He(_n(s.x, o), _n(s.y, a)).toVar(),
      c = He(1e6, 1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: u }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: d }) => {
          const h = ce(Vu(l, u, d, o, a, r, i)).toVar()
          Dt(h.lessThan(c.x), () => {
            ;(c.y.assign(c.x), c.x.assign(h))
          }).ElseIf(h.lessThan(c.y), () => {
            c.y.assign(h)
          })
        })
      }),
      Dt(i.equal(de(0)), () => {
        c.assign(co(c))
      }),
      c
    )
  }).setLayout({
    name: 'mx_worley_noise_vec2_0',
    type: 'vec2',
    inputs: [
      { name: 'p', type: 'vec2' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  vQ = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = He(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = He(_n(s.x, o), _n(s.y, a)).toVar(),
      c = ve(1e6, 1e6, 1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: u }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: d }) => {
          const h = ce(Vu(l, u, d, o, a, r, i)).toVar()
          Dt(h.lessThan(c.x), () => {
            ;(c.z.assign(c.y), c.y.assign(c.x), c.x.assign(h))
          })
            .ElseIf(h.lessThan(c.y), () => {
              ;(c.z.assign(c.y), c.y.assign(h))
            })
            .ElseIf(h.lessThan(c.z), () => {
              c.z.assign(h)
            })
        })
      }),
      Dt(i.equal(de(0)), () => {
        c.assign(co(c))
      }),
      c
    )
  }).setLayout({
    name: 'mx_worley_noise_vec3_0',
    type: 'vec3',
    inputs: [
      { name: 'p', type: 'vec2' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  _Q = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = ve(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = de().toVar(),
      c = ve(_n(s.x, o), _n(s.y, a), _n(s.z, l)).toVar(),
      u = ce(1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: d }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: h }) => {
          cn({ start: -1, end: de(1), name: 'z', condition: '<=' }, ({ z: f }) => {
            const p = ce(Vu(c, d, h, f, o, a, l, r, i)).toVar()
            u.assign(Dr(u, p))
          })
        })
      }),
      Dt(i.equal(de(0)), () => {
        u.assign(co(u))
      }),
      u
    )
  }).setLayout({
    name: 'mx_worley_noise_float_1',
    type: 'float',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  xQ = Ai([gQ, _Q]),
  SQ = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = ve(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = de().toVar(),
      c = ve(_n(s.x, o), _n(s.y, a), _n(s.z, l)).toVar(),
      u = He(1e6, 1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: d }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: h }) => {
          cn({ start: -1, end: de(1), name: 'z', condition: '<=' }, ({ z: f }) => {
            const p = ce(Vu(c, d, h, f, o, a, l, r, i)).toVar()
            Dt(p.lessThan(u.x), () => {
              ;(u.y.assign(u.x), u.x.assign(p))
            }).ElseIf(p.lessThan(u.y), () => {
              u.y.assign(p)
            })
          })
        })
      }),
      Dt(i.equal(de(0)), () => {
        u.assign(co(u))
      }),
      u
    )
  }).setLayout({
    name: 'mx_worley_noise_vec2_1',
    type: 'vec2',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  AQ = Ai([yQ, SQ]),
  bQ = _e(([n, e, t]) => {
    const i = de(t).toVar(),
      r = ce(e).toVar(),
      s = ve(n).toVar(),
      o = de().toVar(),
      a = de().toVar(),
      l = de().toVar(),
      c = ve(_n(s.x, o), _n(s.y, a), _n(s.z, l)).toVar(),
      u = ve(1e6, 1e6, 1e6).toVar()
    return (
      cn({ start: -1, end: de(1), name: 'x', condition: '<=' }, ({ x: d }) => {
        cn({ start: -1, end: de(1), name: 'y', condition: '<=' }, ({ y: h }) => {
          cn({ start: -1, end: de(1), name: 'z', condition: '<=' }, ({ z: f }) => {
            const p = ce(Vu(c, d, h, f, o, a, l, r, i)).toVar()
            Dt(p.lessThan(u.x), () => {
              ;(u.z.assign(u.y), u.y.assign(u.x), u.x.assign(p))
            })
              .ElseIf(p.lessThan(u.y), () => {
                ;(u.z.assign(u.y), u.y.assign(p))
              })
              .ElseIf(p.lessThan(u.z), () => {
                u.z.assign(p)
              })
          })
        })
      }),
      Dt(i.equal(de(0)), () => {
        u.assign(co(u))
      }),
      u
    )
  }).setLayout({
    name: 'mx_worley_noise_vec3_1',
    type: 'vec3',
    inputs: [
      { name: 'p', type: 'vec3' },
      { name: 'jitter', type: 'float' },
      { name: 'metric', type: 'int' },
    ],
  }),
  TQ = Ai([vQ, bQ]),
  wQ = _e(([n]) => {
    const e = n.y,
      t = n.z,
      i = ve().toVar()
    return (
      Dt(e.lessThan(1e-4), () => {
        i.assign(ve(t, t, t))
      }).Else(() => {
        let r = n.x
        r = r.sub(Xs(r)).mul(6).toVar()
        const s = de(ux(r)),
          o = r.sub(ce(s)),
          a = t.mul(e.oneMinus()),
          l = t.mul(e.mul(o).oneMinus()),
          c = t.mul(e.mul(o.oneMinus()).oneMinus())
        Dt(s.equal(de(0)), () => {
          i.assign(ve(t, c, a))
        })
          .ElseIf(s.equal(de(1)), () => {
            i.assign(ve(l, t, a))
          })
          .ElseIf(s.equal(de(2)), () => {
            i.assign(ve(a, t, c))
          })
          .ElseIf(s.equal(de(3)), () => {
            i.assign(ve(a, l, t))
          })
          .ElseIf(s.equal(de(4)), () => {
            i.assign(ve(c, a, t))
          })
          .Else(() => {
            i.assign(ve(t, a, l))
          })
      }),
      i
    )
  }).setLayout({ name: 'mx_hsvtorgb', type: 'vec3', inputs: [{ name: 'hsv', type: 'vec3' }] }),
  CQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = ce(e.x).toVar(),
      i = ce(e.y).toVar(),
      r = ce(e.z).toVar(),
      s = ce(Dr(t, Dr(i, r))).toVar(),
      o = ce(ui(t, ui(i, r))).toVar(),
      a = ce(o.sub(s)).toVar(),
      l = ce().toVar(),
      c = ce().toVar(),
      u = ce().toVar()
    return (
      u.assign(o),
      Dt(o.greaterThan(0), () => {
        c.assign(a.div(o))
      }).Else(() => {
        c.assign(0)
      }),
      Dt(c.lessThanEqual(0), () => {
        l.assign(0)
      }).Else(() => {
        ;(Dt(t.greaterThanEqual(o), () => {
          l.assign(i.sub(r).div(a))
        })
          .ElseIf(i.greaterThanEqual(o), () => {
            l.assign(On(2, r.sub(t).div(a)))
          })
          .Else(() => {
            l.assign(On(4, t.sub(i).div(a)))
          }),
          l.mulAssign(1 / 6),
          Dt(l.lessThan(0), () => {
            l.addAssign(1)
          }))
      }),
      ve(l, c, u)
    )
  }).setLayout({ name: 'mx_rgbtohsv', type: 'vec3', inputs: [{ name: 'c', type: 'vec3' }] }),
  EQ = _e(([n]) => {
    const e = ve(n).toVar(),
      t = ex(nx(e, ve(0.04045))).toVar(),
      i = ve(e.div(12.92)).toVar(),
      r = ve(gs(ui(e.add(ve(0.055)), ve(0)).div(1.055), ve(2.4))).toVar()
    return Ln(i, r, t)
  }).setLayout({
    name: 'mx_srgb_texture_to_lin_rec709',
    type: 'vec3',
    inputs: [{ name: 'color', type: 'vec3' }],
  }),
  B4 = (n, e) => {
    ;((n = ce(n)), (e = ce(e)))
    const t = He(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476)
    return Hl(n.sub(t), n.add(t), e)
  },
  U4 = (n, e, t, i) => Ln(n, e, t[i].clamp()),
  MQ = (n, e, t = xn()) => U4(n, e, t, 'x'),
  RQ = (n, e, t = xn()) => U4(n, e, t, 'y'),
  k4 = (n, e, t, i, r) => Ln(n, e, B4(t, i[r])),
  IQ = (n, e, t, i = xn()) => k4(n, e, t, i, 'x'),
  NQ = (n, e, t, i = xn()) => k4(n, e, t, i, 'y'),
  PQ = (n = 1, e = 0, t = xn()) => t.mul(n).add(e),
  LQ = (n, e = 1) => ((n = ce(n)), n.abs().pow(e).mul(n.sign())),
  DQ = (n, e = 1, t = 0.5) => ce(n).sub(t).mul(e).add(t),
  FQ = (n = xn(), e = 1, t = 0) => Ox(n.convert('vec2|vec3')).mul(e).add(t),
  OQ = (n = xn(), e = 1, t = 0) => Bx(n.convert('vec2|vec3')).mul(e).add(t),
  BQ = (n = xn(), e = 1, t = 0) => (
    (n = n.convert('vec2|vec3')),
    yt(Bx(n), Ox(n.add(He(19, 73))))
      .mul(e)
      .add(t)
  ),
  UQ = (n = xn(), e = 1) => xQ(n.convert('vec2|vec3'), e, de(1)),
  kQ = (n = xn(), e = 1) => AQ(n.convert('vec2|vec3'), e, de(1)),
  zQ = (n = xn(), e = 1) => TQ(n.convert('vec2|vec3'), e, de(1)),
  VQ = (n = xn()) => aQ(n.convert('vec2|vec3')),
  HQ = (n = xn(), e = 3, t = 2, i = 0.5, r = 1) => Dm(n, de(e), t, i).mul(r),
  $Q = (n = xn(), e = 3, t = 2, i = 0.5, r = 1) => hQ(n, de(e), t, i).mul(r),
  GQ = (n = xn(), e = 3, t = 2, i = 0.5, r = 1) => O4(n, de(e), t, i).mul(r),
  WQ = (n = xn(), e = 3, t = 2, i = 0.5, r = 1) => fQ(n, de(e), t, i).mul(r),
  QQ = _e(([n, e, t]) => {
    const i = ql(n).toVar('nDir'),
      r = Bt(ce(0.5).mul(e.sub(t)), Dl)
        .div(i)
        .toVar('rbmax'),
      s = Bt(ce(-0.5).mul(e.sub(t)), Dl)
        .div(i)
        .toVar('rbmin'),
      o = ve().toVar('rbminmax')
    ;((o.x = i.x.greaterThan(ce(0)).select(r.x, s.x)),
      (o.y = i.y.greaterThan(ce(0)).select(r.y, s.y)),
      (o.z = i.z.greaterThan(ce(0)).select(r.z, s.z)))
    const a = Dr(Dr(o.x, o.y), o.z).toVar('correction')
    return Dl.add(i.mul(a)).toVar('boxIntersection').sub(t)
  }),
  jQ = _e(([n, e]) => {
    const t = n.x,
      i = n.y,
      r = n.z
    let s = e.element(0).mul(0.886227)
    return (
      (s = s.add(
        e
          .element(1)
          .mul(2 * 0.511664)
          .mul(i)
      )),
      (s = s.add(
        e
          .element(2)
          .mul(2 * 0.511664)
          .mul(r)
      )),
      (s = s.add(
        e
          .element(3)
          .mul(2 * 0.511664)
          .mul(t)
      )),
      (s = s.add(
        e
          .element(4)
          .mul(2 * 0.429043)
          .mul(t)
          .mul(i)
      )),
      (s = s.add(
        e
          .element(5)
          .mul(2 * 0.429043)
          .mul(i)
          .mul(r)
      )),
      (s = s.add(e.element(6).mul(r.mul(r).mul(0.743125).sub(0.247708)))),
      (s = s.add(
        e
          .element(7)
          .mul(2 * 0.429043)
          .mul(t)
          .mul(r)
      )),
      (s = s.add(
        e
          .element(8)
          .mul(0.429043)
          .mul(xt(t, t).sub(xt(i, i)))
      )),
      s
    )
  })
var O = Object.freeze({
  __proto__: null,
  BRDF_GGX: yH,
  BRDF_Lambert: hH,
  BasicShadowFilter: w4,
  Break: VM,
  Const: BE,
  Continue: OV,
  DFGApprox: vH,
  D_GGX: ZM,
  Discard: tM,
  EPSILON: rE,
  F_Schlick: XM,
  Fn: _e,
  INFINITY: qk,
  If: Dt,
  Loop: cn,
  NodeAccess: js,
  NodeShaderStage: qy,
  NodeType: nk,
  NodeUpdateType: Wt,
  PCFShadowFilter: C4,
  PCFSoftShadowFilter: E4,
  PI: wm,
  PI2: Xk,
  Return: hz,
  Schlick_to_F0: _H,
  ScriptableNodeResources: Op,
  ShaderNode: Gd,
  TBNViewMatrix: Tx,
  VSMShadowFilter: M4,
  V_GGX_SmithCorrelated: YM,
  Var: OE,
  abs: mn,
  acesFilmicToneMapping: vG,
  acos: dE,
  add: On,
  addMethodChaining: Ne,
  addNodeElement: pz,
  agxToneMapping: AG,
  all: ix,
  alphaT: Jy,
  and: jC,
  anisotropy: kC,
  anisotropyB: qc,
  anisotropyT: Dp,
  any: sE,
  append: AC,
  array: PC,
  arrayBuffer: Tk,
  asin: uE,
  assign: zC,
  atan: ox,
  atan2: PE,
  atomicAdd: eW,
  atomicAnd: rW,
  atomicFunc: uo,
  atomicLoad: ZG,
  atomicMax: nW,
  atomicMin: iW,
  atomicOr: sW,
  atomicStore: JG,
  atomicSub: tW,
  atomicXor: oW,
  attenuationColor: Gk,
  attenuationDistance: $k,
  attribute: ea,
  attributeArray: F$,
  backgroundBlurriness: V$,
  backgroundIntensity: H$,
  backgroundRotation: $$,
  batch: UM,
  billboarding: f$,
  bitAnd: YC,
  bitNot: ZC,
  bitOr: JC,
  bitXor: eE,
  bitangentGeometry: Vz,
  bitangentLocal: Hz,
  bitangentView: AM,
  bitangentWorld: $z,
  bitcast: Kk,
  blendBurn: f4,
  blendColor: K$,
  blendDodge: p4,
  blendOverlay: g4,
  blendScreen: m4,
  blur: CH,
  bool: Yo,
  buffer: Wh,
  bufferAttribute: Gh,
  bumpMap: wM,
  burn: Y$,
  bvec2: wC,
  bvec3: ex,
  bvec4: RC,
  bypass: YE,
  cache: KE,
  call: VC,
  cameraFar: Aa,
  cameraIndex: _x,
  cameraNear: Sa,
  cameraNormalMatrix: Az,
  cameraPosition: bz,
  cameraProjectionMatrix: Qh,
  cameraProjectionMatrixInverse: xz,
  cameraViewMatrix: ss,
  cameraWorldMatrix: Sz,
  cbrt: CE,
  cdl: sG,
  ceil: g0,
  checker: PW,
  cineonToneMapping: gG,
  clamp: Jo,
  clearcoat: Mk,
  clearcoatRoughness: Rk,
  code: T0,
  color: bC,
  colorSpaceToWorking: yx,
  colorToDirection: cH,
  compute: XE,
  cond: LE,
  context: px,
  convert: NC,
  convertColorSpace: nz,
  convertToTexture: C$,
  cos: Ro,
  cross: v0,
  cubeTexture: xM,
  dFdx: lx,
  dFdy: cx,
  dashSize: Bk,
  defaultBuildStages: ik,
  defaultShaderStages: mC,
  defined: gh,
  degrees: aE,
  deltaTime: a4,
  densityFog: FG,
  densityFogFactor: A4,
  depth: Rx,
  depthPass: dG,
  difference: SE,
  diffuseColor: hs,
  directPointLight: NW,
  directionToColor: lH,
  dispersion: Wk,
  distance: xE,
  div: Zo,
  dodge: Z$,
  dot: $a,
  drawIndex: FM,
  dynamicBufferAttribute: qE,
  element: IC,
  emissive: Zy,
  equal: HC,
  equals: vE,
  equirectUV: dH,
  exp: lE,
  exp2: Su,
  expression: ka,
  faceDirection: qh,
  faceForward: fx,
  faceforward: Yk,
  float: ce,
  floor: Xs,
  fog: Px,
  fract: sa,
  frameGroup: Ck,
  frameId: i$,
  frontFacing: uM,
  fwidth: gE,
  gain: KH,
  gapSize: Uk,
  getConstNodeType: xC,
  getCurrentStack: SC,
  getDirection: t4,
  getDistanceAttenuation: R4,
  getGeometryRoughness: KM,
  getNormalFromDepth: M$,
  getParallaxCorrectNormal: QQ,
  getRoughness: fH,
  getScreenPosition: E$,
  getShIrradianceAt: jQ,
  getTextureIndex: s4,
  getViewPosition: Rc,
  globalId: VG,
  glsl: CG,
  glslFn: MG,
  grayscale: tG,
  greaterThan: nx,
  greaterThanEqual: QC,
  hash: XH,
  highpModelNormalViewMatrix: Dz,
  highpModelViewMatrix: Lz,
  hue: rG,
  instance: NV,
  instanceIndex: Zh,
  instancedArray: O$,
  instancedBufferAttribute: Em,
  instancedDynamicBufferAttribute: ev,
  instancedMesh: BM,
  int: de,
  inverseSqrt: sx,
  inversesqrt: Zk,
  invocationLocalIndex: IV,
  invocationSubgroupIndex: RV,
  ior: zk,
  iridescence: UC,
  iridescenceIOR: Pk,
  iridescenceThickness: Lk,
  ivec2: Xn,
  ivec3: CC,
  ivec4: EC,
  js: TG,
  label: FE,
  length: Cm,
  lengthSq: hx,
  lessThan: GC,
  lessThanEqual: WC,
  lightPosition: b4,
  lightProjectionUV: aW,
  lightShadowMatrix: Dx,
  lightTargetDirection: cW,
  lightTargetPosition: T4,
  lightViewPosition: lW,
  lightingContext: GM,
  lights: fW,
  linearDepth: Im,
  linearToneMapping: pG,
  localId: HG,
  log: rx,
  log2: Ho,
  logarithmicDepthToViewZ: YV,
  loop: BV,
  luminance: Nx,
  mat2: p0,
  mat3: is,
  mat4: Ll,
  matcapUV: DH,
  materialAO: PM,
  materialAlphaTest: CM,
  materialAnisotropy: hV,
  materialAnisotropyVector: Mc,
  materialAttenuationColor: xV,
  materialAttenuationDistance: _V,
  materialClearcoat: oV,
  materialClearcoatNormal: lV,
  materialClearcoatRoughness: aV,
  materialColor: EM,
  materialDispersion: EV,
  materialEmissive: MM,
  materialIOR: vV,
  materialIridescence: fV,
  materialIridescenceIOR: pV,
  materialIridescenceThickness: mV,
  materialLightMap: NM,
  materialLineDashOffset: wV,
  materialLineDashSize: AV,
  materialLineGapSize: bV,
  materialLineScale: SV,
  materialLineWidth: TV,
  materialMetalness: sV,
  materialNormal: IM,
  materialOpacity: RM,
  materialPointSize: CV,
  materialReference: _l,
  materialReflectivity: iV,
  materialRefractionRatio: mM,
  materialRotation: cV,
  materialRoughness: rV,
  materialSheen: uV,
  materialSheenRoughness: dV,
  materialShininess: Zz,
  materialSpecular: Jz,
  materialSpecularColor: tV,
  materialSpecularIntensity: eV,
  materialSpecularStrength: nV,
  materialThickness: yV,
  materialTransmission: gV,
  max: ui,
  maxMipLevel: rM,
  mediumpModelViewMatrix: lM,
  metalness: Ek,
  min: Dr,
  mix: Ln,
  mixElement: IE,
  mod: dx,
  modInt: tx,
  modelDirection: Mz,
  modelNormalMatrix: aM,
  modelPosition: Rz,
  modelScale: Iz,
  modelViewMatrix: jh,
  modelViewPosition: Nz,
  modelViewProjection: LM,
  modelWorldMatrix: Oo,
  modelWorldMatrixInverse: Pz,
  morphReference: HM,
  mrt: o4,
  mul: xt,
  mx_aastep: B4,
  mx_cell_noise_float: VQ,
  mx_contrast: DQ,
  mx_fractal_noise_float: HQ,
  mx_fractal_noise_vec2: $Q,
  mx_fractal_noise_vec3: GQ,
  mx_fractal_noise_vec4: WQ,
  mx_hsvtorgb: wQ,
  mx_noise_float: FQ,
  mx_noise_vec3: OQ,
  mx_noise_vec4: BQ,
  mx_ramplr: MQ,
  mx_ramptb: RQ,
  mx_rgbtohsv: CQ,
  mx_safepower: LQ,
  mx_splitlr: IQ,
  mx_splittb: NQ,
  mx_srgb_texture_to_lin_rec709: EQ,
  mx_transform_uv: PQ,
  mx_worley_noise_float: UQ,
  mx_worley_noise_vec2: kQ,
  mx_worley_noise_vec3: zQ,
  negate: hE,
  neutralToneMapping: bG,
  nodeArray: Pl,
  nodeImmutable: We,
  nodeObject: Fe,
  nodeObjects: zh,
  nodeProxy: Pe,
  normalFlat: dM,
  normalGeometry: Sx,
  normalLocal: cr,
  normalMap: nv,
  normalView: no,
  normalWorld: hM,
  normalize: ql,
  not: XC,
  notEqual: $C,
  numWorkgroups: kG,
  objectDirection: Tz,
  objectGroup: FC,
  objectPosition: oM,
  objectScale: Cz,
  objectViewPosition: Ez,
  objectWorldMatrix: wz,
  oneMinus: fE,
  or: qC,
  orthographicDepthToViewZ: KV,
  oscSawtooth: u$,
  oscSine: a$,
  oscSquare: l$,
  oscTriangle: c$,
  output: vh,
  outputStruct: jH,
  overlay: eG,
  overloadingFn: Ai,
  parabola: av,
  parallaxDirection: TM,
  parallaxUV: Wz,
  parameter: zH,
  pass: cG,
  passTexture: uG,
  pcurve: YH,
  perspectiveDepthToViewZ: Ex,
  pmremTexture: PH,
  pointUV: z$,
  pointWidth: kk,
  positionGeometry: xx,
  positionLocal: Nn,
  positionPrevious: Mm,
  positionView: Yn,
  positionViewDirection: Cr,
  positionWorld: Dl,
  positionWorldDirection: cM,
  posterize: aG,
  pow: gs,
  pow2: AE,
  pow3: bE,
  pow4: TE,
  property: OC,
  radians: oE,
  rand: RE,
  range: BG,
  rangeFog: DG,
  rangeFogFactor: S4,
  reciprocal: mE,
  reference: Pn,
  referenceBuffer: tv,
  reflect: _E,
  reflectVector: vM,
  reflectView: gM,
  reflector: S$,
  refract: ME,
  refractVector: _M,
  refractView: yM,
  reinhardToneMapping: mG,
  remainder: iE,
  remap: JE,
  remapClamp: eM,
  renderGroup: Ut,
  renderOutput: nM,
  rendererReference: WE,
  rotate: i4,
  rotateUV: d$,
  roughness: BC,
  round: pE,
  rtt: u4,
  sRGBTransferEOTF: zE,
  sRGBTransferOETF: VE,
  sampler: yz,
  saturate: EE,
  saturation: nG,
  screen: J$,
  screenCoordinate: Jh,
  screenSize: Rm,
  screenUV: Ga,
  scriptable: LG,
  scriptableValue: Fp,
  select: rr,
  setCurrentStack: Yy,
  shaderStages: rk,
  shadow: IW,
  shadowPositionWorld: Fx,
  shapeCircle: LW,
  sharedUniformGroup: m0,
  sheen: Ik,
  sheenRoughness: Nk,
  shiftLeft: tE,
  shiftRight: nE,
  shininess: Ok,
  sign: ax,
  sin: Tr,
  sinc: ZH,
  skinning: DV,
  skinningReference: zM,
  smoothstep: Hl,
  smoothstepElement: NE,
  specularColor: Dk,
  specularF90: Fk,
  spherizeUV: h$,
  split: wk,
  spritesheetUV: g$,
  sqrt: co,
  stack: HH,
  step: y0,
  storage: b0,
  storageBarrier: QG,
  storageObject: D$,
  storageTexture: d4,
  string: bk,
  struct: QH,
  sub: Bt,
  subgroupIndex: MV,
  subgroupSize: $G,
  tan: cE,
  tangentGeometry: x0,
  tangentLocal: Xh,
  tangentView: Kh,
  tangentWorld: SM,
  temp: UE,
  texture: Ji,
  texture3D: UH,
  textureBarrier: jG,
  textureBicubic: xH,
  textureCubeUV: n4,
  textureLoad: Rn,
  textureSize: Fa,
  textureStore: W$,
  thickness: Hk,
  time: Xl,
  timerDelta: o$,
  timerGlobal: s$,
  timerLocal: r$,
  toOutputColorSpace: HE,
  toWorkingColorSpace: $E,
  toneMapping: QE,
  toneMappingExposure: jE,
  toonOutlinePass: fG,
  transformDirection: wE,
  transformNormal: pM,
  transformNormalToView: Ax,
  transformedBentNormalView: Qz,
  transformedBitangentView: bM,
  transformedBitangentWorld: Gz,
  transformedClearcoatNormalView: Oz,
  transformedNormalView: na,
  transformedNormalWorld: fM,
  transformedTangentView: bx,
  transformedTangentWorld: zz,
  transmission: Vk,
  transpose: yE,
  triNoise3D: e$,
  triplanarTexture: v$,
  triplanarTextures: l4,
  trunc: ux,
  tslFn: Ak,
  uint: Ye,
  uniform: Rt,
  uniformArray: Fo,
  uniformGroup: DC,
  uniforms: _z,
  userData: j$,
  uv: xn,
  uvec2: TC,
  uvec3: zu,
  uvec4: MC,
  varying: er,
  varyingProperty: yh,
  vec2: He,
  vec3: ve,
  vec4: yt,
  vectorComponents: ku,
  velocity: X$,
  vertexColor: U$,
  vertexIndex: DM,
  vertexStage: kE,
  vibrance: iG,
  viewZToLogarithmicDepth: Mx,
  viewZToOrthographicDepth: Xc,
  viewZToPerspectiveDepth: jM,
  viewport: wx,
  viewportBottomLeft: QV,
  viewportCoordinate: QM,
  viewportDepthTexture: Cx,
  viewportLinearDepth: ZV,
  viewportMipTexture: qV,
  viewportResolution: GV,
  viewportSafeUV: p$,
  viewportSharedTexture: aH,
  viewportSize: WM,
  viewportTexture: jV,
  viewportTopLeft: WV,
  viewportUV: $V,
  wgsl: wG,
  wgslFn: RG,
  workgroupArray: KG,
  workgroupBarrier: WG,
  workgroupId: zG,
  workingToColorSpace: GE,
  xor: KC,
})
const f1 = t4(xn(), ea('faceIndex')).normalize()
;(f1.x, f1.y, f1.z)
const bc = typeof self < 'u' ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 }
;(js.READ_ONLY + '', js.WRITE_ONLY + '', js.READ_WRITE + '')
;(bc && bc.VERTEX, bc && bc.FRAGMENT, bc && bc.COMPUTE)
const cl = {
  tsl_xor: new qn('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),
  mod_float: new qn(
    'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'
  ),
  mod_vec2: new qn(
    'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'
  ),
  mod_vec3: new qn(
    'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'
  ),
  mod_vec4: new qn(
    'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'
  ),
  equals_bool: new qn('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),
  equals_bvec2: new qn(
    'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'
  ),
  equals_bvec3: new qn(
    'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'
  ),
  equals_bvec4: new qn(
    'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'
  ),
  repeatWrapping_float: new qn(
    'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'
  ),
  mirrorWrapping_float: new qn(
    'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'
  ),
  clampWrapping_float: new qn(
    'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'
  ),
  biquadraticTexture: new qn(
    '\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n	let res = vec2f( iRes );\n\n	let uvScaled = coord * res;\n	let uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n	// https://www.shadertoy.com/view/WtyXRy\n\n	let uv = uvWrapping - 0.5;\n	let iuv = floor( uv );\n	let f = fract( uv );\n\n	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n'
  ),
}
typeof navigator < 'u' &&
  /Windows/g.test(navigator.userAgent) &&
  ((cl.pow_float = new qn(
    'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }'
  )),
  (cl.pow_vec2 = new qn(
    'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }',
    [cl.pow_float]
  )),
  (cl.pow_vec3 = new qn(
    'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }',
    [cl.pow_float]
  )),
  (cl.pow_vec4 = new qn(
    'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }',
    [cl.pow_float]
  )))
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ O.BRDF_GGX
O.BRDF_Lambert
O.BasicShadowFilter
O.Break
O.Continue
O.DFGApprox
O.D_GGX
O.Discard
O.EPSILON
O.F_Schlick
O.Fn
O.INFINITY
O.If
O.Loop
O.NodeShaderStage
O.NodeType
O.NodeUpdateType
O.NodeAccess
O.PCFShadowFilter
O.PCFSoftShadowFilter
O.PI
O.PI2
O.Return
O.Schlick_to_F0
O.ScriptableNodeResources
O.ShaderNode
O.TBNViewMatrix
O.VSMShadowFilter
O.V_GGX_SmithCorrelated
O.abs
O.acesFilmicToneMapping
O.acos
O.add
O.addNodeElement
O.agxToneMapping
O.all
O.alphaT
O.and
O.anisotropy
O.anisotropyB
O.anisotropyT
O.any
O.append
O.array
O.arrayBuffer
O.asin
O.assign
O.atan
O.atan2
O.atomicAdd
O.atomicAnd
O.atomicFunc
O.atomicMax
O.atomicMin
O.atomicOr
O.atomicStore
O.atomicSub
O.atomicXor
O.atomicLoad
O.attenuationColor
O.attenuationDistance
O.attribute
O.attributeArray
O.backgroundBlurriness
O.backgroundIntensity
O.backgroundRotation
O.batch
O.billboarding
O.bitAnd
O.bitNot
O.bitOr
O.bitXor
O.bitangentGeometry
O.bitangentLocal
O.bitangentView
O.bitangentWorld
O.bitcast
O.blendBurn
O.blendColor
O.blendDodge
O.blendOverlay
O.blendScreen
O.blur
O.bool
O.buffer
O.bufferAttribute
O.bumpMap
O.burn
O.bvec2
O.bvec3
O.bvec4
O.bypass
O.cache
O.call
O.cameraFar
O.cameraIndex
O.cameraNear
O.cameraNormalMatrix
O.cameraPosition
O.cameraProjectionMatrix
O.cameraProjectionMatrixInverse
O.cameraViewMatrix
O.cameraWorldMatrix
O.cbrt
O.cdl
O.ceil
O.checker
O.cineonToneMapping
O.clamp
O.clearcoat
O.clearcoatRoughness
O.code
O.color
O.colorSpaceToWorking
O.colorToDirection
O.compute
O.cond
O.Const
O.context
O.convert
O.convertColorSpace
O.convertToTexture
O.cos
O.cross
O.cubeTexture
O.dFdx
O.dFdy
O.dashSize
O.defaultBuildStages
O.defaultShaderStages
O.defined
O.degrees
O.deltaTime
O.densityFog
O.densityFogFactor
O.depth
O.depthPass
O.difference
O.diffuseColor
O.directPointLight
O.directionToColor
O.dispersion
O.distance
O.div
O.dodge
O.dot
O.drawIndex
O.dynamicBufferAttribute
O.element
O.emissive
O.equal
O.equals
O.equirectUV
O.exp
O.exp2
O.expression
O.faceDirection
O.faceForward
O.faceforward
O.float
O.floor
O.fog
O.fract
O.frameGroup
O.frameId
O.frontFacing
O.fwidth
O.gain
O.gapSize
O.getConstNodeType
O.getCurrentStack
O.getDirection
O.getDistanceAttenuation
O.getGeometryRoughness
O.getNormalFromDepth
O.getParallaxCorrectNormal
O.getRoughness
O.getScreenPosition
O.getShIrradianceAt
O.getTextureIndex
O.getViewPosition
O.glsl
O.glslFn
O.grayscale
O.greaterThan
O.greaterThanEqual
O.hash
O.highpModelNormalViewMatrix
O.highpModelViewMatrix
O.hue
O.instance
O.instanceIndex
O.instancedArray
O.instancedBufferAttribute
O.instancedDynamicBufferAttribute
O.instancedMesh
O.int
O.inverseSqrt
O.inversesqrt
O.invocationLocalIndex
O.invocationSubgroupIndex
O.ior
O.iridescence
O.iridescenceIOR
O.iridescenceThickness
O.ivec2
O.ivec3
O.ivec4
O.js
O.label
O.length
O.lengthSq
O.lessThan
O.lessThanEqual
O.lightPosition
O.lightTargetDirection
O.lightTargetPosition
O.lightViewPosition
O.lightingContext
O.lights
O.linearDepth
O.linearToneMapping
O.localId
O.globalId
O.log
O.log2
O.logarithmicDepthToViewZ
O.loop
O.luminance
O.mediumpModelViewMatrix
O.mat2
O.mat3
O.mat4
O.matcapUV
O.materialAO
O.materialAlphaTest
O.materialAnisotropy
O.materialAnisotropyVector
O.materialAttenuationColor
O.materialAttenuationDistance
O.materialClearcoat
O.materialClearcoatNormal
O.materialClearcoatRoughness
O.materialColor
O.materialDispersion
O.materialEmissive
O.materialIOR
O.materialIridescence
O.materialIridescenceIOR
O.materialIridescenceThickness
O.materialLightMap
O.materialLineDashOffset
O.materialLineDashSize
O.materialLineGapSize
O.materialLineScale
O.materialLineWidth
O.materialMetalness
O.materialNormal
O.materialOpacity
O.materialPointSize
O.materialReference
O.materialReflectivity
O.materialRefractionRatio
O.materialRotation
O.materialRoughness
O.materialSheen
O.materialSheenRoughness
O.materialShininess
O.materialSpecular
O.materialSpecularColor
O.materialSpecularIntensity
O.materialSpecularStrength
O.materialThickness
O.materialTransmission
O.max
O.maxMipLevel
O.metalness
O.min
O.mix
O.mixElement
O.mod
O.modInt
O.modelDirection
O.modelNormalMatrix
O.modelPosition
O.modelScale
O.modelViewMatrix
O.modelViewPosition
O.modelViewProjection
O.modelWorldMatrix
O.modelWorldMatrixInverse
O.morphReference
O.mrt
O.mul
O.mx_aastep
O.mx_cell_noise_float
O.mx_contrast
O.mx_fractal_noise_float
O.mx_fractal_noise_vec2
O.mx_fractal_noise_vec3
O.mx_fractal_noise_vec4
O.mx_hsvtorgb
O.mx_noise_float
O.mx_noise_vec3
O.mx_noise_vec4
O.mx_ramplr
O.mx_ramptb
O.mx_rgbtohsv
O.mx_safepower
O.mx_splitlr
O.mx_splittb
O.mx_srgb_texture_to_lin_rec709
O.mx_transform_uv
O.mx_worley_noise_float
O.mx_worley_noise_vec2
O.mx_worley_noise_vec3
O.negate
O.neutralToneMapping
O.nodeArray
O.nodeImmutable
O.nodeObject
O.nodeObjects
O.nodeProxy
O.normalFlat
O.normalGeometry
O.normalLocal
O.normalMap
O.normalView
O.normalWorld
O.normalize
O.not
O.notEqual
O.numWorkgroups
O.objectDirection
O.objectGroup
O.objectPosition
O.objectScale
O.objectViewPosition
O.objectWorldMatrix
O.oneMinus
O.or
O.orthographicDepthToViewZ
O.oscSawtooth
O.oscSine
O.oscSquare
O.oscTriangle
O.output
O.outputStruct
O.overlay
O.overloadingFn
O.parabola
O.parallaxDirection
O.parallaxUV
O.parameter
O.pass
O.passTexture
O.pcurve
O.perspectiveDepthToViewZ
O.pmremTexture
O.pointUV
O.pointWidth
O.positionGeometry
O.positionLocal
O.positionPrevious
O.positionView
O.positionViewDirection
O.positionWorld
O.positionWorldDirection
O.posterize
O.pow
O.pow2
O.pow3
O.pow4
O.property
O.radians
O.rand
O.range
O.rangeFog
O.rangeFogFactor
O.reciprocal
O.reference
O.referenceBuffer
O.reflect
O.reflectVector
O.reflectView
O.reflector
O.refract
O.refractVector
O.refractView
O.reinhardToneMapping
O.remainder
O.remap
O.remapClamp
O.renderGroup
O.renderOutput
O.rendererReference
O.rotate
O.rotateUV
O.roughness
O.round
O.rtt
O.sRGBTransferEOTF
O.sRGBTransferOETF
O.sampler
O.saturate
O.saturation
O.screen
O.screenCoordinate
O.screenSize
O.screenUV
O.scriptable
O.scriptableValue
O.select
O.setCurrentStack
O.shaderStages
O.shadow
O.shadowPositionWorld
O.sharedUniformGroup
O.shapeCircle
O.sheen
O.sheenRoughness
O.shiftLeft
O.shiftRight
O.shininess
O.sign
O.sin
O.sinc
O.skinning
O.skinningReference
O.smoothstep
O.smoothstepElement
O.specularColor
O.specularF90
O.spherizeUV
O.split
O.spritesheetUV
O.sqrt
O.stack
O.step
O.storage
O.storageBarrier
O.storageObject
O.storageTexture
O.string
O.struct
O.sub
O.subgroupIndex
O.subgroupSize
O.tan
O.tangentGeometry
O.tangentLocal
O.tangentView
O.tangentWorld
O.temp
O.texture
O.texture3D
O.textureBarrier
O.textureBicubic
O.textureCubeUV
O.textureLoad
O.textureSize
O.textureStore
O.thickness
O.threshold
O.time
O.timerDelta
O.timerGlobal
O.timerLocal
O.toOutputColorSpace
O.toWorkingColorSpace
O.toneMapping
O.toneMappingExposure
O.toonOutlinePass
O.transformDirection
O.transformNormal
O.transformNormalToView
O.transformedBentNormalView
O.transformedBitangentView
O.transformedBitangentWorld
O.transformedClearcoatNormalView
O.transformedNormalView
O.transformedNormalWorld
O.transformedTangentView
O.transformedTangentWorld
O.transmission
O.transpose
O.tri
O.tri3
O.triNoise3D
O.triplanarTexture
O.triplanarTextures
O.trunc
O.tslFn
O.uint
O.uniform
O.uniformArray
O.uniformGroup
O.uniforms
O.userData
O.uv
O.uvec2
O.uvec3
O.uvec4
O.Var
O.varying
O.varyingProperty
O.vec2
O.vec3
O.vec4
O.vectorComponents
O.velocity
O.vertexColor
O.vertexIndex
O.vibrance
O.viewZToLogarithmicDepth
O.viewZToOrthographicDepth
O.viewZToPerspectiveDepth
O.viewport
O.viewportBottomLeft
O.viewportCoordinate
O.viewportDepthTexture
O.viewportLinearDepth
O.viewportMipTexture
O.viewportResolution
O.viewportSafeUV
O.viewportSharedTexture
O.viewportSize
O.viewportTexture
O.viewportTopLeft
O.viewportUV
O.wgsl
O.wgslFn
O.workgroupArray
O.workgroupBarrier
O.workgroupId
O.workingToColorSpace
O.xor
const qQ = 50,
  XQ = 0.75,
  KQ = 15e5,
  YQ = 10,
  ZQ = 2.5,
  JQ = 60,
  xa = class xa {
    constructor(e = {}) {
      xe(this, 'tempForward', new Y())
      xe(this, 'tempMatrixLeft', new qe())
      xe(this, 'tempMatrixRight', new qe())
      xe(this, 'onKeyDown', (e) => {
        switch (
          (this.tempForward.set(0, 0, -1),
          this.tempForward.transformDirection(this.camera.matrixWorld),
          this.tempMatrixLeft.makeRotationAxis(this.tempForward, Math.PI / 128),
          this.tempMatrixRight.makeRotationAxis(this.tempForward, -Math.PI / 128),
          e.code)
        ) {
          case 'KeyG':
            ;((this.focalAdjustment += 0.02), this.forceRenderNextFrame())
            break
          case 'KeyF':
            ;((this.focalAdjustment -= 0.02), this.forceRenderNextFrame())
            break
          case 'ArrowLeft':
            this.camera.up.transformDirection(this.tempMatrixLeft)
            break
          case 'ArrowRight':
            this.camera.up.transformDirection(this.tempMatrixRight)
            break
          case 'KeyC':
            this.showMeshCursor = !this.showMeshCursor
            break
          case 'KeyU':
            this.showControlPlane = !this.showControlPlane
            break
          case 'KeyI':
            ;((this.showInfo = !this.showInfo), this.showInfo)
            break
          case 'KeyO':
            this.usingExternalCamera || this.setOrthographicMode(!this.camera.isOrthographicCamera)
            break
          case 'KeyP':
            this.usingExternalCamera ||
              this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled())
            break
          case 'Equal':
            this.usingExternalCamera ||
              this.splatMesh.setSplatScale(this.splatMesh.getSplatScale() + 0.05)
            break
          case 'Minus':
            this.usingExternalCamera ||
              this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale() - 0.05, 0))
            break
        }
      })
      xe(
        this,
        'onMouseUp',
        (function () {
          const e = new je()
          return function (t) {
            ;(e.copy(this.mousePosition).sub(this.mouseDownPosition),
              ec() - this.mouseDownTime < 0.5 && e.length() < 2 && this.onMouseClick(t))
          }
        })()
      )
      xe(this, 'checkPointRenderDimensions', new je())
      xe(this, 'checkPointToNewFocalPoint', new Y())
      xe(this, 'checkPointOutHits', [])
      xe(this, 'checkForFocalPointChange', () => {
        if (
          !this.transitioningCameraTarget &&
          (this.getRenderDimensions(this.checkPointRenderDimensions),
          (this.checkPointOutHits.length = 0),
          this.raycaster.setFromCameraAndScreenPosition(
            this.camera,
            this.mousePosition,
            this.checkPointRenderDimensions
          ),
          this.raycaster.intersectSplatMesh(this.splatMesh, this.checkPointOutHits),
          this.checkPointOutHits.length > 0)
        ) {
          const t = this.checkPointOutHits[0].origin
          ;(this.checkPointToNewFocalPoint.copy(t).sub(this.camera.position),
            this.checkPointToNewFocalPoint.length() > XQ &&
              (this.previousCameraTarget.copy(this.controls.target),
              this.nextCameraTarget.copy(t),
              (this.transitioningCameraTarget = !0),
              (this.transitioningCameraTargetStartTime = ec())))
        }
      })
      xe(
        this,
        'updateSplatMesh',
        (function () {
          const e = new je()
          return function () {
            if (!this.splatMesh) return
            if (this.splatMesh.getSplatCount() > 0) {
              ;(this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),
                this.splatMesh.updateTransforms(),
                this.getRenderDimensions(e))
              const i =
                  this.camera.projectionMatrix.elements[0] * 0.5 * this.devicePixelRatio * e.x,
                r = this.camera.projectionMatrix.elements[5] * 0.5 * this.devicePixelRatio * e.y,
                s = this.camera.isOrthographicCamera ? 1 / this.devicePixelRatio : 1,
                o = this.focalAdjustment * s,
                a = 1 / o
              ;(this.adjustForWebXRStereo(e),
                this.splatMesh.updateUniforms(
                  e,
                  i * o,
                  r * o,
                  this.camera.isOrthographicCamera,
                  this.camera.zoom || 1,
                  a
                ))
            }
          }
        })()
      )
      xe(this, 'addSplatBuffers', (e, t = [], i = !0, r = !0, s = !0, o = !1, a = !1, l = !0) => {
        if (this.isDisposingOrDisposed()) return Promise.resolve()
        let c = null
        const u = () => {
          c !== null && (this.loadingSpinner.removeTask(c), (c = null))
        }
        return (
          (this.splatRenderReady = !1),
          new Promise((d) => {
            ;(r && (c = this.loadingSpinner.addTask('Processing splats...')),
              ms(() => {
                if (this.isDisposingOrDisposed()) d()
                else {
                  const h = this.addSplatBuffersToMesh(e, t, i, s, o, l),
                    f = this.splatMesh.getMaxSplatCount()
                  ;(this.sortWorker &&
                    this.sortWorker.maxSplatCount !== f &&
                    this.disposeSortWorker(),
                    this.gpuAcceleratedSort ||
                      this.preSortMessages.push({
                        centers: h.centers.buffer,
                        sceneIndexes: h.sceneIndexes.buffer,
                        range: { from: h.from, to: h.to, count: h.count },
                      }),
                    (!this.sortWorker && f > 0
                      ? this.setupSortWorker(this.splatMesh)
                      : Promise.resolve()
                    ).then(() => {
                      this.isDisposingOrDisposed() ||
                        this.runSplatSort(!0, !0).then((g) => {
                          !this.sortWorker || !g
                            ? ((this.splatRenderReady = !0), u(), d())
                            : (a
                                ? (this.splatRenderReady = !0)
                                : this.runAfterNextSort.push(() => {
                                    this.splatRenderReady = !0
                                  }),
                              this.runAfterNextSort.push(() => {
                                ;(u(), d())
                              }))
                        })
                    }))
                }
              }, !0))
          })
        )
      })
      xe(
        this,
        'addSplatBuffersToMesh',
        (function () {
          let e
          return function (t, i, r = !0, s = !1, o = !1, a = !0) {
            if (this.isDisposingOrDisposed()) return
            let l = [],
              c = []
            ;(o ||
              ((l = this.splatMesh.scenes.map((f) => f.splatBuffer) || []),
              (c = this.splatMesh.sceneOptions ? this.splatMesh.sceneOptions.map((f) => f) : [])),
              l.push(...t),
              c.push(...i),
              this.renderer && this.splatMesh.setRenderer(this.renderer))
            const u = (f) => {
                if (this.isDisposingOrDisposed()) return
                const p = this.splatMesh.getSplatCount()
                s &&
                  p >= KQ &&
                  !f &&
                  !e &&
                  (this.loadingSpinner.setMinimized(!0, !0),
                  (e = this.loadingSpinner.addTask('Optimizing data structures...')))
              },
              d = (f) => {
                this.isDisposingOrDisposed() ||
                  (f && e && (this.loadingSpinner.removeTask(e), (e = null)))
              },
              h = this.splatMesh.build(l, c, !0, r, u, d, a)
            return (
              r && this.freeIntermediateSplatData && this.splatMesh.freeIntermediateSplatData(),
              h
            )
          }
        })()
      )
      xe(this, 'vsyncNum', 4)
      xe(
        this,
        'shouldRender',
        (function () {
          let e = 0
          const t = new Y(),
            i = new Qt(),
            r = 1e-4
          return function () {
            if (!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed())
              return !1
            let s = !1,
              o = !1
            if (this.camera) {
              const a = this.camera.position,
                l = this.camera.quaternion
              o =
                Math.abs(a.x - t.x) > r ||
                Math.abs(a.y - t.y) > r ||
                Math.abs(a.z - t.z) > r ||
                Math.abs(l.x - i.x) > r ||
                Math.abs(l.y - i.y) > r ||
                Math.abs(l.z - i.z) > r ||
                Math.abs(l.w - i.w) > r
            }
            return (
              (s =
                this.renderMode !== Zg.Never &&
                (e === 0 ||
                  this.splatMesh.visibleRegionChanging ||
                  o ||
                  this.renderMode === Zg.Always ||
                  this.dynamicMode === !0 ||
                  this.renderNextFrame)),
              this.camera && (t.copy(this.camera.position), i.copy(this.camera.quaternion)),
              e++,
              s
            )
          }
        })()
      )
      xe(
        this,
        'render',
        (function () {
          return function () {
            if (!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed()) return
            const e = (i) => {
                for (let r of i.children) if (r.visible) return !0
                return !1
              },
              t = this.renderer.autoClear
            ;(e(this.threeScene) &&
              (this.renderer.render(this.threeScene, this.camera), (this.renderer.autoClear = !1)),
              this.renderer.render(this.splatMesh, this.camera),
              (this.renderer.autoClear = !1),
              this.sceneHelper.getFocusMarkerOpacity() > 0 &&
                this.renderer.render(this.sceneHelper.focusMarker, this.camera),
              this.showControlPlane &&
                this.renderer.render(this.sceneHelper.controlPlane, this.camera),
              (this.renderer.autoClear = t))
          }
        })()
      )
      xe(this, 'sortedIndexes')
      xe(this, 'lastCalcTime', ec())
      xe(this, 'fpsFrameCount', 0)
      xe(this, 'updateFPS', () => {
        if (this.consecutiveRenderFrames > JQ) {
          const e = ec()
          e - this.lastCalcTime >= 1
            ? ((this.currentFPS = this.fpsFrameCount),
              (this.fpsFrameCount = 0),
              (this.lastCalcTime = e))
            : this.fpsFrameCount++
        } else this.currentFPS = null
      })
      xe(
        this,
        'updateForRendererSizeChanges',
        (function () {
          const e = new je(),
            t = new je()
          let i
          return function () {
            this.usingExternalCamera ||
              (this.renderer.getSize(t),
              (i === void 0 ||
                i !== this.camera.isOrthographicCamera ||
                t.x !== e.x ||
                t.y !== e.y) &&
                (this.camera.isOrthographicCamera
                  ? ((this.camera.left = -t.x / 2),
                    (this.camera.right = t.x / 2),
                    (this.camera.top = t.y / 2),
                    (this.camera.bottom = -t.y / 2))
                  : (this.camera.aspect = t.x / t.y),
                this.camera.updateProjectionMatrix(),
                e.copy(t),
                (i = this.camera.isOrthographicCamera)))
          }
        })()
      )
      xe(
        this,
        'timingSensitiveUpdates',
        (function () {
          let e
          return function () {
            const t = ec()
            e || (e = t)
            const i = t - e
            ;(this.updateCameraTransition(t), this.updateFocusMarker(i), (e = t))
          }
        })()
      )
      xe(this, 'tempCameraTarget', new Y())
      xe(this, 'toPreviousTarget', new Y())
      xe(this, 'toNextTarget', new Y())
      xe(this, 'updateCameraTransition', (e) => {
        if (this.transitioningCameraTarget) {
          ;(this.toPreviousTarget
            .copy(this.previousCameraTarget)
            .sub(this.camera.position)
            .normalize(),
            this.toNextTarget.copy(this.nextCameraTarget).sub(this.camera.position).normalize())
          const t = Math.acos(this.toPreviousTarget.dot(this.toNextTarget)),
            r =
              (((t / (Math.PI / 3)) * 0.65 + 0.3) / t) *
              (e - this.transitioningCameraTargetStartTime)
          ;(this.tempCameraTarget.copy(this.previousCameraTarget).lerp(this.nextCameraTarget, r),
            this.camera.lookAt(this.tempCameraTarget),
            this.controls.target.copy(this.tempCameraTarget),
            r >= 1 && (this.transitioningCameraTarget = !1))
        }
      })
      xe(
        this,
        'updateFocusMarker',
        (function () {
          const e = new je()
          let t = !1
          return function (i) {
            if ((this.getRenderDimensions(e), this.transitioningCameraTarget)) {
              this.sceneHelper.setFocusMarkerVisibility(!0)
              const r = Math.max(this.sceneHelper.getFocusMarkerOpacity(), 0)
              let s = Math.min(r + YQ * i, 1)
              ;(this.sceneHelper.setFocusMarkerOpacity(s),
                this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e),
                (t = !0),
                this.forceRenderNextFrame())
            } else {
              let r
              if (
                (t ? (r = 1) : (r = Math.min(this.sceneHelper.getFocusMarkerOpacity(), 1)), r > 0)
              ) {
                this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e)
                let s = Math.max(r - ZQ * i, 0)
                ;(this.sceneHelper.setFocusMarkerOpacity(s),
                  s === 0 && this.sceneHelper.setFocusMarkerVisibility(!1))
              }
              ;(r > 0 && this.forceRenderNextFrame(), (t = !1))
            }
          }
        })()
      )
      xe(
        this,
        'updateMeshCursor',
        (function () {
          const e = [],
            t = new je()
          return function () {
            this.showMeshCursor
              ? (this.forceRenderNextFrame(),
                this.getRenderDimensions(t),
                (e.length = 0),
                this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, t),
                this.raycaster.intersectSplatMesh(this.splatMesh, e),
                e.length > 0
                  ? (this.sceneHelper.setMeshCursorVisibility(!0),
                    this.sceneHelper.positionAndOrientMeshCursor(e[0].origin, this.camera))
                  : this.sceneHelper.setMeshCursorVisibility(!1))
              : (this.sceneHelper.getMeschCursorVisibility() && this.forceRenderNextFrame(),
                this.sceneHelper.setMeshCursorVisibility(!1))
          }
        })()
      )
      xe(
        this,
        'updateInfoPanel',
        (function () {
          const e = new je()
          return function () {
            if (!this.showInfo) return
            const t = this.splatMesh.getSplatCount()
            ;(this.getRenderDimensions(e),
              this.controls && this.controls.target,
              this.showMeshCursor && this.sceneHelper.meshCursor.position,
              t > 0 && (this.splatRenderCount / t) * 100)
          }
        })()
      )
      xe(this, 'mvpMatrix', new qe())
      xe(this, 'cameraPositionArray', [])
      xe(this, 'lastSortViewDir', new Y(0, 0, -1))
      xe(this, 'sortViewDir', new Y(0, 0, -1))
      xe(this, 'lastSortViewPos', new Y())
      xe(this, 'sortViewOffset', new Y())
      xe(this, 'queuedSorts', [])
      xe(this, 'partialSorts', [
        { angleThreshold: 0.55, sortFractions: [0.125, 0.33333, 0.75] },
        { angleThreshold: 0.65, sortFractions: [0.33333, 0.66667] },
        { angleThreshold: 0.8, sortFractions: [0.5] },
      ])
      xe(this, 'runSplatSort', (e = !1, t = !1) => {
        if (!this.initialized) return Promise.resolve(!1)
        if (this.sortRunning) return Promise.resolve(!0)
        if (this.splatMesh.getSplatCount() <= 0)
          return ((this.splatRenderCount = 0), Promise.resolve(!1))
        let i = 0,
          r = 0,
          s = !1,
          o = !1
        if (
          (this.sortViewDir.set(0, 0, -1).applyQuaternion(this.camera.quaternion),
          (i = this.sortViewDir.dot(this.lastSortViewDir)),
          (r = this.sortViewOffset.copy(this.camera.position).sub(this.lastSortViewPos).length()),
          !e &&
            !this.splatMesh.dynamicMode &&
            this.queuedSorts.length === 0 &&
            (i <= 0.99 && (s = !0), r >= 1 && (o = !0), !s && !o))
        )
          return Promise.resolve(!1)
        this.sortRunning = !0
        let { splatRenderCount: a, shouldSortAll: l } = this.gatherSceneNodesForSort()
        ;((l = l || t),
          (this.splatRenderCount = a),
          this.mvpMatrix.copy(this.camera.matrixWorld).invert())
        const c = this.perspectiveCamera || this.camera
        ;(this.mvpMatrix.premultiply(c.projectionMatrix),
          this.splatMesh.dynamicMode || this.mvpMatrix.multiply(this.splatMesh.matrixWorld))
        let u = Promise.resolve(!0)
        return (
          this.gpuAcceleratedSort &&
            (this.queuedSorts.length <= 1 || this.queuedSorts.length % 2 === 0) &&
            (u = this.splatMesh.computeDistancesOnGPU(
              this.mvpMatrix,
              this.sortWorkerPrecomputedDistances
            )),
          u.then(() => {
            if (this.queuedSorts.length === 0)
              if (this.splatMesh.dynamicMode || l) this.queuedSorts.push(this.splatRenderCount)
              else {
                for (let f of partialSorts)
                  if (i < f.angleThreshold) {
                    for (let p of f.sortFractions)
                      this.queuedSorts.push(Math.floor(this.splatRenderCount * p))
                    break
                  }
                this.queuedSorts.push(this.splatRenderCount)
              }
            let d = Math.min(this.queuedSorts.shift(), this.splatRenderCount)
            ;((this.splatSortCount = d),
              (this.cameraPositionArray[0] = this.camera.position.x),
              (this.cameraPositionArray[1] = this.camera.position.y),
              (this.cameraPositionArray[2] = this.camera.position.z))
            const h = {
              modelViewProj: this.mvpMatrix.elements,
              cameraPosition: this.cameraPositionArray,
              splatRenderCount: this.splatRenderCount,
              splatSortCount: d,
              usePrecomputedDistances: this.gpuAcceleratedSort,
            }
            return (
              this.splatMesh.dynamicMode &&
                this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),
              this.sharedMemoryForWorkers ||
                ((h.indexesToSort = this.sortWorkerIndexesToSort),
                (h.transforms = this.sortWorkerTransforms),
                this.gpuAcceleratedSort &&
                  (h.precomputedDistances = this.sortWorkerPrecomputedDistances)),
              (this.sortPromise = new Promise((f) => {
                this.sortPromiseResolver = f
              })),
              this.preSortMessages.length > 0 &&
                (this.preSortMessages.forEach((f) => {
                  this.sortWorker.postMessage(f)
                }),
                (this.preSortMessages = [])),
              this.sortWorker.postMessage({ sort: h }),
              this.queuedSorts.length === 0 &&
                (this.lastSortViewPos.copy(this.camera.position),
                this.lastSortViewDir.copy(this.sortViewDir)),
              !0
            )
          }),
          u
        )
      })
      xe(
        this,
        'gatherSceneNodesForSort',
        (function () {
          const e = []
          let t = null
          const i = new Y(),
            r = new Y(),
            s = new Y(),
            o = new qe(),
            a = new qe(),
            l = new qe(),
            c = new Y(),
            u = new Y(0, 0, -1),
            d = new Y(),
            h = (f) => d.copy(f.max).sub(f.min).length()
          return function (f = !1) {
            this.getRenderDimensions(c)
            const p = c.y / 2 / Math.tan((this.camera.fov / 2) * Ea.DEG2RAD),
              g = Math.atan(c.x / 2 / p),
              y = Math.atan(c.y / 2 / p),
              m = Math.cos(g),
              v = Math.cos(y),
              x = this.splatMesh.getSplatTree()
            if (x) {
              ;(a.copy(this.camera.matrixWorld).invert(),
                this.splatMesh.dynamicMode || a.multiply(this.splatMesh.matrixWorld))
              let _ = 0,
                S = 0
              for (let A = 0; A < x.subTrees.length; A++) {
                const R = x.subTrees[A]
                ;(o.copy(a),
                  this.splatMesh.dynamicMode &&
                    (this.splatMesh.getSceneTransform(A, l), o.multiply(l)))
                const w = R.nodesWithIndexes.length
                for (let M = 0; M < w; M++) {
                  const I = R.nodesWithIndexes[M]
                  if (!I.data || !I.data.indexes || I.data.indexes.length === 0) continue
                  s.copy(I.center).applyMatrix4(o)
                  const L = s.length()
                  ;(s.normalize(), i.copy(s).setX(0).normalize(), r.copy(s).setY(0).normalize())
                  const U = u.dot(r),
                    T = u.dot(i),
                    F = h(I),
                    V = T < v - 0.6,
                    W = U < m - 0.6
                  ;(!f && (W || V) && L > F) ||
                    ((S += I.data.indexes.length), (e[_] = I), (I.data.distanceToNode = L), _++)
                }
              }
              ;((e.length = _),
                e.sort((A, R) => (A.data.distanceToNode < R.data.distanceToNode ? -1 : 1)))
              let C = S * Ft.BytesPerInt
              for (let A = 0; A < _; A++) {
                const R = e[A],
                  w = R.data.indexes.length,
                  M = w * Ft.BytesPerInt
                ;(new Uint32Array(this.sortWorkerIndexesToSort.buffer, C - M, w).set(
                  R.data.indexes
                ),
                  (C -= M))
              }
              return { splatRenderCount: S, shouldSortAll: !1 }
            } else {
              const _ = this.splatMesh.getSplatCount()
              if (!t || t.length !== _) {
                t = new Uint32Array(_)
                for (let S = 0; S < _; S++) t[S] = S
              }
              return (
                this.sortWorkerIndexesToSort.set(t),
                { splatRenderCount: _, shouldSortAll: !0 }
              )
            }
          }
        })()
      )
      if (
        (e.cameraUp || (e.cameraUp = [0, 1, 0]),
        (this.cameraUp = new Y().fromArray(e.cameraUp)),
        e.initialCameraPosition || (e.initialCameraPosition = [0, 10, 15]),
        (this.initialCameraPosition = new Y().fromArray(e.initialCameraPosition)),
        e.initialCameraRotation || (e.initialCameraRotation = [0, 0, 0]),
        (this.initialCameraRotation = new Y().fromArray(e.initialCameraRotation)),
        (this.backgroundColor = e.backgroundColor),
        e.initialCameraLookAt || (e.initialCameraLookAt = [0, 0, 0]),
        (this.initialCameraLookAt = new Y().fromArray(e.initialCameraLookAt)),
        (this.dropInMode = e.dropInMode || !1),
        (e.selfDrivenMode === void 0 || e.selfDrivenMode === null) && (e.selfDrivenMode = !0),
        (this.selfDrivenMode = e.selfDrivenMode && !this.dropInMode),
        (this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this)),
        e.useBuiltInControls === void 0 && (e.useBuiltInControls = !0),
        (this.useBuiltInControls = e.useBuiltInControls),
        (this.rootElement = e.rootElement),
        (this.canvas = e.threejsCanvas),
        (this.ignoreDevicePixelRatio = e.ignoreDevicePixelRatio || !1),
        (this.devicePixelRatio = this.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio || 1),
        (this.halfPrecisionCovariancesOnGPU = e.halfPrecisionCovariancesOnGPU || !1),
        (this.threeScene = e.threeScene),
        (this.renderer = e.renderer),
        (this.camera = e.camera),
        (this.gpuAcceleratedSort = e.gpuAcceleratedSort || !1),
        (e.integerBasedSort === void 0 || e.integerBasedSort === null) && (e.integerBasedSort = !0),
        (this.integerBasedSort = e.integerBasedSort),
        (e.sharedMemoryForWorkers === void 0 || e.sharedMemoryForWorkers === null) &&
          (e.sharedMemoryForWorkers = !0),
        (this.sharedMemoryForWorkers = !1),
        (this.dynamicScene = !!e.dynamicScene),
        (this.antialiased = e.antialiased || !1),
        (this.kernel2DSize = e.kernel2DSize === void 0 ? 0.3 : e.kernel2DSize),
        (this.webXRMode = e.webXRMode || xc.None),
        this.webXRMode !== xc.None && (this.gpuAcceleratedSort = !1),
        (this.webXRActive = !1),
        (this.webXRSessionInit = e.webXRSessionInit || {}),
        (this.renderMode = e.renderMode || Zg.Always),
        (this.sceneRevealMode = e.sceneRevealMode || $d.Default),
        (this.focalAdjustment = e.focalAdjustment || 1),
        (this.maxScreenSpaceSplatSize = e.maxScreenSpaceSplatSize || 1024),
        (this.logLevel = e.logLevel || jc.None),
        (this.sphericalHarmonicsDegree = e.sphericalHarmonicsDegree || 0),
        (this.enableOptionalEffects = e.enableOptionalEffects || !1),
        (e.enableSIMDInSort === void 0 || e.enableSIMDInSort === null) && (e.enableSIMDInSort = !0),
        (this.enableSIMDInSort = e.enableSIMDInSort),
        (e.inMemoryCompressionLevel === void 0 || e.inMemoryCompressionLevel === null) &&
          (e.inMemoryCompressionLevel = 0),
        (this.inMemoryCompressionLevel = e.inMemoryCompressionLevel),
        (e.optimizeSplatData === void 0 || e.optimizeSplatData === null) &&
          (e.optimizeSplatData = !0),
        (this.optimizeSplatData = e.optimizeSplatData),
        (e.freeIntermediateSplatData === void 0 || e.freeIntermediateSplatData === null) &&
          (e.freeIntermediateSplatData = !1),
        (this.freeIntermediateSplatData = e.freeIntermediateSplatData),
        m_())
      ) {
        const i = g5()
        ;(i.major < 17 && (this.enableSIMDInSort = !1),
          i.major < 16 && (this.sharedMemoryForWorkers = !1))
      }
      ;((e.splatRenderMode === void 0 || e.splatRenderMode === null) &&
        (e.splatRenderMode = Mo.ThreeD),
        (this.splatRenderMode = e.splatRenderMode),
        (this.sceneFadeInRateMultiplier = e.sceneFadeInRateMultiplier || 1),
        (this.splatSortDistanceMapPrecision =
          e.splatSortDistanceMapPrecision || Ft.DefaultSplatSortDistanceMapPrecision))
      const t = this.integerBasedSort ? 20 : 24
      ;((this.splatSortDistanceMapPrecision = gi(this.splatSortDistanceMapPrecision, 10, t)),
        (this.onSplatMeshChangedCallback = null),
        this.createSplatMesh(),
        (this.controls = null),
        (this.perspectiveControls = null),
        (this.orthographicControls = null),
        (this.orthographicCamera = null),
        (this.perspectiveCamera = null),
        (this.showMeshCursor = !1),
        (this.showControlPlane = !1),
        (this.showInfo = !1),
        (this.sceneHelper = null),
        (this.sortWorker = null),
        (this.sortRunning = !1),
        (this.splatRenderCount = 0),
        (this.splatSortCount = 0),
        (this.lastSplatSortCount = 0),
        (this.sortWorkerIndexesToSort = null),
        (this.sortWorkerSortedIndexes = null),
        (this.sortWorkerPrecomputedDistances = null),
        (this.sortWorkerTransforms = null),
        (this.preSortMessages = []),
        (this.runAfterNextSort = []),
        (this.selfDrivenModeRunning = !1),
        (this.splatRenderReady = !1),
        (this.raycaster = new RU()),
        (this.infoPanel = null),
        (this.startInOrthographicMode = !1),
        (this.currentFPS = 0),
        (this.lastSortTime = 0),
        (this.consecutiveRenderFrames = 0),
        (this.previousCameraTarget = new Y()),
        (this.nextCameraTarget = new Y()),
        (this.mousePosition = new je()),
        (this.mouseDownPosition = new je()),
        (this.mouseDownTime = null),
        (this.resizeObserver = null),
        (this.mouseMoveListener = null),
        (this.mouseDownListener = null),
        (this.mouseUpListener = null),
        (this.keyDownListener = null),
        (this.sortPromise = null),
        (this.sortPromiseResolver = null),
        (this.splatSceneDownloadPromises = {}),
        (this.splatSceneDownloadAndBuildPromise = null),
        (this.splatSceneRemovalPromise = null),
        (this.loadingSpinner = new Qy(null, this.rootElement || document.body)),
        this.loadingSpinner.hide(),
        (this.loadingProgressBar = new TU(this.rootElement || document.body)),
        this.loadingProgressBar.hide(),
        (this.usingExternalCamera = !!(this.dropInMode || this.camera)),
        (this.usingExternalRenderer = !!(this.dropInMode || this.renderer)),
        (this.initialized = !1),
        (this.disposing = !1),
        (this.disposed = !1),
        (this.disposePromise = null),
        (this.lastTime = 0),
        (this.gaussianSplatCount = 0),
        (this.totalFrames = 0),
        (this.flame_params = null),
        (this.bone_tree = null),
        (this.lbs_weight_80k = null),
        (this.frame = 0),
        (this.useFlame = !0),
        (this.bones = null),
        (this.skeleton = null),
        (this.avatarMesh = null),
        (this.skinModel = null),
        (this.boneRoot = null),
        (this.baseMesh = null),
        (this.setSkinAttibutes = !1),
        this.dropInMode || this.init())
    }
    createSplatMesh() {
      ;((this.splatMesh = new li(
        this.splatRenderMode,
        this.dynamicScene,
        this.enableOptionalEffects,
        this.halfPrecisionCovariancesOnGPU,
        this.devicePixelRatio,
        this.gpuAcceleratedSort,
        this.integerBasedSort,
        this.antialiased,
        this.maxScreenSpaceSplatSize,
        this.logLevel,
        this.sphericalHarmonicsDegree,
        this.sceneFadeInRateMultiplier,
        this.kernel2DSize
      )),
        (this.splatMesh.frustumCulled = !1),
        this.onSplatMeshChangedCallback && this.onSplatMeshChangedCallback())
    }
    init() {
      this.initialized ||
        (this.rootElement ||
          (this.usingExternalRenderer
            ? (this.rootElement = this.renderer.domElement || document.body)
            : ((this.rootElement = document.createElement('div')),
              (this.rootElement.style.width = '100%'),
              (this.rootElement.style.height = '100%'),
              (this.rootElement.style.position = 'absolute'),
              document.body.appendChild(this.rootElement))),
        this.setupCamera(),
        this.setupRenderer(),
        this.setupWebXR(this.webXRSessionInit),
        this.setupEventHandlers(),
        (this.threeScene = this.threeScene || new cL()),
        (this.sceneHelper = new Vd(this.threeScene)),
        this.sceneHelper.setupMeshCursor(),
        this.sceneHelper.setupFocusMarker(),
        this.sceneHelper.setupControlPlane(),
        this.loadingProgressBar.setContainer(this.rootElement),
        this.loadingSpinner.setContainer(this.rootElement),
        (this.initialized = !0))
    }
    setupCamera() {
      if (!this.usingExternalCamera) {
        const e = new je()
        ;(this.getRenderDimensions(e),
          (this.perspectiveCamera = new Ki(qQ, e.x / e.y, 0.1, 1e3)),
          (this.orthographicCamera = new Bu(e.x / -2, e.x / 2, e.y / 2, e.y / -2, 0.1, 1e3)),
          (this.camera = this.startInOrthographicMode
            ? this.orthographicCamera
            : this.perspectiveCamera),
          this.camera.position.copy(this.initialCameraPosition),
          this.camera.rotateX(Ea.degToRad(this.initialCameraRotation.x)),
          this.camera.rotateY(Ea.degToRad(this.initialCameraRotation.y)),
          this.camera.rotateZ(Ea.degToRad(this.initialCameraRotation.z)))
      }
    }
    setupRenderer() {
      if (!this.usingExternalRenderer) {
        const e = new je()
        ;(this.getRenderDimensions(e),
          (this.renderer = new UB({ antialias: !1, precision: 'highp', canvas: this.canvas })),
          this.renderer.setPixelRatio(this.devicePixelRatio),
          (this.renderer.autoClear = !0),
          this.renderer.setClearColor(this.backgroundColor, 1),
          this.renderer.setSize(e.x, e.y),
          (this.resizeObserver = new ResizeObserver(() => {
            ;(this.getRenderDimensions(e),
              this.renderer.setSize(e.x, e.y),
              this.forceRenderNextFrame())
          })),
          this.resizeObserver.observe(this.rootElement),
          this.rootElement.appendChild(this.renderer.domElement))
      }
    }
    setupWebXR(e) {
      this.webXRMode &&
        (this.webXRMode === xc.VR
          ? this.rootElement.appendChild(_u.createButton(this.renderer, e))
          : this.webXRMode === xc.AR &&
            this.rootElement.appendChild(KU.createButton(this.renderer, e)),
        this.renderer.xr.addEventListener('sessionstart', (t) => {
          this.webXRActive = !0
        }),
        this.renderer.xr.addEventListener('sessionend', (t) => {
          this.webXRActive = !1
        }),
        (this.renderer.xr.enabled = !0),
        this.camera.position.copy(this.initialCameraPosition),
        this.camera.up.copy(this.cameraUp).normalize(),
        this.camera.lookAt(this.initialCameraLookAt))
    }
    setupControls() {
      if (this.useBuiltInControls && this.webXRMode === xc.None) {
        this.usingExternalCamera
          ? this.camera.isOrthographicCamera
            ? (this.orthographicControls = new Zf(this.camera, this.renderer.domElement))
            : (this.perspectiveControls = new Zf(this.camera, this.renderer.domElement))
          : ((this.perspectiveControls = new Zf(this.perspectiveCamera, this.renderer.domElement)),
            (this.orthographicControls = new Zf(this.orthographicCamera, this.renderer.domElement)))
        for (let e of [this.orthographicControls, this.perspectiveControls])
          e &&
            (e.listenToKeyEvents(window),
            (e.rotateSpeed = 0.5),
            (e.maxPolarAngle = Math.PI * 0.5),
            (e.minPolarAngle = Math.PI * 0.5),
            (e.enableDamping = !0),
            (e.dampingFactor = 0.05),
            e.target.copy(this.initialCameraLookAt),
            e.update())
        ;((this.controls = this.camera.isOrthographicCamera
          ? this.orthographicControls
          : this.perspectiveControls),
          this.controls.update())
      }
    }
    setupEventHandlers() {
      this.useBuiltInControls &&
        this.webXRMode === xc.None &&
        ((this.mouseMoveListener = this.onMouseMove.bind(this)),
        this.renderer.domElement.addEventListener('pointermove', this.mouseMoveListener, !1),
        (this.mouseDownListener = this.onMouseDown.bind(this)),
        this.renderer.domElement.addEventListener('pointerdown', this.mouseDownListener, !1),
        (this.mouseUpListener = this.onMouseUp.bind(this)),
        this.renderer.domElement.addEventListener('pointerup', this.mouseUpListener, !1),
        (this.keyDownListener = this.onKeyDown.bind(this)))
    }
    removeEventHandlers() {
      this.useBuiltInControls &&
        (this.renderer.domElement.removeEventListener('pointermove', this.mouseMoveListener),
        (this.mouseMoveListener = null),
        this.renderer.domElement.removeEventListener('pointerdown', this.mouseDownListener),
        (this.mouseDownListener = null),
        this.renderer.domElement.removeEventListener('pointerup', this.mouseUpListener),
        (this.mouseUpListener = null),
        window.removeEventListener('keydown', this.keyDownListener),
        (this.keyDownListener = null))
    }
    setRenderMode(e) {
      this.renderMode = e
    }
    setActiveSphericalHarmonicsDegrees(e) {
      ;((this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value = e),
        (this.splatMesh.material.uniformsNeedUpdate = !0))
    }
    onSplatMeshChanged(e) {
      this.onSplatMeshChangedCallback = e
    }
    onMouseMove(e) {
      this.mousePosition.set(e.offsetX, e.offsetY)
    }
    onMouseDown() {
      ;(this.mouseDownPosition.copy(this.mousePosition), (this.mouseDownTime = ec()))
    }
    onMouseClick(e) {
      ;(this.mousePosition.set(e.offsetX, e.offsetY), this.checkForFocalPointChange())
    }
    getRenderDimensions(e) {
      this.rootElement
        ? ((e.x = this.rootElement.offsetWidth), (e.y = this.rootElement.offsetHeight))
        : this.renderer.getSize(e)
    }
    setOrthographicMode(e) {
      if (e === this.camera.isOrthographicCamera) return
      const t = this.camera,
        i = e ? this.orthographicCamera : this.perspectiveCamera
      if (
        (i.position.copy(t.position),
        i.up.copy(t.up),
        i.rotation.copy(t.rotation),
        i.quaternion.copy(t.quaternion),
        i.matrix.copy(t.matrix),
        (this.camera = i),
        this.controls)
      ) {
        const r = (a) => {
            ;(a.saveState(), a.reset())
          },
          s = this.controls,
          o = e ? this.orthographicControls : this.perspectiveControls
        ;(r(o),
          r(s),
          o.target.copy(s.target),
          e ? xa.setCameraZoomFromPosition(i, t, s) : xa.setCameraPositionFromZoom(i, t, o),
          (this.controls = o),
          this.camera.lookAt(this.controls.target))
      }
    }
    adjustForWebXRStereo(e) {
      if (this.camera && this.webXRActive) {
        const i = this.renderer.xr.getCamera().projectionMatrix.elements[0],
          r = this.camera.projectionMatrix.elements[0]
        e.x *= r / i
      }
    }
    isLoadingOrUnloading() {
      return (
        Object.keys(this.splatSceneDownloadPromises).length > 0 ||
        this.splatSceneDownloadAndBuildPromise !== null ||
        this.splatSceneRemovalPromise !== null
      )
    }
    isDisposingOrDisposed() {
      return this.disposing || this.disposed
    }
    addSplatSceneDownloadPromise(e) {
      this.splatSceneDownloadPromises[e.id] = e
    }
    removeSplatSceneDownloadPromise(e) {
      delete this.splatSceneDownloadPromises[e.id]
    }
    setSplatSceneDownloadAndBuildPromise(e) {
      this.splatSceneDownloadAndBuildPromise = e
    }
    clearSplatSceneDownloadAndBuildPromise() {
      this.splatSceneDownloadAndBuildPromise = null
    }
    addSplatScene(e, t = {}) {
      if (this.isLoadingOrUnloading())
        throw new Error(
          'Cannot add splat scene while another load or unload is already in progress.'
        )
      if (this.isDisposingOrDisposed())
        throw new Error('Cannot add splat scene after dispose() is called.')
      t.progressiveLoad &&
        this.splatMesh.scenes &&
        this.splatMesh.scenes.length > 0 &&
        (console.log(
          'addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'
        ),
        (t.progressiveLoad = !1))
      const i = t.format !== void 0 && t.format !== null ? t.format : KA(e),
        r = xa.isProgressivelyLoadable(i) && t.progressiveLoad,
        s = t.showLoadingUI !== void 0 && t.showLoadingUI !== null ? t.showLoadingUI : !0
      let o = null
      s &&
        (this.loadingSpinner.removeAllTasks(), (o = this.loadingSpinner.addTask('Downloading...')))
      const a = () => {
          ;(this.loadingProgressBar.hide(), this.loadingSpinner.removeAllTasks())
        },
        l = (g, y, m) => {
          if (s)
            if (m === Kn.Downloading)
              if (g == 100) this.loadingSpinner.setMessageForTask(o, 'Download complete!')
              else if (r) this.loadingSpinner.setMessageForTask(o, 'Downloading splats...')
              else {
                const v = y ? ': '.concat(y) : '...'
                this.loadingSpinner.setMessageForTask(o, 'Downloading'.concat(v))
              }
            else
              m === Kn.Processing &&
                (console.log('loaderStatus === LoaderStatus.Processing'),
                this.loadingSpinner.setMessageForTask(o, 'Processing splats...'))
        }
      let c = !1,
        u = 0
      const d = (g, y) => {
          s &&
            (((g && r) || (y && !r)) &&
              (this.loadingSpinner.removeTask(o), !y && !c && this.loadingProgressBar.show()),
            r &&
              (y
                ? ((c = !0), this.loadingProgressBar.hide())
                : this.loadingProgressBar.setProgress(u)))
        },
        h = (g, y, m) => {
          ;((u = g), l(g, y, m), t.onProgress && t.onProgress(g, y, m))
        },
        f = (g, y, m) => {
          !r && t.onProgress && t.onProgress(0, '0%', Kn.Processing)
          const v = {
            rotation: t.rotation || t.orientation,
            position: t.position,
            scale: t.scale,
            splatAlphaRemovalThreshold: t.splatAlphaRemovalThreshold,
          }
          return this.addSplatBuffers([g], [v], m, y && s, s, r, r).then(() => {
            ;(!r && t.onProgress && t.onProgress(100, '100%', Kn.Processing), d(y, m))
          })
        }
      return (
        r
          ? this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this)
          : this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this)
      )(e, i, t.splatAlphaRemovalThreshold, f.bind(this), h, a.bind(this), t.headers)
    }
    downloadAndBuildSingleSplatSceneStandardLoad(e, t, i, r, s, o, a) {
      const l = this.downloadSplatSceneToSplatBuffer(e, i, s, !1, void 0, t, a),
        c = dg(l.abortHandler)
      return (
        l
          .then(
            (u) => (
              this.removeSplatSceneDownloadPromise(l),
              r(u, !0, !0).then(() => {
                ;(c.resolve(), this.clearSplatSceneDownloadAndBuildPromise())
              })
            )
          )
          .catch((u) => {
            ;(o && o(),
              this.clearSplatSceneDownloadAndBuildPromise(),
              this.removeSplatSceneDownloadPromise(l))
            const d =
              u instanceof Cp
                ? u
                : new Error('Viewer::addSplatScene -> Could not load file '.concat(e))
            c.reject(d)
          }),
        this.addSplatSceneDownloadPromise(l),
        this.setSplatSceneDownloadAndBuildPromise(c.promise),
        c.promise
      )
    }
    downloadAndBuildSingleSplatSceneProgressiveLoad(e, t, i, r, s, o, a) {
      let l = 0,
        c = !1
      const u = [],
        d = () => {
          if (u.length > 0 && !c && !this.isDisposingOrDisposed()) {
            c = !0
            const y = u.shift()
            r(y.splatBuffer, y.firstBuild, y.finalBuild).then(() => {
              ;((c = !1),
                y.firstBuild
                  ? p.resolve()
                  : y.finalBuild && (g.resolve(), this.clearSplatSceneDownloadAndBuildPromise()),
                u.length > 0 && ms(() => d()))
            })
          }
        },
        h = (y, m) => {
          this.isDisposingOrDisposed() ||
            ((m || u.length === 0 || y.getSplatCount() > u[0].splatBuffer.getSplatCount()) &&
              (u.push({ splatBuffer: y, firstBuild: l === 0, finalBuild: m }), l++, d()))
        },
        f = this.downloadSplatSceneToSplatBuffer(e, i, s, !0, h, t, a),
        p = dg(f.abortHandler),
        g = dg()
      return (
        this.addSplatSceneDownloadPromise(f),
        this.setSplatSceneDownloadAndBuildPromise(g.promise),
        f
          .then(() => {
            this.removeSplatSceneDownloadPromise(f)
          })
          .catch((y) => {
            ;(this.clearSplatSceneDownloadAndBuildPromise(),
              this.removeSplatSceneDownloadPromise(f))
            const m =
              y instanceof Cp
                ? y
                : new Error('Viewer::addSplatScene -> Could not load one or more scenes')
            ;(p.reject(m), o && o(m))
          }),
        p.promise
      )
    }
    addSplatScenes(e, t = !0, i = void 0) {
      if (this.isLoadingOrUnloading())
        throw new Error(
          'Cannot add splat scene while another load or unload is already in progress.'
        )
      if (this.isDisposingOrDisposed())
        throw new Error('Cannot add splat scene after dispose() is called.')
      const r = e.length,
        s = []
      let o
      t &&
        (this.loadingSpinner.removeAllTasks(), (o = this.loadingSpinner.addTask('Downloading...')))
      const a = (d, h, f, p) => {
          s[d] = h
          let g = 0
          for (let y = 0; y < r; y++) g += s[y] || 0
          ;((g = g / r),
            (f = ''.concat(g.toFixed(2), '%')),
            t &&
              p === Kn.Downloading &&
              this.loadingSpinner.setMessageForTask(
                o,
                g == 100 ? 'Download complete!' : 'Downloading: '.concat(f)
              ),
            i && i(g, f, p))
        },
        l = [],
        c = []
      for (let d = 0; d < e.length; d++) {
        const h = e[d],
          f = h.format !== void 0 && h.format !== null ? h.format : KA(h.path),
          p = this.downloadSplatSceneToSplatBuffer(
            h.path,
            h.splatAlphaRemovalThreshold,
            a.bind(this, d),
            !1,
            void 0,
            f,
            h.headers
          )
        ;(l.push(p), c.push(p.promise))
      }
      const u = new rh(
        (d, h) => {
          Promise.all(c)
            .then((f) => {
              ;(t && this.loadingSpinner.removeTask(o),
                i && i(0, '0%', Kn.Processing),
                this.addSplatBuffers(f, e, !0, t, t, !1, !1).then(() => {
                  ;(i && i(100, '100%', Kn.Processing),
                    this.clearSplatSceneDownloadAndBuildPromise(),
                    d())
                }))
            })
            .catch((f) => {
              ;(t && this.loadingSpinner.removeTask(o),
                this.clearSplatSceneDownloadAndBuildPromise())
              const p =
                f instanceof Cp
                  ? f
                  : new Error('Viewer::addSplatScenes -> Could not load one or more splat scenes.')
              h(p)
            })
            .finally(() => {
              this.removeSplatSceneDownloadPromise(u)
            })
        },
        (d) => {
          for (let h of l) h.abort(d)
        }
      )
      return (this.addSplatSceneDownloadPromise(u), this.setSplatSceneDownloadAndBuildPromise(u), u)
    }
    downloadSplatSceneToSplatBuffer(e, t = 1, i = void 0, r = !1, s = void 0, o, a) {
      const l = r ? !1 : this.optimizeSplatData
      try {
        if (o === Hs.Splat)
          return j_.loadFromURL(e, i, r, s, t, this.inMemoryCompressionLevel, l, a)
        if (o === Hs.KSplat) return Wy.loadFromURL(e, i, r, s, a)
        if (o === Hs.Ply)
          return Q_.loadFromURL(
            e,
            i,
            r,
            s,
            t,
            this.inMemoryCompressionLevel,
            l,
            this.sphericalHarmonicsDegree,
            a
          )
      } catch (c) {
        throw c instanceof W_
          ? new Error('File type or server does not support progressive loading.')
          : c
      }
      throw new Error(
        'Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: '.concat(e)
      )
    }
    static isProgressivelyLoadable(e) {
      return e === Hs.Splat || e === Hs.KSplat || e === Hs.Ply
    }
    async setupSortWorker(e) {
      if (!this.isDisposingOrDisposed())
        return new Promise(async (t) => {
          const i = this.integerBasedSort ? Int32Array : Float32Array,
            r = e.getSplatCount(),
            s = e.getMaxSplatCount()
          ;((this.sortWorker = await XU(
            s,
            this.sharedMemoryForWorkers,
            this.enableSIMDInSort,
            this.integerBasedSort,
            this.splatMesh.dynamicMode,
            this.splatSortDistanceMapPrecision
          )),
            (this.sortWorker.onmessage = (o) => {
              if (o.data.sortDone) {
                if (
                  ((this.sortRunning = !1),
                  Array.from({ length: this.gaussianSplatCount }, (a, l) => l),
                  this.sharedMemoryForWorkers)
                )
                  this.splatMesh.updateRenderIndexes(
                    this.sortWorkerSortedIndexes,
                    o.data.splatRenderCount
                  )
                else {
                  const a = new Uint32Array(o.data.sortedIndexes.buffer, 0, o.data.splatRenderCount)
                  this.splatMesh.updateRenderIndexes(a, o.data.splatRenderCount)
                }
                ;((this.lastSplatSortCount = this.splatSortCount),
                  (this.lastSortTime = o.data.sortTime),
                  this.sortPromiseResolver(),
                  (this.sortPromiseResolver = null),
                  this.forceRenderNextFrame(),
                  this.runAfterNextSort.length > 0 &&
                    (this.runAfterNextSort.forEach((a) => {
                      a()
                    }),
                    (this.runAfterNextSort.length = 0)))
              } else if (o.data.sortCanceled) this.sortRunning = !1
              else if (o.data.sortSetupPhase1Complete) {
                ;(this.logLevel >= jc.Info &&
                  console.log('Sorting web worker WASM setup complete.'),
                  this.sharedMemoryForWorkers
                    ? ((this.sortWorkerSortedIndexes = new Uint32Array(
                        o.data.sortedIndexesBuffer,
                        o.data.sortedIndexesOffset,
                        s
                      )),
                      (this.sortWorkerIndexesToSort = new Uint32Array(
                        o.data.indexesToSortBuffer,
                        o.data.indexesToSortOffset,
                        s
                      )),
                      (this.sortWorkerPrecomputedDistances = new i(
                        o.data.precomputedDistancesBuffer,
                        o.data.precomputedDistancesOffset,
                        s
                      )),
                      (this.sortWorkerTransforms = new Float32Array(
                        o.data.transformsBuffer,
                        o.data.transformsOffset,
                        Ft.MaxScenes * 16
                      )))
                    : ((this.sortWorkerIndexesToSort = new Uint32Array(s)),
                      (this.sortWorkerPrecomputedDistances = new i(s)),
                      (this.sortWorkerTransforms = new Float32Array(Ft.MaxScenes * 16))))
                for (let a = 0; a < r; a++) this.sortWorkerIndexesToSort[a] = a
                if (((this.sortWorker.maxSplatCount = s), this.logLevel >= jc.Info)) {
                  console.log('Sorting web worker ready.')
                  const a = this.splatMesh.getSplatDataTextures(),
                    l = a.covariances.size,
                    c = a.centerColors.size
                  ;(console.log('Covariances texture size: ' + l.x + ' x ' + l.y),
                    console.log('Centers/colors texture size: ' + c.x + ' x ' + c.y))
                }
                t()
              }
            }))
        })
    }
    disposeSortWorker() {
      ;(this.sortWorker && this.sortWorker.terminate(),
        (this.sortWorker = null),
        (this.sortPromise = null),
        this.sortPromiseResolver && (this.sortPromiseResolver(), (this.sortPromiseResolver = null)),
        (this.preSortMessages = []),
        (this.sortRunning = !1))
    }
    removeSplatScene(e, t = !0) {
      return this.removeSplatScenes([e], t)
    }
    removeSplatScenes(e, t = !0) {
      if (this.isLoadingOrUnloading())
        throw new Error(
          'Cannot remove splat scene while another load or unload is already in progress.'
        )
      if (this.isDisposingOrDisposed())
        throw new Error('Cannot remove splat scene after dispose() is called.')
      let i
      return (
        (this.splatSceneRemovalPromise = new Promise((r, s) => {
          let o
          t &&
            (this.loadingSpinner.removeAllTasks(),
            this.loadingSpinner.show(),
            (o = this.loadingSpinner.addTask('Removing splat scene...')))
          const a = () => {
              t && (this.loadingSpinner.hide(), this.loadingSpinner.removeTask(o))
            },
            l = (u) => {
              ;(a(), (this.splatSceneRemovalPromise = null), u ? s(u) : r())
            },
            c = () => (this.isDisposingOrDisposed() ? (l(), !0) : !1)
          ;((i = this.sortPromise || Promise.resolve()),
            i.then(() => {
              if (c()) return
              const u = [],
                d = [],
                h = []
              for (let f = 0; f < this.splatMesh.scenes.length; f++) {
                let p = !1
                for (let g of e)
                  if (g === f) {
                    p = !0
                    break
                  }
                if (!p) {
                  const g = this.splatMesh.scenes[f]
                  ;(u.push(g.splatBuffer),
                    d.push(this.splatMesh.sceneOptions[f]),
                    h.push({
                      position: g.position.clone(),
                      quaternion: g.quaternion.clone(),
                      scale: g.scale.clone(),
                    }))
                }
              }
              ;(this.disposeSortWorker(),
                this.splatMesh.dispose(),
                (this.sceneRevealMode = $d.Instant),
                this.createSplatMesh(),
                this.addSplatBuffers(u, d, !0, !1, !0)
                  .then(() => {
                    c() ||
                      (a(),
                      this.splatMesh.scenes.forEach((f, p) => {
                        ;(f.position.copy(h[p].position),
                          f.quaternion.copy(h[p].quaternion),
                          f.scale.copy(h[p].scale))
                      }),
                      this.splatMesh.updateTransforms(),
                      (this.splatRenderReady = !1),
                      this.runSplatSort(!0).then(() => {
                        if (c()) {
                          this.splatRenderReady = !0
                          return
                        }
                        ;((i = this.sortPromise || Promise.resolve()),
                          i.then(() => {
                            ;((this.splatRenderReady = !0), l())
                          }))
                      }))
                  })
                  .catch((f) => {
                    l(f)
                  }))
            }))
        })),
        this.splatSceneRemovalPromise
      )
    }
    start() {
      if (this.selfDrivenMode)
        (this.webXRMode
          ? this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc)
          : (this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc)),
          (this.selfDrivenModeRunning = !0))
      else throw new Error('Cannot start viewer unless it is in self driven mode.')
    }
    stop() {
      this.selfDrivenMode &&
        this.selfDrivenModeRunning &&
        (this.webXRMode
          ? this.renderer.setAnimationLoop(null)
          : cancelAnimationFrame(this.requestFrameId),
        (this.selfDrivenModeRunning = !1))
    }
    async dispose() {
      if (this.isDisposingOrDisposed()) return this.disposePromise
      let e = [],
        t = []
      for (let i in this.splatSceneDownloadPromises)
        if (this.splatSceneDownloadPromises.hasOwnProperty(i)) {
          const r = this.splatSceneDownloadPromises[i]
          ;(t.push(r), e.push(r.promise))
        }
      return (
        this.sortPromise && e.push(this.sortPromise),
        (this.disposing = !0),
        (this.disposePromise = Promise.all(e).finally(() => {
          ;(this.stop(),
            this.orthographicControls &&
              (this.orthographicControls.dispose(), (this.orthographicControls = null)),
            this.perspectiveControls &&
              (this.perspectiveControls.dispose(), (this.perspectiveControls = null)),
            (this.controls = null),
            this.splatMesh && (this.splatMesh.dispose(), (this.splatMesh = null)),
            this.sceneHelper && (this.sceneHelper.dispose(), (this.sceneHelper = null)),
            this.resizeObserver &&
              (this.resizeObserver.unobserve(this.rootElement), (this.resizeObserver = null)),
            this.disposeSortWorker(),
            this.removeEventHandlers(),
            this.loadingSpinner.removeAllTasks(),
            this.loadingSpinner.setContainer(null),
            this.loadingProgressBar.hide(),
            this.loadingProgressBar.setContainer(null),
            (this.camera = null),
            (this.threeScene = null),
            (this.splatRenderReady = !1),
            (this.initialized = !1),
            this.renderer &&
              (this.usingExternalRenderer ||
                (this.rootElement.removeChild(this.renderer.domElement), this.renderer.dispose()),
              (this.renderer = null)),
            this.usingExternalRenderer,
            (this.sortWorkerSortedIndexes = null),
            (this.sortWorkerIndexesToSort = null),
            (this.sortWorkerPrecomputedDistances = null),
            (this.sortWorkerTransforms = null),
            (this.disposed = !0),
            (this.disposing = !1),
            (this.disposePromise = null))
        })),
        t.forEach((i) => {
          i.abort('Scene disposed')
        }),
        this.disposePromise
      )
    }
    selfDrivenUpdate() {
      ;(this.selfDrivenMode &&
        !this.webXRMode &&
        (this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc)),
        this.vsyncCount++,
        !(this.vsyncCount < this.vsyncNum) &&
          ((this.vsyncCount = 0),
          this.update(),
          this.shouldRender()
            ? (this.render(), this.consecutiveRenderFrames++)
            : (this.consecutiveRenderFrames = 0),
          (this.renderNextFrame = !1)))
    }
    forceRenderNextFrame() {
      this.renderNextFrame = !0
    }
    update(e, t) {
      const i = document.getElementById('fps')
      ;(i && (i.textContent = 'FPS: '.concat(this.currentFPS)),
        this.frame >= this.totalFrames && (this.frame = 0),
        this.dropInMode && this.updateForDropInMode(e, t),
        !(!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed()) &&
          (this.controls &&
            (this.controls.update(),
            this.camera.isOrthographicCamera &&
              !this.usingExternalCamera &&
              xa.setCameraPositionFromZoom(this.camera, this.camera, this.controls)),
          this.runMorphUpdate(),
          this.runSplatSort(!0, !0),
          this.updateForRendererSizeChanges(),
          this.updateSplatMesh(),
          this.updateMeshCursor(),
          this.updateFPS(),
          this.timingSensitiveUpdates(),
          this.updateControlPlane()))
    }
    updateForDropInMode(e, t) {
      ;((this.renderer = e),
        this.splatMesh && this.splatMesh.setRenderer(this.renderer),
        (this.camera = t),
        this.controls && (this.controls.object = t),
        this.init())
    }
    updateControlPlane() {
      this.showControlPlane
        ? (this.sceneHelper.setControlPlaneVisibility(!0),
          this.sceneHelper.positionAndOrientControlPlane(this.controls.target, this.camera.up))
        : this.sceneHelper.setControlPlaneVisibility(!1)
    }
    getSplatMesh() {
      return this.splatMesh
    }
    getSplatScene(e) {
      return this.splatMesh.getScene(e)
    }
    getSceneCount() {
      return this.splatMesh.getSceneCount()
    }
    isMobile() {
      return navigator.userAgent.includes('Mobi')
    }
    createBonesFromJson(e) {
      const t = []
      function i(r, s = null) {
        const o = new fh()
        return (
          (o.name = r.name),
          s && s.add(o),
          o.position.set(...r.position),
          t.push(o),
          r.children && r.children.forEach((a) => i(a, o)),
          o
        )
      }
      return (e.forEach((r) => i(r)), t)
    }
    updateMorphTarget(e) {
      if (
        ((this.avatarMesh = e),
        (this.splatMesh.flameModel = e),
        (this.splatMesh.useFlameModel = this.useFlame),
        this.useFlame == !0)
      ) {
        this.bones = this.createBonesFromJson(this.bone_tree.bones)
        const t = [
          new Y(this.bones[0].position.x, this.bones[0].position.y, this.bones[0].position.z),
          new Y(this.bones[1].position.x, this.bones[1].position.y, this.bones[1].position.z),
          new Y(this.bones[2].position.x, this.bones[2].position.y, this.bones[2].position.z),
          new Y(this.bones[3].position.x, this.bones[3].position.y, this.bones[3].position.z),
          new Y(this.bones[4].position.x, this.bones[4].position.y, this.bones[4].position.z),
        ]
        ;(this.bones[1].position.copy(new Y(t[1].x - t[0].x, t[1].y - t[0].y, t[1].z - t[0].z)),
          this.bones[2].position.copy(new Y(t[2].x - t[1].x, t[2].y - t[1].y, t[2].z - t[1].z)),
          this.bones[3].position.copy(new Y(t[3].x - t[1].x, t[3].y - t[1].y, t[3].z - t[1].z)),
          this.bones[4].position.copy(new Y(t[4].x - t[1].x, t[4].y - t[1].y, t[4].z - t[1].z)),
          this.bones[0].updateMatrixWorld(!0))
        const i = [
          this.bones[0].matrixWorld.clone().invert(),
          this.bones[1].matrixWorld.clone().invert(),
          this.bones[2].matrixWorld.clone().invert(),
          this.bones[3].matrixWorld.clone().invert(),
          this.bones[4].matrixWorld.clone().invert(),
        ]
        this.skeleton = new c0(this.bones, i)
      }
      ;(this.runMorphUpdate(), (this.splatMesh.gaussianSplatCount = this.gaussianSplatCount))
    }
    updatedBoneMatrices(e) {
      let t = []
      for (let r = 0; r < e; r++) {
        let o = function (a, l) {
            let c = a.elements
            for (let u = 0; u < c.length; u++) l.push(c[u])
          },
          s
        ;((s = this.skeleton.bones[r].matrixWorld
          .clone()
          .multiply(this.skeleton.boneInverses[r].clone())),
          o(s, t))
      }
      return new Float32Array(t)
    }
    runMorphUpdate() {
      this.gaussianSplatCount = this.avatarMesh.geometry.attributes.position.count
      var e = new Float32Array(this.avatarMesh.geometry.attributes.position.array)
      const t = 5
      if (((this.splatMesh.bonesNum = t), this.useFlame == !1)) {
        if (
          (this.skinModel.skeleton.update(),
          this.boneRoot.updateMatrixWorld(!0),
          this.splatMesh.geometry.getAttribute('splatIndex') && this.setSkinAttibutes === !1)
        ) {
          this.setSkinAttibutes = !0
          const r = this.splatMesh.geometry,
            s = this.skinModel.geometry.attributes.skinIndex,
            o = this.skinModel.geometry.attributes.skinWeight,
            a = new Ko(new s.array.constructor(s.array), 4, s.normalized, 1),
            l = new Ko(new o.array.constructor(o.array), 4, o.normalized, 1)
          ;(a.setUsage(Ca),
            l.setUsage(Ca),
            r.setAttribute('skinIndex', a),
            r.setAttribute('skinWeight', l))
        }
      } else this.updateFlameBones()
      this.splatMesh.morphedMesh = e
      let i = this.splatMesh.morphedMesh.length / 3
      this.splatMesh.splatDataTextures.flameModel != null &&
        this.splatMesh.updateTetureAfterBSAndSkeleton(0, i - 1, this.useFlame)
    }
    updateFlameBones() {
      this.splatMesh.bsWeight = this.flame_params.expr[this.frame]
      function e(s, o, a = !1) {
        let l
        if (a == !0) l = new Qt(o[0], o[1], o[2], o[3])
        else {
          const c = new Y(o[0], o[1], o[2]),
            u = c.length(),
            d = c.normalize()
          l = new Qt().setFromAxisAngle(d, u)
        }
        ;(s.quaternion.copy(l), s.updateMatrixWorld(!0))
      }
      let t = this.flame_params.rotation[this.frame]
      ;(e(this.skeleton.bones[0], t),
        (t = this.flame_params.neck_pose[this.frame]),
        e(this.skeleton.bones[1], t),
        (t = this.flame_params.jaw_pose[this.frame]),
        e(this.skeleton.bones[2], t),
        (t = this.flame_params.eyes_pose[this.frame]),
        e(this.skeleton.bones[3], t),
        e(this.skeleton.bones[4], [t[3], t[4], t[5]]),
        this.skeleton.update())
      const i = 5,
        r = this.updatedBoneMatrices(i)
      ;((this.splatMesh.bonesMatrix = r),
        (this.splatMesh.bonesNum = i),
        (this.splatMesh.bonesWeight = this.lbs_weight_80k))
    }
  }
;(xe(
  xa,
  'setCameraPositionFromZoom',
  (function () {
    const e = new Y()
    return function (t, i, r) {
      const s = 1 / (i.zoom * 0.001)
      ;(e.copy(r.target).sub(t.position).normalize().multiplyScalar(s).negate(),
        t.position.copy(r.target).add(e))
    }
  })()
),
  xe(
    xa,
    'setCameraZoomFromPosition',
    (function () {
      const e = new Y()
      return function (t, i, r) {
        const s = e.copy(r.target).sub(i.position).length()
        t.zoom = 1 / (s * 0.001)
      }
    })()
  ))
let lv = xa
function ul(n, e, t, i) {
  function r(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s)
        })
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(u) {
      try {
        c(i.next(u))
      } catch (d) {
        o(d)
      }
    }
    function l(u) {
      try {
        c(i.throw(u))
      } catch (d) {
        o(d)
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(a, l)
    }
    c((i = i.apply(n, e || [])).next())
  })
}
function z4(n, e) {
  return function () {
    return n.apply(e, arguments)
  }
}
const { toString: ej } = Object.prototype,
  { getPrototypeOf: Ux } = Object,
  w0 = ((n) => (e) => {
    const t = ej.call(e)
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase())
  })(Object.create(null)),
  Ms = (n) => ((n = n.toLowerCase()), (e) => w0(e) === n),
  C0 = (n) => (e) => typeof e === n,
  { isArray: Hu } = Array,
  xh = C0('undefined')
function tj(n) {
  return (
    n !== null &&
    !xh(n) &&
    n.constructor !== null &&
    !xh(n.constructor) &&
    Pr(n.constructor.isBuffer) &&
    n.constructor.isBuffer(n)
  )
}
const V4 = Ms('ArrayBuffer')
function nj(n) {
  let e
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(n))
      : (e = n && n.buffer && V4(n.buffer)),
    e
  )
}
const ij = C0('string'),
  Pr = C0('function'),
  H4 = C0('number'),
  E0 = (n) => n !== null && typeof n == 'object',
  rj = (n) => n === !0 || n === !1,
  Bp = (n) => {
    if (w0(n) !== 'object') return !1
    const e = Ux(n)
    return (
      (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    )
  },
  sj = Ms('Date'),
  oj = Ms('File'),
  aj = Ms('Blob'),
  lj = Ms('FileList'),
  cj = (n) => E0(n) && Pr(n.pipe),
  uj = (n) => {
    let e
    return (
      n &&
      ((typeof FormData == 'function' && n instanceof FormData) ||
        (Pr(n.append) &&
          ((e = w0(n)) === 'formdata' ||
            (e === 'object' && Pr(n.toString) && n.toString() === '[object FormData]'))))
    )
  },
  dj = Ms('URLSearchParams'),
  [hj, fj, pj, mj] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(Ms),
  gj = (n) => (n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''))
function rf(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > 'u') return
  let i, r
  if ((typeof n != 'object' && (n = [n]), Hu(n)))
    for (i = 0, r = n.length; i < r; i++) e.call(null, n[i], i, n)
  else {
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
      o = s.length
    let a
    for (i = 0; i < o; i++) ((a = s[i]), e.call(null, n[a], a, n))
  }
}
function $4(n, e) {
  e = e.toLowerCase()
  const t = Object.keys(n)
  let i = t.length,
    r
  for (; i-- > 0; ) if (((r = t[i]), e === r.toLowerCase())) return r
  return null
}
const Cl =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : global,
  G4 = (n) => !xh(n) && n !== Cl
function cv() {
  const { caseless: n } = (G4(this) && this) || {},
    e = {},
    t = (i, r) => {
      const s = (n && $4(e, r)) || r
      Bp(e[s]) && Bp(i)
        ? (e[s] = cv(e[s], i))
        : Bp(i)
          ? (e[s] = cv({}, i))
          : Hu(i)
            ? (e[s] = i.slice())
            : (e[s] = i)
    }
  for (let i = 0, r = arguments.length; i < r; i++) arguments[i] && rf(arguments[i], t)
  return e
}
const yj = (n, e, t, { allOwnKeys: i } = {}) => (
    rf(
      e,
      (r, s) => {
        t && Pr(r) ? (n[s] = z4(r, t)) : (n[s] = r)
      },
      { allOwnKeys: i }
    ),
    n
  ),
  vj = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
  _j = (n, e, t, i) => {
    ;((n.prototype = Object.create(e.prototype, i)),
      (n.prototype.constructor = n),
      Object.defineProperty(n, 'super', { value: e.prototype }),
      t && Object.assign(n.prototype, t))
  },
  xj = (n, e, t, i) => {
    let r, s, o
    const a = {}
    if (((e = e || {}), n == null)) return e
    do {
      for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
        ((o = r[s]), (!i || i(o, n, e)) && !a[o] && ((e[o] = n[o]), (a[o] = !0)))
      n = t !== !1 && Ux(n)
    } while (n && (!t || t(n, e)) && n !== Object.prototype)
    return e
  },
  Sj = (n, e, t) => {
    ;((n = String(n)), (t === void 0 || t > n.length) && (t = n.length), (t -= e.length))
    const i = n.indexOf(e, t)
    return i !== -1 && i === t
  },
  Aj = (n) => {
    if (!n) return null
    if (Hu(n)) return n
    let e = n.length
    if (!H4(e)) return null
    const t = new Array(e)
    for (; e-- > 0; ) t[e] = n[e]
    return t
  },
  bj = (
    (n) => (e) =>
      n && e instanceof n
  )(typeof Uint8Array < 'u' && Ux(Uint8Array)),
  Tj = (n, e) => {
    const i = (n && n[Symbol.iterator]).call(n)
    let r
    for (; (r = i.next()) && !r.done; ) {
      const s = r.value
      e.call(n, s[0], s[1])
    }
  },
  wj = (n, e) => {
    let t
    const i = []
    for (; (t = n.exec(e)) !== null; ) i.push(t)
    return i
  },
  Cj = Ms('HTMLFormElement'),
  Ej = (n) =>
    n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, i, r) {
      return i.toUpperCase() + r
    }),
  Ib = (
    ({ hasOwnProperty: n }) =>
    (e, t) =>
      n.call(e, t)
  )(Object.prototype),
  Mj = Ms('RegExp'),
  W4 = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n),
      i = {}
    ;(rf(t, (r, s) => {
      let o
      ;(o = e(r, s, n)) !== !1 && (i[s] = o || r)
    }),
      Object.defineProperties(n, i))
  },
  Rj = (n) => {
    W4(n, (e, t) => {
      if (Pr(n) && ['arguments', 'caller', 'callee'].indexOf(t) !== -1) return !1
      const i = n[t]
      if (Pr(i)) {
        if (((e.enumerable = !1), 'writable' in e)) {
          e.writable = !1
          return
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'")
          })
      }
    })
  },
  Ij = (n, e) => {
    const t = {},
      i = (r) => {
        r.forEach((s) => {
          t[s] = !0
        })
      }
    return (Hu(n) ? i(n) : i(String(n).split(e)), t)
  },
  Nj = () => {},
  Pj = (n, e) => (n != null && Number.isFinite((n = +n)) ? n : e)
function Lj(n) {
  return !!(n && Pr(n.append) && n[Symbol.toStringTag] === 'FormData' && n[Symbol.iterator])
}
const Dj = (n) => {
    const e = new Array(10),
      t = (i, r) => {
        if (E0(i)) {
          if (e.indexOf(i) >= 0) return
          if (!('toJSON' in i)) {
            e[r] = i
            const s = Hu(i) ? [] : {}
            return (
              rf(i, (o, a) => {
                const l = t(o, r + 1)
                !xh(l) && (s[a] = l)
              }),
              (e[r] = void 0),
              s
            )
          }
        }
        return i
      }
    return t(n, 0)
  },
  Fj = Ms('AsyncFunction'),
  Oj = (n) => n && (E0(n) || Pr(n)) && Pr(n.then) && Pr(n.catch),
  Q4 = ((n, e) =>
    n
      ? setImmediate
      : e
        ? ((t, i) => (
            Cl.addEventListener(
              'message',
              ({ source: r, data: s }) => {
                r === Cl && s === t && i.length && i.shift()()
              },
              !1
            ),
            (r) => {
              ;(i.push(r), Cl.postMessage(t, '*'))
            }
          ))('axios@'.concat(Math.random()), [])
        : (t) => setTimeout(t))(typeof setImmediate == 'function', Pr(Cl.postMessage)),
  Bj =
    typeof queueMicrotask < 'u'
      ? queueMicrotask.bind(Cl)
      : (typeof process < 'u' && process.nextTick) || Q4
var Re = {
  isArray: Hu,
  isArrayBuffer: V4,
  isBuffer: tj,
  isFormData: uj,
  isArrayBufferView: nj,
  isString: ij,
  isNumber: H4,
  isBoolean: rj,
  isObject: E0,
  isPlainObject: Bp,
  isReadableStream: hj,
  isRequest: fj,
  isResponse: pj,
  isHeaders: mj,
  isUndefined: xh,
  isDate: sj,
  isFile: oj,
  isBlob: aj,
  isRegExp: Mj,
  isFunction: Pr,
  isStream: cj,
  isURLSearchParams: dj,
  isTypedArray: bj,
  isFileList: lj,
  forEach: rf,
  merge: cv,
  extend: yj,
  trim: gj,
  stripBOM: vj,
  inherits: _j,
  toFlatObject: xj,
  kindOf: w0,
  kindOfTest: Ms,
  endsWith: Sj,
  toArray: Aj,
  forEachEntry: Tj,
  matchAll: wj,
  isHTMLForm: Cj,
  hasOwnProperty: Ib,
  hasOwnProp: Ib,
  reduceDescriptors: W4,
  freezeMethods: Rj,
  toObjectSet: Ij,
  toCamelCase: Ej,
  noop: Nj,
  toFiniteNumber: Pj,
  findKey: $4,
  global: Cl,
  isContextDefined: G4,
  isSpecCompliantForm: Lj,
  toJSONObject: Dj,
  isAsyncFn: Fj,
  isThenable: Oj,
  setImmediate: Q4,
  asap: Bj,
}
function Et(n, e, t, i, r) {
  ;(Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = n),
    (this.name = 'AxiosError'),
    e && (this.code = e),
    t && (this.config = t),
    i && (this.request = i),
    r && ((this.response = r), (this.status = r.status ? r.status : null)))
}
Re.inherits(Et, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: Re.toJSONObject(this.config),
      code: this.code,
      status: this.status,
    }
  },
})
const j4 = Et.prototype,
  q4 = {}
;[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL',
].forEach((n) => {
  q4[n] = { value: n }
})
Object.defineProperties(Et, q4)
Object.defineProperty(j4, 'isAxiosError', { value: !0 })
Et.from = (n, e, t, i, r, s) => {
  const o = Object.create(j4)
  return (
    Re.toFlatObject(
      n,
      o,
      function (l) {
        return l !== Error.prototype
      },
      (a) => a !== 'isAxiosError'
    ),
    Et.call(o, n.message, e, t, i, r),
    (o.cause = n),
    (o.name = n.name),
    s && Object.assign(o, s),
    o
  )
}
var Uj = null
function uv(n) {
  return Re.isPlainObject(n) || Re.isArray(n)
}
function X4(n) {
  return Re.endsWith(n, '[]') ? n.slice(0, -2) : n
}
function Nb(n, e, t) {
  return n
    ? n
        .concat(e)
        .map(function (r, s) {
          return ((r = X4(r)), !t && s ? '[' + r + ']' : r)
        })
        .join(t ? '.' : '')
    : e
}
function kj(n) {
  return Re.isArray(n) && !n.some(uv)
}
const zj = Re.toFlatObject(Re, {}, null, function (e) {
  return /^is[A-Z]/.test(e)
})
function M0(n, e, t) {
  if (!Re.isObject(n)) throw new TypeError('target must be an object')
  ;((e = e || new FormData()),
    (t = Re.toFlatObject(t, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (g, y) {
      return !Re.isUndefined(y[g])
    })))
  const i = t.metaTokens,
    r = t.visitor || u,
    s = t.dots,
    o = t.indexes,
    l = (t.Blob || (typeof Blob < 'u' && Blob)) && Re.isSpecCompliantForm(e)
  if (!Re.isFunction(r)) throw new TypeError('visitor must be a function')
  function c(p) {
    if (p === null) return ''
    if (Re.isDate(p)) return p.toISOString()
    if (!l && Re.isBlob(p)) throw new Et('Blob is not supported. Use a Buffer instead.')
    return Re.isArrayBuffer(p) || Re.isTypedArray(p)
      ? l && typeof Blob == 'function'
        ? new Blob([p])
        : Buffer.from(p)
      : p
  }
  function u(p, g, y) {
    let m = p
    if (p && !y && typeof p == 'object') {
      if (Re.endsWith(g, '{}')) ((g = i ? g : g.slice(0, -2)), (p = JSON.stringify(p)))
      else if (
        (Re.isArray(p) && kj(p)) ||
        ((Re.isFileList(p) || Re.endsWith(g, '[]')) && (m = Re.toArray(p)))
      )
        return (
          (g = X4(g)),
          m.forEach(function (x, _) {
            !(Re.isUndefined(x) || x === null) &&
              e.append(o === !0 ? Nb([g], _, s) : o === null ? g : g + '[]', c(x))
          }),
          !1
        )
    }
    return uv(p) ? !0 : (e.append(Nb(y, g, s), c(p)), !1)
  }
  const d = [],
    h = Object.assign(zj, { defaultVisitor: u, convertValue: c, isVisitable: uv })
  function f(p, g) {
    if (!Re.isUndefined(p)) {
      if (d.indexOf(p) !== -1) throw Error('Circular reference detected in ' + g.join('.'))
      ;(d.push(p),
        Re.forEach(p, function (m, v) {
          ;(!(Re.isUndefined(m) || m === null) &&
            r.call(e, m, Re.isString(v) ? v.trim() : v, g, h)) === !0 && f(m, g ? g.concat(v) : [v])
        }),
        d.pop())
    }
  }
  if (!Re.isObject(n)) throw new TypeError('data must be an object')
  return (f(n), e)
}
function Pb(n) {
  const e = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' }
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (i) {
    return e[i]
  })
}
function kx(n, e) {
  ;((this._pairs = []), n && M0(n, this, e))
}
const K4 = kx.prototype
K4.append = function (e, t) {
  this._pairs.push([e, t])
}
K4.toString = function (e) {
  const t = e
    ? function (i) {
        return e.call(this, i, Pb)
      }
    : Pb
  return this._pairs
    .map(function (r) {
      return t(r[0]) + '=' + t(r[1])
    }, '')
    .join('&')
}
function Vj(n) {
  return encodeURIComponent(n)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']')
}
function Y4(n, e, t) {
  if (!e) return n
  const i = (t && t.encode) || Vj
  Re.isFunction(t) && (t = { serialize: t })
  const r = t && t.serialize
  let s
  if (
    (r ? (s = r(e, t)) : (s = Re.isURLSearchParams(e) ? e.toString() : new kx(e, t).toString(i)), s)
  ) {
    const o = n.indexOf('#')
    ;(o !== -1 && (n = n.slice(0, o)), (n += (n.indexOf('?') === -1 ? '?' : '&') + s))
  }
  return n
}
class Lb {
  constructor() {
    this.handlers = []
  }
  use(e, t, i) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: i ? i.synchronous : !1,
        runWhen: i ? i.runWhen : null,
      }),
      this.handlers.length - 1
    )
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(e) {
    Re.forEach(this.handlers, function (i) {
      i !== null && e(i)
    })
  }
}
var Z4 = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
  Hj = typeof URLSearchParams < 'u' ? URLSearchParams : kx,
  $j = typeof FormData < 'u' ? FormData : null,
  Gj = typeof Blob < 'u' ? Blob : null,
  Wj = {
    isBrowser: !0,
    classes: { URLSearchParams: Hj, FormData: $j, Blob: Gj },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data'],
  }
const zx = typeof window < 'u' && typeof document < 'u',
  dv = (typeof navigator == 'object' && navigator) || void 0,
  Qj = zx && (!dv || ['ReactNative', 'NativeScript', 'NS'].indexOf(dv.product) < 0),
  jj =
    typeof WorkerGlobalScope < 'u' &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == 'function',
  qj = (zx && window.location.href) || 'http://localhost'
var Xj = Object.freeze({
    __proto__: null,
    hasBrowserEnv: zx,
    hasStandardBrowserEnv: Qj,
    hasStandardBrowserWebWorkerEnv: jj,
    navigator: dv,
    origin: qj,
  }),
  Di = { ...Xj, ...Wj }
function Kj(n, e) {
  return M0(
    n,
    new Di.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (t, i, r, s) {
          return Di.isNode && Re.isBuffer(t)
            ? (this.append(i, t.toString('base64')), !1)
            : s.defaultVisitor.apply(this, arguments)
        },
      },
      e
    )
  )
}
function Yj(n) {
  return Re.matchAll(/\w+|\[(\w*)]/g, n).map((e) => (e[0] === '[]' ? '' : e[1] || e[0]))
}
function Zj(n) {
  const e = {},
    t = Object.keys(n)
  let i
  const r = t.length
  let s
  for (i = 0; i < r; i++) ((s = t[i]), (e[s] = n[s]))
  return e
}
function J4(n) {
  function e(t, i, r, s) {
    let o = t[s++]
    if (o === '__proto__') return !0
    const a = Number.isFinite(+o),
      l = s >= t.length
    return (
      (o = !o && Re.isArray(r) ? r.length : o),
      l
        ? (Re.hasOwnProp(r, o) ? (r[o] = [r[o], i]) : (r[o] = i), !a)
        : ((!r[o] || !Re.isObject(r[o])) && (r[o] = []),
          e(t, i, r[o], s) && Re.isArray(r[o]) && (r[o] = Zj(r[o])),
          !a)
    )
  }
  if (Re.isFormData(n) && Re.isFunction(n.entries)) {
    const t = {}
    return (
      Re.forEachEntry(n, (i, r) => {
        e(Yj(i), r, t, 0)
      }),
      t
    )
  }
  return null
}
function Jj(n, e, t) {
  if (Re.isString(n))
    try {
      return ((e || JSON.parse)(n), Re.trim(n))
    } catch (i) {
      if (i.name !== 'SyntaxError') throw i
    }
  return (t || JSON.stringify)(n)
}
const sf = {
  transitional: Z4,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [
    function (e, t) {
      const i = t.getContentType() || '',
        r = i.indexOf('application/json') > -1,
        s = Re.isObject(e)
      if ((s && Re.isHTMLForm(e) && (e = new FormData(e)), Re.isFormData(e)))
        return r ? JSON.stringify(J4(e)) : e
      if (
        Re.isArrayBuffer(e) ||
        Re.isBuffer(e) ||
        Re.isStream(e) ||
        Re.isFile(e) ||
        Re.isBlob(e) ||
        Re.isReadableStream(e)
      )
        return e
      if (Re.isArrayBufferView(e)) return e.buffer
      if (Re.isURLSearchParams(e))
        return (
          t.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1),
          e.toString()
        )
      let a
      if (s) {
        if (i.indexOf('application/x-www-form-urlencoded') > -1)
          return Kj(e, this.formSerializer).toString()
        if ((a = Re.isFileList(e)) || i.indexOf('multipart/form-data') > -1) {
          const l = this.env && this.env.FormData
          return M0(a ? { 'files[]': e } : e, l && new l(), this.formSerializer)
        }
      }
      return s || r ? (t.setContentType('application/json', !1), Jj(e)) : e
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || sf.transitional,
        i = t && t.forcedJSONParsing,
        r = this.responseType === 'json'
      if (Re.isResponse(e) || Re.isReadableStream(e)) return e
      if (e && Re.isString(e) && ((i && !this.responseType) || r)) {
        const o = !(t && t.silentJSONParsing) && r
        try {
          return JSON.parse(e)
        } catch (a) {
          if (o)
            throw a.name === 'SyntaxError'
              ? Et.from(a, Et.ERR_BAD_RESPONSE, this, null, this.response)
              : a
        }
      }
      return e
    },
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: Di.classes.FormData, Blob: Di.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300
  },
  headers: { common: { Accept: 'application/json, text/plain, */*', 'Content-Type': void 0 } },
}
Re.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (n) => {
  sf.headers[n] = {}
})
const eq = Re.toObjectSet([
  'age',
  'authorization',
  'content-length',
  'content-type',
  'etag',
  'expires',
  'from',
  'host',
  'if-modified-since',
  'if-unmodified-since',
  'last-modified',
  'location',
  'max-forwards',
  'proxy-authorization',
  'referer',
  'retry-after',
  'user-agent',
])
var tq = (n) => {
  const e = {}
  let t, i, r
  return (
    n &&
      n.split('\n').forEach(function (o) {
        ;((r = o.indexOf(':')),
          (t = o.substring(0, r).trim().toLowerCase()),
          (i = o.substring(r + 1).trim()),
          !(!t || (e[t] && eq[t])) &&
            (t === 'set-cookie'
              ? e[t]
                ? e[t].push(i)
                : (e[t] = [i])
              : (e[t] = e[t] ? e[t] + ', ' + i : i)))
      }),
    e
  )
}
const Db = Symbol('internals')
function vd(n) {
  return n && String(n).trim().toLowerCase()
}
function Up(n) {
  return n === !1 || n == null ? n : Re.isArray(n) ? n.map(Up) : String(n)
}
function nq(n) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
  let i
  for (; (i = t.exec(n)); ) e[i[1]] = i[2]
  return e
}
const iq = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim())
function p1(n, e, t, i, r) {
  if (Re.isFunction(i)) return i.call(this, e, t)
  if ((r && (e = t), !!Re.isString(e))) {
    if (Re.isString(i)) return e.indexOf(i) !== -1
    if (Re.isRegExp(i)) return i.test(e)
  }
}
function rq(n) {
  return n
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i)
}
function sq(n, e) {
  const t = Re.toCamelCase(' ' + e)
  ;['get', 'set', 'has'].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function (r, s, o) {
        return this[i].call(this, e, r, s, o)
      },
      configurable: !0,
    })
  })
}
let lr = class {
  constructor(e) {
    e && this.set(e)
  }
  set(e, t, i) {
    const r = this
    function s(a, l, c) {
      const u = vd(l)
      if (!u) throw new Error('header name must be a non-empty string')
      const d = Re.findKey(r, u)
      ;(!d || r[d] === void 0 || c === !0 || (c === void 0 && r[d] !== !1)) && (r[d || l] = Up(a))
    }
    const o = (a, l) => Re.forEach(a, (c, u) => s(c, u, l))
    if (Re.isPlainObject(e) || e instanceof this.constructor) o(e, t)
    else if (Re.isString(e) && (e = e.trim()) && !iq(e)) o(tq(e), t)
    else if (Re.isHeaders(e)) for (const [a, l] of e.entries()) s(l, a, i)
    else e != null && s(t, e, i)
    return this
  }
  get(e, t) {
    if (((e = vd(e)), e)) {
      const i = Re.findKey(this, e)
      if (i) {
        const r = this[i]
        if (!t) return r
        if (t === !0) return nq(r)
        if (Re.isFunction(t)) return t.call(this, r, i)
        if (Re.isRegExp(t)) return t.exec(r)
        throw new TypeError('parser must be boolean|regexp|function')
      }
    }
  }
  has(e, t) {
    if (((e = vd(e)), e)) {
      const i = Re.findKey(this, e)
      return !!(i && this[i] !== void 0 && (!t || p1(this, this[i], i, t)))
    }
    return !1
  }
  delete(e, t) {
    const i = this
    let r = !1
    function s(o) {
      if (((o = vd(o)), o)) {
        const a = Re.findKey(i, o)
        a && (!t || p1(i, i[a], a, t)) && (delete i[a], (r = !0))
      }
    }
    return (Re.isArray(e) ? e.forEach(s) : s(e), r)
  }
  clear(e) {
    const t = Object.keys(this)
    let i = t.length,
      r = !1
    for (; i--; ) {
      const s = t[i]
      ;(!e || p1(this, this[s], s, e, !0)) && (delete this[s], (r = !0))
    }
    return r
  }
  normalize(e) {
    const t = this,
      i = {}
    return (
      Re.forEach(this, (r, s) => {
        const o = Re.findKey(i, s)
        if (o) {
          ;((t[o] = Up(r)), delete t[s])
          return
        }
        const a = e ? rq(s) : String(s).trim()
        ;(a !== s && delete t[s], (t[a] = Up(r)), (i[a] = !0))
      }),
      this
    )
  }
  concat(...e) {
    return this.constructor.concat(this, ...e)
  }
  toJSON(e) {
    const t = Object.create(null)
    return (
      Re.forEach(this, (i, r) => {
        i != null && i !== !1 && (t[r] = e && Re.isArray(i) ? i.join(', ') : i)
      }),
      t
    )
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON())
      .map(([e, t]) => e + ': ' + t)
      .join('\n')
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders'
  }
  static from(e) {
    return e instanceof this ? e : new this(e)
  }
  static concat(e, ...t) {
    const i = new this(e)
    return (t.forEach((r) => i.set(r)), i)
  }
  static accessor(e) {
    const i = (this[Db] = this[Db] = { accessors: {} }).accessors,
      r = this.prototype
    function s(o) {
      const a = vd(o)
      i[a] || (sq(r, o), (i[a] = !0))
    }
    return (Re.isArray(e) ? e.forEach(s) : s(e), this)
  }
}
lr.accessor([
  'Content-Type',
  'Content-Length',
  'Accept',
  'Accept-Encoding',
  'User-Agent',
  'Authorization',
])
Re.reduceDescriptors(lr.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1)
  return {
    get: () => n,
    set(i) {
      this[t] = i
    },
  }
})
Re.freezeMethods(lr)
function m1(n, e) {
  const t = this || sf,
    i = e || t,
    r = lr.from(i.headers)
  let s = i.data
  return (
    Re.forEach(n, function (a) {
      s = a.call(t, s, r.normalize(), e ? e.status : void 0)
    }),
    r.normalize(),
    s
  )
}
function e6(n) {
  return !!(n && n.__CANCEL__)
}
function $u(n, e, t) {
  ;(Et.call(this, n == null ? 'canceled' : n, Et.ERR_CANCELED, e, t), (this.name = 'CanceledError'))
}
Re.inherits($u, Et, { __CANCEL__: !0 })
function t6(n, e, t) {
  const i = t.config.validateStatus
  !t.status || !i || i(t.status)
    ? n(t)
    : e(
        new Et(
          'Request failed with status code ' + t.status,
          [Et.ERR_BAD_REQUEST, Et.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
          t.config,
          t.request,
          t
        )
      )
}
function oq(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n)
  return (e && e[1]) || ''
}
function aq(n, e) {
  n = n || 10
  const t = new Array(n),
    i = new Array(n)
  let r = 0,
    s = 0,
    o
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const c = Date.now(),
        u = i[s]
      ;(o || (o = c), (t[r] = l), (i[r] = c))
      let d = s,
        h = 0
      for (; d !== r; ) ((h += t[d++]), (d = d % n))
      if (((r = (r + 1) % n), r === s && (s = (s + 1) % n), c - o < e)) return
      const f = u && c - u
      return f ? Math.round((h * 1e3) / f) : void 0
    }
  )
}
function lq(n, e) {
  let t = 0,
    i = 1e3 / e,
    r,
    s
  const o = (c, u = Date.now()) => {
    ;((t = u), (r = null), s && (clearTimeout(s), (s = null)), n.apply(null, c))
  }
  return [
    (...c) => {
      const u = Date.now(),
        d = u - t
      d >= i
        ? o(c, u)
        : ((r = c),
          s ||
            (s = setTimeout(() => {
              ;((s = null), o(r))
            }, i - d)))
    },
    () => r && o(r),
  ]
}
const Fm = (n, e, t = 3) => {
    let i = 0
    const r = aq(50, 250)
    return lq((s) => {
      const o = s.loaded,
        a = s.lengthComputable ? s.total : void 0,
        l = o - i,
        c = r(l),
        u = o <= a
      i = o
      const d = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: l,
        rate: c || void 0,
        estimated: c && a && u ? (a - o) / c : void 0,
        event: s,
        lengthComputable: a != null,
        [e ? 'download' : 'upload']: !0,
      }
      n(d)
    }, t)
  },
  Fb = (n, e) => {
    const t = n != null
    return [(i) => e[0]({ lengthComputable: t, total: n, loaded: i }), e[1]]
  },
  Ob =
    (n) =>
    (...e) =>
      Re.asap(() => n(...e))
var cq = Di.hasStandardBrowserEnv
    ? ((n, e) => (t) => (
        (t = new URL(t, Di.origin)),
        n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)
      ))(new URL(Di.origin), Di.navigator && /(msie|trident)/i.test(Di.navigator.userAgent))
    : () => !0,
  uq = Di.hasStandardBrowserEnv
    ? {
        write(n, e, t, i, r, s) {
          const o = [n + '=' + encodeURIComponent(e)]
          ;(Re.isNumber(t) && o.push('expires=' + new Date(t).toGMTString()),
            Re.isString(i) && o.push('path=' + i),
            Re.isString(r) && o.push('domain=' + r),
            s === !0 && o.push('secure'),
            (document.cookie = o.join('; ')))
        },
        read(n) {
          const e = document.cookie.match(new RegExp('(^|;\\s*)(' + n + ')=([^;]*)'))
          return e ? decodeURIComponent(e[3]) : null
        },
        remove(n) {
          this.write(n, '', Date.now() - 864e5)
        },
      }
    : {
        write() {},
        read() {
          return null
        },
        remove() {},
      }
function dq(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n)
}
function hq(n, e) {
  return e ? n.replace(/\/?\/$/, '') + '/' + e.replace(/^\/+/, '') : n
}
function n6(n, e, t) {
  let i = !dq(e)
  return n && (i || t == !1) ? hq(n, e) : e
}
const Bb = (n) => (n instanceof lr ? { ...n } : n)
function $l(n, e) {
  e = e || {}
  const t = {}
  function i(c, u, d, h) {
    return Re.isPlainObject(c) && Re.isPlainObject(u)
      ? Re.merge.call({ caseless: h }, c, u)
      : Re.isPlainObject(u)
        ? Re.merge({}, u)
        : Re.isArray(u)
          ? u.slice()
          : u
  }
  function r(c, u, d, h) {
    if (Re.isUndefined(u)) {
      if (!Re.isUndefined(c)) return i(void 0, c, d, h)
    } else return i(c, u, d, h)
  }
  function s(c, u) {
    if (!Re.isUndefined(u)) return i(void 0, u)
  }
  function o(c, u) {
    if (Re.isUndefined(u)) {
      if (!Re.isUndefined(c)) return i(void 0, c)
    } else return i(void 0, u)
  }
  function a(c, u, d) {
    if (d in e) return i(c, u)
    if (d in n) return i(void 0, c)
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u, d) => r(Bb(c), Bb(u), d, !0),
  }
  return (
    Re.forEach(Object.keys(Object.assign({}, n, e)), function (u) {
      const d = l[u] || r,
        h = d(n[u], e[u], u)
      ;(Re.isUndefined(h) && d !== a) || (t[u] = h)
    }),
    t
  )
}
var i6 = (n) => {
  const e = $l({}, n)
  let { data: t, withXSRFToken: i, xsrfHeaderName: r, xsrfCookieName: s, headers: o, auth: a } = e
  ;((e.headers = o = lr.from(o)),
    (e.url = Y4(n6(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer)),
    a &&
      o.set(
        'Authorization',
        'Basic ' +
          btoa(
            (a.username || '') + ':' + (a.password ? unescape(encodeURIComponent(a.password)) : '')
          )
      ))
  let l
  if (Re.isFormData(t)) {
    if (Di.hasStandardBrowserEnv || Di.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0)
    else if ((l = o.getContentType()) !== !1) {
      const [c, ...u] = l
        ? l
            .split(';')
            .map((d) => d.trim())
            .filter(Boolean)
        : []
      o.setContentType([c || 'multipart/form-data', ...u].join('; '))
    }
  }
  if (
    Di.hasStandardBrowserEnv &&
    (i && Re.isFunction(i) && (i = i(e)), i || (i !== !1 && cq(e.url)))
  ) {
    const c = r && s && uq.read(s)
    c && o.set(r, c)
  }
  return e
}
const fq = typeof XMLHttpRequest < 'u'
var pq =
  fq &&
  function (n) {
    return new Promise(function (t, i) {
      const r = i6(n)
      let s = r.data
      const o = lr.from(r.headers).normalize()
      let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = r,
        u,
        d,
        h,
        f,
        p
      function g() {
        ;(f && f(),
          p && p(),
          r.cancelToken && r.cancelToken.unsubscribe(u),
          r.signal && r.signal.removeEventListener('abort', u))
      }
      let y = new XMLHttpRequest()
      ;(y.open(r.method.toUpperCase(), r.url, !0), (y.timeout = r.timeout))
      function m() {
        if (!y) return
        const x = lr.from('getAllResponseHeaders' in y && y.getAllResponseHeaders()),
          S = {
            data: !a || a === 'text' || a === 'json' ? y.responseText : y.response,
            status: y.status,
            statusText: y.statusText,
            headers: x,
            config: n,
            request: y,
          }
        ;(t6(
          function (A) {
            ;(t(A), g())
          },
          function (A) {
            ;(i(A), g())
          },
          S
        ),
          (y = null))
      }
      ;('onloadend' in y
        ? (y.onloadend = m)
        : (y.onreadystatechange = function () {
            !y ||
              y.readyState !== 4 ||
              (y.status === 0 && !(y.responseURL && y.responseURL.indexOf('file:') === 0)) ||
              setTimeout(m)
          }),
        (y.onabort = function () {
          y && (i(new Et('Request aborted', Et.ECONNABORTED, n, y)), (y = null))
        }),
        (y.onerror = function () {
          ;(i(new Et('Network Error', Et.ERR_NETWORK, n, y)), (y = null))
        }),
        (y.ontimeout = function () {
          let _ = r.timeout ? 'timeout of ' + r.timeout + 'ms exceeded' : 'timeout exceeded'
          const S = r.transitional || Z4
          ;(r.timeoutErrorMessage && (_ = r.timeoutErrorMessage),
            i(new Et(_, S.clarifyTimeoutError ? Et.ETIMEDOUT : Et.ECONNABORTED, n, y)),
            (y = null))
        }),
        s === void 0 && o.setContentType(null),
        'setRequestHeader' in y &&
          Re.forEach(o.toJSON(), function (_, S) {
            y.setRequestHeader(S, _)
          }),
        Re.isUndefined(r.withCredentials) || (y.withCredentials = !!r.withCredentials),
        a && a !== 'json' && (y.responseType = r.responseType),
        c && (([h, p] = Fm(c, !0)), y.addEventListener('progress', h)),
        l &&
          y.upload &&
          (([d, f] = Fm(l)),
          y.upload.addEventListener('progress', d),
          y.upload.addEventListener('loadend', f)),
        (r.cancelToken || r.signal) &&
          ((u = (x) => {
            y && (i(!x || x.type ? new $u(null, n, y) : x), y.abort(), (y = null))
          }),
          r.cancelToken && r.cancelToken.subscribe(u),
          r.signal && (r.signal.aborted ? u() : r.signal.addEventListener('abort', u))))
      const v = oq(r.url)
      if (v && Di.protocols.indexOf(v) === -1) {
        i(new Et('Unsupported protocol ' + v + ':', Et.ERR_BAD_REQUEST, n))
        return
      }
      y.send(s || null)
    })
  }
const mq = (n, e) => {
    const { length: t } = (n = n ? n.filter(Boolean) : [])
    if (e || t) {
      let i = new AbortController(),
        r
      const s = function (c) {
        if (!r) {
          ;((r = !0), a())
          const u = c instanceof Error ? c : this.reason
          i.abort(u instanceof Et ? u : new $u(u instanceof Error ? u.message : u))
        }
      }
      let o =
        e &&
        setTimeout(() => {
          ;((o = null), s(new Et('timeout '.concat(e, ' of ms exceeded'), Et.ETIMEDOUT)))
        }, e)
      const a = () => {
        n &&
          (o && clearTimeout(o),
          (o = null),
          n.forEach((c) => {
            c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener('abort', s)
          }),
          (n = null))
      }
      n.forEach((c) => c.addEventListener('abort', s))
      const { signal: l } = i
      return ((l.unsubscribe = () => Re.asap(a)), l)
    }
  },
  gq = function* (n, e) {
    let t = n.byteLength
    if (t < e) {
      yield n
      return
    }
    let i = 0,
      r
    for (; i < t; ) ((r = i + e), yield n.slice(i, r), (i = r))
  },
  yq = async function* (n, e) {
    for await (const t of vq(n)) yield* gq(t, e)
  },
  vq = async function* (n) {
    if (n[Symbol.asyncIterator]) {
      yield* n
      return
    }
    const e = n.getReader()
    try {
      for (;;) {
        const { done: t, value: i } = await e.read()
        if (t) break
        yield i
      }
    } finally {
      await e.cancel()
    }
  },
  Ub = (n, e, t, i) => {
    const r = yq(n, e)
    let s = 0,
      o,
      a = (l) => {
        o || ((o = !0), i && i(l))
      }
    return new ReadableStream(
      {
        async pull(l) {
          try {
            const { done: c, value: u } = await r.next()
            if (c) {
              ;(a(), l.close())
              return
            }
            let d = u.byteLength
            if (t) {
              let h = (s += d)
              t(h)
            }
            l.enqueue(new Uint8Array(u))
          } catch (c) {
            throw (a(c), c)
          }
        },
        cancel(l) {
          return (a(l), r.return())
        },
      },
      { highWaterMark: 2 }
    )
  },
  R0 = typeof fetch == 'function' && typeof Request == 'function' && typeof Response == 'function',
  r6 = R0 && typeof ReadableStream == 'function',
  _q =
    R0 &&
    (typeof TextEncoder == 'function'
      ? (
          (n) => (e) =>
            n.encode(e)
        )(new TextEncoder())
      : async (n) => new Uint8Array(await new Response(n).arrayBuffer())),
  s6 = (n, ...e) => {
    try {
      return !!n(...e)
    } catch (t) {
      return !1
    }
  },
  xq =
    r6 &&
    s6(() => {
      let n = !1
      const e = new Request(Di.origin, {
        body: new ReadableStream(),
        method: 'POST',
        get duplex() {
          return ((n = !0), 'half')
        },
      }).headers.has('Content-Type')
      return n && !e
    }),
  kb = 64 * 1024,
  hv = r6 && s6(() => Re.isReadableStream(new Response('').body)),
  Om = { stream: hv && ((n) => n.body) }
R0 &&
  ((n) => {
    ;['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((e) => {
      !Om[e] &&
        (Om[e] = Re.isFunction(n[e])
          ? (t) => t[e]()
          : (t, i) => {
              throw new Et("Response type '".concat(e, "' is not supported"), Et.ERR_NOT_SUPPORT, i)
            })
    })
  })(new Response())
const Sq = async (n) => {
    if (n == null) return 0
    if (Re.isBlob(n)) return n.size
    if (Re.isSpecCompliantForm(n))
      return (await new Request(Di.origin, { method: 'POST', body: n }).arrayBuffer()).byteLength
    if (Re.isArrayBufferView(n) || Re.isArrayBuffer(n)) return n.byteLength
    if ((Re.isURLSearchParams(n) && (n = n + ''), Re.isString(n))) return (await _q(n)).byteLength
  },
  Aq = async (n, e) => {
    const t = Re.toFiniteNumber(n.getContentLength())
    return t == null ? Sq(e) : t
  }
var bq =
  R0 &&
  (async (n) => {
    let {
      url: e,
      method: t,
      data: i,
      signal: r,
      cancelToken: s,
      timeout: o,
      onDownloadProgress: a,
      onUploadProgress: l,
      responseType: c,
      headers: u,
      withCredentials: d = 'same-origin',
      fetchOptions: h,
    } = i6(n)
    c = c ? (c + '').toLowerCase() : 'text'
    let f = mq([r, s && s.toAbortSignal()], o),
      p
    const g =
      f &&
      f.unsubscribe &&
      (() => {
        f.unsubscribe()
      })
    let y
    try {
      if (l && xq && t !== 'get' && t !== 'head' && (y = await Aq(u, i)) !== 0) {
        let S = new Request(e, { method: 'POST', body: i, duplex: 'half' }),
          C
        if (
          (Re.isFormData(i) && (C = S.headers.get('content-type')) && u.setContentType(C), S.body)
        ) {
          const [A, R] = Fb(y, Fm(Ob(l)))
          i = Ub(S.body, kb, A, R)
        }
      }
      Re.isString(d) || (d = d ? 'include' : 'omit')
      const m = 'credentials' in Request.prototype
      p = new Request(e, {
        ...h,
        signal: f,
        method: t.toUpperCase(),
        headers: u.normalize().toJSON(),
        body: i,
        duplex: 'half',
        credentials: m ? d : void 0,
      })
      let v = await fetch(p)
      const x = hv && (c === 'stream' || c === 'response')
      if (hv && (a || (x && g))) {
        const S = {}
        ;['status', 'statusText', 'headers'].forEach((w) => {
          S[w] = v[w]
        })
        const C = Re.toFiniteNumber(v.headers.get('content-length')),
          [A, R] = (a && Fb(C, Fm(Ob(a), !0))) || []
        v = new Response(
          Ub(v.body, kb, A, () => {
            ;(R && R(), g && g())
          }),
          S
        )
      }
      c = c || 'text'
      let _ = await Om[Re.findKey(Om, c) || 'text'](v, n)
      return (
        !x && g && g(),
        await new Promise((S, C) => {
          t6(S, C, {
            data: _,
            headers: lr.from(v.headers),
            status: v.status,
            statusText: v.statusText,
            config: n,
            request: p,
          })
        })
      )
    } catch (m) {
      throw (
        g && g(),
        m && m.name === 'TypeError' && /fetch/i.test(m.message)
          ? Object.assign(new Et('Network Error', Et.ERR_NETWORK, n, p), { cause: m.cause || m })
          : Et.from(m, m && m.code, n, p)
      )
    }
  })
const fv = { http: Uj, xhr: pq, fetch: bq }
Re.forEach(fv, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, 'name', { value: e })
    } catch (t) {}
    Object.defineProperty(n, 'adapterName', { value: e })
  }
})
const zb = (n) => '- '.concat(n),
  Tq = (n) => Re.isFunction(n) || n === null || n === !1
var o6 = {
  getAdapter: (n) => {
    n = Re.isArray(n) ? n : [n]
    const { length: e } = n
    let t, i
    const r = {}
    for (let s = 0; s < e; s++) {
      t = n[s]
      let o
      if (((i = t), !Tq(t) && ((i = fv[(o = String(t)).toLowerCase()]), i === void 0)))
        throw new Et("Unknown adapter '".concat(o, "'"))
      if (i) break
      r[o || '#' + s] = i
    }
    if (!i) {
      const s = Object.entries(r).map(
        ([a, l]) =>
          'adapter '.concat(a, ' ') +
          (l === !1 ? 'is not supported by the environment' : 'is not available in the build')
      )
      let o = e
        ? s.length > 1
          ? 'since :\n' + s.map(zb).join('\n')
          : ' ' + zb(s[0])
        : 'as no adapter specified'
      throw new Et('There is no suitable adapter to dispatch the request ' + o, 'ERR_NOT_SUPPORT')
    }
    return i
  },
  adapters: fv,
}
function g1(n) {
  if ((n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted))
    throw new $u(null, n)
}
function Vb(n) {
  return (
    g1(n),
    (n.headers = lr.from(n.headers)),
    (n.data = m1.call(n, n.transformRequest)),
    ['post', 'put', 'patch'].indexOf(n.method) !== -1 &&
      n.headers.setContentType('application/x-www-form-urlencoded', !1),
    o6
      .getAdapter(n.adapter || sf.adapter)(n)
      .then(
        function (i) {
          return (
            g1(n),
            (i.data = m1.call(n, n.transformResponse, i)),
            (i.headers = lr.from(i.headers)),
            i
          )
        },
        function (i) {
          return (
            e6(i) ||
              (g1(n),
              i &&
                i.response &&
                ((i.response.data = m1.call(n, n.transformResponse, i.response)),
                (i.response.headers = lr.from(i.response.headers)))),
            Promise.reject(i)
          )
        }
      )
  )
}
const a6 = '1.8.4',
  I0 = {}
;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((n, e) => {
  I0[n] = function (i) {
    return typeof i === n || 'a' + (e < 1 ? 'n ' : ' ') + n
  }
})
const Hb = {}
I0.transitional = function (e, t, i) {
  function r(s, o) {
    return '[Axios v' + a6 + "] Transitional option '" + s + "'" + o + (i ? '. ' + i : '')
  }
  return (s, o, a) => {
    if (e === !1) throw new Et(r(o, ' has been removed' + (t ? ' in ' + t : '')), Et.ERR_DEPRECATED)
    return (
      t &&
        !Hb[o] &&
        ((Hb[o] = !0),
        console.warn(
          r(o, ' has been deprecated since v' + t + ' and will be removed in the near future')
        )),
      e ? e(s, o, a) : !0
    )
  }
}
I0.spelling = function (e) {
  return (t, i) => (console.warn(''.concat(i, ' is likely a misspelling of ').concat(e)), !0)
}
function wq(n, e, t) {
  if (typeof n != 'object') throw new Et('options must be an object', Et.ERR_BAD_OPTION_VALUE)
  const i = Object.keys(n)
  let r = i.length
  for (; r-- > 0; ) {
    const s = i[r],
      o = e[s]
    if (o) {
      const a = n[s],
        l = a === void 0 || o(a, s, n)
      if (l !== !0) throw new Et('option ' + s + ' must be ' + l, Et.ERR_BAD_OPTION_VALUE)
      continue
    }
    if (t !== !0) throw new Et('Unknown option ' + s, Et.ERR_BAD_OPTION)
  }
}
var kp = { assertOptions: wq, validators: I0 }
const Ns = kp.validators
let Fl = class {
  constructor(e) {
    ;((this.defaults = e), (this.interceptors = { request: new Lb(), response: new Lb() }))
  }
  async request(e, t) {
    try {
      return await this._request(e, t)
    } catch (i) {
      if (i instanceof Error) {
        let r = {}
        Error.captureStackTrace ? Error.captureStackTrace(r) : (r = new Error())
        const s = r.stack ? r.stack.replace(/^.+\n/, '') : ''
        try {
          i.stack
            ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, '')) && (i.stack += '\n' + s)
            : (i.stack = s)
        } catch (o) {}
      }
      throw i
    }
  }
  _request(e, t) {
    ;(typeof e == 'string' ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = $l(this.defaults, t)))
    const { transitional: i, paramsSerializer: r, headers: s } = t
    ;(i !== void 0 &&
      kp.assertOptions(
        i,
        {
          silentJSONParsing: Ns.transitional(Ns.boolean),
          forcedJSONParsing: Ns.transitional(Ns.boolean),
          clarifyTimeoutError: Ns.transitional(Ns.boolean),
        },
        !1
      ),
      r != null &&
        (Re.isFunction(r)
          ? (t.paramsSerializer = { serialize: r })
          : kp.assertOptions(r, { encode: Ns.function, serialize: Ns.function }, !0)),
      t.allowAbsoluteUrls !== void 0 ||
        (this.defaults.allowAbsoluteUrls !== void 0
          ? (t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
          : (t.allowAbsoluteUrls = !0)),
      kp.assertOptions(
        t,
        { baseUrl: Ns.spelling('baseURL'), withXsrfToken: Ns.spelling('withXSRFToken') },
        !0
      ),
      (t.method = (t.method || this.defaults.method || 'get').toLowerCase()))
    let o = s && Re.merge(s.common, s[t.method])
    ;(s &&
      Re.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (p) => {
        delete s[p]
      }),
      (t.headers = lr.concat(o, s)))
    const a = []
    let l = !0
    this.interceptors.request.forEach(function (g) {
      ;(typeof g.runWhen == 'function' && g.runWhen(t) === !1) ||
        ((l = l && g.synchronous), a.unshift(g.fulfilled, g.rejected))
    })
    const c = []
    this.interceptors.response.forEach(function (g) {
      c.push(g.fulfilled, g.rejected)
    })
    let u,
      d = 0,
      h
    if (!l) {
      const p = [Vb.bind(this), void 0]
      for (p.unshift.apply(p, a), p.push.apply(p, c), h = p.length, u = Promise.resolve(t); d < h; )
        u = u.then(p[d++], p[d++])
      return u
    }
    h = a.length
    let f = t
    for (d = 0; d < h; ) {
      const p = a[d++],
        g = a[d++]
      try {
        f = p(f)
      } catch (y) {
        g.call(this, y)
        break
      }
    }
    try {
      u = Vb.call(this, f)
    } catch (p) {
      return Promise.reject(p)
    }
    for (d = 0, h = c.length; d < h; ) u = u.then(c[d++], c[d++])
    return u
  }
  getUri(e) {
    e = $l(this.defaults, e)
    const t = n6(e.baseURL, e.url, e.allowAbsoluteUrls)
    return Y4(t, e.params, e.paramsSerializer)
  }
}
Re.forEach(['delete', 'get', 'head', 'options'], function (e) {
  Fl.prototype[e] = function (t, i) {
    return this.request($l(i || {}, { method: e, url: t, data: (i || {}).data }))
  }
})
Re.forEach(['post', 'put', 'patch'], function (e) {
  function t(i) {
    return function (s, o, a) {
      return this.request(
        $l(a || {}, {
          method: e,
          headers: i ? { 'Content-Type': 'multipart/form-data' } : {},
          url: s,
          data: o,
        })
      )
    }
  }
  ;((Fl.prototype[e] = t()), (Fl.prototype[e + 'Form'] = t(!0)))
})
let Cq = class l6 {
  constructor(e) {
    if (typeof e != 'function') throw new TypeError('executor must be a function.')
    let t
    this.promise = new Promise(function (s) {
      t = s
    })
    const i = this
    ;(this.promise.then((r) => {
      if (!i._listeners) return
      let s = i._listeners.length
      for (; s-- > 0; ) i._listeners[s](r)
      i._listeners = null
    }),
      (this.promise.then = (r) => {
        let s
        const o = new Promise((a) => {
          ;(i.subscribe(a), (s = a))
        }).then(r)
        return (
          (o.cancel = function () {
            i.unsubscribe(s)
          }),
          o
        )
      }),
      e(function (s, o, a) {
        i.reason || ((i.reason = new $u(s, o, a)), t(i.reason))
      }))
  }
  throwIfRequested() {
    if (this.reason) throw this.reason
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason)
      return
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e])
  }
  unsubscribe(e) {
    if (!this._listeners) return
    const t = this._listeners.indexOf(e)
    t !== -1 && this._listeners.splice(t, 1)
  }
  toAbortSignal() {
    const e = new AbortController(),
      t = (i) => {
        e.abort(i)
      }
    return (this.subscribe(t), (e.signal.unsubscribe = () => this.unsubscribe(t)), e.signal)
  }
  static source() {
    let e
    return {
      token: new l6(function (r) {
        e = r
      }),
      cancel: e,
    }
  }
}
function Eq(n) {
  return function (t) {
    return n.apply(null, t)
  }
}
function Mq(n) {
  return Re.isObject(n) && n.isAxiosError === !0
}
const pv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
}
Object.entries(pv).forEach(([n, e]) => {
  pv[e] = n
})
function c6(n) {
  const e = new Fl(n),
    t = z4(Fl.prototype.request, e)
  return (
    Re.extend(t, Fl.prototype, e, { allOwnKeys: !0 }),
    Re.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (r) {
      return c6($l(n, r))
    }),
    t
  )
}
const Bn = c6(sf)
Bn.Axios = Fl
Bn.CanceledError = $u
Bn.CancelToken = Cq
Bn.isCancel = e6
Bn.VERSION = a6
Bn.toFormData = M0
Bn.AxiosError = Et
Bn.Cancel = Bn.CanceledError
Bn.all = function (e) {
  return Promise.all(e)
}
Bn.spread = Eq
Bn.isAxiosError = Mq
Bn.mergeConfig = $l
Bn.AxiosHeaders = lr
Bn.formToJSON = (n) => J4(Re.isHTMLForm(n) ? new FormData(n) : n)
Bn.getAdapter = o6.getAdapter
Bn.HttpStatusCode = pv
Bn.default = Bn
const {
  Axios: Are,
  AxiosError: bre,
  CanceledError: Tre,
  isCancel: wre,
  CancelToken: Cre,
  VERSION: Ere,
  all: Mre,
  Cancel: Rre,
  isAxiosError: Ire,
  spread: Nre,
  toFormData: Pre,
  AxiosHeaders: Lre,
  HttpStatusCode: Dre,
  formToJSON: Fre,
  getAdapter: Ore,
  mergeConfig: Bre,
} = Bn
var Bc =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {}
function u6(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n
}
function lp(n) {
  throw new Error(
    'Could not dynamically require "' +
      n +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  )
}
var y1 = { exports: {} },
  $b
function Rq() {
  return (
    $b ||
      (($b = 1),
      (function (n, e) {
        ;(function (t) {
          n.exports = t()
        })(function () {
          return (function t(i, r, s) {
            function o(c, u) {
              if (!r[c]) {
                if (!i[c]) {
                  var d = typeof lp == 'function' && lp
                  if (!u && d) return d(c, !0)
                  if (a) return a(c, !0)
                  var h = new Error("Cannot find module '" + c + "'")
                  throw ((h.code = 'MODULE_NOT_FOUND'), h)
                }
                var f = (r[c] = { exports: {} })
                i[c][0].call(
                  f.exports,
                  function (p) {
                    var g = i[c][1][p]
                    return o(g || p)
                  },
                  f,
                  f.exports,
                  t,
                  i,
                  r,
                  s
                )
              }
              return r[c].exports
            }
            for (var a = typeof lp == 'function' && lp, l = 0; l < s.length; l++) o(s[l])
            return o
          })(
            {
              1: [
                function (t, i, r) {
                  var s = t('./utils'),
                    o = t('./support'),
                    a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                  ;((r.encode = function (l) {
                    for (
                      var c,
                        u,
                        d,
                        h,
                        f,
                        p,
                        g,
                        y = [],
                        m = 0,
                        v = l.length,
                        x = v,
                        _ = s.getTypeOf(l) !== 'string';
                      m < l.length;

                    )
                      ((x = v - m),
                        (d = _
                          ? ((c = l[m++]), (u = m < v ? l[m++] : 0), m < v ? l[m++] : 0)
                          : ((c = l.charCodeAt(m++)),
                            (u = m < v ? l.charCodeAt(m++) : 0),
                            m < v ? l.charCodeAt(m++) : 0)),
                        (h = c >> 2),
                        (f = ((3 & c) << 4) | (u >> 4)),
                        (p = 1 < x ? ((15 & u) << 2) | (d >> 6) : 64),
                        (g = 2 < x ? 63 & d : 64),
                        y.push(a.charAt(h) + a.charAt(f) + a.charAt(p) + a.charAt(g)))
                    return y.join('')
                  }),
                    (r.decode = function (l) {
                      var c,
                        u,
                        d,
                        h,
                        f,
                        p,
                        g = 0,
                        y = 0,
                        m = 'data:'
                      if (l.substr(0, m.length) === m)
                        throw new Error('Invalid base64 input, it looks like a data url.')
                      var v,
                        x = (3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, '')).length) / 4
                      if (
                        (l.charAt(l.length - 1) === a.charAt(64) && x--,
                        l.charAt(l.length - 2) === a.charAt(64) && x--,
                        x % 1 != 0)
                      )
                        throw new Error('Invalid base64 input, bad content length.')
                      for (
                        v = o.uint8array ? new Uint8Array(0 | x) : new Array(0 | x);
                        g < l.length;

                      )
                        ((c =
                          (a.indexOf(l.charAt(g++)) << 2) | ((h = a.indexOf(l.charAt(g++))) >> 4)),
                          (u = ((15 & h) << 4) | ((f = a.indexOf(l.charAt(g++))) >> 2)),
                          (d = ((3 & f) << 6) | (p = a.indexOf(l.charAt(g++)))),
                          (v[y++] = c),
                          f !== 64 && (v[y++] = u),
                          p !== 64 && (v[y++] = d))
                      return v
                    }))
                },
                { './support': 30, './utils': 32 },
              ],
              2: [
                function (t, i, r) {
                  var s = t('./external'),
                    o = t('./stream/DataWorker'),
                    a = t('./stream/Crc32Probe'),
                    l = t('./stream/DataLengthProbe')
                  function c(u, d, h, f, p) {
                    ;((this.compressedSize = u),
                      (this.uncompressedSize = d),
                      (this.crc32 = h),
                      (this.compression = f),
                      (this.compressedContent = p))
                  }
                  ;((c.prototype = {
                    getContentWorker: function () {
                      var u = new o(s.Promise.resolve(this.compressedContent))
                          .pipe(this.compression.uncompressWorker())
                          .pipe(new l('data_length')),
                        d = this
                      return (
                        u.on('end', function () {
                          if (this.streamInfo.data_length !== d.uncompressedSize)
                            throw new Error('Bug : uncompressed data size mismatch')
                        }),
                        u
                      )
                    },
                    getCompressedWorker: function () {
                      return new o(s.Promise.resolve(this.compressedContent))
                        .withStreamInfo('compressedSize', this.compressedSize)
                        .withStreamInfo('uncompressedSize', this.uncompressedSize)
                        .withStreamInfo('crc32', this.crc32)
                        .withStreamInfo('compression', this.compression)
                    },
                  }),
                    (c.createWorkerFrom = function (u, d, h) {
                      return u
                        .pipe(new a())
                        .pipe(new l('uncompressedSize'))
                        .pipe(d.compressWorker(h))
                        .pipe(new l('compressedSize'))
                        .withStreamInfo('compression', d)
                    }),
                    (i.exports = c))
                },
                {
                  './external': 6,
                  './stream/Crc32Probe': 25,
                  './stream/DataLengthProbe': 26,
                  './stream/DataWorker': 27,
                },
              ],
              3: [
                function (t, i, r) {
                  var s = t('./stream/GenericWorker')
                  ;((r.STORE = {
                    magic: '\0\0',
                    compressWorker: function () {
                      return new s('STORE compression')
                    },
                    uncompressWorker: function () {
                      return new s('STORE decompression')
                    },
                  }),
                    (r.DEFLATE = t('./flate')))
                },
                { './flate': 7, './stream/GenericWorker': 28 },
              ],
              4: [
                function (t, i, r) {
                  var s = t('./utils'),
                    o = (function () {
                      for (var a, l = [], c = 0; c < 256; c++) {
                        a = c
                        for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ (a >>> 1) : a >>> 1
                        l[c] = a
                      }
                      return l
                    })()
                  i.exports = function (a, l) {
                    return a !== void 0 && a.length
                      ? s.getTypeOf(a) !== 'string'
                        ? (function (c, u, d, h) {
                            var f = o,
                              p = h + d
                            c ^= -1
                            for (var g = h; g < p; g++) c = (c >>> 8) ^ f[255 & (c ^ u[g])]
                            return -1 ^ c
                          })(0 | l, a, a.length, 0)
                        : (function (c, u, d, h) {
                            var f = o,
                              p = h + d
                            c ^= -1
                            for (var g = h; g < p; g++)
                              c = (c >>> 8) ^ f[255 & (c ^ u.charCodeAt(g))]
                            return -1 ^ c
                          })(0 | l, a, a.length, 0)
                      : 0
                  }
                },
                { './utils': 32 },
              ],
              5: [
                function (t, i, r) {
                  ;((r.base64 = !1),
                    (r.binary = !1),
                    (r.dir = !1),
                    (r.createFolders = !0),
                    (r.date = null),
                    (r.compression = null),
                    (r.compressionOptions = null),
                    (r.comment = null),
                    (r.unixPermissions = null),
                    (r.dosPermissions = null))
                },
                {},
              ],
              6: [
                function (t, i, r) {
                  var s = null
                  ;((s = typeof Promise < 'u' ? Promise : t('lie')), (i.exports = { Promise: s }))
                },
                { lie: 37 },
              ],
              7: [
                function (t, i, r) {
                  var s =
                      typeof Uint8Array < 'u' &&
                      typeof Uint16Array < 'u' &&
                      typeof Uint32Array < 'u',
                    o = t('pako'),
                    a = t('./utils'),
                    l = t('./stream/GenericWorker'),
                    c = s ? 'uint8array' : 'array'
                  function u(d, h) {
                    ;(l.call(this, 'FlateWorker/' + d),
                      (this._pako = null),
                      (this._pakoAction = d),
                      (this._pakoOptions = h),
                      (this.meta = {}))
                  }
                  ;((r.magic = '\b\0'),
                    a.inherits(u, l),
                    (u.prototype.processChunk = function (d) {
                      ;((this.meta = d.meta),
                        this._pako === null && this._createPako(),
                        this._pako.push(a.transformTo(c, d.data), !1))
                    }),
                    (u.prototype.flush = function () {
                      ;(l.prototype.flush.call(this),
                        this._pako === null && this._createPako(),
                        this._pako.push([], !0))
                    }),
                    (u.prototype.cleanUp = function () {
                      ;(l.prototype.cleanUp.call(this), (this._pako = null))
                    }),
                    (u.prototype._createPako = function () {
                      this._pako = new o[this._pakoAction]({
                        raw: !0,
                        level: this._pakoOptions.level || -1,
                      })
                      var d = this
                      this._pako.onData = function (h) {
                        d.push({ data: h, meta: d.meta })
                      }
                    }),
                    (r.compressWorker = function (d) {
                      return new u('Deflate', d)
                    }),
                    (r.uncompressWorker = function () {
                      return new u('Inflate', {})
                    }))
                },
                { './stream/GenericWorker': 28, './utils': 32, pako: 38 },
              ],
              8: [
                function (t, i, r) {
                  function s(f, p) {
                    var g,
                      y = ''
                    for (g = 0; g < p; g++) ((y += String.fromCharCode(255 & f)), (f >>>= 8))
                    return y
                  }
                  function o(f, p, g, y, m, v) {
                    var x,
                      _,
                      S = f.file,
                      C = f.compression,
                      A = v !== c.utf8encode,
                      R = a.transformTo('string', v(S.name)),
                      w = a.transformTo('string', c.utf8encode(S.name)),
                      M = S.comment,
                      I = a.transformTo('string', v(M)),
                      L = a.transformTo('string', c.utf8encode(M)),
                      U = w.length !== S.name.length,
                      T = L.length !== M.length,
                      F = '',
                      V = '',
                      W = '',
                      ee = S.dir,
                      se = S.date,
                      he = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }
                    ;(p && !g) ||
                      ((he.crc32 = f.crc32),
                      (he.compressedSize = f.compressedSize),
                      (he.uncompressedSize = f.uncompressedSize))
                    var ne = 0
                    ;(p && (ne |= 8), A || (!U && !T) || (ne |= 2048))
                    var ie = 0,
                      be = 0
                    ;(ee && (ie |= 16),
                      m === 'UNIX'
                        ? ((be = 798),
                          (ie |= (function (fe, we) {
                            var Ee = fe
                            return (fe || (Ee = we ? 16893 : 33204), (65535 & Ee) << 16)
                          })(S.unixPermissions, ee)))
                        : ((be = 20),
                          (ie |= (function (fe) {
                            return 63 & (fe || 0)
                          })(S.dosPermissions))),
                      (x = se.getUTCHours()),
                      (x <<= 6),
                      (x |= se.getUTCMinutes()),
                      (x <<= 5),
                      (x |= se.getUTCSeconds() / 2),
                      (_ = se.getUTCFullYear() - 1980),
                      (_ <<= 4),
                      (_ |= se.getUTCMonth() + 1),
                      (_ <<= 5),
                      (_ |= se.getUTCDate()),
                      U && ((V = s(1, 1) + s(u(R), 4) + w), (F += 'up' + s(V.length, 2) + V)),
                      T && ((W = s(1, 1) + s(u(I), 4) + L), (F += 'uc' + s(W.length, 2) + W)))
                    var le = ''
                    return (
                      (le += '\n\0'),
                      (le += s(ne, 2)),
                      (le += C.magic),
                      (le += s(x, 2)),
                      (le += s(_, 2)),
                      (le += s(he.crc32, 4)),
                      (le += s(he.compressedSize, 4)),
                      (le += s(he.uncompressedSize, 4)),
                      (le += s(R.length, 2)),
                      (le += s(F.length, 2)),
                      {
                        fileRecord: d.LOCAL_FILE_HEADER + le + R + F,
                        dirRecord:
                          d.CENTRAL_FILE_HEADER +
                          s(be, 2) +
                          le +
                          s(I.length, 2) +
                          '\0\0\0\0' +
                          s(ie, 4) +
                          s(y, 4) +
                          R +
                          F +
                          I,
                      }
                    )
                  }
                  var a = t('../utils'),
                    l = t('../stream/GenericWorker'),
                    c = t('../utf8'),
                    u = t('../crc32'),
                    d = t('../signature')
                  function h(f, p, g, y) {
                    ;(l.call(this, 'ZipFileWorker'),
                      (this.bytesWritten = 0),
                      (this.zipComment = p),
                      (this.zipPlatform = g),
                      (this.encodeFileName = y),
                      (this.streamFiles = f),
                      (this.accumulate = !1),
                      (this.contentBuffer = []),
                      (this.dirRecords = []),
                      (this.currentSourceOffset = 0),
                      (this.entriesCount = 0),
                      (this.currentFile = null),
                      (this._sources = []))
                  }
                  ;(a.inherits(h, l),
                    (h.prototype.push = function (f) {
                      var p = f.meta.percent || 0,
                        g = this.entriesCount,
                        y = this._sources.length
                      this.accumulate
                        ? this.contentBuffer.push(f)
                        : ((this.bytesWritten += f.data.length),
                          l.prototype.push.call(this, {
                            data: f.data,
                            meta: {
                              currentFile: this.currentFile,
                              percent: g ? (p + 100 * (g - y - 1)) / g : 100,
                            },
                          }))
                    }),
                    (h.prototype.openedSource = function (f) {
                      ;((this.currentSourceOffset = this.bytesWritten),
                        (this.currentFile = f.file.name))
                      var p = this.streamFiles && !f.file.dir
                      if (p) {
                        var g = o(
                          f,
                          p,
                          !1,
                          this.currentSourceOffset,
                          this.zipPlatform,
                          this.encodeFileName
                        )
                        this.push({ data: g.fileRecord, meta: { percent: 0 } })
                      } else this.accumulate = !0
                    }),
                    (h.prototype.closedSource = function (f) {
                      this.accumulate = !1
                      var p = this.streamFiles && !f.file.dir,
                        g = o(
                          f,
                          p,
                          !0,
                          this.currentSourceOffset,
                          this.zipPlatform,
                          this.encodeFileName
                        )
                      if ((this.dirRecords.push(g.dirRecord), p))
                        this.push({
                          data: (function (y) {
                            return (
                              d.DATA_DESCRIPTOR +
                              s(y.crc32, 4) +
                              s(y.compressedSize, 4) +
                              s(y.uncompressedSize, 4)
                            )
                          })(f),
                          meta: { percent: 100 },
                        })
                      else
                        for (
                          this.push({ data: g.fileRecord, meta: { percent: 0 } });
                          this.contentBuffer.length;

                        )
                          this.push(this.contentBuffer.shift())
                      this.currentFile = null
                    }),
                    (h.prototype.flush = function () {
                      for (var f = this.bytesWritten, p = 0; p < this.dirRecords.length; p++)
                        this.push({ data: this.dirRecords[p], meta: { percent: 100 } })
                      var g = this.bytesWritten - f,
                        y = (function (m, v, x, _, S) {
                          var C = a.transformTo('string', S(_))
                          return (
                            d.CENTRAL_DIRECTORY_END +
                            '\0\0\0\0' +
                            s(m, 2) +
                            s(m, 2) +
                            s(v, 4) +
                            s(x, 4) +
                            s(C.length, 2) +
                            C
                          )
                        })(this.dirRecords.length, g, f, this.zipComment, this.encodeFileName)
                      this.push({ data: y, meta: { percent: 100 } })
                    }),
                    (h.prototype.prepareNextSource = function () {
                      ;((this.previous = this._sources.shift()),
                        this.openedSource(this.previous.streamInfo),
                        this.isPaused ? this.previous.pause() : this.previous.resume())
                    }),
                    (h.prototype.registerPrevious = function (f) {
                      this._sources.push(f)
                      var p = this
                      return (
                        f.on('data', function (g) {
                          p.processChunk(g)
                        }),
                        f.on('end', function () {
                          ;(p.closedSource(p.previous.streamInfo),
                            p._sources.length ? p.prepareNextSource() : p.end())
                        }),
                        f.on('error', function (g) {
                          p.error(g)
                        }),
                        this
                      )
                    }),
                    (h.prototype.resume = function () {
                      return (
                        !!l.prototype.resume.call(this) &&
                        (!this.previous && this._sources.length
                          ? (this.prepareNextSource(), !0)
                          : this.previous || this._sources.length || this.generatedError
                            ? void 0
                            : (this.end(), !0))
                      )
                    }),
                    (h.prototype.error = function (f) {
                      var p = this._sources
                      if (!l.prototype.error.call(this, f)) return !1
                      for (var g = 0; g < p.length; g++)
                        try {
                          p[g].error(f)
                        } catch (y) {}
                      return !0
                    }),
                    (h.prototype.lock = function () {
                      l.prototype.lock.call(this)
                      for (var f = this._sources, p = 0; p < f.length; p++) f[p].lock()
                    }),
                    (i.exports = h))
                },
                {
                  '../crc32': 4,
                  '../signature': 23,
                  '../stream/GenericWorker': 28,
                  '../utf8': 31,
                  '../utils': 32,
                },
              ],
              9: [
                function (t, i, r) {
                  var s = t('../compressions'),
                    o = t('./ZipFileWorker')
                  r.generateWorker = function (a, l, c) {
                    var u = new o(l.streamFiles, c, l.platform, l.encodeFileName),
                      d = 0
                    try {
                      ;(a.forEach(function (h, f) {
                        d++
                        var p = (function (v, x) {
                            var _ = v || x,
                              S = s[_]
                            if (!S) throw new Error(_ + ' is not a valid compression method !')
                            return S
                          })(f.options.compression, l.compression),
                          g = f.options.compressionOptions || l.compressionOptions || {},
                          y = f.dir,
                          m = f.date
                        f._compressWorker(p, g)
                          .withStreamInfo('file', {
                            name: h,
                            dir: y,
                            date: m,
                            comment: f.comment || '',
                            unixPermissions: f.unixPermissions,
                            dosPermissions: f.dosPermissions,
                          })
                          .pipe(u)
                      }),
                        (u.entriesCount = d))
                    } catch (h) {
                      u.error(h)
                    }
                    return u
                  }
                },
                { '../compressions': 3, './ZipFileWorker': 8 },
              ],
              10: [
                function (t, i, r) {
                  function s() {
                    if (!(this instanceof s)) return new s()
                    if (arguments.length)
                      throw new Error(
                        'The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.'
                      )
                    ;((this.files = Object.create(null)),
                      (this.comment = null),
                      (this.root = ''),
                      (this.clone = function () {
                        var o = new s()
                        for (var a in this) typeof this[a] != 'function' && (o[a] = this[a])
                        return o
                      }))
                  }
                  ;(((s.prototype = t('./object')).loadAsync = t('./load')),
                    (s.support = t('./support')),
                    (s.defaults = t('./defaults')),
                    (s.version = '3.10.1'),
                    (s.loadAsync = function (o, a) {
                      return new s().loadAsync(o, a)
                    }),
                    (s.external = t('./external')),
                    (i.exports = s))
                },
                { './defaults': 5, './external': 6, './load': 11, './object': 15, './support': 30 },
              ],
              11: [
                function (t, i, r) {
                  var s = t('./utils'),
                    o = t('./external'),
                    a = t('./utf8'),
                    l = t('./zipEntries'),
                    c = t('./stream/Crc32Probe'),
                    u = t('./nodejsUtils')
                  function d(h) {
                    return new o.Promise(function (f, p) {
                      var g = h.decompressed.getContentWorker().pipe(new c())
                      g.on('error', function (y) {
                        p(y)
                      })
                        .on('end', function () {
                          g.streamInfo.crc32 !== h.decompressed.crc32
                            ? p(new Error('Corrupted zip : CRC32 mismatch'))
                            : f()
                        })
                        .resume()
                    })
                  }
                  i.exports = function (h, f) {
                    var p = this
                    return (
                      (f = s.extend(f || {}, {
                        base64: !1,
                        checkCRC32: !1,
                        optimizedBinaryString: !1,
                        createFolders: !1,
                        decodeFileName: a.utf8decode,
                      })),
                      u.isNode && u.isStream(h)
                        ? o.Promise.reject(
                            new Error("JSZip can't accept a stream when loading a zip file.")
                          )
                        : s
                            .prepareContent(
                              'the loaded zip file',
                              h,
                              !0,
                              f.optimizedBinaryString,
                              f.base64
                            )
                            .then(function (g) {
                              var y = new l(f)
                              return (y.load(g), y)
                            })
                            .then(function (g) {
                              var y = [o.Promise.resolve(g)],
                                m = g.files
                              if (f.checkCRC32) for (var v = 0; v < m.length; v++) y.push(d(m[v]))
                              return o.Promise.all(y)
                            })
                            .then(function (g) {
                              for (var y = g.shift(), m = y.files, v = 0; v < m.length; v++) {
                                var x = m[v],
                                  _ = x.fileNameStr,
                                  S = s.resolve(x.fileNameStr)
                                ;(p.file(S, x.decompressed, {
                                  binary: !0,
                                  optimizedBinaryString: !0,
                                  date: x.date,
                                  dir: x.dir,
                                  comment: x.fileCommentStr.length ? x.fileCommentStr : null,
                                  unixPermissions: x.unixPermissions,
                                  dosPermissions: x.dosPermissions,
                                  createFolders: f.createFolders,
                                }),
                                  x.dir || (p.file(S).unsafeOriginalName = _))
                              }
                              return (y.zipComment.length && (p.comment = y.zipComment), p)
                            })
                    )
                  }
                },
                {
                  './external': 6,
                  './nodejsUtils': 14,
                  './stream/Crc32Probe': 25,
                  './utf8': 31,
                  './utils': 32,
                  './zipEntries': 33,
                },
              ],
              12: [
                function (t, i, r) {
                  var s = t('../utils'),
                    o = t('../stream/GenericWorker')
                  function a(l, c) {
                    ;(o.call(this, 'Nodejs stream input adapter for ' + l),
                      (this._upstreamEnded = !1),
                      this._bindStream(c))
                  }
                  ;(s.inherits(a, o),
                    (a.prototype._bindStream = function (l) {
                      var c = this
                      ;((this._stream = l).pause(),
                        l
                          .on('data', function (u) {
                            c.push({ data: u, meta: { percent: 0 } })
                          })
                          .on('error', function (u) {
                            c.isPaused ? (this.generatedError = u) : c.error(u)
                          })
                          .on('end', function () {
                            c.isPaused ? (c._upstreamEnded = !0) : c.end()
                          }))
                    }),
                    (a.prototype.pause = function () {
                      return !!o.prototype.pause.call(this) && (this._stream.pause(), !0)
                    }),
                    (a.prototype.resume = function () {
                      return (
                        !!o.prototype.resume.call(this) &&
                        (this._upstreamEnded ? this.end() : this._stream.resume(), !0)
                      )
                    }),
                    (i.exports = a))
                },
                { '../stream/GenericWorker': 28, '../utils': 32 },
              ],
              13: [
                function (t, i, r) {
                  var s = t('readable-stream').Readable
                  function o(a, l, c) {
                    ;(s.call(this, l), (this._helper = a))
                    var u = this
                    a.on('data', function (d, h) {
                      ;(u.push(d) || u._helper.pause(), c && c(h))
                    })
                      .on('error', function (d) {
                        u.emit('error', d)
                      })
                      .on('end', function () {
                        u.push(null)
                      })
                  }
                  ;(t('../utils').inherits(o, s),
                    (o.prototype._read = function () {
                      this._helper.resume()
                    }),
                    (i.exports = o))
                },
                { '../utils': 32, 'readable-stream': 16 },
              ],
              14: [
                function (t, i, r) {
                  i.exports = {
                    isNode: typeof Buffer < 'u',
                    newBufferFrom: function (s, o) {
                      if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o)
                      if (typeof s == 'number')
                        throw new Error('The "data" argument must not be a number')
                      return new Buffer(s, o)
                    },
                    allocBuffer: function (s) {
                      if (Buffer.alloc) return Buffer.alloc(s)
                      var o = new Buffer(s)
                      return (o.fill(0), o)
                    },
                    isBuffer: function (s) {
                      return Buffer.isBuffer(s)
                    },
                    isStream: function (s) {
                      return (
                        s &&
                        typeof s.on == 'function' &&
                        typeof s.pause == 'function' &&
                        typeof s.resume == 'function'
                      )
                    },
                  }
                },
                {},
              ],
              15: [
                function (t, i, r) {
                  function s(S, C, A) {
                    var R,
                      w = a.getTypeOf(C),
                      M = a.extend(A || {}, u)
                    ;((M.date = M.date || new Date()),
                      M.compression !== null && (M.compression = M.compression.toUpperCase()),
                      typeof M.unixPermissions == 'string' &&
                        (M.unixPermissions = parseInt(M.unixPermissions, 8)),
                      M.unixPermissions && 16384 & M.unixPermissions && (M.dir = !0),
                      M.dosPermissions && 16 & M.dosPermissions && (M.dir = !0),
                      M.dir && (S = m(S)),
                      M.createFolders && (R = y(S)) && v.call(this, R, !0))
                    var I = w === 'string' && M.binary === !1 && M.base64 === !1
                    ;((A && A.binary !== void 0) || (M.binary = !I),
                      ((C instanceof d && C.uncompressedSize === 0) ||
                        M.dir ||
                        !C ||
                        C.length === 0) &&
                        ((M.base64 = !1),
                        (M.binary = !0),
                        (C = ''),
                        (M.compression = 'STORE'),
                        (w = 'string')))
                    var L = null
                    L =
                      C instanceof d || C instanceof l
                        ? C
                        : p.isNode && p.isStream(C)
                          ? new g(S, C)
                          : a.prepareContent(S, C, M.binary, M.optimizedBinaryString, M.base64)
                    var U = new h(S, L, M)
                    this.files[S] = U
                  }
                  var o = t('./utf8'),
                    a = t('./utils'),
                    l = t('./stream/GenericWorker'),
                    c = t('./stream/StreamHelper'),
                    u = t('./defaults'),
                    d = t('./compressedObject'),
                    h = t('./zipObject'),
                    f = t('./generate'),
                    p = t('./nodejsUtils'),
                    g = t('./nodejs/NodejsStreamInputAdapter'),
                    y = function (S) {
                      S.slice(-1) === '/' && (S = S.substring(0, S.length - 1))
                      var C = S.lastIndexOf('/')
                      return 0 < C ? S.substring(0, C) : ''
                    },
                    m = function (S) {
                      return (S.slice(-1) !== '/' && (S += '/'), S)
                    },
                    v = function (S, C) {
                      return (
                        (C = C !== void 0 ? C : u.createFolders),
                        (S = m(S)),
                        this.files[S] || s.call(this, S, null, { dir: !0, createFolders: C }),
                        this.files[S]
                      )
                    }
                  function x(S) {
                    return Object.prototype.toString.call(S) === '[object RegExp]'
                  }
                  var _ = {
                    load: function () {
                      throw new Error(
                        'This method has been removed in JSZip 3.0, please check the upgrade guide.'
                      )
                    },
                    forEach: function (S) {
                      var C, A, R
                      for (C in this.files)
                        ((R = this.files[C]),
                          (A = C.slice(this.root.length, C.length)) &&
                            C.slice(0, this.root.length) === this.root &&
                            S(A, R))
                    },
                    filter: function (S) {
                      var C = []
                      return (
                        this.forEach(function (A, R) {
                          S(A, R) && C.push(R)
                        }),
                        C
                      )
                    },
                    file: function (S, C, A) {
                      if (arguments.length !== 1)
                        return ((S = this.root + S), s.call(this, S, C, A), this)
                      if (x(S)) {
                        var R = S
                        return this.filter(function (M, I) {
                          return !I.dir && R.test(M)
                        })
                      }
                      var w = this.files[this.root + S]
                      return w && !w.dir ? w : null
                    },
                    folder: function (S) {
                      if (!S) return this
                      if (x(S))
                        return this.filter(function (w, M) {
                          return M.dir && S.test(w)
                        })
                      var C = this.root + S,
                        A = v.call(this, C),
                        R = this.clone()
                      return ((R.root = A.name), R)
                    },
                    remove: function (S) {
                      S = this.root + S
                      var C = this.files[S]
                      if (
                        (C || (S.slice(-1) !== '/' && (S += '/'), (C = this.files[S])), C && !C.dir)
                      )
                        delete this.files[S]
                      else
                        for (
                          var A = this.filter(function (w, M) {
                              return M.name.slice(0, S.length) === S
                            }),
                            R = 0;
                          R < A.length;
                          R++
                        )
                          delete this.files[A[R].name]
                      return this
                    },
                    generate: function () {
                      throw new Error(
                        'This method has been removed in JSZip 3.0, please check the upgrade guide.'
                      )
                    },
                    generateInternalStream: function (S) {
                      var C,
                        A = {}
                      try {
                        if (
                          (((A = a.extend(S || {}, {
                            streamFiles: !1,
                            compression: 'STORE',
                            compressionOptions: null,
                            type: '',
                            platform: 'DOS',
                            comment: null,
                            mimeType: 'application/zip',
                            encodeFileName: o.utf8encode,
                          })).type = A.type.toLowerCase()),
                          (A.compression = A.compression.toUpperCase()),
                          A.type === 'binarystring' && (A.type = 'string'),
                          !A.type)
                        )
                          throw new Error('No output type specified.')
                        ;(a.checkSupport(A.type),
                          (A.platform !== 'darwin' &&
                            A.platform !== 'freebsd' &&
                            A.platform !== 'linux' &&
                            A.platform !== 'sunos') ||
                            (A.platform = 'UNIX'),
                          A.platform === 'win32' && (A.platform = 'DOS'))
                        var R = A.comment || this.comment || ''
                        C = f.generateWorker(this, A, R)
                      } catch (w) {
                        ;(C = new l('error')).error(w)
                      }
                      return new c(C, A.type || 'string', A.mimeType)
                    },
                    generateAsync: function (S, C) {
                      return this.generateInternalStream(S).accumulate(C)
                    },
                    generateNodeStream: function (S, C) {
                      return (
                        (S = S || {}).type || (S.type = 'nodebuffer'),
                        this.generateInternalStream(S).toNodejsStream(C)
                      )
                    },
                  }
                  i.exports = _
                },
                {
                  './compressedObject': 2,
                  './defaults': 5,
                  './generate': 9,
                  './nodejs/NodejsStreamInputAdapter': 12,
                  './nodejsUtils': 14,
                  './stream/GenericWorker': 28,
                  './stream/StreamHelper': 29,
                  './utf8': 31,
                  './utils': 32,
                  './zipObject': 35,
                },
              ],
              16: [
                function (t, i, r) {
                  i.exports = t('stream')
                },
                { stream: void 0 },
              ],
              17: [
                function (t, i, r) {
                  var s = t('./DataReader')
                  function o(a) {
                    s.call(this, a)
                    for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l]
                  }
                  ;(t('../utils').inherits(o, s),
                    (o.prototype.byteAt = function (a) {
                      return this.data[this.zero + a]
                    }),
                    (o.prototype.lastIndexOfSignature = function (a) {
                      for (
                        var l = a.charCodeAt(0),
                          c = a.charCodeAt(1),
                          u = a.charCodeAt(2),
                          d = a.charCodeAt(3),
                          h = this.length - 4;
                        0 <= h;
                        --h
                      )
                        if (
                          this.data[h] === l &&
                          this.data[h + 1] === c &&
                          this.data[h + 2] === u &&
                          this.data[h + 3] === d
                        )
                          return h - this.zero
                      return -1
                    }),
                    (o.prototype.readAndCheckSignature = function (a) {
                      var l = a.charCodeAt(0),
                        c = a.charCodeAt(1),
                        u = a.charCodeAt(2),
                        d = a.charCodeAt(3),
                        h = this.readData(4)
                      return l === h[0] && c === h[1] && u === h[2] && d === h[3]
                    }),
                    (o.prototype.readData = function (a) {
                      if ((this.checkOffset(a), a === 0)) return []
                      var l = this.data.slice(this.zero + this.index, this.zero + this.index + a)
                      return ((this.index += a), l)
                    }),
                    (i.exports = o))
                },
                { '../utils': 32, './DataReader': 18 },
              ],
              18: [
                function (t, i, r) {
                  var s = t('../utils')
                  function o(a) {
                    ;((this.data = a), (this.length = a.length), (this.index = 0), (this.zero = 0))
                  }
                  ;((o.prototype = {
                    checkOffset: function (a) {
                      this.checkIndex(this.index + a)
                    },
                    checkIndex: function (a) {
                      if (this.length < this.zero + a || a < 0)
                        throw new Error(
                          'End of data reached (data length = ' +
                            this.length +
                            ', asked index = ' +
                            a +
                            '). Corrupted zip ?'
                        )
                    },
                    setIndex: function (a) {
                      ;(this.checkIndex(a), (this.index = a))
                    },
                    skip: function (a) {
                      this.setIndex(this.index + a)
                    },
                    byteAt: function () {},
                    readInt: function (a) {
                      var l,
                        c = 0
                      for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--)
                        c = (c << 8) + this.byteAt(l)
                      return ((this.index += a), c)
                    },
                    readString: function (a) {
                      return s.transformTo('string', this.readData(a))
                    },
                    readData: function () {},
                    lastIndexOfSignature: function () {},
                    readAndCheckSignature: function () {},
                    readDate: function () {
                      var a = this.readInt(4)
                      return new Date(
                        Date.UTC(
                          1980 + ((a >> 25) & 127),
                          ((a >> 21) & 15) - 1,
                          (a >> 16) & 31,
                          (a >> 11) & 31,
                          (a >> 5) & 63,
                          (31 & a) << 1
                        )
                      )
                    },
                  }),
                    (i.exports = o))
                },
                { '../utils': 32 },
              ],
              19: [
                function (t, i, r) {
                  var s = t('./Uint8ArrayReader')
                  function o(a) {
                    s.call(this, a)
                  }
                  ;(t('../utils').inherits(o, s),
                    (o.prototype.readData = function (a) {
                      this.checkOffset(a)
                      var l = this.data.slice(this.zero + this.index, this.zero + this.index + a)
                      return ((this.index += a), l)
                    }),
                    (i.exports = o))
                },
                { '../utils': 32, './Uint8ArrayReader': 21 },
              ],
              20: [
                function (t, i, r) {
                  var s = t('./DataReader')
                  function o(a) {
                    s.call(this, a)
                  }
                  ;(t('../utils').inherits(o, s),
                    (o.prototype.byteAt = function (a) {
                      return this.data.charCodeAt(this.zero + a)
                    }),
                    (o.prototype.lastIndexOfSignature = function (a) {
                      return this.data.lastIndexOf(a) - this.zero
                    }),
                    (o.prototype.readAndCheckSignature = function (a) {
                      return a === this.readData(4)
                    }),
                    (o.prototype.readData = function (a) {
                      this.checkOffset(a)
                      var l = this.data.slice(this.zero + this.index, this.zero + this.index + a)
                      return ((this.index += a), l)
                    }),
                    (i.exports = o))
                },
                { '../utils': 32, './DataReader': 18 },
              ],
              21: [
                function (t, i, r) {
                  var s = t('./ArrayReader')
                  function o(a) {
                    s.call(this, a)
                  }
                  ;(t('../utils').inherits(o, s),
                    (o.prototype.readData = function (a) {
                      if ((this.checkOffset(a), a === 0)) return new Uint8Array(0)
                      var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a)
                      return ((this.index += a), l)
                    }),
                    (i.exports = o))
                },
                { '../utils': 32, './ArrayReader': 17 },
              ],
              22: [
                function (t, i, r) {
                  var s = t('../utils'),
                    o = t('../support'),
                    a = t('./ArrayReader'),
                    l = t('./StringReader'),
                    c = t('./NodeBufferReader'),
                    u = t('./Uint8ArrayReader')
                  i.exports = function (d) {
                    var h = s.getTypeOf(d)
                    return (
                      s.checkSupport(h),
                      h !== 'string' || o.uint8array
                        ? h === 'nodebuffer'
                          ? new c(d)
                          : o.uint8array
                            ? new u(s.transformTo('uint8array', d))
                            : new a(s.transformTo('array', d))
                        : new l(d)
                    )
                  }
                },
                {
                  '../support': 30,
                  '../utils': 32,
                  './ArrayReader': 17,
                  './NodeBufferReader': 19,
                  './StringReader': 20,
                  './Uint8ArrayReader': 21,
                },
              ],
              23: [
                function (t, i, r) {
                  ;((r.LOCAL_FILE_HEADER = 'PK'),
                    (r.CENTRAL_FILE_HEADER = 'PK'),
                    (r.CENTRAL_DIRECTORY_END = 'PK'),
                    (r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\x07'),
                    (r.ZIP64_CENTRAL_DIRECTORY_END = 'PK'),
                    (r.DATA_DESCRIPTOR = 'PK\x07\b'))
                },
                {},
              ],
              24: [
                function (t, i, r) {
                  var s = t('./GenericWorker'),
                    o = t('../utils')
                  function a(l) {
                    ;(s.call(this, 'ConvertWorker to ' + l), (this.destType = l))
                  }
                  ;(o.inherits(a, s),
                    (a.prototype.processChunk = function (l) {
                      this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta })
                    }),
                    (i.exports = a))
                },
                { '../utils': 32, './GenericWorker': 28 },
              ],
              25: [
                function (t, i, r) {
                  var s = t('./GenericWorker'),
                    o = t('../crc32')
                  function a() {
                    ;(s.call(this, 'Crc32Probe'), this.withStreamInfo('crc32', 0))
                  }
                  ;(t('../utils').inherits(a, s),
                    (a.prototype.processChunk = function (l) {
                      ;((this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0)),
                        this.push(l))
                    }),
                    (i.exports = a))
                },
                { '../crc32': 4, '../utils': 32, './GenericWorker': 28 },
              ],
              26: [
                function (t, i, r) {
                  var s = t('../utils'),
                    o = t('./GenericWorker')
                  function a(l) {
                    ;(o.call(this, 'DataLengthProbe for ' + l),
                      (this.propName = l),
                      this.withStreamInfo(l, 0))
                  }
                  ;(s.inherits(a, o),
                    (a.prototype.processChunk = function (l) {
                      if (l) {
                        var c = this.streamInfo[this.propName] || 0
                        this.streamInfo[this.propName] = c + l.data.length
                      }
                      o.prototype.processChunk.call(this, l)
                    }),
                    (i.exports = a))
                },
                { '../utils': 32, './GenericWorker': 28 },
              ],
              27: [
                function (t, i, r) {
                  var s = t('../utils'),
                    o = t('./GenericWorker')
                  function a(l) {
                    o.call(this, 'DataWorker')
                    var c = this
                    ;((this.dataIsReady = !1),
                      (this.index = 0),
                      (this.max = 0),
                      (this.data = null),
                      (this.type = ''),
                      (this._tickScheduled = !1),
                      l.then(
                        function (u) {
                          ;((c.dataIsReady = !0),
                            (c.data = u),
                            (c.max = (u && u.length) || 0),
                            (c.type = s.getTypeOf(u)),
                            c.isPaused || c._tickAndRepeat())
                        },
                        function (u) {
                          c.error(u)
                        }
                      ))
                  }
                  ;(s.inherits(a, o),
                    (a.prototype.cleanUp = function () {
                      ;(o.prototype.cleanUp.call(this), (this.data = null))
                    }),
                    (a.prototype.resume = function () {
                      return (
                        !!o.prototype.resume.call(this) &&
                        (!this._tickScheduled &&
                          this.dataIsReady &&
                          ((this._tickScheduled = !0), s.delay(this._tickAndRepeat, [], this)),
                        !0)
                      )
                    }),
                    (a.prototype._tickAndRepeat = function () {
                      ;((this._tickScheduled = !1),
                        this.isPaused ||
                          this.isFinished ||
                          (this._tick(),
                          this.isFinished ||
                            (s.delay(this._tickAndRepeat, [], this), (this._tickScheduled = !0))))
                    }),
                    (a.prototype._tick = function () {
                      if (this.isPaused || this.isFinished) return !1
                      var l = null,
                        c = Math.min(this.max, this.index + 16384)
                      if (this.index >= this.max) return this.end()
                      switch (this.type) {
                        case 'string':
                          l = this.data.substring(this.index, c)
                          break
                        case 'uint8array':
                          l = this.data.subarray(this.index, c)
                          break
                        case 'array':
                        case 'nodebuffer':
                          l = this.data.slice(this.index, c)
                      }
                      return (
                        (this.index = c),
                        this.push({
                          data: l,
                          meta: { percent: this.max ? (this.index / this.max) * 100 : 0 },
                        })
                      )
                    }),
                    (i.exports = a))
                },
                { '../utils': 32, './GenericWorker': 28 },
              ],
              28: [
                function (t, i, r) {
                  function s(o) {
                    ;((this.name = o || 'default'),
                      (this.streamInfo = {}),
                      (this.generatedError = null),
                      (this.extraStreamInfo = {}),
                      (this.isPaused = !0),
                      (this.isFinished = !1),
                      (this.isLocked = !1),
                      (this._listeners = { data: [], end: [], error: [] }),
                      (this.previous = null))
                  }
                  ;((s.prototype = {
                    push: function (o) {
                      this.emit('data', o)
                    },
                    end: function () {
                      if (this.isFinished) return !1
                      this.flush()
                      try {
                        ;(this.emit('end'), this.cleanUp(), (this.isFinished = !0))
                      } catch (o) {
                        this.emit('error', o)
                      }
                      return !0
                    },
                    error: function (o) {
                      return (
                        !this.isFinished &&
                        (this.isPaused
                          ? (this.generatedError = o)
                          : ((this.isFinished = !0),
                            this.emit('error', o),
                            this.previous && this.previous.error(o),
                            this.cleanUp()),
                        !0)
                      )
                    },
                    on: function (o, a) {
                      return (this._listeners[o].push(a), this)
                    },
                    cleanUp: function () {
                      ;((this.streamInfo = this.generatedError = this.extraStreamInfo = null),
                        (this._listeners = []))
                    },
                    emit: function (o, a) {
                      if (this._listeners[o])
                        for (var l = 0; l < this._listeners[o].length; l++)
                          this._listeners[o][l].call(this, a)
                    },
                    pipe: function (o) {
                      return o.registerPrevious(this)
                    },
                    registerPrevious: function (o) {
                      if (this.isLocked)
                        throw new Error("The stream '" + this + "' has already been used.")
                      ;((this.streamInfo = o.streamInfo),
                        this.mergeStreamInfo(),
                        (this.previous = o))
                      var a = this
                      return (
                        o.on('data', function (l) {
                          a.processChunk(l)
                        }),
                        o.on('end', function () {
                          a.end()
                        }),
                        o.on('error', function (l) {
                          a.error(l)
                        }),
                        this
                      )
                    },
                    pause: function () {
                      return (
                        !this.isPaused &&
                        !this.isFinished &&
                        ((this.isPaused = !0), this.previous && this.previous.pause(), !0)
                      )
                    },
                    resume: function () {
                      if (!this.isPaused || this.isFinished) return !1
                      var o = (this.isPaused = !1)
                      return (
                        this.generatedError && (this.error(this.generatedError), (o = !0)),
                        this.previous && this.previous.resume(),
                        !o
                      )
                    },
                    flush: function () {},
                    processChunk: function (o) {
                      this.push(o)
                    },
                    withStreamInfo: function (o, a) {
                      return ((this.extraStreamInfo[o] = a), this.mergeStreamInfo(), this)
                    },
                    mergeStreamInfo: function () {
                      for (var o in this.extraStreamInfo)
                        Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) &&
                          (this.streamInfo[o] = this.extraStreamInfo[o])
                    },
                    lock: function () {
                      if (this.isLocked)
                        throw new Error("The stream '" + this + "' has already been used.")
                      ;((this.isLocked = !0), this.previous && this.previous.lock())
                    },
                    toString: function () {
                      var o = 'Worker ' + this.name
                      return this.previous ? this.previous + ' -> ' + o : o
                    },
                  }),
                    (i.exports = s))
                },
                {},
              ],
              29: [
                function (t, i, r) {
                  var s = t('../utils'),
                    o = t('./ConvertWorker'),
                    a = t('./GenericWorker'),
                    l = t('../base64'),
                    c = t('../support'),
                    u = t('../external'),
                    d = null
                  if (c.nodestream)
                    try {
                      d = t('../nodejs/NodejsStreamOutputAdapter')
                    } catch (p) {}
                  function h(p, g) {
                    return new u.Promise(function (y, m) {
                      var v = [],
                        x = p._internalType,
                        _ = p._outputType,
                        S = p._mimeType
                      p.on('data', function (C, A) {
                        ;(v.push(C), g && g(A))
                      })
                        .on('error', function (C) {
                          ;((v = []), m(C))
                        })
                        .on('end', function () {
                          try {
                            var C = (function (A, R, w) {
                              switch (A) {
                                case 'blob':
                                  return s.newBlob(s.transformTo('arraybuffer', R), w)
                                case 'base64':
                                  return l.encode(R)
                                default:
                                  return s.transformTo(A, R)
                              }
                            })(
                              _,
                              (function (A, R) {
                                var w,
                                  M = 0,
                                  I = null,
                                  L = 0
                                for (w = 0; w < R.length; w++) L += R[w].length
                                switch (A) {
                                  case 'string':
                                    return R.join('')
                                  case 'array':
                                    return Array.prototype.concat.apply([], R)
                                  case 'uint8array':
                                    for (I = new Uint8Array(L), w = 0; w < R.length; w++)
                                      (I.set(R[w], M), (M += R[w].length))
                                    return I
                                  case 'nodebuffer':
                                    return Buffer.concat(R)
                                  default:
                                    throw new Error("concat : unsupported type '" + A + "'")
                                }
                              })(x, v),
                              S
                            )
                            y(C)
                          } catch (A) {
                            m(A)
                          }
                          v = []
                        })
                        .resume()
                    })
                  }
                  function f(p, g, y) {
                    var m = g
                    switch (g) {
                      case 'blob':
                      case 'arraybuffer':
                        m = 'uint8array'
                        break
                      case 'base64':
                        m = 'string'
                    }
                    try {
                      ;((this._internalType = m),
                        (this._outputType = g),
                        (this._mimeType = y),
                        s.checkSupport(m),
                        (this._worker = p.pipe(new o(m))),
                        p.lock())
                    } catch (v) {
                      ;((this._worker = new a('error')), this._worker.error(v))
                    }
                  }
                  ;((f.prototype = {
                    accumulate: function (p) {
                      return h(this, p)
                    },
                    on: function (p, g) {
                      var y = this
                      return (
                        p === 'data'
                          ? this._worker.on(p, function (m) {
                              g.call(y, m.data, m.meta)
                            })
                          : this._worker.on(p, function () {
                              s.delay(g, arguments, y)
                            }),
                        this
                      )
                    },
                    resume: function () {
                      return (s.delay(this._worker.resume, [], this._worker), this)
                    },
                    pause: function () {
                      return (this._worker.pause(), this)
                    },
                    toNodejsStream: function (p) {
                      if ((s.checkSupport('nodestream'), this._outputType !== 'nodebuffer'))
                        throw new Error(this._outputType + ' is not supported by this method')
                      return new d(this, { objectMode: this._outputType !== 'nodebuffer' }, p)
                    },
                  }),
                    (i.exports = f))
                },
                {
                  '../base64': 1,
                  '../external': 6,
                  '../nodejs/NodejsStreamOutputAdapter': 13,
                  '../support': 30,
                  '../utils': 32,
                  './ConvertWorker': 24,
                  './GenericWorker': 28,
                },
              ],
              30: [
                function (t, i, r) {
                  if (
                    ((r.base64 = !0),
                    (r.array = !0),
                    (r.string = !0),
                    (r.arraybuffer = typeof ArrayBuffer < 'u' && typeof Uint8Array < 'u'),
                    (r.nodebuffer = typeof Buffer < 'u'),
                    (r.uint8array = typeof Uint8Array < 'u'),
                    typeof ArrayBuffer > 'u')
                  )
                    r.blob = !1
                  else {
                    var s = new ArrayBuffer(0)
                    try {
                      r.blob = new Blob([s], { type: 'application/zip' }).size === 0
                    } catch (a) {
                      try {
                        var o = new (self.BlobBuilder ||
                          self.WebKitBlobBuilder ||
                          self.MozBlobBuilder ||
                          self.MSBlobBuilder)()
                        ;(o.append(s), (r.blob = o.getBlob('application/zip').size === 0))
                      } catch (l) {
                        r.blob = !1
                      }
                    }
                  }
                  try {
                    r.nodestream = !!t('readable-stream').Readable
                  } catch (a) {
                    r.nodestream = !1
                  }
                },
                { 'readable-stream': 16 },
              ],
              31: [
                function (t, i, r) {
                  for (
                    var s = t('./utils'),
                      o = t('./support'),
                      a = t('./nodejsUtils'),
                      l = t('./stream/GenericWorker'),
                      c = new Array(256),
                      u = 0;
                    u < 256;
                    u++
                  )
                    c[u] =
                      252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1
                  c[254] = c[254] = 1
                  function d() {
                    ;(l.call(this, 'utf-8 decode'), (this.leftOver = null))
                  }
                  function h() {
                    l.call(this, 'utf-8 encode')
                  }
                  ;((r.utf8encode = function (f) {
                    return o.nodebuffer
                      ? a.newBufferFrom(f, 'utf-8')
                      : (function (p) {
                          var g,
                            y,
                            m,
                            v,
                            x,
                            _ = p.length,
                            S = 0
                          for (v = 0; v < _; v++)
                            ((64512 & (y = p.charCodeAt(v))) == 55296 &&
                              v + 1 < _ &&
                              (64512 & (m = p.charCodeAt(v + 1))) == 56320 &&
                              ((y = 65536 + ((y - 55296) << 10) + (m - 56320)), v++),
                              (S += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4))
                          for (
                            g = o.uint8array ? new Uint8Array(S) : new Array(S), v = x = 0;
                            x < S;
                            v++
                          )
                            ((64512 & (y = p.charCodeAt(v))) == 55296 &&
                              v + 1 < _ &&
                              (64512 & (m = p.charCodeAt(v + 1))) == 56320 &&
                              ((y = 65536 + ((y - 55296) << 10) + (m - 56320)), v++),
                              y < 128
                                ? (g[x++] = y)
                                : (y < 2048
                                    ? (g[x++] = 192 | (y >>> 6))
                                    : (y < 65536
                                        ? (g[x++] = 224 | (y >>> 12))
                                        : ((g[x++] = 240 | (y >>> 18)),
                                          (g[x++] = 128 | ((y >>> 12) & 63))),
                                      (g[x++] = 128 | ((y >>> 6) & 63))),
                                  (g[x++] = 128 | (63 & y))))
                          return g
                        })(f)
                  }),
                    (r.utf8decode = function (f) {
                      return o.nodebuffer
                        ? s.transformTo('nodebuffer', f).toString('utf-8')
                        : (function (p) {
                            var g,
                              y,
                              m,
                              v,
                              x = p.length,
                              _ = new Array(2 * x)
                            for (g = y = 0; g < x; )
                              if ((m = p[g++]) < 128) _[y++] = m
                              else if (4 < (v = c[m])) ((_[y++] = 65533), (g += v - 1))
                              else {
                                for (m &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && g < x; )
                                  ((m = (m << 6) | (63 & p[g++])), v--)
                                1 < v
                                  ? (_[y++] = 65533)
                                  : m < 65536
                                    ? (_[y++] = m)
                                    : ((m -= 65536),
                                      (_[y++] = 55296 | ((m >> 10) & 1023)),
                                      (_[y++] = 56320 | (1023 & m)))
                              }
                            return (
                              _.length !== y &&
                                (_.subarray ? (_ = _.subarray(0, y)) : (_.length = y)),
                              s.applyFromCharCode(_)
                            )
                          })((f = s.transformTo(o.uint8array ? 'uint8array' : 'array', f)))
                    }),
                    s.inherits(d, l),
                    (d.prototype.processChunk = function (f) {
                      var p = s.transformTo(o.uint8array ? 'uint8array' : 'array', f.data)
                      if (this.leftOver && this.leftOver.length) {
                        if (o.uint8array) {
                          var g = p
                          ;((p = new Uint8Array(g.length + this.leftOver.length)).set(
                            this.leftOver,
                            0
                          ),
                            p.set(g, this.leftOver.length))
                        } else p = this.leftOver.concat(p)
                        this.leftOver = null
                      }
                      var y = (function (v, x) {
                          var _
                          for (
                            (x = x || v.length) > v.length && (x = v.length), _ = x - 1;
                            0 <= _ && (192 & v[_]) == 128;

                          )
                            _--
                          return _ < 0 || _ === 0 ? x : _ + c[v[_]] > x ? _ : x
                        })(p),
                        m = p
                      ;(y !== p.length &&
                        (o.uint8array
                          ? ((m = p.subarray(0, y)), (this.leftOver = p.subarray(y, p.length)))
                          : ((m = p.slice(0, y)), (this.leftOver = p.slice(y, p.length)))),
                        this.push({ data: r.utf8decode(m), meta: f.meta }))
                    }),
                    (d.prototype.flush = function () {
                      this.leftOver &&
                        this.leftOver.length &&
                        (this.push({ data: r.utf8decode(this.leftOver), meta: {} }),
                        (this.leftOver = null))
                    }),
                    (r.Utf8DecodeWorker = d),
                    s.inherits(h, l),
                    (h.prototype.processChunk = function (f) {
                      this.push({ data: r.utf8encode(f.data), meta: f.meta })
                    }),
                    (r.Utf8EncodeWorker = h))
                },
                {
                  './nodejsUtils': 14,
                  './stream/GenericWorker': 28,
                  './support': 30,
                  './utils': 32,
                },
              ],
              32: [
                function (t, i, r) {
                  var s = t('./support'),
                    o = t('./base64'),
                    a = t('./nodejsUtils'),
                    l = t('./external')
                  function c(g) {
                    return g
                  }
                  function u(g, y) {
                    for (var m = 0; m < g.length; ++m) y[m] = 255 & g.charCodeAt(m)
                    return y
                  }
                  ;(t('setimmediate'),
                    (r.newBlob = function (g, y) {
                      r.checkSupport('blob')
                      try {
                        return new Blob([g], { type: y })
                      } catch (v) {
                        try {
                          var m = new (self.BlobBuilder ||
                            self.WebKitBlobBuilder ||
                            self.MozBlobBuilder ||
                            self.MSBlobBuilder)()
                          return (m.append(g), m.getBlob(y))
                        } catch (x) {
                          throw new Error("Bug : can't construct the Blob.")
                        }
                      }
                    }))
                  var d = {
                    stringifyByChunk: function (g, y, m) {
                      var v = [],
                        x = 0,
                        _ = g.length
                      if (_ <= m) return String.fromCharCode.apply(null, g)
                      for (; x < _; )
                        (y === 'array' || y === 'nodebuffer'
                          ? v.push(String.fromCharCode.apply(null, g.slice(x, Math.min(x + m, _))))
                          : v.push(
                              String.fromCharCode.apply(null, g.subarray(x, Math.min(x + m, _)))
                            ),
                          (x += m))
                      return v.join('')
                    },
                    stringifyByChar: function (g) {
                      for (var y = '', m = 0; m < g.length; m++) y += String.fromCharCode(g[m])
                      return y
                    },
                    applyCanBeUsed: {
                      uint8array: (function () {
                        try {
                          return (
                            s.uint8array &&
                            String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                          )
                        } catch (g) {
                          return !1
                        }
                      })(),
                      nodebuffer: (function () {
                        try {
                          return (
                            s.nodebuffer &&
                            String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1
                          )
                        } catch (g) {
                          return !1
                        }
                      })(),
                    },
                  }
                  function h(g) {
                    var y = 65536,
                      m = r.getTypeOf(g),
                      v = !0
                    if (
                      (m === 'uint8array'
                        ? (v = d.applyCanBeUsed.uint8array)
                        : m === 'nodebuffer' && (v = d.applyCanBeUsed.nodebuffer),
                      v)
                    )
                      for (; 1 < y; )
                        try {
                          return d.stringifyByChunk(g, m, y)
                        } catch (x) {
                          y = Math.floor(y / 2)
                        }
                    return d.stringifyByChar(g)
                  }
                  function f(g, y) {
                    for (var m = 0; m < g.length; m++) y[m] = g[m]
                    return y
                  }
                  r.applyFromCharCode = h
                  var p = {}
                  ;((p.string = {
                    string: c,
                    array: function (g) {
                      return u(g, new Array(g.length))
                    },
                    arraybuffer: function (g) {
                      return p.string.uint8array(g).buffer
                    },
                    uint8array: function (g) {
                      return u(g, new Uint8Array(g.length))
                    },
                    nodebuffer: function (g) {
                      return u(g, a.allocBuffer(g.length))
                    },
                  }),
                    (p.array = {
                      string: h,
                      array: c,
                      arraybuffer: function (g) {
                        return new Uint8Array(g).buffer
                      },
                      uint8array: function (g) {
                        return new Uint8Array(g)
                      },
                      nodebuffer: function (g) {
                        return a.newBufferFrom(g)
                      },
                    }),
                    (p.arraybuffer = {
                      string: function (g) {
                        return h(new Uint8Array(g))
                      },
                      array: function (g) {
                        return f(new Uint8Array(g), new Array(g.byteLength))
                      },
                      arraybuffer: c,
                      uint8array: function (g) {
                        return new Uint8Array(g)
                      },
                      nodebuffer: function (g) {
                        return a.newBufferFrom(new Uint8Array(g))
                      },
                    }),
                    (p.uint8array = {
                      string: h,
                      array: function (g) {
                        return f(g, new Array(g.length))
                      },
                      arraybuffer: function (g) {
                        return g.buffer
                      },
                      uint8array: c,
                      nodebuffer: function (g) {
                        return a.newBufferFrom(g)
                      },
                    }),
                    (p.nodebuffer = {
                      string: h,
                      array: function (g) {
                        return f(g, new Array(g.length))
                      },
                      arraybuffer: function (g) {
                        return p.nodebuffer.uint8array(g).buffer
                      },
                      uint8array: function (g) {
                        return f(g, new Uint8Array(g.length))
                      },
                      nodebuffer: c,
                    }),
                    (r.transformTo = function (g, y) {
                      if (((y = y || ''), !g)) return y
                      r.checkSupport(g)
                      var m = r.getTypeOf(y)
                      return p[m][g](y)
                    }),
                    (r.resolve = function (g) {
                      for (var y = g.split('/'), m = [], v = 0; v < y.length; v++) {
                        var x = y[v]
                        x === '.' ||
                          (x === '' && v !== 0 && v !== y.length - 1) ||
                          (x === '..' ? m.pop() : m.push(x))
                      }
                      return m.join('/')
                    }),
                    (r.getTypeOf = function (g) {
                      return typeof g == 'string'
                        ? 'string'
                        : Object.prototype.toString.call(g) === '[object Array]'
                          ? 'array'
                          : s.nodebuffer && a.isBuffer(g)
                            ? 'nodebuffer'
                            : s.uint8array && g instanceof Uint8Array
                              ? 'uint8array'
                              : s.arraybuffer && g instanceof ArrayBuffer
                                ? 'arraybuffer'
                                : void 0
                    }),
                    (r.checkSupport = function (g) {
                      if (!s[g.toLowerCase()])
                        throw new Error(g + ' is not supported by this platform')
                    }),
                    (r.MAX_VALUE_16BITS = 65535),
                    (r.MAX_VALUE_32BITS = -1),
                    (r.pretty = function (g) {
                      var y,
                        m,
                        v = ''
                      for (m = 0; m < (g || '').length; m++)
                        v +=
                          '\\x' +
                          ((y = g.charCodeAt(m)) < 16 ? '0' : '') +
                          y.toString(16).toUpperCase()
                      return v
                    }),
                    (r.delay = function (g, y, m) {
                      setImmediate(function () {
                        g.apply(m || null, y || [])
                      })
                    }),
                    (r.inherits = function (g, y) {
                      function m() {}
                      ;((m.prototype = y.prototype), (g.prototype = new m()))
                    }),
                    (r.extend = function () {
                      var g,
                        y,
                        m = {}
                      for (g = 0; g < arguments.length; g++)
                        for (y in arguments[g])
                          Object.prototype.hasOwnProperty.call(arguments[g], y) &&
                            m[y] === void 0 &&
                            (m[y] = arguments[g][y])
                      return m
                    }),
                    (r.prepareContent = function (g, y, m, v, x) {
                      return l.Promise.resolve(y)
                        .then(function (_) {
                          return s.blob &&
                            (_ instanceof Blob ||
                              ['[object File]', '[object Blob]'].indexOf(
                                Object.prototype.toString.call(_)
                              ) !== -1) &&
                            typeof FileReader < 'u'
                            ? new l.Promise(function (S, C) {
                                var A = new FileReader()
                                ;((A.onload = function (R) {
                                  S(R.target.result)
                                }),
                                  (A.onerror = function (R) {
                                    C(R.target.error)
                                  }),
                                  A.readAsArrayBuffer(_))
                              })
                            : _
                        })
                        .then(function (_) {
                          var S = r.getTypeOf(_)
                          return S
                            ? (S === 'arraybuffer'
                                ? (_ = r.transformTo('uint8array', _))
                                : S === 'string' &&
                                  (x
                                    ? (_ = o.decode(_))
                                    : m &&
                                      v !== !0 &&
                                      (_ = (function (C) {
                                        return u(
                                          C,
                                          s.uint8array
                                            ? new Uint8Array(C.length)
                                            : new Array(C.length)
                                        )
                                      })(_))),
                              _)
                            : l.Promise.reject(
                                new Error(
                                  "Can't read the data of '" +
                                    g +
                                    "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"
                                )
                              )
                        })
                    }))
                },
                {
                  './base64': 1,
                  './external': 6,
                  './nodejsUtils': 14,
                  './support': 30,
                  setimmediate: 54,
                },
              ],
              33: [
                function (t, i, r) {
                  var s = t('./reader/readerFor'),
                    o = t('./utils'),
                    a = t('./signature'),
                    l = t('./zipEntry'),
                    c = t('./support')
                  function u(d) {
                    ;((this.files = []), (this.loadOptions = d))
                  }
                  ;((u.prototype = {
                    checkSignature: function (d) {
                      if (!this.reader.readAndCheckSignature(d)) {
                        this.reader.index -= 4
                        var h = this.reader.readString(4)
                        throw new Error(
                          'Corrupted zip or bug: unexpected signature (' +
                            o.pretty(h) +
                            ', expected ' +
                            o.pretty(d) +
                            ')'
                        )
                      }
                    },
                    isSignature: function (d, h) {
                      var f = this.reader.index
                      this.reader.setIndex(d)
                      var p = this.reader.readString(4) === h
                      return (this.reader.setIndex(f), p)
                    },
                    readBlockEndOfCentral: function () {
                      ;((this.diskNumber = this.reader.readInt(2)),
                        (this.diskWithCentralDirStart = this.reader.readInt(2)),
                        (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                        (this.centralDirRecords = this.reader.readInt(2)),
                        (this.centralDirSize = this.reader.readInt(4)),
                        (this.centralDirOffset = this.reader.readInt(4)),
                        (this.zipCommentLength = this.reader.readInt(2)))
                      var d = this.reader.readData(this.zipCommentLength),
                        h = c.uint8array ? 'uint8array' : 'array',
                        f = o.transformTo(h, d)
                      this.zipComment = this.loadOptions.decodeFileName(f)
                    },
                    readBlockZip64EndOfCentral: function () {
                      ;((this.zip64EndOfCentralSize = this.reader.readInt(8)),
                        this.reader.skip(4),
                        (this.diskNumber = this.reader.readInt(4)),
                        (this.diskWithCentralDirStart = this.reader.readInt(4)),
                        (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                        (this.centralDirRecords = this.reader.readInt(8)),
                        (this.centralDirSize = this.reader.readInt(8)),
                        (this.centralDirOffset = this.reader.readInt(8)),
                        (this.zip64ExtensibleData = {}))
                      for (var d, h, f, p = this.zip64EndOfCentralSize - 44; 0 < p; )
                        ((d = this.reader.readInt(2)),
                          (h = this.reader.readInt(4)),
                          (f = this.reader.readData(h)),
                          (this.zip64ExtensibleData[d] = { id: d, length: h, value: f }))
                    },
                    readBlockZip64EndOfCentralLocator: function () {
                      if (
                        ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                        (this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8)),
                        (this.disksCount = this.reader.readInt(4)),
                        1 < this.disksCount)
                      )
                        throw new Error('Multi-volumes zip are not supported')
                    },
                    readLocalFiles: function () {
                      var d, h
                      for (d = 0; d < this.files.length; d++)
                        ((h = this.files[d]),
                          this.reader.setIndex(h.localHeaderOffset),
                          this.checkSignature(a.LOCAL_FILE_HEADER),
                          h.readLocalPart(this.reader),
                          h.handleUTF8(),
                          h.processAttributes())
                    },
                    readCentralDir: function () {
                      var d
                      for (
                        this.reader.setIndex(this.centralDirOffset);
                        this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER);

                      )
                        ((d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(
                          this.reader
                        ),
                          this.files.push(d))
                      if (
                        this.centralDirRecords !== this.files.length &&
                        this.centralDirRecords !== 0 &&
                        this.files.length === 0
                      )
                        throw new Error(
                          'Corrupted zip or bug: expected ' +
                            this.centralDirRecords +
                            ' records in central dir, got ' +
                            this.files.length
                        )
                    },
                    readEndOfCentral: function () {
                      var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END)
                      if (d < 0)
                        throw this.isSignature(0, a.LOCAL_FILE_HEADER)
                          ? new Error("Corrupted zip: can't find end of central directory")
                          : new Error(
                              "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"
                            )
                      this.reader.setIndex(d)
                      var h = d
                      if (
                        (this.checkSignature(a.CENTRAL_DIRECTORY_END),
                        this.readBlockEndOfCentral(),
                        this.diskNumber === o.MAX_VALUE_16BITS ||
                          this.diskWithCentralDirStart === o.MAX_VALUE_16BITS ||
                          this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS ||
                          this.centralDirRecords === o.MAX_VALUE_16BITS ||
                          this.centralDirSize === o.MAX_VALUE_32BITS ||
                          this.centralDirOffset === o.MAX_VALUE_32BITS)
                      ) {
                        if (
                          ((this.zip64 = !0),
                          (d = this.reader.lastIndexOfSignature(
                            a.ZIP64_CENTRAL_DIRECTORY_LOCATOR
                          )) < 0)
                        )
                          throw new Error(
                            "Corrupted zip: can't find the ZIP64 end of central directory locator"
                          )
                        if (
                          (this.reader.setIndex(d),
                          this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                          this.readBlockZip64EndOfCentralLocator(),
                          !this.isSignature(
                            this.relativeOffsetEndOfZip64CentralDir,
                            a.ZIP64_CENTRAL_DIRECTORY_END
                          ) &&
                            ((this.relativeOffsetEndOfZip64CentralDir =
                              this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END)),
                            this.relativeOffsetEndOfZip64CentralDir < 0))
                        )
                          throw new Error(
                            "Corrupted zip: can't find the ZIP64 end of central directory"
                          )
                        ;(this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                          this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END),
                          this.readBlockZip64EndOfCentral())
                      }
                      var f = this.centralDirOffset + this.centralDirSize
                      this.zip64 && ((f += 20), (f += 12 + this.zip64EndOfCentralSize))
                      var p = h - f
                      if (0 < p)
                        this.isSignature(h, a.CENTRAL_FILE_HEADER) || (this.reader.zero = p)
                      else if (p < 0)
                        throw new Error('Corrupted zip: missing ' + Math.abs(p) + ' bytes.')
                    },
                    prepareReader: function (d) {
                      this.reader = s(d)
                    },
                    load: function (d) {
                      ;(this.prepareReader(d),
                        this.readEndOfCentral(),
                        this.readCentralDir(),
                        this.readLocalFiles())
                    },
                  }),
                    (i.exports = u))
                },
                {
                  './reader/readerFor': 22,
                  './signature': 23,
                  './support': 30,
                  './utils': 32,
                  './zipEntry': 34,
                },
              ],
              34: [
                function (t, i, r) {
                  var s = t('./reader/readerFor'),
                    o = t('./utils'),
                    a = t('./compressedObject'),
                    l = t('./crc32'),
                    c = t('./utf8'),
                    u = t('./compressions'),
                    d = t('./support')
                  function h(f, p) {
                    ;((this.options = f), (this.loadOptions = p))
                  }
                  ;((h.prototype = {
                    isEncrypted: function () {
                      return (1 & this.bitFlag) == 1
                    },
                    useUTF8: function () {
                      return (2048 & this.bitFlag) == 2048
                    },
                    readLocalPart: function (f) {
                      var p, g
                      if (
                        (f.skip(22),
                        (this.fileNameLength = f.readInt(2)),
                        (g = f.readInt(2)),
                        (this.fileName = f.readData(this.fileNameLength)),
                        f.skip(g),
                        this.compressedSize === -1 || this.uncompressedSize === -1)
                      )
                        throw new Error(
                          "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"
                        )
                      if (
                        (p = (function (y) {
                          for (var m in u)
                            if (Object.prototype.hasOwnProperty.call(u, m) && u[m].magic === y)
                              return u[m]
                          return null
                        })(this.compressionMethod)) === null
                      )
                        throw new Error(
                          'Corrupted zip : compression ' +
                            o.pretty(this.compressionMethod) +
                            ' unknown (inner file : ' +
                            o.transformTo('string', this.fileName) +
                            ')'
                        )
                      this.decompressed = new a(
                        this.compressedSize,
                        this.uncompressedSize,
                        this.crc32,
                        p,
                        f.readData(this.compressedSize)
                      )
                    },
                    readCentralPart: function (f) {
                      ;((this.versionMadeBy = f.readInt(2)),
                        f.skip(2),
                        (this.bitFlag = f.readInt(2)),
                        (this.compressionMethod = f.readString(2)),
                        (this.date = f.readDate()),
                        (this.crc32 = f.readInt(4)),
                        (this.compressedSize = f.readInt(4)),
                        (this.uncompressedSize = f.readInt(4)))
                      var p = f.readInt(2)
                      if (
                        ((this.extraFieldsLength = f.readInt(2)),
                        (this.fileCommentLength = f.readInt(2)),
                        (this.diskNumberStart = f.readInt(2)),
                        (this.internalFileAttributes = f.readInt(2)),
                        (this.externalFileAttributes = f.readInt(4)),
                        (this.localHeaderOffset = f.readInt(4)),
                        this.isEncrypted())
                      )
                        throw new Error('Encrypted zip are not supported')
                      ;(f.skip(p),
                        this.readExtraFields(f),
                        this.parseZIP64ExtraField(f),
                        (this.fileComment = f.readData(this.fileCommentLength)))
                    },
                    processAttributes: function () {
                      ;((this.unixPermissions = null), (this.dosPermissions = null))
                      var f = this.versionMadeBy >> 8
                      ;((this.dir = !!(16 & this.externalFileAttributes)),
                        f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes),
                        f == 3 &&
                          (this.unixPermissions = (this.externalFileAttributes >> 16) & 65535),
                        this.dir || this.fileNameStr.slice(-1) !== '/' || (this.dir = !0))
                    },
                    parseZIP64ExtraField: function () {
                      if (this.extraFields[1]) {
                        var f = s(this.extraFields[1].value)
                        ;(this.uncompressedSize === o.MAX_VALUE_32BITS &&
                          (this.uncompressedSize = f.readInt(8)),
                          this.compressedSize === o.MAX_VALUE_32BITS &&
                            (this.compressedSize = f.readInt(8)),
                          this.localHeaderOffset === o.MAX_VALUE_32BITS &&
                            (this.localHeaderOffset = f.readInt(8)),
                          this.diskNumberStart === o.MAX_VALUE_32BITS &&
                            (this.diskNumberStart = f.readInt(4)))
                      }
                    },
                    readExtraFields: function (f) {
                      var p,
                        g,
                        y,
                        m = f.index + this.extraFieldsLength
                      for (this.extraFields || (this.extraFields = {}); f.index + 4 < m; )
                        ((p = f.readInt(2)),
                          (g = f.readInt(2)),
                          (y = f.readData(g)),
                          (this.extraFields[p] = { id: p, length: g, value: y }))
                      f.setIndex(m)
                    },
                    handleUTF8: function () {
                      var f = d.uint8array ? 'uint8array' : 'array'
                      if (this.useUTF8())
                        ((this.fileNameStr = c.utf8decode(this.fileName)),
                          (this.fileCommentStr = c.utf8decode(this.fileComment)))
                      else {
                        var p = this.findExtraFieldUnicodePath()
                        if (p !== null) this.fileNameStr = p
                        else {
                          var g = o.transformTo(f, this.fileName)
                          this.fileNameStr = this.loadOptions.decodeFileName(g)
                        }
                        var y = this.findExtraFieldUnicodeComment()
                        if (y !== null) this.fileCommentStr = y
                        else {
                          var m = o.transformTo(f, this.fileComment)
                          this.fileCommentStr = this.loadOptions.decodeFileName(m)
                        }
                      }
                    },
                    findExtraFieldUnicodePath: function () {
                      var f = this.extraFields[28789]
                      if (f) {
                        var p = s(f.value)
                        return p.readInt(1) !== 1 || l(this.fileName) !== p.readInt(4)
                          ? null
                          : c.utf8decode(p.readData(f.length - 5))
                      }
                      return null
                    },
                    findExtraFieldUnicodeComment: function () {
                      var f = this.extraFields[25461]
                      if (f) {
                        var p = s(f.value)
                        return p.readInt(1) !== 1 || l(this.fileComment) !== p.readInt(4)
                          ? null
                          : c.utf8decode(p.readData(f.length - 5))
                      }
                      return null
                    },
                  }),
                    (i.exports = h))
                },
                {
                  './compressedObject': 2,
                  './compressions': 3,
                  './crc32': 4,
                  './reader/readerFor': 22,
                  './support': 30,
                  './utf8': 31,
                  './utils': 32,
                },
              ],
              35: [
                function (t, i, r) {
                  function s(p, g, y) {
                    ;((this.name = p),
                      (this.dir = y.dir),
                      (this.date = y.date),
                      (this.comment = y.comment),
                      (this.unixPermissions = y.unixPermissions),
                      (this.dosPermissions = y.dosPermissions),
                      (this._data = g),
                      (this._dataBinary = y.binary),
                      (this.options = {
                        compression: y.compression,
                        compressionOptions: y.compressionOptions,
                      }))
                  }
                  var o = t('./stream/StreamHelper'),
                    a = t('./stream/DataWorker'),
                    l = t('./utf8'),
                    c = t('./compressedObject'),
                    u = t('./stream/GenericWorker')
                  s.prototype = {
                    internalStream: function (p) {
                      var g = null,
                        y = 'string'
                      try {
                        if (!p) throw new Error('No output type specified.')
                        var m = (y = p.toLowerCase()) === 'string' || y === 'text'
                        ;((y !== 'binarystring' && y !== 'text') || (y = 'string'),
                          (g = this._decompressWorker()))
                        var v = !this._dataBinary
                        ;(v && !m && (g = g.pipe(new l.Utf8EncodeWorker())),
                          !v && m && (g = g.pipe(new l.Utf8DecodeWorker())))
                      } catch (x) {
                        ;(g = new u('error')).error(x)
                      }
                      return new o(g, y, '')
                    },
                    async: function (p, g) {
                      return this.internalStream(p).accumulate(g)
                    },
                    nodeStream: function (p, g) {
                      return this.internalStream(p || 'nodebuffer').toNodejsStream(g)
                    },
                    _compressWorker: function (p, g) {
                      if (this._data instanceof c && this._data.compression.magic === p.magic)
                        return this._data.getCompressedWorker()
                      var y = this._decompressWorker()
                      return (
                        this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())),
                        c.createWorkerFrom(y, p, g)
                      )
                    },
                    _decompressWorker: function () {
                      return this._data instanceof c
                        ? this._data.getContentWorker()
                        : this._data instanceof u
                          ? this._data
                          : new a(this._data)
                    },
                  }
                  for (
                    var d = ['asText', 'asBinary', 'asNodeBuffer', 'asUint8Array', 'asArrayBuffer'],
                      h = function () {
                        throw new Error(
                          'This method has been removed in JSZip 3.0, please check the upgrade guide.'
                        )
                      },
                      f = 0;
                    f < d.length;
                    f++
                  )
                    s.prototype[d[f]] = h
                  i.exports = s
                },
                {
                  './compressedObject': 2,
                  './stream/DataWorker': 27,
                  './stream/GenericWorker': 28,
                  './stream/StreamHelper': 29,
                  './utf8': 31,
                },
              ],
              36: [
                function (t, i, r) {
                  ;(function (s) {
                    var o,
                      a,
                      l = s.MutationObserver || s.WebKitMutationObserver
                    if (l) {
                      var c = 0,
                        u = new l(p),
                        d = s.document.createTextNode('')
                      ;(u.observe(d, { characterData: !0 }),
                        (o = function () {
                          d.data = c = ++c % 2
                        }))
                    } else if (s.setImmediate || s.MessageChannel === void 0)
                      o =
                        'document' in s &&
                        'onreadystatechange' in s.document.createElement('script')
                          ? function () {
                              var g = s.document.createElement('script')
                              ;((g.onreadystatechange = function () {
                                ;(p(),
                                  (g.onreadystatechange = null),
                                  g.parentNode.removeChild(g),
                                  (g = null))
                              }),
                                s.document.documentElement.appendChild(g))
                            }
                          : function () {
                              setTimeout(p, 0)
                            }
                    else {
                      var h = new s.MessageChannel()
                      ;((h.port1.onmessage = p),
                        (o = function () {
                          h.port2.postMessage(0)
                        }))
                    }
                    var f = []
                    function p() {
                      var g, y
                      a = !0
                      for (var m = f.length; m; ) {
                        for (y = f, f = [], g = -1; ++g < m; ) y[g]()
                        m = f.length
                      }
                      a = !1
                    }
                    i.exports = function (g) {
                      f.push(g) !== 1 || a || o()
                    }
                  }).call(
                    this,
                    typeof Bc < 'u'
                      ? Bc
                      : typeof self < 'u'
                        ? self
                        : typeof window < 'u'
                          ? window
                          : {}
                  )
                },
                {},
              ],
              37: [
                function (t, i, r) {
                  var s = t('immediate')
                  function o() {}
                  var a = {},
                    l = ['REJECTED'],
                    c = ['FULFILLED'],
                    u = ['PENDING']
                  function d(m) {
                    if (typeof m != 'function') throw new TypeError('resolver must be a function')
                    ;((this.state = u),
                      (this.queue = []),
                      (this.outcome = void 0),
                      m !== o && g(this, m))
                  }
                  function h(m, v, x) {
                    ;((this.promise = m),
                      typeof v == 'function' &&
                        ((this.onFulfilled = v), (this.callFulfilled = this.otherCallFulfilled)),
                      typeof x == 'function' &&
                        ((this.onRejected = x), (this.callRejected = this.otherCallRejected)))
                  }
                  function f(m, v, x) {
                    s(function () {
                      var _
                      try {
                        _ = v(x)
                      } catch (S) {
                        return a.reject(m, S)
                      }
                      _ === m
                        ? a.reject(m, new TypeError('Cannot resolve promise with itself'))
                        : a.resolve(m, _)
                    })
                  }
                  function p(m) {
                    var v = m && m.then
                    if (
                      m &&
                      (typeof m == 'object' || typeof m == 'function') &&
                      typeof v == 'function'
                    )
                      return function () {
                        v.apply(m, arguments)
                      }
                  }
                  function g(m, v) {
                    var x = !1
                    function _(A) {
                      x || ((x = !0), a.reject(m, A))
                    }
                    function S(A) {
                      x || ((x = !0), a.resolve(m, A))
                    }
                    var C = y(function () {
                      v(S, _)
                    })
                    C.status === 'error' && _(C.value)
                  }
                  function y(m, v) {
                    var x = {}
                    try {
                      ;((x.value = m(v)), (x.status = 'success'))
                    } catch (_) {
                      ;((x.status = 'error'), (x.value = _))
                    }
                    return x
                  }
                  ;(((i.exports = d).prototype.finally = function (m) {
                    if (typeof m != 'function') return this
                    var v = this.constructor
                    return this.then(
                      function (x) {
                        return v.resolve(m()).then(function () {
                          return x
                        })
                      },
                      function (x) {
                        return v.resolve(m()).then(function () {
                          throw x
                        })
                      }
                    )
                  }),
                    (d.prototype.catch = function (m) {
                      return this.then(null, m)
                    }),
                    (d.prototype.then = function (m, v) {
                      if (
                        (typeof m != 'function' && this.state === c) ||
                        (typeof v != 'function' && this.state === l)
                      )
                        return this
                      var x = new this.constructor(o)
                      return (
                        this.state !== u
                          ? f(x, this.state === c ? m : v, this.outcome)
                          : this.queue.push(new h(x, m, v)),
                        x
                      )
                    }),
                    (h.prototype.callFulfilled = function (m) {
                      a.resolve(this.promise, m)
                    }),
                    (h.prototype.otherCallFulfilled = function (m) {
                      f(this.promise, this.onFulfilled, m)
                    }),
                    (h.prototype.callRejected = function (m) {
                      a.reject(this.promise, m)
                    }),
                    (h.prototype.otherCallRejected = function (m) {
                      f(this.promise, this.onRejected, m)
                    }),
                    (a.resolve = function (m, v) {
                      var x = y(p, v)
                      if (x.status === 'error') return a.reject(m, x.value)
                      var _ = x.value
                      if (_) g(m, _)
                      else {
                        ;((m.state = c), (m.outcome = v))
                        for (var S = -1, C = m.queue.length; ++S < C; ) m.queue[S].callFulfilled(v)
                      }
                      return m
                    }),
                    (a.reject = function (m, v) {
                      ;((m.state = l), (m.outcome = v))
                      for (var x = -1, _ = m.queue.length; ++x < _; ) m.queue[x].callRejected(v)
                      return m
                    }),
                    (d.resolve = function (m) {
                      return m instanceof this ? m : a.resolve(new this(o), m)
                    }),
                    (d.reject = function (m) {
                      var v = new this(o)
                      return a.reject(v, m)
                    }),
                    (d.all = function (m) {
                      var v = this
                      if (Object.prototype.toString.call(m) !== '[object Array]')
                        return this.reject(new TypeError('must be an array'))
                      var x = m.length,
                        _ = !1
                      if (!x) return this.resolve([])
                      for (var S = new Array(x), C = 0, A = -1, R = new this(o); ++A < x; )
                        w(m[A], A)
                      return R
                      function w(M, I) {
                        v.resolve(M).then(
                          function (L) {
                            ;((S[I] = L), ++C !== x || _ || ((_ = !0), a.resolve(R, S)))
                          },
                          function (L) {
                            _ || ((_ = !0), a.reject(R, L))
                          }
                        )
                      }
                    }),
                    (d.race = function (m) {
                      var v = this
                      if (Object.prototype.toString.call(m) !== '[object Array]')
                        return this.reject(new TypeError('must be an array'))
                      var x = m.length,
                        _ = !1
                      if (!x) return this.resolve([])
                      for (var S = -1, C = new this(o); ++S < x; )
                        ((A = m[S]),
                          v.resolve(A).then(
                            function (R) {
                              _ || ((_ = !0), a.resolve(C, R))
                            },
                            function (R) {
                              _ || ((_ = !0), a.reject(C, R))
                            }
                          ))
                      var A
                      return C
                    }))
                },
                { immediate: 36 },
              ],
              38: [
                function (t, i, r) {
                  var s = {}
                  ;((0, t('./lib/utils/common').assign)(
                    s,
                    t('./lib/deflate'),
                    t('./lib/inflate'),
                    t('./lib/zlib/constants')
                  ),
                    (i.exports = s))
                },
                {
                  './lib/deflate': 39,
                  './lib/inflate': 40,
                  './lib/utils/common': 41,
                  './lib/zlib/constants': 44,
                },
              ],
              39: [
                function (t, i, r) {
                  var s = t('./zlib/deflate'),
                    o = t('./utils/common'),
                    a = t('./utils/strings'),
                    l = t('./zlib/messages'),
                    c = t('./zlib/zstream'),
                    u = Object.prototype.toString,
                    d = 0,
                    h = -1,
                    f = 0,
                    p = 8
                  function g(m) {
                    if (!(this instanceof g)) return new g(m)
                    this.options = o.assign(
                      {
                        level: h,
                        method: p,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: f,
                        to: '',
                      },
                      m || {}
                    )
                    var v = this.options
                    ;(v.raw && 0 < v.windowBits
                      ? (v.windowBits = -v.windowBits)
                      : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16),
                      (this.err = 0),
                      (this.msg = ''),
                      (this.ended = !1),
                      (this.chunks = []),
                      (this.strm = new c()),
                      (this.strm.avail_out = 0))
                    var x = s.deflateInit2(
                      this.strm,
                      v.level,
                      v.method,
                      v.windowBits,
                      v.memLevel,
                      v.strategy
                    )
                    if (x !== d) throw new Error(l[x])
                    if ((v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary)) {
                      var _
                      if (
                        ((_ =
                          typeof v.dictionary == 'string'
                            ? a.string2buf(v.dictionary)
                            : u.call(v.dictionary) === '[object ArrayBuffer]'
                              ? new Uint8Array(v.dictionary)
                              : v.dictionary),
                        (x = s.deflateSetDictionary(this.strm, _)) !== d)
                      )
                        throw new Error(l[x])
                      this._dict_set = !0
                    }
                  }
                  function y(m, v) {
                    var x = new g(v)
                    if ((x.push(m, !0), x.err)) throw x.msg || l[x.err]
                    return x.result
                  }
                  ;((g.prototype.push = function (m, v) {
                    var x,
                      _,
                      S = this.strm,
                      C = this.options.chunkSize
                    if (this.ended) return !1
                    ;((_ = v === ~~v ? v : v === !0 ? 4 : 0),
                      typeof m == 'string'
                        ? (S.input = a.string2buf(m))
                        : u.call(m) === '[object ArrayBuffer]'
                          ? (S.input = new Uint8Array(m))
                          : (S.input = m),
                      (S.next_in = 0),
                      (S.avail_in = S.input.length))
                    do {
                      if (
                        (S.avail_out === 0 &&
                          ((S.output = new o.Buf8(C)), (S.next_out = 0), (S.avail_out = C)),
                        (x = s.deflate(S, _)) !== 1 && x !== d)
                      )
                        return (this.onEnd(x), !(this.ended = !0))
                      ;(S.avail_out !== 0 && (S.avail_in !== 0 || (_ !== 4 && _ !== 2))) ||
                        (this.options.to === 'string'
                          ? this.onData(a.buf2binstring(o.shrinkBuf(S.output, S.next_out)))
                          : this.onData(o.shrinkBuf(S.output, S.next_out)))
                    } while ((0 < S.avail_in || S.avail_out === 0) && x !== 1)
                    return _ === 4
                      ? ((x = s.deflateEnd(this.strm)), this.onEnd(x), (this.ended = !0), x === d)
                      : _ !== 2 || (this.onEnd(d), !(S.avail_out = 0))
                  }),
                    (g.prototype.onData = function (m) {
                      this.chunks.push(m)
                    }),
                    (g.prototype.onEnd = function (m) {
                      ;(m === d &&
                        (this.options.to === 'string'
                          ? (this.result = this.chunks.join(''))
                          : (this.result = o.flattenChunks(this.chunks))),
                        (this.chunks = []),
                        (this.err = m),
                        (this.msg = this.strm.msg))
                    }),
                    (r.Deflate = g),
                    (r.deflate = y),
                    (r.deflateRaw = function (m, v) {
                      return (((v = v || {}).raw = !0), y(m, v))
                    }),
                    (r.gzip = function (m, v) {
                      return (((v = v || {}).gzip = !0), y(m, v))
                    }))
                },
                {
                  './utils/common': 41,
                  './utils/strings': 42,
                  './zlib/deflate': 46,
                  './zlib/messages': 51,
                  './zlib/zstream': 53,
                },
              ],
              40: [
                function (t, i, r) {
                  var s = t('./zlib/inflate'),
                    o = t('./utils/common'),
                    a = t('./utils/strings'),
                    l = t('./zlib/constants'),
                    c = t('./zlib/messages'),
                    u = t('./zlib/zstream'),
                    d = t('./zlib/gzheader'),
                    h = Object.prototype.toString
                  function f(g) {
                    if (!(this instanceof f)) return new f(g)
                    this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: '' }, g || {})
                    var y = this.options
                    ;(y.raw &&
                      0 <= y.windowBits &&
                      y.windowBits < 16 &&
                      ((y.windowBits = -y.windowBits), y.windowBits === 0 && (y.windowBits = -15)),
                      !(0 <= y.windowBits && y.windowBits < 16) ||
                        (g && g.windowBits) ||
                        (y.windowBits += 32),
                      15 < y.windowBits &&
                        y.windowBits < 48 &&
                        (15 & y.windowBits) == 0 &&
                        (y.windowBits |= 15),
                      (this.err = 0),
                      (this.msg = ''),
                      (this.ended = !1),
                      (this.chunks = []),
                      (this.strm = new u()),
                      (this.strm.avail_out = 0))
                    var m = s.inflateInit2(this.strm, y.windowBits)
                    if (m !== l.Z_OK) throw new Error(c[m])
                    ;((this.header = new d()), s.inflateGetHeader(this.strm, this.header))
                  }
                  function p(g, y) {
                    var m = new f(y)
                    if ((m.push(g, !0), m.err)) throw m.msg || c[m.err]
                    return m.result
                  }
                  ;((f.prototype.push = function (g, y) {
                    var m,
                      v,
                      x,
                      _,
                      S,
                      C,
                      A = this.strm,
                      R = this.options.chunkSize,
                      w = this.options.dictionary,
                      M = !1
                    if (this.ended) return !1
                    ;((v = y === ~~y ? y : y === !0 ? l.Z_FINISH : l.Z_NO_FLUSH),
                      typeof g == 'string'
                        ? (A.input = a.binstring2buf(g))
                        : h.call(g) === '[object ArrayBuffer]'
                          ? (A.input = new Uint8Array(g))
                          : (A.input = g),
                      (A.next_in = 0),
                      (A.avail_in = A.input.length))
                    do {
                      if (
                        (A.avail_out === 0 &&
                          ((A.output = new o.Buf8(R)), (A.next_out = 0), (A.avail_out = R)),
                        (m = s.inflate(A, l.Z_NO_FLUSH)) === l.Z_NEED_DICT &&
                          w &&
                          ((C =
                            typeof w == 'string'
                              ? a.string2buf(w)
                              : h.call(w) === '[object ArrayBuffer]'
                                ? new Uint8Array(w)
                                : w),
                          (m = s.inflateSetDictionary(this.strm, C))),
                        m === l.Z_BUF_ERROR && M === !0 && ((m = l.Z_OK), (M = !1)),
                        m !== l.Z_STREAM_END && m !== l.Z_OK)
                      )
                        return (this.onEnd(m), !(this.ended = !0))
                      ;(A.next_out &&
                        ((A.avail_out !== 0 &&
                          m !== l.Z_STREAM_END &&
                          (A.avail_in !== 0 || (v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH))) ||
                          (this.options.to === 'string'
                            ? ((x = a.utf8border(A.output, A.next_out)),
                              (_ = A.next_out - x),
                              (S = a.buf2string(A.output, x)),
                              (A.next_out = _),
                              (A.avail_out = R - _),
                              _ && o.arraySet(A.output, A.output, x, _, 0),
                              this.onData(S))
                            : this.onData(o.shrinkBuf(A.output, A.next_out)))),
                        A.avail_in === 0 && A.avail_out === 0 && (M = !0))
                    } while ((0 < A.avail_in || A.avail_out === 0) && m !== l.Z_STREAM_END)
                    return (
                      m === l.Z_STREAM_END && (v = l.Z_FINISH),
                      v === l.Z_FINISH
                        ? ((m = s.inflateEnd(this.strm)),
                          this.onEnd(m),
                          (this.ended = !0),
                          m === l.Z_OK)
                        : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(A.avail_out = 0))
                    )
                  }),
                    (f.prototype.onData = function (g) {
                      this.chunks.push(g)
                    }),
                    (f.prototype.onEnd = function (g) {
                      ;(g === l.Z_OK &&
                        (this.options.to === 'string'
                          ? (this.result = this.chunks.join(''))
                          : (this.result = o.flattenChunks(this.chunks))),
                        (this.chunks = []),
                        (this.err = g),
                        (this.msg = this.strm.msg))
                    }),
                    (r.Inflate = f),
                    (r.inflate = p),
                    (r.inflateRaw = function (g, y) {
                      return (((y = y || {}).raw = !0), p(g, y))
                    }),
                    (r.ungzip = p))
                },
                {
                  './utils/common': 41,
                  './utils/strings': 42,
                  './zlib/constants': 44,
                  './zlib/gzheader': 47,
                  './zlib/inflate': 49,
                  './zlib/messages': 51,
                  './zlib/zstream': 53,
                },
              ],
              41: [
                function (t, i, r) {
                  var s =
                    typeof Uint8Array < 'u' && typeof Uint16Array < 'u' && typeof Int32Array < 'u'
                  ;((r.assign = function (l) {
                    for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
                      var u = c.shift()
                      if (u) {
                        if (typeof u != 'object') throw new TypeError(u + 'must be non-object')
                        for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d])
                      }
                    }
                    return l
                  }),
                    (r.shrinkBuf = function (l, c) {
                      return l.length === c
                        ? l
                        : l.subarray
                          ? l.subarray(0, c)
                          : ((l.length = c), l)
                    }))
                  var o = {
                      arraySet: function (l, c, u, d, h) {
                        if (c.subarray && l.subarray) l.set(c.subarray(u, u + d), h)
                        else for (var f = 0; f < d; f++) l[h + f] = c[u + f]
                      },
                      flattenChunks: function (l) {
                        var c, u, d, h, f, p
                        for (c = d = 0, u = l.length; c < u; c++) d += l[c].length
                        for (p = new Uint8Array(d), c = h = 0, u = l.length; c < u; c++)
                          ((f = l[c]), p.set(f, h), (h += f.length))
                        return p
                      },
                    },
                    a = {
                      arraySet: function (l, c, u, d, h) {
                        for (var f = 0; f < d; f++) l[h + f] = c[u + f]
                      },
                      flattenChunks: function (l) {
                        return [].concat.apply([], l)
                      },
                    }
                  ;((r.setTyped = function (l) {
                    l
                      ? ((r.Buf8 = Uint8Array),
                        (r.Buf16 = Uint16Array),
                        (r.Buf32 = Int32Array),
                        r.assign(r, o))
                      : ((r.Buf8 = Array), (r.Buf16 = Array), (r.Buf32 = Array), r.assign(r, a))
                  }),
                    r.setTyped(s))
                },
                {},
              ],
              42: [
                function (t, i, r) {
                  var s = t('./common'),
                    o = !0,
                    a = !0
                  try {
                    String.fromCharCode.apply(null, [0])
                  } catch (d) {
                    o = !1
                  }
                  try {
                    String.fromCharCode.apply(null, new Uint8Array(1))
                  } catch (d) {
                    a = !1
                  }
                  for (var l = new s.Buf8(256), c = 0; c < 256; c++)
                    l[c] =
                      252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1
                  function u(d, h) {
                    if (h < 65537 && ((d.subarray && a) || (!d.subarray && o)))
                      return String.fromCharCode.apply(null, s.shrinkBuf(d, h))
                    for (var f = '', p = 0; p < h; p++) f += String.fromCharCode(d[p])
                    return f
                  }
                  ;((l[254] = l[254] = 1),
                    (r.string2buf = function (d) {
                      var h,
                        f,
                        p,
                        g,
                        y,
                        m = d.length,
                        v = 0
                      for (g = 0; g < m; g++)
                        ((64512 & (f = d.charCodeAt(g))) == 55296 &&
                          g + 1 < m &&
                          (64512 & (p = d.charCodeAt(g + 1))) == 56320 &&
                          ((f = 65536 + ((f - 55296) << 10) + (p - 56320)), g++),
                          (v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4))
                      for (h = new s.Buf8(v), g = y = 0; y < v; g++)
                        ((64512 & (f = d.charCodeAt(g))) == 55296 &&
                          g + 1 < m &&
                          (64512 & (p = d.charCodeAt(g + 1))) == 56320 &&
                          ((f = 65536 + ((f - 55296) << 10) + (p - 56320)), g++),
                          f < 128
                            ? (h[y++] = f)
                            : (f < 2048
                                ? (h[y++] = 192 | (f >>> 6))
                                : (f < 65536
                                    ? (h[y++] = 224 | (f >>> 12))
                                    : ((h[y++] = 240 | (f >>> 18)),
                                      (h[y++] = 128 | ((f >>> 12) & 63))),
                                  (h[y++] = 128 | ((f >>> 6) & 63))),
                              (h[y++] = 128 | (63 & f))))
                      return h
                    }),
                    (r.buf2binstring = function (d) {
                      return u(d, d.length)
                    }),
                    (r.binstring2buf = function (d) {
                      for (var h = new s.Buf8(d.length), f = 0, p = h.length; f < p; f++)
                        h[f] = d.charCodeAt(f)
                      return h
                    }),
                    (r.buf2string = function (d, h) {
                      var f,
                        p,
                        g,
                        y,
                        m = h || d.length,
                        v = new Array(2 * m)
                      for (f = p = 0; f < m; )
                        if ((g = d[f++]) < 128) v[p++] = g
                        else if (4 < (y = l[g])) ((v[p++] = 65533), (f += y - 1))
                        else {
                          for (g &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && f < m; )
                            ((g = (g << 6) | (63 & d[f++])), y--)
                          1 < y
                            ? (v[p++] = 65533)
                            : g < 65536
                              ? (v[p++] = g)
                              : ((g -= 65536),
                                (v[p++] = 55296 | ((g >> 10) & 1023)),
                                (v[p++] = 56320 | (1023 & g)))
                        }
                      return u(v, p)
                    }),
                    (r.utf8border = function (d, h) {
                      var f
                      for (
                        (h = h || d.length) > d.length && (h = d.length), f = h - 1;
                        0 <= f && (192 & d[f]) == 128;

                      )
                        f--
                      return f < 0 || f === 0 ? h : f + l[d[f]] > h ? f : h
                    }))
                },
                { './common': 41 },
              ],
              43: [
                function (t, i, r) {
                  i.exports = function (s, o, a, l) {
                    for (var c = (65535 & s) | 0, u = ((s >>> 16) & 65535) | 0, d = 0; a !== 0; ) {
                      for (
                        a -= d = 2e3 < a ? 2e3 : a;
                        (u = (u + (c = (c + o[l++]) | 0)) | 0), --d;

                      );
                      ;((c %= 65521), (u %= 65521))
                    }
                    return c | (u << 16) | 0
                  }
                },
                {},
              ],
              44: [
                function (t, i, r) {
                  i.exports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8,
                  }
                },
                {},
              ],
              45: [
                function (t, i, r) {
                  var s = (function () {
                    for (var o, a = [], l = 0; l < 256; l++) {
                      o = l
                      for (var c = 0; c < 8; c++) o = 1 & o ? 3988292384 ^ (o >>> 1) : o >>> 1
                      a[l] = o
                    }
                    return a
                  })()
                  i.exports = function (o, a, l, c) {
                    var u = s,
                      d = c + l
                    o ^= -1
                    for (var h = c; h < d; h++) o = (o >>> 8) ^ u[255 & (o ^ a[h])]
                    return -1 ^ o
                  }
                },
                {},
              ],
              46: [
                function (t, i, r) {
                  var s,
                    o = t('../utils/common'),
                    a = t('./trees'),
                    l = t('./adler32'),
                    c = t('./crc32'),
                    u = t('./messages'),
                    d = 0,
                    h = 4,
                    f = 0,
                    p = -2,
                    g = -1,
                    y = 4,
                    m = 2,
                    v = 8,
                    x = 9,
                    _ = 286,
                    S = 30,
                    C = 19,
                    A = 2 * _ + 1,
                    R = 15,
                    w = 3,
                    M = 258,
                    I = M + w + 1,
                    L = 42,
                    U = 113,
                    T = 1,
                    F = 2,
                    V = 3,
                    W = 4
                  function ee(b, oe) {
                    return ((b.msg = u[oe]), oe)
                  }
                  function se(b) {
                    return (b << 1) - (4 < b ? 9 : 0)
                  }
                  function he(b) {
                    for (var oe = b.length; 0 <= --oe; ) b[oe] = 0
                  }
                  function ne(b) {
                    var oe = b.state,
                      J = oe.pending
                    ;(J > b.avail_out && (J = b.avail_out),
                      J !== 0 &&
                        (o.arraySet(b.output, oe.pending_buf, oe.pending_out, J, b.next_out),
                        (b.next_out += J),
                        (oe.pending_out += J),
                        (b.total_out += J),
                        (b.avail_out -= J),
                        (oe.pending -= J),
                        oe.pending === 0 && (oe.pending_out = 0)))
                  }
                  function ie(b, oe) {
                    ;(a._tr_flush_block(
                      b,
                      0 <= b.block_start ? b.block_start : -1,
                      b.strstart - b.block_start,
                      oe
                    ),
                      (b.block_start = b.strstart),
                      ne(b.strm))
                  }
                  function be(b, oe) {
                    b.pending_buf[b.pending++] = oe
                  }
                  function le(b, oe) {
                    ;((b.pending_buf[b.pending++] = (oe >>> 8) & 255),
                      (b.pending_buf[b.pending++] = 255 & oe))
                  }
                  function fe(b, oe) {
                    var J,
                      H,
                      P = b.max_chain_length,
                      k = b.strstart,
                      j = b.prev_length,
                      B = b.nice_match,
                      D = b.strstart > b.w_size - I ? b.strstart - (b.w_size - I) : 0,
                      Q = b.window,
                      G = b.w_mask,
                      X = b.prev,
                      ue = b.strstart + M,
                      z = Q[k + j - 1],
                      E = Q[k + j]
                    ;(b.prev_length >= b.good_match && (P >>= 2),
                      B > b.lookahead && (B = b.lookahead))
                    do
                      if (
                        Q[(J = oe) + j] === E &&
                        Q[J + j - 1] === z &&
                        Q[J] === Q[k] &&
                        Q[++J] === Q[k + 1]
                      ) {
                        ;((k += 2), J++)
                        do;
                        while (
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          Q[++k] === Q[++J] &&
                          k < ue
                        )
                        if (((H = M - (ue - k)), (k = ue - M), j < H)) {
                          if (((b.match_start = oe), B <= (j = H))) break
                          ;((z = Q[k + j - 1]), (E = Q[k + j]))
                        }
                      }
                    while ((oe = X[oe & G]) > D && --P != 0)
                    return j <= b.lookahead ? j : b.lookahead
                  }
                  function we(b) {
                    var oe,
                      J,
                      H,
                      P,
                      k,
                      j,
                      B,
                      D,
                      Q,
                      G,
                      X = b.w_size
                    do {
                      if (
                        ((P = b.window_size - b.lookahead - b.strstart), b.strstart >= X + (X - I))
                      ) {
                        for (
                          o.arraySet(b.window, b.window, X, X, 0),
                            b.match_start -= X,
                            b.strstart -= X,
                            b.block_start -= X,
                            oe = J = b.hash_size;
                          (H = b.head[--oe]), (b.head[oe] = X <= H ? H - X : 0), --J;

                        );
                        for (
                          oe = J = X;
                          (H = b.prev[--oe]), (b.prev[oe] = X <= H ? H - X : 0), --J;

                        );
                        P += X
                      }
                      if (b.strm.avail_in === 0) break
                      if (
                        ((j = b.strm),
                        (B = b.window),
                        (D = b.strstart + b.lookahead),
                        (Q = P),
                        (G = void 0),
                        (G = j.avail_in),
                        Q < G && (G = Q),
                        (J =
                          G === 0
                            ? 0
                            : ((j.avail_in -= G),
                              o.arraySet(B, j.input, j.next_in, G, D),
                              j.state.wrap === 1
                                ? (j.adler = l(j.adler, B, G, D))
                                : j.state.wrap === 2 && (j.adler = c(j.adler, B, G, D)),
                              (j.next_in += G),
                              (j.total_in += G),
                              G)),
                        (b.lookahead += J),
                        b.lookahead + b.insert >= w)
                      )
                        for (
                          k = b.strstart - b.insert,
                            b.ins_h = b.window[k],
                            b.ins_h = ((b.ins_h << b.hash_shift) ^ b.window[k + 1]) & b.hash_mask;
                          b.insert &&
                          ((b.ins_h =
                            ((b.ins_h << b.hash_shift) ^ b.window[k + w - 1]) & b.hash_mask),
                          (b.prev[k & b.w_mask] = b.head[b.ins_h]),
                          (b.head[b.ins_h] = k),
                          k++,
                          b.insert--,
                          !(b.lookahead + b.insert < w));

                        );
                    } while (b.lookahead < I && b.strm.avail_in !== 0)
                  }
                  function Ee(b, oe) {
                    for (var J, H; ; ) {
                      if (b.lookahead < I) {
                        if ((we(b), b.lookahead < I && oe === d)) return T
                        if (b.lookahead === 0) break
                      }
                      if (
                        ((J = 0),
                        b.lookahead >= w &&
                          ((b.ins_h =
                            ((b.ins_h << b.hash_shift) ^ b.window[b.strstart + w - 1]) &
                            b.hash_mask),
                          (J = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h]),
                          (b.head[b.ins_h] = b.strstart)),
                        J !== 0 && b.strstart - J <= b.w_size - I && (b.match_length = fe(b, J)),
                        b.match_length >= w)
                      )
                        if (
                          ((H = a._tr_tally(b, b.strstart - b.match_start, b.match_length - w)),
                          (b.lookahead -= b.match_length),
                          b.match_length <= b.max_lazy_match && b.lookahead >= w)
                        ) {
                          for (
                            b.match_length--;
                            b.strstart++,
                              (b.ins_h =
                                ((b.ins_h << b.hash_shift) ^ b.window[b.strstart + w - 1]) &
                                b.hash_mask),
                              (J = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h]),
                              (b.head[b.ins_h] = b.strstart),
                              --b.match_length != 0;

                          );
                          b.strstart++
                        } else
                          ((b.strstart += b.match_length),
                            (b.match_length = 0),
                            (b.ins_h = b.window[b.strstart]),
                            (b.ins_h =
                              ((b.ins_h << b.hash_shift) ^ b.window[b.strstart + 1]) & b.hash_mask))
                      else
                        ((H = a._tr_tally(b, 0, b.window[b.strstart])), b.lookahead--, b.strstart++)
                      if (H && (ie(b, !1), b.strm.avail_out === 0)) return T
                    }
                    return (
                      (b.insert = b.strstart < w - 1 ? b.strstart : w - 1),
                      oe === h
                        ? (ie(b, !0), b.strm.avail_out === 0 ? V : W)
                        : b.last_lit && (ie(b, !1), b.strm.avail_out === 0)
                          ? T
                          : F
                    )
                  }
                  function Ie(b, oe) {
                    for (var J, H, P; ; ) {
                      if (b.lookahead < I) {
                        if ((we(b), b.lookahead < I && oe === d)) return T
                        if (b.lookahead === 0) break
                      }
                      if (
                        ((J = 0),
                        b.lookahead >= w &&
                          ((b.ins_h =
                            ((b.ins_h << b.hash_shift) ^ b.window[b.strstart + w - 1]) &
                            b.hash_mask),
                          (J = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h]),
                          (b.head[b.ins_h] = b.strstart)),
                        (b.prev_length = b.match_length),
                        (b.prev_match = b.match_start),
                        (b.match_length = w - 1),
                        J !== 0 &&
                          b.prev_length < b.max_lazy_match &&
                          b.strstart - J <= b.w_size - I &&
                          ((b.match_length = fe(b, J)),
                          b.match_length <= 5 &&
                            (b.strategy === 1 ||
                              (b.match_length === w && 4096 < b.strstart - b.match_start)) &&
                            (b.match_length = w - 1)),
                        b.prev_length >= w && b.match_length <= b.prev_length)
                      ) {
                        for (
                          P = b.strstart + b.lookahead - w,
                            H = a._tr_tally(b, b.strstart - 1 - b.prev_match, b.prev_length - w),
                            b.lookahead -= b.prev_length - 1,
                            b.prev_length -= 2;
                          ++b.strstart <= P &&
                            ((b.ins_h =
                              ((b.ins_h << b.hash_shift) ^ b.window[b.strstart + w - 1]) &
                              b.hash_mask),
                            (J = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h]),
                            (b.head[b.ins_h] = b.strstart)),
                            --b.prev_length != 0;

                        );
                        if (
                          ((b.match_available = 0),
                          (b.match_length = w - 1),
                          b.strstart++,
                          H && (ie(b, !1), b.strm.avail_out === 0))
                        )
                          return T
                      } else if (b.match_available) {
                        if (
                          ((H = a._tr_tally(b, 0, b.window[b.strstart - 1])) && ie(b, !1),
                          b.strstart++,
                          b.lookahead--,
                          b.strm.avail_out === 0)
                        )
                          return T
                      } else ((b.match_available = 1), b.strstart++, b.lookahead--)
                    }
                    return (
                      b.match_available &&
                        ((H = a._tr_tally(b, 0, b.window[b.strstart - 1])),
                        (b.match_available = 0)),
                      (b.insert = b.strstart < w - 1 ? b.strstart : w - 1),
                      oe === h
                        ? (ie(b, !0), b.strm.avail_out === 0 ? V : W)
                        : b.last_lit && (ie(b, !1), b.strm.avail_out === 0)
                          ? T
                          : F
                    )
                  }
                  function ze(b, oe, J, H, P) {
                    ;((this.good_length = b),
                      (this.max_lazy = oe),
                      (this.nice_length = J),
                      (this.max_chain = H),
                      (this.func = P))
                  }
                  function Be() {
                    ;((this.strm = null),
                      (this.status = 0),
                      (this.pending_buf = null),
                      (this.pending_buf_size = 0),
                      (this.pending_out = 0),
                      (this.pending = 0),
                      (this.wrap = 0),
                      (this.gzhead = null),
                      (this.gzindex = 0),
                      (this.method = v),
                      (this.last_flush = -1),
                      (this.w_size = 0),
                      (this.w_bits = 0),
                      (this.w_mask = 0),
                      (this.window = null),
                      (this.window_size = 0),
                      (this.prev = null),
                      (this.head = null),
                      (this.ins_h = 0),
                      (this.hash_size = 0),
                      (this.hash_bits = 0),
                      (this.hash_mask = 0),
                      (this.hash_shift = 0),
                      (this.block_start = 0),
                      (this.match_length = 0),
                      (this.prev_match = 0),
                      (this.match_available = 0),
                      (this.strstart = 0),
                      (this.match_start = 0),
                      (this.lookahead = 0),
                      (this.prev_length = 0),
                      (this.max_chain_length = 0),
                      (this.max_lazy_match = 0),
                      (this.level = 0),
                      (this.strategy = 0),
                      (this.good_match = 0),
                      (this.nice_match = 0),
                      (this.dyn_ltree = new o.Buf16(2 * A)),
                      (this.dyn_dtree = new o.Buf16(2 * (2 * S + 1))),
                      (this.bl_tree = new o.Buf16(2 * (2 * C + 1))),
                      he(this.dyn_ltree),
                      he(this.dyn_dtree),
                      he(this.bl_tree),
                      (this.l_desc = null),
                      (this.d_desc = null),
                      (this.bl_desc = null),
                      (this.bl_count = new o.Buf16(R + 1)),
                      (this.heap = new o.Buf16(2 * _ + 1)),
                      he(this.heap),
                      (this.heap_len = 0),
                      (this.heap_max = 0),
                      (this.depth = new o.Buf16(2 * _ + 1)),
                      he(this.depth),
                      (this.l_buf = 0),
                      (this.lit_bufsize = 0),
                      (this.last_lit = 0),
                      (this.d_buf = 0),
                      (this.opt_len = 0),
                      (this.static_len = 0),
                      (this.matches = 0),
                      (this.insert = 0),
                      (this.bi_buf = 0),
                      (this.bi_valid = 0))
                  }
                  function it(b) {
                    var oe
                    return b && b.state
                      ? ((b.total_in = b.total_out = 0),
                        (b.data_type = m),
                        ((oe = b.state).pending = 0),
                        (oe.pending_out = 0),
                        oe.wrap < 0 && (oe.wrap = -oe.wrap),
                        (oe.status = oe.wrap ? L : U),
                        (b.adler = oe.wrap === 2 ? 0 : 1),
                        (oe.last_flush = d),
                        a._tr_init(oe),
                        f)
                      : ee(b, p)
                  }
                  function te(b) {
                    var oe = it(b)
                    return (
                      oe === f &&
                        (function (J) {
                          ;((J.window_size = 2 * J.w_size),
                            he(J.head),
                            (J.max_lazy_match = s[J.level].max_lazy),
                            (J.good_match = s[J.level].good_length),
                            (J.nice_match = s[J.level].nice_length),
                            (J.max_chain_length = s[J.level].max_chain),
                            (J.strstart = 0),
                            (J.block_start = 0),
                            (J.lookahead = 0),
                            (J.insert = 0),
                            (J.match_length = J.prev_length = w - 1),
                            (J.match_available = 0),
                            (J.ins_h = 0))
                        })(b.state),
                      oe
                    )
                  }
                  function re(b, oe, J, H, P, k) {
                    if (!b) return p
                    var j = 1
                    if (
                      (oe === g && (oe = 6),
                      H < 0 ? ((j = 0), (H = -H)) : 15 < H && ((j = 2), (H -= 16)),
                      P < 1 ||
                        x < P ||
                        J !== v ||
                        H < 8 ||
                        15 < H ||
                        oe < 0 ||
                        9 < oe ||
                        k < 0 ||
                        y < k)
                    )
                      return ee(b, p)
                    H === 8 && (H = 9)
                    var B = new Be()
                    return (
                      ((b.state = B).strm = b),
                      (B.wrap = j),
                      (B.gzhead = null),
                      (B.w_bits = H),
                      (B.w_size = 1 << B.w_bits),
                      (B.w_mask = B.w_size - 1),
                      (B.hash_bits = P + 7),
                      (B.hash_size = 1 << B.hash_bits),
                      (B.hash_mask = B.hash_size - 1),
                      (B.hash_shift = ~~((B.hash_bits + w - 1) / w)),
                      (B.window = new o.Buf8(2 * B.w_size)),
                      (B.head = new o.Buf16(B.hash_size)),
                      (B.prev = new o.Buf16(B.w_size)),
                      (B.lit_bufsize = 1 << (P + 6)),
                      (B.pending_buf_size = 4 * B.lit_bufsize),
                      (B.pending_buf = new o.Buf8(B.pending_buf_size)),
                      (B.d_buf = 1 * B.lit_bufsize),
                      (B.l_buf = 3 * B.lit_bufsize),
                      (B.level = oe),
                      (B.strategy = k),
                      (B.method = J),
                      te(b)
                    )
                  }
                  ;((s = [
                    new ze(0, 0, 0, 0, function (b, oe) {
                      var J = 65535
                      for (J > b.pending_buf_size - 5 && (J = b.pending_buf_size - 5); ; ) {
                        if (b.lookahead <= 1) {
                          if ((we(b), b.lookahead === 0 && oe === d)) return T
                          if (b.lookahead === 0) break
                        }
                        ;((b.strstart += b.lookahead), (b.lookahead = 0))
                        var H = b.block_start + J
                        if (
                          ((b.strstart === 0 || b.strstart >= H) &&
                            ((b.lookahead = b.strstart - H),
                            (b.strstart = H),
                            ie(b, !1),
                            b.strm.avail_out === 0)) ||
                          (b.strstart - b.block_start >= b.w_size - I &&
                            (ie(b, !1), b.strm.avail_out === 0))
                        )
                          return T
                      }
                      return (
                        (b.insert = 0),
                        oe === h
                          ? (ie(b, !0), b.strm.avail_out === 0 ? V : W)
                          : (b.strstart > b.block_start && (ie(b, !1), b.strm.avail_out), T)
                      )
                    }),
                    new ze(4, 4, 8, 4, Ee),
                    new ze(4, 5, 16, 8, Ee),
                    new ze(4, 6, 32, 32, Ee),
                    new ze(4, 4, 16, 16, Ie),
                    new ze(8, 16, 32, 32, Ie),
                    new ze(8, 16, 128, 128, Ie),
                    new ze(8, 32, 128, 256, Ie),
                    new ze(32, 128, 258, 1024, Ie),
                    new ze(32, 258, 258, 4096, Ie),
                  ]),
                    (r.deflateInit = function (b, oe) {
                      return re(b, oe, v, 15, 8, 0)
                    }),
                    (r.deflateInit2 = re),
                    (r.deflateReset = te),
                    (r.deflateResetKeep = it),
                    (r.deflateSetHeader = function (b, oe) {
                      return b && b.state
                        ? b.state.wrap !== 2
                          ? p
                          : ((b.state.gzhead = oe), f)
                        : p
                    }),
                    (r.deflate = function (b, oe) {
                      var J, H, P, k
                      if (!b || !b.state || 5 < oe || oe < 0) return b ? ee(b, p) : p
                      if (
                        ((H = b.state),
                        !b.output ||
                          (!b.input && b.avail_in !== 0) ||
                          (H.status === 666 && oe !== h))
                      )
                        return ee(b, b.avail_out === 0 ? -5 : p)
                      if (((H.strm = b), (J = H.last_flush), (H.last_flush = oe), H.status === L))
                        if (H.wrap === 2)
                          ((b.adler = 0),
                            be(H, 31),
                            be(H, 139),
                            be(H, 8),
                            H.gzhead
                              ? (be(
                                  H,
                                  (H.gzhead.text ? 1 : 0) +
                                    (H.gzhead.hcrc ? 2 : 0) +
                                    (H.gzhead.extra ? 4 : 0) +
                                    (H.gzhead.name ? 8 : 0) +
                                    (H.gzhead.comment ? 16 : 0)
                                ),
                                be(H, 255 & H.gzhead.time),
                                be(H, (H.gzhead.time >> 8) & 255),
                                be(H, (H.gzhead.time >> 16) & 255),
                                be(H, (H.gzhead.time >> 24) & 255),
                                be(H, H.level === 9 ? 2 : 2 <= H.strategy || H.level < 2 ? 4 : 0),
                                be(H, 255 & H.gzhead.os),
                                H.gzhead.extra &&
                                  H.gzhead.extra.length &&
                                  (be(H, 255 & H.gzhead.extra.length),
                                  be(H, (H.gzhead.extra.length >> 8) & 255)),
                                H.gzhead.hcrc &&
                                  (b.adler = c(b.adler, H.pending_buf, H.pending, 0)),
                                (H.gzindex = 0),
                                (H.status = 69))
                              : (be(H, 0),
                                be(H, 0),
                                be(H, 0),
                                be(H, 0),
                                be(H, 0),
                                be(H, H.level === 9 ? 2 : 2 <= H.strategy || H.level < 2 ? 4 : 0),
                                be(H, 3),
                                (H.status = U)))
                        else {
                          var j = (v + ((H.w_bits - 8) << 4)) << 8
                          ;((j |=
                            (2 <= H.strategy || H.level < 2
                              ? 0
                              : H.level < 6
                                ? 1
                                : H.level === 6
                                  ? 2
                                  : 3) << 6),
                            H.strstart !== 0 && (j |= 32),
                            (j += 31 - (j % 31)),
                            (H.status = U),
                            le(H, j),
                            H.strstart !== 0 && (le(H, b.adler >>> 16), le(H, 65535 & b.adler)),
                            (b.adler = 1))
                        }
                      if (H.status === 69)
                        if (H.gzhead.extra) {
                          for (
                            P = H.pending;
                            H.gzindex < (65535 & H.gzhead.extra.length) &&
                            (H.pending !== H.pending_buf_size ||
                              (H.gzhead.hcrc &&
                                H.pending > P &&
                                (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                              ne(b),
                              (P = H.pending),
                              H.pending !== H.pending_buf_size));

                          )
                            (be(H, 255 & H.gzhead.extra[H.gzindex]), H.gzindex++)
                          ;(H.gzhead.hcrc &&
                            H.pending > P &&
                            (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                            H.gzindex === H.gzhead.extra.length &&
                              ((H.gzindex = 0), (H.status = 73)))
                        } else H.status = 73
                      if (H.status === 73)
                        if (H.gzhead.name) {
                          P = H.pending
                          do {
                            if (
                              H.pending === H.pending_buf_size &&
                              (H.gzhead.hcrc &&
                                H.pending > P &&
                                (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                              ne(b),
                              (P = H.pending),
                              H.pending === H.pending_buf_size)
                            ) {
                              k = 1
                              break
                            }
                            ;((k =
                              H.gzindex < H.gzhead.name.length
                                ? 255 & H.gzhead.name.charCodeAt(H.gzindex++)
                                : 0),
                              be(H, k))
                          } while (k !== 0)
                          ;(H.gzhead.hcrc &&
                            H.pending > P &&
                            (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                            k === 0 && ((H.gzindex = 0), (H.status = 91)))
                        } else H.status = 91
                      if (H.status === 91)
                        if (H.gzhead.comment) {
                          P = H.pending
                          do {
                            if (
                              H.pending === H.pending_buf_size &&
                              (H.gzhead.hcrc &&
                                H.pending > P &&
                                (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                              ne(b),
                              (P = H.pending),
                              H.pending === H.pending_buf_size)
                            ) {
                              k = 1
                              break
                            }
                            ;((k =
                              H.gzindex < H.gzhead.comment.length
                                ? 255 & H.gzhead.comment.charCodeAt(H.gzindex++)
                                : 0),
                              be(H, k))
                          } while (k !== 0)
                          ;(H.gzhead.hcrc &&
                            H.pending > P &&
                            (b.adler = c(b.adler, H.pending_buf, H.pending - P, P)),
                            k === 0 && (H.status = 103))
                        } else H.status = 103
                      if (
                        (H.status === 103 &&
                          (H.gzhead.hcrc
                            ? (H.pending + 2 > H.pending_buf_size && ne(b),
                              H.pending + 2 <= H.pending_buf_size &&
                                (be(H, 255 & b.adler),
                                be(H, (b.adler >> 8) & 255),
                                (b.adler = 0),
                                (H.status = U)))
                            : (H.status = U)),
                        H.pending !== 0)
                      ) {
                        if ((ne(b), b.avail_out === 0)) return ((H.last_flush = -1), f)
                      } else if (b.avail_in === 0 && se(oe) <= se(J) && oe !== h) return ee(b, -5)
                      if (H.status === 666 && b.avail_in !== 0) return ee(b, -5)
                      if (b.avail_in !== 0 || H.lookahead !== 0 || (oe !== d && H.status !== 666)) {
                        var B =
                          H.strategy === 2
                            ? (function (D, Q) {
                                for (var G; ; ) {
                                  if (D.lookahead === 0 && (we(D), D.lookahead === 0)) {
                                    if (Q === d) return T
                                    break
                                  }
                                  if (
                                    ((D.match_length = 0),
                                    (G = a._tr_tally(D, 0, D.window[D.strstart])),
                                    D.lookahead--,
                                    D.strstart++,
                                    G && (ie(D, !1), D.strm.avail_out === 0))
                                  )
                                    return T
                                }
                                return (
                                  (D.insert = 0),
                                  Q === h
                                    ? (ie(D, !0), D.strm.avail_out === 0 ? V : W)
                                    : D.last_lit && (ie(D, !1), D.strm.avail_out === 0)
                                      ? T
                                      : F
                                )
                              })(H, oe)
                            : H.strategy === 3
                              ? (function (D, Q) {
                                  for (var G, X, ue, z, E = D.window; ; ) {
                                    if (D.lookahead <= M) {
                                      if ((we(D), D.lookahead <= M && Q === d)) return T
                                      if (D.lookahead === 0) break
                                    }
                                    if (
                                      ((D.match_length = 0),
                                      D.lookahead >= w &&
                                        0 < D.strstart &&
                                        (X = E[(ue = D.strstart - 1)]) === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue])
                                    ) {
                                      z = D.strstart + M
                                      do;
                                      while (
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        X === E[++ue] &&
                                        ue < z
                                      )
                                      ;((D.match_length = M - (z - ue)),
                                        D.match_length > D.lookahead &&
                                          (D.match_length = D.lookahead))
                                    }
                                    if (
                                      (D.match_length >= w
                                        ? ((G = a._tr_tally(D, 1, D.match_length - w)),
                                          (D.lookahead -= D.match_length),
                                          (D.strstart += D.match_length),
                                          (D.match_length = 0))
                                        : ((G = a._tr_tally(D, 0, D.window[D.strstart])),
                                          D.lookahead--,
                                          D.strstart++),
                                      G && (ie(D, !1), D.strm.avail_out === 0))
                                    )
                                      return T
                                  }
                                  return (
                                    (D.insert = 0),
                                    Q === h
                                      ? (ie(D, !0), D.strm.avail_out === 0 ? V : W)
                                      : D.last_lit && (ie(D, !1), D.strm.avail_out === 0)
                                        ? T
                                        : F
                                  )
                                })(H, oe)
                              : s[H.level].func(H, oe)
                        if (((B !== V && B !== W) || (H.status = 666), B === T || B === V))
                          return (b.avail_out === 0 && (H.last_flush = -1), f)
                        if (
                          B === F &&
                          (oe === 1
                            ? a._tr_align(H)
                            : oe !== 5 &&
                              (a._tr_stored_block(H, 0, 0, !1),
                              oe === 3 &&
                                (he(H.head),
                                H.lookahead === 0 &&
                                  ((H.strstart = 0), (H.block_start = 0), (H.insert = 0)))),
                          ne(b),
                          b.avail_out === 0)
                        )
                          return ((H.last_flush = -1), f)
                      }
                      return oe !== h
                        ? f
                        : H.wrap <= 0
                          ? 1
                          : (H.wrap === 2
                              ? (be(H, 255 & b.adler),
                                be(H, (b.adler >> 8) & 255),
                                be(H, (b.adler >> 16) & 255),
                                be(H, (b.adler >> 24) & 255),
                                be(H, 255 & b.total_in),
                                be(H, (b.total_in >> 8) & 255),
                                be(H, (b.total_in >> 16) & 255),
                                be(H, (b.total_in >> 24) & 255))
                              : (le(H, b.adler >>> 16), le(H, 65535 & b.adler)),
                            ne(b),
                            0 < H.wrap && (H.wrap = -H.wrap),
                            H.pending !== 0 ? f : 1)
                    }),
                    (r.deflateEnd = function (b) {
                      var oe
                      return b && b.state
                        ? (oe = b.state.status) !== L &&
                          oe !== 69 &&
                          oe !== 73 &&
                          oe !== 91 &&
                          oe !== 103 &&
                          oe !== U &&
                          oe !== 666
                          ? ee(b, p)
                          : ((b.state = null), oe === U ? ee(b, -3) : f)
                        : p
                    }),
                    (r.deflateSetDictionary = function (b, oe) {
                      var J,
                        H,
                        P,
                        k,
                        j,
                        B,
                        D,
                        Q,
                        G = oe.length
                      if (
                        !b ||
                        !b.state ||
                        (k = (J = b.state).wrap) === 2 ||
                        (k === 1 && J.status !== L) ||
                        J.lookahead
                      )
                        return p
                      for (
                        k === 1 && (b.adler = l(b.adler, oe, G, 0)),
                          J.wrap = 0,
                          G >= J.w_size &&
                            (k === 0 &&
                              (he(J.head), (J.strstart = 0), (J.block_start = 0), (J.insert = 0)),
                            (Q = new o.Buf8(J.w_size)),
                            o.arraySet(Q, oe, G - J.w_size, J.w_size, 0),
                            (oe = Q),
                            (G = J.w_size)),
                          j = b.avail_in,
                          B = b.next_in,
                          D = b.input,
                          b.avail_in = G,
                          b.next_in = 0,
                          b.input = oe,
                          we(J);
                        J.lookahead >= w;

                      ) {
                        for (
                          H = J.strstart, P = J.lookahead - (w - 1);
                          (J.ins_h =
                            ((J.ins_h << J.hash_shift) ^ J.window[H + w - 1]) & J.hash_mask),
                            (J.prev[H & J.w_mask] = J.head[J.ins_h]),
                            (J.head[J.ins_h] = H),
                            H++,
                            --P;

                        );
                        ;((J.strstart = H), (J.lookahead = w - 1), we(J))
                      }
                      return (
                        (J.strstart += J.lookahead),
                        (J.block_start = J.strstart),
                        (J.insert = J.lookahead),
                        (J.lookahead = 0),
                        (J.match_length = J.prev_length = w - 1),
                        (J.match_available = 0),
                        (b.next_in = B),
                        (b.input = D),
                        (b.avail_in = j),
                        (J.wrap = k),
                        f
                      )
                    }),
                    (r.deflateInfo = 'pako deflate (from Nodeca project)'))
                },
                {
                  '../utils/common': 41,
                  './adler32': 43,
                  './crc32': 45,
                  './messages': 51,
                  './trees': 52,
                },
              ],
              47: [
                function (t, i, r) {
                  i.exports = function () {
                    ;((this.text = 0),
                      (this.time = 0),
                      (this.xflags = 0),
                      (this.os = 0),
                      (this.extra = null),
                      (this.extra_len = 0),
                      (this.name = ''),
                      (this.comment = ''),
                      (this.hcrc = 0),
                      (this.done = !1))
                  }
                },
                {},
              ],
              48: [
                function (t, i, r) {
                  i.exports = function (s, o) {
                    var a, l, c, u, d, h, f, p, g, y, m, v, x, _, S, C, A, R, w, M, I, L, U, T, F
                    ;((a = s.state),
                      (l = s.next_in),
                      (T = s.input),
                      (c = l + (s.avail_in - 5)),
                      (u = s.next_out),
                      (F = s.output),
                      (d = u - (o - s.avail_out)),
                      (h = u + (s.avail_out - 257)),
                      (f = a.dmax),
                      (p = a.wsize),
                      (g = a.whave),
                      (y = a.wnext),
                      (m = a.window),
                      (v = a.hold),
                      (x = a.bits),
                      (_ = a.lencode),
                      (S = a.distcode),
                      (C = (1 << a.lenbits) - 1),
                      (A = (1 << a.distbits) - 1))
                    e: do {
                      ;(x < 15 && ((v += T[l++] << x), (x += 8), (v += T[l++] << x), (x += 8)),
                        (R = _[v & C]))
                      t: for (;;) {
                        if (((v >>>= w = R >>> 24), (x -= w), (w = (R >>> 16) & 255) === 0))
                          F[u++] = 65535 & R
                        else {
                          if (!(16 & w)) {
                            if ((64 & w) == 0) {
                              R = _[(65535 & R) + (v & ((1 << w) - 1))]
                              continue t
                            }
                            if (32 & w) {
                              a.mode = 12
                              break e
                            }
                            ;((s.msg = 'invalid literal/length code'), (a.mode = 30))
                            break e
                          }
                          ;((M = 65535 & R),
                            (w &= 15) &&
                              (x < w && ((v += T[l++] << x), (x += 8)),
                              (M += v & ((1 << w) - 1)),
                              (v >>>= w),
                              (x -= w)),
                            x < 15 && ((v += T[l++] << x), (x += 8), (v += T[l++] << x), (x += 8)),
                            (R = S[v & A]))
                          n: for (;;) {
                            if (((v >>>= w = R >>> 24), (x -= w), !(16 & (w = (R >>> 16) & 255)))) {
                              if ((64 & w) == 0) {
                                R = S[(65535 & R) + (v & ((1 << w) - 1))]
                                continue n
                              }
                              ;((s.msg = 'invalid distance code'), (a.mode = 30))
                              break e
                            }
                            if (
                              ((I = 65535 & R),
                              x < (w &= 15) &&
                                ((v += T[l++] << x),
                                (x += 8) < w && ((v += T[l++] << x), (x += 8))),
                              f < (I += v & ((1 << w) - 1)))
                            ) {
                              ;((s.msg = 'invalid distance too far back'), (a.mode = 30))
                              break e
                            }
                            if (((v >>>= w), (x -= w), (w = u - d) < I)) {
                              if (g < (w = I - w) && a.sane) {
                                ;((s.msg = 'invalid distance too far back'), (a.mode = 30))
                                break e
                              }
                              if (((U = m), (L = 0) === y)) {
                                if (((L += p - w), w < M)) {
                                  for (M -= w; (F[u++] = m[L++]), --w; );
                                  ;((L = u - I), (U = F))
                                }
                              } else if (y < w) {
                                if (((L += p + y - w), (w -= y) < M)) {
                                  for (M -= w; (F[u++] = m[L++]), --w; );
                                  if (((L = 0), y < M)) {
                                    for (M -= w = y; (F[u++] = m[L++]), --w; );
                                    ;((L = u - I), (U = F))
                                  }
                                }
                              } else if (((L += y - w), w < M)) {
                                for (M -= w; (F[u++] = m[L++]), --w; );
                                ;((L = u - I), (U = F))
                              }
                              for (; 2 < M; )
                                ((F[u++] = U[L++]), (F[u++] = U[L++]), (F[u++] = U[L++]), (M -= 3))
                              M && ((F[u++] = U[L++]), 1 < M && (F[u++] = U[L++]))
                            } else {
                              for (
                                L = u - I;
                                (F[u++] = F[L++]),
                                  (F[u++] = F[L++]),
                                  (F[u++] = F[L++]),
                                  2 < (M -= 3);

                              );
                              M && ((F[u++] = F[L++]), 1 < M && (F[u++] = F[L++]))
                            }
                            break
                          }
                        }
                        break
                      }
                    } while (l < c && u < h)
                    ;((l -= M = x >> 3),
                      (v &= (1 << (x -= M << 3)) - 1),
                      (s.next_in = l),
                      (s.next_out = u),
                      (s.avail_in = l < c ? c - l + 5 : 5 - (l - c)),
                      (s.avail_out = u < h ? h - u + 257 : 257 - (u - h)),
                      (a.hold = v),
                      (a.bits = x))
                  }
                },
                {},
              ],
              49: [
                function (t, i, r) {
                  var s = t('../utils/common'),
                    o = t('./adler32'),
                    a = t('./crc32'),
                    l = t('./inffast'),
                    c = t('./inftrees'),
                    u = 1,
                    d = 2,
                    h = 0,
                    f = -2,
                    p = 1,
                    g = 852,
                    y = 592
                  function m(L) {
                    return (
                      ((L >>> 24) & 255) +
                      ((L >>> 8) & 65280) +
                      ((65280 & L) << 8) +
                      ((255 & L) << 24)
                    )
                  }
                  function v() {
                    ;((this.mode = 0),
                      (this.last = !1),
                      (this.wrap = 0),
                      (this.havedict = !1),
                      (this.flags = 0),
                      (this.dmax = 0),
                      (this.check = 0),
                      (this.total = 0),
                      (this.head = null),
                      (this.wbits = 0),
                      (this.wsize = 0),
                      (this.whave = 0),
                      (this.wnext = 0),
                      (this.window = null),
                      (this.hold = 0),
                      (this.bits = 0),
                      (this.length = 0),
                      (this.offset = 0),
                      (this.extra = 0),
                      (this.lencode = null),
                      (this.distcode = null),
                      (this.lenbits = 0),
                      (this.distbits = 0),
                      (this.ncode = 0),
                      (this.nlen = 0),
                      (this.ndist = 0),
                      (this.have = 0),
                      (this.next = null),
                      (this.lens = new s.Buf16(320)),
                      (this.work = new s.Buf16(288)),
                      (this.lendyn = null),
                      (this.distdyn = null),
                      (this.sane = 0),
                      (this.back = 0),
                      (this.was = 0))
                  }
                  function x(L) {
                    var U
                    return L && L.state
                      ? ((U = L.state),
                        (L.total_in = L.total_out = U.total = 0),
                        (L.msg = ''),
                        U.wrap && (L.adler = 1 & U.wrap),
                        (U.mode = p),
                        (U.last = 0),
                        (U.havedict = 0),
                        (U.dmax = 32768),
                        (U.head = null),
                        (U.hold = 0),
                        (U.bits = 0),
                        (U.lencode = U.lendyn = new s.Buf32(g)),
                        (U.distcode = U.distdyn = new s.Buf32(y)),
                        (U.sane = 1),
                        (U.back = -1),
                        h)
                      : f
                  }
                  function _(L) {
                    var U
                    return L && L.state
                      ? (((U = L.state).wsize = 0), (U.whave = 0), (U.wnext = 0), x(L))
                      : f
                  }
                  function S(L, U) {
                    var T, F
                    return L && L.state
                      ? ((F = L.state),
                        U < 0 ? ((T = 0), (U = -U)) : ((T = 1 + (U >> 4)), U < 48 && (U &= 15)),
                        U && (U < 8 || 15 < U)
                          ? f
                          : (F.window !== null && F.wbits !== U && (F.window = null),
                            (F.wrap = T),
                            (F.wbits = U),
                            _(L)))
                      : f
                  }
                  function C(L, U) {
                    var T, F
                    return L
                      ? ((F = new v()),
                        ((L.state = F).window = null),
                        (T = S(L, U)) !== h && (L.state = null),
                        T)
                      : f
                  }
                  var A,
                    R,
                    w = !0
                  function M(L) {
                    if (w) {
                      var U
                      for (A = new s.Buf32(512), R = new s.Buf32(32), U = 0; U < 144; )
                        L.lens[U++] = 8
                      for (; U < 256; ) L.lens[U++] = 9
                      for (; U < 280; ) L.lens[U++] = 7
                      for (; U < 288; ) L.lens[U++] = 8
                      for (c(u, L.lens, 0, 288, A, 0, L.work, { bits: 9 }), U = 0; U < 32; )
                        L.lens[U++] = 5
                      ;(c(d, L.lens, 0, 32, R, 0, L.work, { bits: 5 }), (w = !1))
                    }
                    ;((L.lencode = A), (L.lenbits = 9), (L.distcode = R), (L.distbits = 5))
                  }
                  function I(L, U, T, F) {
                    var V,
                      W = L.state
                    return (
                      W.window === null &&
                        ((W.wsize = 1 << W.wbits),
                        (W.wnext = 0),
                        (W.whave = 0),
                        (W.window = new s.Buf8(W.wsize))),
                      F >= W.wsize
                        ? (s.arraySet(W.window, U, T - W.wsize, W.wsize, 0),
                          (W.wnext = 0),
                          (W.whave = W.wsize))
                        : (F < (V = W.wsize - W.wnext) && (V = F),
                          s.arraySet(W.window, U, T - F, V, W.wnext),
                          (F -= V)
                            ? (s.arraySet(W.window, U, T - F, F, 0),
                              (W.wnext = F),
                              (W.whave = W.wsize))
                            : ((W.wnext += V),
                              W.wnext === W.wsize && (W.wnext = 0),
                              W.whave < W.wsize && (W.whave += V))),
                      0
                    )
                  }
                  ;((r.inflateReset = _),
                    (r.inflateReset2 = S),
                    (r.inflateResetKeep = x),
                    (r.inflateInit = function (L) {
                      return C(L, 15)
                    }),
                    (r.inflateInit2 = C),
                    (r.inflate = function (L, U) {
                      var T,
                        F,
                        V,
                        W,
                        ee,
                        se,
                        he,
                        ne,
                        ie,
                        be,
                        le,
                        fe,
                        we,
                        Ee,
                        Ie,
                        ze,
                        Be,
                        it,
                        te,
                        re,
                        b,
                        oe,
                        J,
                        H,
                        P = 0,
                        k = new s.Buf8(4),
                        j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                      if (!L || !L.state || !L.output || (!L.input && L.avail_in !== 0)) return f
                      ;((T = L.state).mode === 12 && (T.mode = 13),
                        (ee = L.next_out),
                        (V = L.output),
                        (he = L.avail_out),
                        (W = L.next_in),
                        (F = L.input),
                        (se = L.avail_in),
                        (ne = T.hold),
                        (ie = T.bits),
                        (be = se),
                        (le = he),
                        (oe = h))
                      e: for (;;)
                        switch (T.mode) {
                          case p:
                            if (T.wrap === 0) {
                              T.mode = 13
                              break
                            }
                            for (; ie < 16; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if (2 & T.wrap && ne === 35615) {
                              ;((k[(T.check = 0)] = 255 & ne),
                                (k[1] = (ne >>> 8) & 255),
                                (T.check = a(T.check, k, 2, 0)),
                                (ie = ne = 0),
                                (T.mode = 2))
                              break
                            }
                            if (
                              ((T.flags = 0),
                              T.head && (T.head.done = !1),
                              !(1 & T.wrap) || (((255 & ne) << 8) + (ne >> 8)) % 31)
                            ) {
                              ;((L.msg = 'incorrect header check'), (T.mode = 30))
                              break
                            }
                            if ((15 & ne) != 8) {
                              ;((L.msg = 'unknown compression method'), (T.mode = 30))
                              break
                            }
                            if (((ie -= 4), (b = 8 + (15 & (ne >>>= 4))), T.wbits === 0))
                              T.wbits = b
                            else if (b > T.wbits) {
                              ;((L.msg = 'invalid window size'), (T.mode = 30))
                              break
                            }
                            ;((T.dmax = 1 << b),
                              (L.adler = T.check = 1),
                              (T.mode = 512 & ne ? 10 : 12),
                              (ie = ne = 0))
                            break
                          case 2:
                            for (; ie < 16; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if (((T.flags = ne), (255 & T.flags) != 8)) {
                              ;((L.msg = 'unknown compression method'), (T.mode = 30))
                              break
                            }
                            if (57344 & T.flags) {
                              ;((L.msg = 'unknown header flags set'), (T.mode = 30))
                              break
                            }
                            ;(T.head && (T.head.text = (ne >> 8) & 1),
                              512 & T.flags &&
                                ((k[0] = 255 & ne),
                                (k[1] = (ne >>> 8) & 255),
                                (T.check = a(T.check, k, 2, 0))),
                              (ie = ne = 0),
                              (T.mode = 3))
                          case 3:
                            for (; ie < 32; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            ;(T.head && (T.head.time = ne),
                              512 & T.flags &&
                                ((k[0] = 255 & ne),
                                (k[1] = (ne >>> 8) & 255),
                                (k[2] = (ne >>> 16) & 255),
                                (k[3] = (ne >>> 24) & 255),
                                (T.check = a(T.check, k, 4, 0))),
                              (ie = ne = 0),
                              (T.mode = 4))
                          case 4:
                            for (; ie < 16; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            ;(T.head && ((T.head.xflags = 255 & ne), (T.head.os = ne >> 8)),
                              512 & T.flags &&
                                ((k[0] = 255 & ne),
                                (k[1] = (ne >>> 8) & 255),
                                (T.check = a(T.check, k, 2, 0))),
                              (ie = ne = 0),
                              (T.mode = 5))
                          case 5:
                            if (1024 & T.flags) {
                              for (; ie < 16; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((T.length = ne),
                                T.head && (T.head.extra_len = ne),
                                512 & T.flags &&
                                  ((k[0] = 255 & ne),
                                  (k[1] = (ne >>> 8) & 255),
                                  (T.check = a(T.check, k, 2, 0))),
                                (ie = ne = 0))
                            } else T.head && (T.head.extra = null)
                            T.mode = 6
                          case 6:
                            if (
                              1024 & T.flags &&
                              (se < (fe = T.length) && (fe = se),
                              fe &&
                                (T.head &&
                                  ((b = T.head.extra_len - T.length),
                                  T.head.extra || (T.head.extra = new Array(T.head.extra_len)),
                                  s.arraySet(T.head.extra, F, W, fe, b)),
                                512 & T.flags && (T.check = a(T.check, F, fe, W)),
                                (se -= fe),
                                (W += fe),
                                (T.length -= fe)),
                              T.length)
                            )
                              break e
                            ;((T.length = 0), (T.mode = 7))
                          case 7:
                            if (2048 & T.flags) {
                              if (se === 0) break e
                              for (
                                fe = 0;
                                (b = F[W + fe++]),
                                  T.head &&
                                    b &&
                                    T.length < 65536 &&
                                    (T.head.name += String.fromCharCode(b)),
                                  b && fe < se;

                              );
                              if (
                                (512 & T.flags && (T.check = a(T.check, F, fe, W)),
                                (se -= fe),
                                (W += fe),
                                b)
                              )
                                break e
                            } else T.head && (T.head.name = null)
                            ;((T.length = 0), (T.mode = 8))
                          case 8:
                            if (4096 & T.flags) {
                              if (se === 0) break e
                              for (
                                fe = 0;
                                (b = F[W + fe++]),
                                  T.head &&
                                    b &&
                                    T.length < 65536 &&
                                    (T.head.comment += String.fromCharCode(b)),
                                  b && fe < se;

                              );
                              if (
                                (512 & T.flags && (T.check = a(T.check, F, fe, W)),
                                (se -= fe),
                                (W += fe),
                                b)
                              )
                                break e
                            } else T.head && (T.head.comment = null)
                            T.mode = 9
                          case 9:
                            if (512 & T.flags) {
                              for (; ie < 16; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              if (ne !== (65535 & T.check)) {
                                ;((L.msg = 'header crc mismatch'), (T.mode = 30))
                                break
                              }
                              ie = ne = 0
                            }
                            ;(T.head && ((T.head.hcrc = (T.flags >> 9) & 1), (T.head.done = !0)),
                              (L.adler = T.check = 0),
                              (T.mode = 12))
                            break
                          case 10:
                            for (; ie < 32; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            ;((L.adler = T.check = m(ne)), (ie = ne = 0), (T.mode = 11))
                          case 11:
                            if (T.havedict === 0)
                              return (
                                (L.next_out = ee),
                                (L.avail_out = he),
                                (L.next_in = W),
                                (L.avail_in = se),
                                (T.hold = ne),
                                (T.bits = ie),
                                2
                              )
                            ;((L.adler = T.check = 1), (T.mode = 12))
                          case 12:
                            if (U === 5 || U === 6) break e
                          case 13:
                            if (T.last) {
                              ;((ne >>>= 7 & ie), (ie -= 7 & ie), (T.mode = 27))
                              break
                            }
                            for (; ie < 3; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            switch (((T.last = 1 & ne), (ie -= 1), 3 & (ne >>>= 1))) {
                              case 0:
                                T.mode = 14
                                break
                              case 1:
                                if ((M(T), (T.mode = 20), U !== 6)) break
                                ;((ne >>>= 2), (ie -= 2))
                                break e
                              case 2:
                                T.mode = 17
                                break
                              case 3:
                                ;((L.msg = 'invalid block type'), (T.mode = 30))
                            }
                            ;((ne >>>= 2), (ie -= 2))
                            break
                          case 14:
                            for (ne >>>= 7 & ie, ie -= 7 & ie; ie < 32; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if ((65535 & ne) != ((ne >>> 16) ^ 65535)) {
                              ;((L.msg = 'invalid stored block lengths'), (T.mode = 30))
                              break
                            }
                            if (((T.length = 65535 & ne), (ie = ne = 0), (T.mode = 15), U === 6))
                              break e
                          case 15:
                            T.mode = 16
                          case 16:
                            if ((fe = T.length)) {
                              if ((se < fe && (fe = se), he < fe && (fe = he), fe === 0)) break e
                              ;(s.arraySet(V, F, W, fe, ee),
                                (se -= fe),
                                (W += fe),
                                (he -= fe),
                                (ee += fe),
                                (T.length -= fe))
                              break
                            }
                            T.mode = 12
                            break
                          case 17:
                            for (; ie < 14; ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if (
                              ((T.nlen = 257 + (31 & ne)),
                              (ne >>>= 5),
                              (ie -= 5),
                              (T.ndist = 1 + (31 & ne)),
                              (ne >>>= 5),
                              (ie -= 5),
                              (T.ncode = 4 + (15 & ne)),
                              (ne >>>= 4),
                              (ie -= 4),
                              286 < T.nlen || 30 < T.ndist)
                            ) {
                              ;((L.msg = 'too many length or distance symbols'), (T.mode = 30))
                              break
                            }
                            ;((T.have = 0), (T.mode = 18))
                          case 18:
                            for (; T.have < T.ncode; ) {
                              for (; ie < 3; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((T.lens[j[T.have++]] = 7 & ne), (ne >>>= 3), (ie -= 3))
                            }
                            for (; T.have < 19; ) T.lens[j[T.have++]] = 0
                            if (
                              ((T.lencode = T.lendyn),
                              (T.lenbits = 7),
                              (J = { bits: T.lenbits }),
                              (oe = c(0, T.lens, 0, 19, T.lencode, 0, T.work, J)),
                              (T.lenbits = J.bits),
                              oe)
                            ) {
                              ;((L.msg = 'invalid code lengths set'), (T.mode = 30))
                              break
                            }
                            ;((T.have = 0), (T.mode = 19))
                          case 19:
                            for (; T.have < T.nlen + T.ndist; ) {
                              for (
                                ;
                                (ze = ((P = T.lencode[ne & ((1 << T.lenbits) - 1)]) >>> 16) & 255),
                                  (Be = 65535 & P),
                                  !((Ie = P >>> 24) <= ie);

                              ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              if (Be < 16) ((ne >>>= Ie), (ie -= Ie), (T.lens[T.have++] = Be))
                              else {
                                if (Be === 16) {
                                  for (H = Ie + 2; ie < H; ) {
                                    if (se === 0) break e
                                    ;(se--, (ne += F[W++] << ie), (ie += 8))
                                  }
                                  if (((ne >>>= Ie), (ie -= Ie), T.have === 0)) {
                                    ;((L.msg = 'invalid bit length repeat'), (T.mode = 30))
                                    break
                                  }
                                  ;((b = T.lens[T.have - 1]),
                                    (fe = 3 + (3 & ne)),
                                    (ne >>>= 2),
                                    (ie -= 2))
                                } else if (Be === 17) {
                                  for (H = Ie + 3; ie < H; ) {
                                    if (se === 0) break e
                                    ;(se--, (ne += F[W++] << ie), (ie += 8))
                                  }
                                  ;((ie -= Ie),
                                    (b = 0),
                                    (fe = 3 + (7 & (ne >>>= Ie))),
                                    (ne >>>= 3),
                                    (ie -= 3))
                                } else {
                                  for (H = Ie + 7; ie < H; ) {
                                    if (se === 0) break e
                                    ;(se--, (ne += F[W++] << ie), (ie += 8))
                                  }
                                  ;((ie -= Ie),
                                    (b = 0),
                                    (fe = 11 + (127 & (ne >>>= Ie))),
                                    (ne >>>= 7),
                                    (ie -= 7))
                                }
                                if (T.have + fe > T.nlen + T.ndist) {
                                  ;((L.msg = 'invalid bit length repeat'), (T.mode = 30))
                                  break
                                }
                                for (; fe--; ) T.lens[T.have++] = b
                              }
                            }
                            if (T.mode === 30) break
                            if (T.lens[256] === 0) {
                              ;((L.msg = 'invalid code -- missing end-of-block'), (T.mode = 30))
                              break
                            }
                            if (
                              ((T.lenbits = 9),
                              (J = { bits: T.lenbits }),
                              (oe = c(u, T.lens, 0, T.nlen, T.lencode, 0, T.work, J)),
                              (T.lenbits = J.bits),
                              oe)
                            ) {
                              ;((L.msg = 'invalid literal/lengths set'), (T.mode = 30))
                              break
                            }
                            if (
                              ((T.distbits = 6),
                              (T.distcode = T.distdyn),
                              (J = { bits: T.distbits }),
                              (oe = c(d, T.lens, T.nlen, T.ndist, T.distcode, 0, T.work, J)),
                              (T.distbits = J.bits),
                              oe)
                            ) {
                              ;((L.msg = 'invalid distances set'), (T.mode = 30))
                              break
                            }
                            if (((T.mode = 20), U === 6)) break e
                          case 20:
                            T.mode = 21
                          case 21:
                            if (6 <= se && 258 <= he) {
                              ;((L.next_out = ee),
                                (L.avail_out = he),
                                (L.next_in = W),
                                (L.avail_in = se),
                                (T.hold = ne),
                                (T.bits = ie),
                                l(L, le),
                                (ee = L.next_out),
                                (V = L.output),
                                (he = L.avail_out),
                                (W = L.next_in),
                                (F = L.input),
                                (se = L.avail_in),
                                (ne = T.hold),
                                (ie = T.bits),
                                T.mode === 12 && (T.back = -1))
                              break
                            }
                            for (
                              T.back = 0;
                              (ze = ((P = T.lencode[ne & ((1 << T.lenbits) - 1)]) >>> 16) & 255),
                                (Be = 65535 & P),
                                !((Ie = P >>> 24) <= ie);

                            ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if (ze && (240 & ze) == 0) {
                              for (
                                it = Ie, te = ze, re = Be;
                                (ze =
                                  ((P = T.lencode[re + ((ne & ((1 << (it + te)) - 1)) >> it)]) >>>
                                    16) &
                                  255),
                                  (Be = 65535 & P),
                                  !(it + (Ie = P >>> 24) <= ie);

                              ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((ne >>>= it), (ie -= it), (T.back += it))
                            }
                            if (
                              ((ne >>>= Ie), (ie -= Ie), (T.back += Ie), (T.length = Be), ze === 0)
                            ) {
                              T.mode = 26
                              break
                            }
                            if (32 & ze) {
                              ;((T.back = -1), (T.mode = 12))
                              break
                            }
                            if (64 & ze) {
                              ;((L.msg = 'invalid literal/length code'), (T.mode = 30))
                              break
                            }
                            ;((T.extra = 15 & ze), (T.mode = 22))
                          case 22:
                            if (T.extra) {
                              for (H = T.extra; ie < H; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((T.length += ne & ((1 << T.extra) - 1)),
                                (ne >>>= T.extra),
                                (ie -= T.extra),
                                (T.back += T.extra))
                            }
                            ;((T.was = T.length), (T.mode = 23))
                          case 23:
                            for (
                              ;
                              (ze = ((P = T.distcode[ne & ((1 << T.distbits) - 1)]) >>> 16) & 255),
                                (Be = 65535 & P),
                                !((Ie = P >>> 24) <= ie);

                            ) {
                              if (se === 0) break e
                              ;(se--, (ne += F[W++] << ie), (ie += 8))
                            }
                            if ((240 & ze) == 0) {
                              for (
                                it = Ie, te = ze, re = Be;
                                (ze =
                                  ((P = T.distcode[re + ((ne & ((1 << (it + te)) - 1)) >> it)]) >>>
                                    16) &
                                  255),
                                  (Be = 65535 & P),
                                  !(it + (Ie = P >>> 24) <= ie);

                              ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((ne >>>= it), (ie -= it), (T.back += it))
                            }
                            if (((ne >>>= Ie), (ie -= Ie), (T.back += Ie), 64 & ze)) {
                              ;((L.msg = 'invalid distance code'), (T.mode = 30))
                              break
                            }
                            ;((T.offset = Be), (T.extra = 15 & ze), (T.mode = 24))
                          case 24:
                            if (T.extra) {
                              for (H = T.extra; ie < H; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              ;((T.offset += ne & ((1 << T.extra) - 1)),
                                (ne >>>= T.extra),
                                (ie -= T.extra),
                                (T.back += T.extra))
                            }
                            if (T.offset > T.dmax) {
                              ;((L.msg = 'invalid distance too far back'), (T.mode = 30))
                              break
                            }
                            T.mode = 25
                          case 25:
                            if (he === 0) break e
                            if (((fe = le - he), T.offset > fe)) {
                              if ((fe = T.offset - fe) > T.whave && T.sane) {
                                ;((L.msg = 'invalid distance too far back'), (T.mode = 30))
                                break
                              }
                              ;((we =
                                fe > T.wnext ? ((fe -= T.wnext), T.wsize - fe) : T.wnext - fe),
                                fe > T.length && (fe = T.length),
                                (Ee = T.window))
                            } else ((Ee = V), (we = ee - T.offset), (fe = T.length))
                            for (
                              he < fe && (fe = he), he -= fe, T.length -= fe;
                              (V[ee++] = Ee[we++]), --fe;

                            );
                            T.length === 0 && (T.mode = 21)
                            break
                          case 26:
                            if (he === 0) break e
                            ;((V[ee++] = T.length), he--, (T.mode = 21))
                            break
                          case 27:
                            if (T.wrap) {
                              for (; ie < 32; ) {
                                if (se === 0) break e
                                ;(se--, (ne |= F[W++] << ie), (ie += 8))
                              }
                              if (
                                ((le -= he),
                                (L.total_out += le),
                                (T.total += le),
                                le &&
                                  (L.adler = T.check =
                                    T.flags
                                      ? a(T.check, V, le, ee - le)
                                      : o(T.check, V, le, ee - le)),
                                (le = he),
                                (T.flags ? ne : m(ne)) !== T.check)
                              ) {
                                ;((L.msg = 'incorrect data check'), (T.mode = 30))
                                break
                              }
                              ie = ne = 0
                            }
                            T.mode = 28
                          case 28:
                            if (T.wrap && T.flags) {
                              for (; ie < 32; ) {
                                if (se === 0) break e
                                ;(se--, (ne += F[W++] << ie), (ie += 8))
                              }
                              if (ne !== (4294967295 & T.total)) {
                                ;((L.msg = 'incorrect length check'), (T.mode = 30))
                                break
                              }
                              ie = ne = 0
                            }
                            T.mode = 29
                          case 29:
                            oe = 1
                            break e
                          case 30:
                            oe = -3
                            break e
                          case 31:
                            return -4
                          case 32:
                          default:
                            return f
                        }
                      return (
                        (L.next_out = ee),
                        (L.avail_out = he),
                        (L.next_in = W),
                        (L.avail_in = se),
                        (T.hold = ne),
                        (T.bits = ie),
                        (T.wsize ||
                          (le !== L.avail_out && T.mode < 30 && (T.mode < 27 || U !== 4))) &&
                        I(L, L.output, L.next_out, le - L.avail_out)
                          ? ((T.mode = 31), -4)
                          : ((be -= L.avail_in),
                            (le -= L.avail_out),
                            (L.total_in += be),
                            (L.total_out += le),
                            (T.total += le),
                            T.wrap &&
                              le &&
                              (L.adler = T.check =
                                T.flags
                                  ? a(T.check, V, le, L.next_out - le)
                                  : o(T.check, V, le, L.next_out - le)),
                            (L.data_type =
                              T.bits +
                              (T.last ? 64 : 0) +
                              (T.mode === 12 ? 128 : 0) +
                              (T.mode === 20 || T.mode === 15 ? 256 : 0)),
                            ((be == 0 && le === 0) || U === 4) && oe === h && (oe = -5),
                            oe)
                      )
                    }),
                    (r.inflateEnd = function (L) {
                      if (!L || !L.state) return f
                      var U = L.state
                      return (U.window && (U.window = null), (L.state = null), h)
                    }),
                    (r.inflateGetHeader = function (L, U) {
                      var T
                      return L && L.state
                        ? (2 & (T = L.state).wrap) == 0
                          ? f
                          : (((T.head = U).done = !1), h)
                        : f
                    }),
                    (r.inflateSetDictionary = function (L, U) {
                      var T,
                        F = U.length
                      return L && L.state
                        ? (T = L.state).wrap !== 0 && T.mode !== 11
                          ? f
                          : T.mode === 11 && o(1, U, F, 0) !== T.check
                            ? -3
                            : I(L, U, F, F)
                              ? ((T.mode = 31), -4)
                              : ((T.havedict = 1), h)
                        : f
                    }),
                    (r.inflateInfo = 'pako inflate (from Nodeca project)'))
                },
                {
                  '../utils/common': 41,
                  './adler32': 43,
                  './crc32': 45,
                  './inffast': 48,
                  './inftrees': 50,
                },
              ],
              50: [
                function (t, i, r) {
                  var s = t('../utils/common'),
                    o = [
                      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,
                      83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
                    ],
                    a = [
                      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19,
                      19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
                    ],
                    l = [
                      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
                      1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
                    ],
                    c = [
                      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24,
                      24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
                    ]
                  i.exports = function (u, d, h, f, p, g, y, m) {
                    var v,
                      x,
                      _,
                      S,
                      C,
                      A,
                      R,
                      w,
                      M,
                      I = m.bits,
                      L = 0,
                      U = 0,
                      T = 0,
                      F = 0,
                      V = 0,
                      W = 0,
                      ee = 0,
                      se = 0,
                      he = 0,
                      ne = 0,
                      ie = null,
                      be = 0,
                      le = new s.Buf16(16),
                      fe = new s.Buf16(16),
                      we = null,
                      Ee = 0
                    for (L = 0; L <= 15; L++) le[L] = 0
                    for (U = 0; U < f; U++) le[d[h + U]]++
                    for (V = I, F = 15; 1 <= F && le[F] === 0; F--);
                    if ((F < V && (V = F), F === 0))
                      return ((p[g++] = 20971520), (p[g++] = 20971520), (m.bits = 1), 0)
                    for (T = 1; T < F && le[T] === 0; T++);
                    for (V < T && (V = T), L = se = 1; L <= 15; L++)
                      if (((se <<= 1), (se -= le[L]) < 0)) return -1
                    if (0 < se && (u === 0 || F !== 1)) return -1
                    for (fe[1] = 0, L = 1; L < 15; L++) fe[L + 1] = fe[L] + le[L]
                    for (U = 0; U < f; U++) d[h + U] !== 0 && (y[fe[d[h + U]]++] = U)
                    if (
                      ((A =
                        u === 0
                          ? ((ie = we = y), 19)
                          : u === 1
                            ? ((ie = o), (be -= 257), (we = a), (Ee -= 257), 256)
                            : ((ie = l), (we = c), -1)),
                      (L = T),
                      (C = g),
                      (ee = U = ne = 0),
                      (_ = -1),
                      (S = (he = 1 << (W = V)) - 1),
                      (u === 1 && 852 < he) || (u === 2 && 592 < he))
                    )
                      return 1
                    for (;;) {
                      for (
                        R = L - ee,
                          M =
                            y[U] < A
                              ? ((w = 0), y[U])
                              : y[U] > A
                                ? ((w = we[Ee + y[U]]), ie[be + y[U]])
                                : ((w = 96), 0),
                          v = 1 << (L - ee),
                          T = x = 1 << W;
                        (p[C + (ne >> ee) + (x -= v)] = (R << 24) | (w << 16) | M | 0), x !== 0;

                      );
                      for (v = 1 << (L - 1); ne & v; ) v >>= 1
                      if ((v !== 0 ? ((ne &= v - 1), (ne += v)) : (ne = 0), U++, --le[L] == 0)) {
                        if (L === F) break
                        L = d[h + y[U]]
                      }
                      if (V < L && (ne & S) !== _) {
                        for (
                          ee === 0 && (ee = V), C += T, se = 1 << (W = L - ee);
                          W + ee < F && !((se -= le[W + ee]) <= 0);

                        )
                          (W++, (se <<= 1))
                        if (((he += 1 << W), (u === 1 && 852 < he) || (u === 2 && 592 < he)))
                          return 1
                        p[(_ = ne & S)] = (V << 24) | (W << 16) | (C - g) | 0
                      }
                    }
                    return (
                      ne !== 0 && (p[C + ne] = ((L - ee) << 24) | (64 << 16) | 0),
                      (m.bits = V),
                      0
                    )
                  }
                },
                { '../utils/common': 41 },
              ],
              51: [
                function (t, i, r) {
                  i.exports = {
                    2: 'need dictionary',
                    1: 'stream end',
                    0: '',
                    '-1': 'file error',
                    '-2': 'stream error',
                    '-3': 'data error',
                    '-4': 'insufficient memory',
                    '-5': 'buffer error',
                    '-6': 'incompatible version',
                  }
                },
                {},
              ],
              52: [
                function (t, i, r) {
                  var s = t('../utils/common'),
                    o = 0,
                    a = 1
                  function l(P) {
                    for (var k = P.length; 0 <= --k; ) P[k] = 0
                  }
                  var c = 0,
                    u = 29,
                    d = 256,
                    h = d + 1 + u,
                    f = 30,
                    p = 19,
                    g = 2 * h + 1,
                    y = 15,
                    m = 16,
                    v = 7,
                    x = 256,
                    _ = 16,
                    S = 17,
                    C = 18,
                    A = [
                      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
                      5, 5, 0,
                    ],
                    R = [
                      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
                      11, 12, 12, 13, 13,
                    ],
                    w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                    M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    I = new Array(2 * (h + 2))
                  l(I)
                  var L = new Array(2 * f)
                  l(L)
                  var U = new Array(512)
                  l(U)
                  var T = new Array(256)
                  l(T)
                  var F = new Array(u)
                  l(F)
                  var V,
                    W,
                    ee,
                    se = new Array(f)
                  function he(P, k, j, B, D) {
                    ;((this.static_tree = P),
                      (this.extra_bits = k),
                      (this.extra_base = j),
                      (this.elems = B),
                      (this.max_length = D),
                      (this.has_stree = P && P.length))
                  }
                  function ne(P, k) {
                    ;((this.dyn_tree = P), (this.max_code = 0), (this.stat_desc = k))
                  }
                  function ie(P) {
                    return P < 256 ? U[P] : U[256 + (P >>> 7)]
                  }
                  function be(P, k) {
                    ;((P.pending_buf[P.pending++] = 255 & k),
                      (P.pending_buf[P.pending++] = (k >>> 8) & 255))
                  }
                  function le(P, k, j) {
                    P.bi_valid > m - j
                      ? ((P.bi_buf |= (k << P.bi_valid) & 65535),
                        be(P, P.bi_buf),
                        (P.bi_buf = k >> (m - P.bi_valid)),
                        (P.bi_valid += j - m))
                      : ((P.bi_buf |= (k << P.bi_valid) & 65535), (P.bi_valid += j))
                  }
                  function fe(P, k, j) {
                    le(P, j[2 * k], j[2 * k + 1])
                  }
                  function we(P, k) {
                    for (var j = 0; (j |= 1 & P), (P >>>= 1), (j <<= 1), 0 < --k; );
                    return j >>> 1
                  }
                  function Ee(P, k, j) {
                    var B,
                      D,
                      Q = new Array(y + 1),
                      G = 0
                    for (B = 1; B <= y; B++) Q[B] = G = (G + j[B - 1]) << 1
                    for (D = 0; D <= k; D++) {
                      var X = P[2 * D + 1]
                      X !== 0 && (P[2 * D] = we(Q[X]++, X))
                    }
                  }
                  function Ie(P) {
                    var k
                    for (k = 0; k < h; k++) P.dyn_ltree[2 * k] = 0
                    for (k = 0; k < f; k++) P.dyn_dtree[2 * k] = 0
                    for (k = 0; k < p; k++) P.bl_tree[2 * k] = 0
                    ;((P.dyn_ltree[2 * x] = 1),
                      (P.opt_len = P.static_len = 0),
                      (P.last_lit = P.matches = 0))
                  }
                  function ze(P) {
                    ;(8 < P.bi_valid
                      ? be(P, P.bi_buf)
                      : 0 < P.bi_valid && (P.pending_buf[P.pending++] = P.bi_buf),
                      (P.bi_buf = 0),
                      (P.bi_valid = 0))
                  }
                  function Be(P, k, j, B) {
                    var D = 2 * k,
                      Q = 2 * j
                    return P[D] < P[Q] || (P[D] === P[Q] && B[k] <= B[j])
                  }
                  function it(P, k, j) {
                    for (
                      var B = P.heap[j], D = j << 1;
                      D <= P.heap_len &&
                      (D < P.heap_len && Be(k, P.heap[D + 1], P.heap[D], P.depth) && D++,
                      !Be(k, B, P.heap[D], P.depth));

                    )
                      ((P.heap[j] = P.heap[D]), (j = D), (D <<= 1))
                    P.heap[j] = B
                  }
                  function te(P, k, j) {
                    var B,
                      D,
                      Q,
                      G,
                      X = 0
                    if (P.last_lit !== 0)
                      for (
                        ;
                        (B =
                          (P.pending_buf[P.d_buf + 2 * X] << 8) |
                          P.pending_buf[P.d_buf + 2 * X + 1]),
                          (D = P.pending_buf[P.l_buf + X]),
                          X++,
                          B === 0
                            ? fe(P, D, k)
                            : (fe(P, (Q = T[D]) + d + 1, k),
                              (G = A[Q]) !== 0 && le(P, (D -= F[Q]), G),
                              fe(P, (Q = ie(--B)), j),
                              (G = R[Q]) !== 0 && le(P, (B -= se[Q]), G)),
                          X < P.last_lit;

                      );
                    fe(P, x, k)
                  }
                  function re(P, k) {
                    var j,
                      B,
                      D,
                      Q = k.dyn_tree,
                      G = k.stat_desc.static_tree,
                      X = k.stat_desc.has_stree,
                      ue = k.stat_desc.elems,
                      z = -1
                    for (P.heap_len = 0, P.heap_max = g, j = 0; j < ue; j++)
                      Q[2 * j] !== 0
                        ? ((P.heap[++P.heap_len] = z = j), (P.depth[j] = 0))
                        : (Q[2 * j + 1] = 0)
                    for (; P.heap_len < 2; )
                      ((Q[2 * (D = P.heap[++P.heap_len] = z < 2 ? ++z : 0)] = 1),
                        (P.depth[D] = 0),
                        P.opt_len--,
                        X && (P.static_len -= G[2 * D + 1]))
                    for (k.max_code = z, j = P.heap_len >> 1; 1 <= j; j--) it(P, Q, j)
                    for (
                      D = ue;
                      (j = P.heap[1]),
                        (P.heap[1] = P.heap[P.heap_len--]),
                        it(P, Q, 1),
                        (B = P.heap[1]),
                        (P.heap[--P.heap_max] = j),
                        (P.heap[--P.heap_max] = B),
                        (Q[2 * D] = Q[2 * j] + Q[2 * B]),
                        (P.depth[D] = (P.depth[j] >= P.depth[B] ? P.depth[j] : P.depth[B]) + 1),
                        (Q[2 * j + 1] = Q[2 * B + 1] = D),
                        (P.heap[1] = D++),
                        it(P, Q, 1),
                        2 <= P.heap_len;

                    );
                    ;((P.heap[--P.heap_max] = P.heap[1]),
                      (function (E, N) {
                        var q,
                          Z,
                          $,
                          ae,
                          Ue,
                          Le,
                          Ve = N.dyn_tree,
                          Je = N.max_code,
                          rt = N.stat_desc.static_tree,
                          pe = N.stat_desc.has_stree,
                          Ze = N.stat_desc.extra_bits,
                          Ce = N.stat_desc.extra_base,
                          De = N.stat_desc.max_length,
                          Xe = 0
                        for (ae = 0; ae <= y; ae++) E.bl_count[ae] = 0
                        for (Ve[2 * E.heap[E.heap_max] + 1] = 0, q = E.heap_max + 1; q < g; q++)
                          (De < (ae = Ve[2 * Ve[2 * (Z = E.heap[q]) + 1] + 1] + 1) &&
                            ((ae = De), Xe++),
                            (Ve[2 * Z + 1] = ae),
                            Je < Z ||
                              (E.bl_count[ae]++,
                              (Ue = 0),
                              Ce <= Z && (Ue = Ze[Z - Ce]),
                              (Le = Ve[2 * Z]),
                              (E.opt_len += Le * (ae + Ue)),
                              pe && (E.static_len += Le * (rt[2 * Z + 1] + Ue))))
                        if (Xe !== 0) {
                          do {
                            for (ae = De - 1; E.bl_count[ae] === 0; ) ae--
                            ;(E.bl_count[ae]--,
                              (E.bl_count[ae + 1] += 2),
                              E.bl_count[De]--,
                              (Xe -= 2))
                          } while (0 < Xe)
                          for (ae = De; ae !== 0; ae--)
                            for (Z = E.bl_count[ae]; Z !== 0; )
                              Je < ($ = E.heap[--q]) ||
                                (Ve[2 * $ + 1] !== ae &&
                                  ((E.opt_len += (ae - Ve[2 * $ + 1]) * Ve[2 * $]),
                                  (Ve[2 * $ + 1] = ae)),
                                Z--)
                        }
                      })(P, k),
                      Ee(Q, z, P.bl_count))
                  }
                  function b(P, k, j) {
                    var B,
                      D,
                      Q = -1,
                      G = k[1],
                      X = 0,
                      ue = 7,
                      z = 4
                    for (
                      G === 0 && ((ue = 138), (z = 3)), k[2 * (j + 1) + 1] = 65535, B = 0;
                      B <= j;
                      B++
                    )
                      ((D = G),
                        (G = k[2 * (B + 1) + 1]),
                        (++X < ue && D === G) ||
                          (X < z
                            ? (P.bl_tree[2 * D] += X)
                            : D !== 0
                              ? (D !== Q && P.bl_tree[2 * D]++, P.bl_tree[2 * _]++)
                              : X <= 10
                                ? P.bl_tree[2 * S]++
                                : P.bl_tree[2 * C]++,
                          (Q = D),
                          (z =
                            (X = 0) === G
                              ? ((ue = 138), 3)
                              : D === G
                                ? ((ue = 6), 3)
                                : ((ue = 7), 4))))
                  }
                  function oe(P, k, j) {
                    var B,
                      D,
                      Q = -1,
                      G = k[1],
                      X = 0,
                      ue = 7,
                      z = 4
                    for (G === 0 && ((ue = 138), (z = 3)), B = 0; B <= j; B++)
                      if (((D = G), (G = k[2 * (B + 1) + 1]), !(++X < ue && D === G))) {
                        if (X < z) for (; fe(P, D, P.bl_tree), --X != 0; );
                        else
                          D !== 0
                            ? (D !== Q && (fe(P, D, P.bl_tree), X--),
                              fe(P, _, P.bl_tree),
                              le(P, X - 3, 2))
                            : X <= 10
                              ? (fe(P, S, P.bl_tree), le(P, X - 3, 3))
                              : (fe(P, C, P.bl_tree), le(P, X - 11, 7))
                        ;((Q = D),
                          (z =
                            (X = 0) === G
                              ? ((ue = 138), 3)
                              : D === G
                                ? ((ue = 6), 3)
                                : ((ue = 7), 4)))
                      }
                  }
                  l(se)
                  var J = !1
                  function H(P, k, j, B) {
                    ;(le(P, (c << 1) + (B ? 1 : 0), 3),
                      (function (D, Q, G, X) {
                        ;(ze(D),
                          be(D, G),
                          be(D, ~G),
                          s.arraySet(D.pending_buf, D.window, Q, G, D.pending),
                          (D.pending += G))
                      })(P, k, j))
                  }
                  ;((r._tr_init = function (P) {
                    ;(J ||
                      ((function () {
                        var k,
                          j,
                          B,
                          D,
                          Q,
                          G = new Array(y + 1)
                        for (D = B = 0; D < u - 1; D++)
                          for (F[D] = B, k = 0; k < 1 << A[D]; k++) T[B++] = D
                        for (T[B - 1] = D, D = Q = 0; D < 16; D++)
                          for (se[D] = Q, k = 0; k < 1 << R[D]; k++) U[Q++] = D
                        for (Q >>= 7; D < f; D++)
                          for (se[D] = Q << 7, k = 0; k < 1 << (R[D] - 7); k++) U[256 + Q++] = D
                        for (j = 0; j <= y; j++) G[j] = 0
                        for (k = 0; k <= 143; ) ((I[2 * k + 1] = 8), k++, G[8]++)
                        for (; k <= 255; ) ((I[2 * k + 1] = 9), k++, G[9]++)
                        for (; k <= 279; ) ((I[2 * k + 1] = 7), k++, G[7]++)
                        for (; k <= 287; ) ((I[2 * k + 1] = 8), k++, G[8]++)
                        for (Ee(I, h + 1, G), k = 0; k < f; k++)
                          ((L[2 * k + 1] = 5), (L[2 * k] = we(k, 5)))
                        ;((V = new he(I, A, d + 1, h, y)),
                          (W = new he(L, R, 0, f, y)),
                          (ee = new he(new Array(0), w, 0, p, v)))
                      })(),
                      (J = !0)),
                      (P.l_desc = new ne(P.dyn_ltree, V)),
                      (P.d_desc = new ne(P.dyn_dtree, W)),
                      (P.bl_desc = new ne(P.bl_tree, ee)),
                      (P.bi_buf = 0),
                      (P.bi_valid = 0),
                      Ie(P))
                  }),
                    (r._tr_stored_block = H),
                    (r._tr_flush_block = function (P, k, j, B) {
                      var D,
                        Q,
                        G = 0
                      ;(0 < P.level
                        ? (P.strm.data_type === 2 &&
                            (P.strm.data_type = (function (X) {
                              var ue,
                                z = 4093624447
                              for (ue = 0; ue <= 31; ue++, z >>>= 1)
                                if (1 & z && X.dyn_ltree[2 * ue] !== 0) return o
                              if (
                                X.dyn_ltree[18] !== 0 ||
                                X.dyn_ltree[20] !== 0 ||
                                X.dyn_ltree[26] !== 0
                              )
                                return a
                              for (ue = 32; ue < d; ue++) if (X.dyn_ltree[2 * ue] !== 0) return a
                              return o
                            })(P)),
                          re(P, P.l_desc),
                          re(P, P.d_desc),
                          (G = (function (X) {
                            var ue
                            for (
                              b(X, X.dyn_ltree, X.l_desc.max_code),
                                b(X, X.dyn_dtree, X.d_desc.max_code),
                                re(X, X.bl_desc),
                                ue = p - 1;
                              3 <= ue && X.bl_tree[2 * M[ue] + 1] === 0;
                              ue--
                            );
                            return ((X.opt_len += 3 * (ue + 1) + 5 + 5 + 4), ue)
                          })(P)),
                          (D = (P.opt_len + 3 + 7) >>> 3),
                          (Q = (P.static_len + 3 + 7) >>> 3) <= D && (D = Q))
                        : (D = Q = j + 5),
                        j + 4 <= D && k !== -1
                          ? H(P, k, j, B)
                          : P.strategy === 4 || Q === D
                            ? (le(P, 2 + (B ? 1 : 0), 3), te(P, I, L))
                            : (le(P, 4 + (B ? 1 : 0), 3),
                              (function (X, ue, z, E) {
                                var N
                                for (
                                  le(X, ue - 257, 5), le(X, z - 1, 5), le(X, E - 4, 4), N = 0;
                                  N < E;
                                  N++
                                )
                                  le(X, X.bl_tree[2 * M[N] + 1], 3)
                                ;(oe(X, X.dyn_ltree, ue - 1), oe(X, X.dyn_dtree, z - 1))
                              })(P, P.l_desc.max_code + 1, P.d_desc.max_code + 1, G + 1),
                              te(P, P.dyn_ltree, P.dyn_dtree)),
                        Ie(P),
                        B && ze(P))
                    }),
                    (r._tr_tally = function (P, k, j) {
                      return (
                        (P.pending_buf[P.d_buf + 2 * P.last_lit] = (k >>> 8) & 255),
                        (P.pending_buf[P.d_buf + 2 * P.last_lit + 1] = 255 & k),
                        (P.pending_buf[P.l_buf + P.last_lit] = 255 & j),
                        P.last_lit++,
                        k === 0
                          ? P.dyn_ltree[2 * j]++
                          : (P.matches++,
                            k--,
                            P.dyn_ltree[2 * (T[j] + d + 1)]++,
                            P.dyn_dtree[2 * ie(k)]++),
                        P.last_lit === P.lit_bufsize - 1
                      )
                    }),
                    (r._tr_align = function (P) {
                      ;(le(P, 2, 3),
                        fe(P, x, I),
                        (function (k) {
                          k.bi_valid === 16
                            ? (be(k, k.bi_buf), (k.bi_buf = 0), (k.bi_valid = 0))
                            : 8 <= k.bi_valid &&
                              ((k.pending_buf[k.pending++] = 255 & k.bi_buf),
                              (k.bi_buf >>= 8),
                              (k.bi_valid -= 8))
                        })(P))
                    }))
                },
                { '../utils/common': 41 },
              ],
              53: [
                function (t, i, r) {
                  i.exports = function () {
                    ;((this.input = null),
                      (this.next_in = 0),
                      (this.avail_in = 0),
                      (this.total_in = 0),
                      (this.output = null),
                      (this.next_out = 0),
                      (this.avail_out = 0),
                      (this.total_out = 0),
                      (this.msg = ''),
                      (this.state = null),
                      (this.data_type = 2),
                      (this.adler = 0))
                  }
                },
                {},
              ],
              54: [
                function (t, i, r) {
                  ;(function (s) {
                    ;(function (o, a) {
                      if (!o.setImmediate) {
                        var l,
                          c,
                          u,
                          d,
                          h = 1,
                          f = {},
                          p = !1,
                          g = o.document,
                          y = Object.getPrototypeOf && Object.getPrototypeOf(o)
                        ;((y = y && y.setTimeout ? y : o),
                          (l =
                            {}.toString.call(o.process) === '[object process]'
                              ? function (_) {
                                  process.nextTick(function () {
                                    v(_)
                                  })
                                }
                              : (function () {
                                    if (o.postMessage && !o.importScripts) {
                                      var _ = !0,
                                        S = o.onmessage
                                      return (
                                        (o.onmessage = function () {
                                          _ = !1
                                        }),
                                        o.postMessage('', '*'),
                                        (o.onmessage = S),
                                        _
                                      )
                                    }
                                  })()
                                ? ((d = 'setImmediate$' + Math.random() + '$'),
                                  o.addEventListener
                                    ? o.addEventListener('message', x, !1)
                                    : o.attachEvent('onmessage', x),
                                  function (_) {
                                    o.postMessage(d + _, '*')
                                  })
                                : o.MessageChannel
                                  ? (((u = new MessageChannel()).port1.onmessage = function (_) {
                                      v(_.data)
                                    }),
                                    function (_) {
                                      u.port2.postMessage(_)
                                    })
                                  : g && 'onreadystatechange' in g.createElement('script')
                                    ? ((c = g.documentElement),
                                      function (_) {
                                        var S = g.createElement('script')
                                        ;((S.onreadystatechange = function () {
                                          ;(v(_),
                                            (S.onreadystatechange = null),
                                            c.removeChild(S),
                                            (S = null))
                                        }),
                                          c.appendChild(S))
                                      })
                                    : function (_) {
                                        setTimeout(v, 0, _)
                                      }),
                          (y.setImmediate = function (_) {
                            typeof _ != 'function' && (_ = new Function('' + _))
                            for (var S = new Array(arguments.length - 1), C = 0; C < S.length; C++)
                              S[C] = arguments[C + 1]
                            var A = { callback: _, args: S }
                            return ((f[h] = A), l(h), h++)
                          }),
                          (y.clearImmediate = m))
                      }
                      function m(_) {
                        delete f[_]
                      }
                      function v(_) {
                        if (p) setTimeout(v, 0, _)
                        else {
                          var S = f[_]
                          if (S) {
                            p = !0
                            try {
                              ;(function (C) {
                                var A = C.callback,
                                  R = C.args
                                switch (R.length) {
                                  case 0:
                                    A()
                                    break
                                  case 1:
                                    A(R[0])
                                    break
                                  case 2:
                                    A(R[0], R[1])
                                    break
                                  case 3:
                                    A(R[0], R[1], R[2])
                                    break
                                  default:
                                    A.apply(a, R)
                                }
                              })(S)
                            } finally {
                              ;(m(_), (p = !1))
                            }
                          }
                        }
                      }
                      function x(_) {
                        _.source === o &&
                          typeof _.data == 'string' &&
                          _.data.indexOf(d) === 0 &&
                          v(+_.data.slice(d.length))
                      }
                    })(typeof self > 'u' ? (s === void 0 ? this : s) : self)
                  }).call(
                    this,
                    typeof Bc < 'u'
                      ? Bc
                      : typeof self < 'u'
                        ? self
                        : typeof window < 'u'
                          ? window
                          : {}
                  )
                },
                {},
              ],
            },
            {},
            [10]
          )(10)
        })
      })(y1)),
    y1.exports
  )
}
var Iq = Rq(),
  v1,
  Gb
function Nq() {
  return (
    Gb ||
      ((Gb = 1),
      (v1 = function (e, t) {
        if (((t = t.split(':')[0]), (e = +e), !e)) return !1
        switch (t) {
          case 'http':
          case 'ws':
            return e !== 80
          case 'https':
          case 'wss':
            return e !== 443
          case 'ftp':
            return e !== 21
          case 'gopher':
            return e !== 70
          case 'file':
            return !1
        }
        return e !== 0
      })),
    v1
  )
}
var cp = {},
  Wb
function Pq() {
  if (Wb) return cp
  Wb = 1
  var n = Object.prototype.hasOwnProperty,
    e
  function t(o) {
    try {
      return decodeURIComponent(o.replace(/\+/g, ' '))
    } catch (a) {
      return null
    }
  }
  function i(o) {
    try {
      return encodeURIComponent(o)
    } catch (a) {
      return null
    }
  }
  function r(o) {
    for (var a = /([^=?#&]+)=?([^&]*)/g, l = {}, c; (c = a.exec(o)); ) {
      var u = t(c[1]),
        d = t(c[2])
      u === null || d === null || u in l || (l[u] = d)
    }
    return l
  }
  function s(o, a) {
    a = a || ''
    var l = [],
      c,
      u
    typeof a != 'string' && (a = '?')
    for (u in o)
      if (n.call(o, u)) {
        if (
          ((c = o[u]),
          !c && (c === null || c === e || isNaN(c)) && (c = ''),
          (u = i(u)),
          (c = i(c)),
          u === null || c === null)
        )
          continue
        l.push(u + '=' + c)
      }
    return l.length ? a + l.join('&') : ''
  }
  return ((cp.stringify = s), (cp.parse = r), cp)
}
var _1, Qb
function Lq() {
  if (Qb) return _1
  Qb = 1
  var n = Nq(),
    e = Pq(),
    t = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
    i = /[\n\r\t]/g,
    r = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
    s = /:\d+$/,
    o = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
    a = /^[a-zA-Z]:/
  function l(v) {
    return (v || '').toString().replace(t, '')
  }
  var c = [
      ['#', 'hash'],
      ['?', 'query'],
      function (x, _) {
        return h(_.protocol) ? x.replace(/\\/g, '/') : x
      },
      ['/', 'pathname'],
      ['@', 'auth', 1],
      [NaN, 'host', void 0, 1, 1],
      [/:(\d*)$/, 'port', void 0, 1],
      [NaN, 'hostname', void 0, 1, 1],
    ],
    u = { hash: 1, query: 1 }
  function d(v) {
    var x
    typeof window < 'u'
      ? (x = window)
      : typeof Bc < 'u'
        ? (x = Bc)
        : typeof self < 'u'
          ? (x = self)
          : (x = {})
    var _ = x.location || {}
    v = v || _
    var S = {},
      C = typeof v,
      A
    if (v.protocol === 'blob:') S = new g(unescape(v.pathname), {})
    else if (C === 'string') {
      S = new g(v, {})
      for (A in u) delete S[A]
    } else if (C === 'object') {
      for (A in v) A in u || (S[A] = v[A])
      S.slashes === void 0 && (S.slashes = r.test(v.href))
    }
    return S
  }
  function h(v) {
    return (
      v === 'file:' ||
      v === 'ftp:' ||
      v === 'http:' ||
      v === 'https:' ||
      v === 'ws:' ||
      v === 'wss:'
    )
  }
  function f(v, x) {
    ;((v = l(v)), (v = v.replace(i, '')), (x = x || {}))
    var _ = o.exec(v),
      S = _[1] ? _[1].toLowerCase() : '',
      C = !!_[2],
      A = !!_[3],
      R = 0,
      w
    return (
      C
        ? A
          ? ((w = _[2] + _[3] + _[4]), (R = _[2].length + _[3].length))
          : ((w = _[2] + _[4]), (R = _[2].length))
        : A
          ? ((w = _[3] + _[4]), (R = _[3].length))
          : (w = _[4]),
      S === 'file:'
        ? R >= 2 && (w = w.slice(2))
        : h(S)
          ? (w = _[4])
          : S
            ? C && (w = w.slice(2))
            : R >= 2 && h(x.protocol) && (w = _[4]),
      { protocol: S, slashes: C || h(S), slashesCount: R, rest: w }
    )
  }
  function p(v, x) {
    if (v === '') return x
    for (
      var _ = (x || '/').split('/').slice(0, -1).concat(v.split('/')),
        S = _.length,
        C = _[S - 1],
        A = !1,
        R = 0;
      S--;

    )
      _[S] === '.'
        ? _.splice(S, 1)
        : _[S] === '..'
          ? (_.splice(S, 1), R++)
          : R && (S === 0 && (A = !0), _.splice(S, 1), R--)
    return (A && _.unshift(''), (C === '.' || C === '..') && _.push(''), _.join('/'))
  }
  function g(v, x, _) {
    if (((v = l(v)), (v = v.replace(i, '')), !(this instanceof g))) return new g(v, x, _)
    var S,
      C,
      A,
      R,
      w,
      M,
      I = c.slice(),
      L = typeof x,
      U = this,
      T = 0
    for (
      L !== 'object' && L !== 'string' && ((_ = x), (x = null)),
        _ && typeof _ != 'function' && (_ = e.parse),
        x = d(x),
        C = f(v || '', x),
        S = !C.protocol && !C.slashes,
        U.slashes = C.slashes || (S && x.slashes),
        U.protocol = C.protocol || x.protocol || '',
        v = C.rest,
        ((C.protocol === 'file:' && (C.slashesCount !== 2 || a.test(v))) ||
          (!C.slashes && (C.protocol || C.slashesCount < 2 || !h(U.protocol)))) &&
          (I[3] = [/(.*)/, 'pathname']);
      T < I.length;
      T++
    ) {
      if (((R = I[T]), typeof R == 'function')) {
        v = R(v, U)
        continue
      }
      ;((A = R[0]),
        (M = R[1]),
        A !== A
          ? (U[M] = v)
          : typeof A == 'string'
            ? ((w = A === '@' ? v.lastIndexOf(A) : v.indexOf(A)),
              ~w &&
                (typeof R[2] == 'number'
                  ? ((U[M] = v.slice(0, w)), (v = v.slice(w + R[2])))
                  : ((U[M] = v.slice(w)), (v = v.slice(0, w)))))
            : (w = A.exec(v)) && ((U[M] = w[1]), (v = v.slice(0, w.index))),
        (U[M] = U[M] || (S && R[3] && x[M]) || ''),
        R[4] && (U[M] = U[M].toLowerCase()))
    }
    ;(_ && (U.query = _(U.query)),
      S &&
        x.slashes &&
        U.pathname.charAt(0) !== '/' &&
        (U.pathname !== '' || x.pathname !== '') &&
        (U.pathname = p(U.pathname, x.pathname)),
      U.pathname.charAt(0) !== '/' && h(U.protocol) && (U.pathname = '/' + U.pathname),
      n(U.port, U.protocol) || ((U.host = U.hostname), (U.port = '')),
      (U.username = U.password = ''),
      U.auth &&
        ((w = U.auth.indexOf(':')),
        ~w
          ? ((U.username = U.auth.slice(0, w)),
            (U.username = encodeURIComponent(decodeURIComponent(U.username))),
            (U.password = U.auth.slice(w + 1)),
            (U.password = encodeURIComponent(decodeURIComponent(U.password))))
          : (U.username = encodeURIComponent(decodeURIComponent(U.auth))),
        (U.auth = U.password ? U.username + ':' + U.password : U.username)),
      (U.origin =
        U.protocol !== 'file:' && h(U.protocol) && U.host ? U.protocol + '//' + U.host : 'null'),
      (U.href = U.toString()))
  }
  function y(v, x, _) {
    var S = this
    switch (v) {
      case 'query':
        ;(typeof x == 'string' && x.length && (x = (_ || e.parse)(x)), (S[v] = x))
        break
      case 'port':
        ;((S[v] = x),
          n(x, S.protocol)
            ? x && (S.host = S.hostname + ':' + x)
            : ((S.host = S.hostname), (S[v] = '')))
        break
      case 'hostname':
        ;((S[v] = x), S.port && (x += ':' + S.port), (S.host = x))
        break
      case 'host':
        ;((S[v] = x),
          s.test(x)
            ? ((x = x.split(':')), (S.port = x.pop()), (S.hostname = x.join(':')))
            : ((S.hostname = x), (S.port = '')))
        break
      case 'protocol':
        ;((S.protocol = x.toLowerCase()), (S.slashes = !_))
        break
      case 'pathname':
      case 'hash':
        if (x) {
          var C = v === 'pathname' ? '/' : '#'
          S[v] = x.charAt(0) !== C ? C + x : x
        } else S[v] = x
        break
      case 'username':
      case 'password':
        S[v] = encodeURIComponent(x)
        break
      case 'auth':
        var A = x.indexOf(':')
        ~A
          ? ((S.username = x.slice(0, A)),
            (S.username = encodeURIComponent(decodeURIComponent(S.username))),
            (S.password = x.slice(A + 1)),
            (S.password = encodeURIComponent(decodeURIComponent(S.password))))
          : (S.username = encodeURIComponent(decodeURIComponent(x)))
    }
    for (var R = 0; R < c.length; R++) {
      var w = c[R]
      w[4] && (S[w[1]] = S[w[1]].toLowerCase())
    }
    return (
      (S.auth = S.password ? S.username + ':' + S.password : S.username),
      (S.origin =
        S.protocol !== 'file:' && h(S.protocol) && S.host ? S.protocol + '//' + S.host : 'null'),
      (S.href = S.toString()),
      S
    )
  }
  function m(v) {
    ;(!v || typeof v != 'function') && (v = e.stringify)
    var x,
      _ = this,
      S = _.host,
      C = _.protocol
    C && C.charAt(C.length - 1) !== ':' && (C += ':')
    var A = C + ((_.protocol && _.slashes) || h(_.protocol) ? '//' : '')
    return (
      _.username
        ? ((A += _.username), _.password && (A += ':' + _.password), (A += '@'))
        : _.password
          ? ((A += ':' + _.password), (A += '@'))
          : _.protocol !== 'file:' && h(_.protocol) && !S && _.pathname !== '/' && (A += '@'),
      (S[S.length - 1] === ':' || (s.test(_.hostname) && !_.port)) && (S += ':'),
      (A += S + _.pathname),
      (x = typeof _.query == 'object' ? v(_.query) : _.query),
      x && (A += x.charAt(0) !== '?' ? '?' + x : x),
      _.hash && (A += _.hash),
      A
    )
  }
  return (
    (g.prototype = { set: y, toString: m }),
    (g.extractProtocol = f),
    (g.location = d),
    (g.trimLeft = l),
    (g.qs = e),
    (_1 = g),
    _1
  )
}
var Dq = Lq(),
  Fq = u6(Dq),
  zp = { exports: {} }
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */ var Oq = zp.exports,
  jb
function Bq() {
  return (
    jb ||
      ((jb = 1),
      (function (n, e) {
        ;(function (t, i) {
          n.exports = i()
        })(Oq, function () {
          var t = {}
          t.version = '0.2.0'
          var i = (t.settings = {
            minimum: 0.08,
            easing: 'ease',
            positionUsing: '',
            speed: 200,
            trickle: !0,
            trickleRate: 0.02,
            trickleSpeed: 800,
            showSpinner: !0,
            barSelector: '[role="bar"]',
            spinnerSelector: '[role="spinner"]',
            parent: 'body',
            template:
              '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>',
          })
          ;((t.configure = function (p) {
            var g, y
            for (g in p) ((y = p[g]), y !== void 0 && p.hasOwnProperty(g) && (i[g] = y))
            return this
          }),
            (t.status = null),
            (t.set = function (p) {
              var g = t.isStarted()
              ;((p = r(p, i.minimum, 1)), (t.status = p === 1 ? null : p))
              var y = t.render(!g),
                m = y.querySelector(i.barSelector),
                v = i.speed,
                x = i.easing
              return (
                y.offsetWidth,
                a(function (_) {
                  ;(i.positionUsing === '' && (i.positionUsing = t.getPositioningCSS()),
                    l(m, o(p, v, x)),
                    p === 1
                      ? (l(y, { transition: 'none', opacity: 1 }),
                        y.offsetWidth,
                        setTimeout(function () {
                          ;(l(y, { transition: 'all ' + v + 'ms linear', opacity: 0 }),
                            setTimeout(function () {
                              ;(t.remove(), _())
                            }, v))
                        }, v))
                      : setTimeout(_, v))
                }),
                this
              )
            }),
            (t.isStarted = function () {
              return typeof t.status == 'number'
            }),
            (t.start = function () {
              t.status || t.set(0)
              var p = function () {
                setTimeout(function () {
                  t.status && (t.trickle(), p())
                }, i.trickleSpeed)
              }
              return (i.trickle && p(), this)
            }),
            (t.done = function (p) {
              return !p && !t.status ? this : t.inc(0.3 + 0.5 * Math.random()).set(1)
            }),
            (t.inc = function (p) {
              var g = t.status
              return g
                ? (typeof p != 'number' && (p = (1 - g) * r(Math.random() * g, 0.1, 0.95)),
                  (g = r(g + p, 0, 0.994)),
                  t.set(g))
                : t.start()
            }),
            (t.trickle = function () {
              return t.inc(Math.random() * i.trickleRate)
            }),
            (function () {
              var p = 0,
                g = 0
              t.promise = function (y) {
                return !y || y.state() === 'resolved'
                  ? this
                  : (g === 0 && t.start(),
                    p++,
                    g++,
                    y.always(function () {
                      ;(g--, g === 0 ? ((p = 0), t.done()) : t.set((p - g) / p))
                    }),
                    this)
              }
            })(),
            (t.render = function (p) {
              if (t.isRendered()) return document.getElementById('nprogress')
              u(document.documentElement, 'nprogress-busy')
              var g = document.createElement('div')
              ;((g.id = 'nprogress'), (g.innerHTML = i.template))
              var y = g.querySelector(i.barSelector),
                m = p ? '-100' : s(t.status || 0),
                v = document.querySelector(i.parent),
                x
              return (
                l(y, { transition: 'all 0 linear', transform: 'translate3d(' + m + '%,0,0)' }),
                i.showSpinner || ((x = g.querySelector(i.spinnerSelector)), x && f(x)),
                v != document.body && u(v, 'nprogress-custom-parent'),
                v.appendChild(g),
                g
              )
            }),
            (t.remove = function () {
              ;(d(document.documentElement, 'nprogress-busy'),
                d(document.querySelector(i.parent), 'nprogress-custom-parent'))
              var p = document.getElementById('nprogress')
              p && f(p)
            }),
            (t.isRendered = function () {
              return !!document.getElementById('nprogress')
            }),
            (t.getPositioningCSS = function () {
              var p = document.body.style,
                g =
                  'WebkitTransform' in p
                    ? 'Webkit'
                    : 'MozTransform' in p
                      ? 'Moz'
                      : 'msTransform' in p
                        ? 'ms'
                        : 'OTransform' in p
                          ? 'O'
                          : ''
              return g + 'Perspective' in p
                ? 'translate3d'
                : g + 'Transform' in p
                  ? 'translate'
                  : 'margin'
            }))
          function r(p, g, y) {
            return p < g ? g : p > y ? y : p
          }
          function s(p) {
            return (-1 + p) * 100
          }
          function o(p, g, y) {
            var m
            return (
              i.positionUsing === 'translate3d'
                ? (m = { transform: 'translate3d(' + s(p) + '%,0,0)' })
                : i.positionUsing === 'translate'
                  ? (m = { transform: 'translate(' + s(p) + '%,0)' })
                  : (m = { 'margin-left': s(p) + '%' }),
              (m.transition = 'all ' + g + 'ms ' + y),
              m
            )
          }
          var a = (function () {
              var p = []
              function g() {
                var y = p.shift()
                y && y(g)
              }
              return function (y) {
                ;(p.push(y), p.length == 1 && g())
              }
            })(),
            l = (function () {
              var p = ['Webkit', 'O', 'Moz', 'ms'],
                g = {}
              function y(_) {
                return _.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (S, C) {
                  return C.toUpperCase()
                })
              }
              function m(_) {
                var S = document.body.style
                if (_ in S) return _
                for (var C = p.length, A = _.charAt(0).toUpperCase() + _.slice(1), R; C--; )
                  if (((R = p[C] + A), R in S)) return R
                return _
              }
              function v(_) {
                return ((_ = y(_)), g[_] || (g[_] = m(_)))
              }
              function x(_, S, C) {
                ;((S = v(S)), (_.style[S] = C))
              }
              return function (_, S) {
                var C = arguments,
                  A,
                  R
                if (C.length == 2)
                  for (A in S) ((R = S[A]), R !== void 0 && S.hasOwnProperty(A) && x(_, A, R))
                else x(_, C[1], C[2])
              }
            })()
          function c(p, g) {
            var y = typeof p == 'string' ? p : h(p)
            return y.indexOf(' ' + g + ' ') >= 0
          }
          function u(p, g) {
            var y = h(p),
              m = y + g
            c(y, g) || (p.className = m.substring(1))
          }
          function d(p, g) {
            var y = h(p),
              m
            c(p, g) &&
              ((m = y.replace(' ' + g + ' ', ' ')), (p.className = m.substring(1, m.length - 1)))
          }
          function h(p) {
            return (' ' + (p.className || '') + ' ').replace(/\s+/gi, ' ')
          }
          function f(p) {
            p && p.parentNode && p.parentNode.removeChild(p)
          }
          return t
        })
      })(zp)),
    zp.exports
  )
}
var Uq = Bq(),
  x1 = u6(Uq),
  At
;(function (n) {
  ;((n.Idle = 'Idle'),
    (n.Listening = 'Listening'),
    (n.Responding = 'Responding'),
    (n.Thinking = 'Thinking'))
})(At || (At = {}))
var qb
;(function (n) {
  ;((n.cpu = 'cpu'), (n.gpu = 'gpu'))
})(qb || (qb = {}))
var Xb
;(function (n) {
  ;((n.High = 'High'), (n.Low = 'Low'), (n.Standard = 'Standard'))
})(Xb || (Xb = {}))
var Kb
;(function (n) {
  ;((n.GAUSSIAN_SPLATTING_3D = 'GAUSSIAN_SPLATTING_3D'),
    (n.REALTIME_AVATAR_3D = 'REALTIME_AVATAR_3D'),
    (n.REALTIME_AVATAR_LIVE2D = 'REALTIME_AVATAR_LIVE2D'),
    (n.REALTIME_AVATAR_MOBILE2D = 'REALTIME_AVATAR_MOBILE2D'))
})(Kb || (Kb = {}))
var Yb
;(function (n) {
  ;((n.Idle = 'idle'), (n.Listening = 'listen'), (n.Responding = 'speak'), (n.Thinking = 'think'))
})(Yb || (Yb = {}))
class Qe {
  static SetWeight(e, t) {
    ;((e.enabled = !0), e.setEffectiveTimeScale(1), e.setEffectiveWeight(t))
  }
  static PrepareCrossFade(e, t, i) {
    const r = i
    ;(Qe.UnPauseAllActions(),
      Qe.ExecuteCrossFade(e, t, r),
      (Qe.IsBlending = !0),
      setTimeout(() => {
        Qe.IsBlending = !1
      }, i + 0.1))
  }
  static PauseAllActions() {
    Qe.actions.forEach(function (e) {
      e.paused = !0
    })
  }
  static UnPauseAllActions() {
    Qe.actions.forEach(function (e) {
      e.paused = !1
    })
  }
  static ExecuteCrossFade(e, t, i) {
    ;(Qe.SetWeight(t, 1), (t.time = 0), e.crossFadeTo(t, i, !0))
  }
  constructor(e, t, i) {
    const r = [],
      s = [],
      o = [],
      a = [],
      l = []
    this.mixer = e
    const c = i.hello.size,
      u = i.idle.size + c,
      d = i.listen.size + u,
      h = i.speak.size + d,
      f = i.think.size + h
    for (let p = 0; p < t.length; p++) {
      const g = t[p],
        y = e.clipAction(g)
      if (p < c) r.push(y)
      else if (p < u) {
        if ((s.push(y), d == u)) {
          const m = e.clipAction(g.clone())
          o.push(m)
        }
        if (a == o) {
          const m = e.clipAction(g.clone())
          a.push(m)
        }
        if (f == h) {
          const m = e.clipAction(g.clone())
          l.push(m)
        }
      } else p < d ? o.push(y) : p < h ? a.push(y) : p < f && l.push(y)
      ;(Qe.actions.push(y), Qe.SetWeight(y, 0))
    }
    ;((this.hello = new kq(r, i.hello.isGroup)),
      (this.idle = new zq(s, i.idle.isGroup)),
      (this.listen = new Vq(o, i.listen.isGroup)),
      (this.think = new Hq(l, i.think.isGroup)),
      (this.speak = new $q(a, i.speak.isGroup)))
  }
  curPlaying() {
    if (this.hello.isPlaying || this.idle.isPlaying) return At.Idle
    if (this.listen.isPlaying) return At.Listening
    if (this.think.isPlaying) return At.Thinking
    if (this.speak.isPlaying) return At.Responding
  }
  dispose() {
    ;(this.hello.dispose(),
      this.idle.dispose(),
      this.listen.dispose(),
      this.think.dispose(),
      this.speak.dispose())
  }
  resetAllActions(e = !1) {
    switch (this.curPlaying()) {
      case At.Idle:
        Qe.LastAction = this.hello.actions[this.hello.stage]
        break
      case At.Listening:
        Qe.LastAction = this.listen.actions[this.listen.stage]
        break
      case At.Thinking:
        Qe.LastAction = this.think.actions[this.think.stage]
        break
      case At.Responding:
        Qe.LastAction = this.speak.actions[this.speak.stage]
        break
      default:
        Qe.LastAction = void 0
        break
    }
    ;(Qe.LastAction &&
      ((Qe.LastAction.loop = Jr),
      (Qe.LastAction.clampWhenFinished = !0),
      Qe.SetWeight(Qe.LastAction, 1)),
      e &&
        (Qe.PauseAllActions(),
        Qe.actions.forEach(function (i) {
          ;((i.time = 0), Qe.SetWeight(i, 0))
        }),
        (Qe.LastAction = void 0)),
      (this.hello.isPlaying = !1),
      (this.idle.isPlaying = !1),
      (this.listen.isPlaying = !1),
      (this.think.isPlaying = !1),
      (this.speak.isPlaying = !1))
  }
  update(e) {
    if (!Qe.IsBlending)
      if (((Qe.CurPlaying = this.curPlaying()), Qe.CurPlaying == null))
        switch (e) {
          case At.Idle:
            this.idle.update(e)
            break
          case At.Listening:
            this.listen.update(e)
            break
          case At.Thinking:
            this.think.update(e)
            break
          case At.Responding:
            this.speak.update(e)
            break
          default:
            this.idle.update(e)
            break
        }
      else
        switch (Qe.CurPlaying) {
          case At.Idle:
            this.idle.update(e)
            break
          case At.Listening:
            this.listen.update(e)
            break
          case At.Thinking:
            this.think.update(e)
            break
          case At.Responding:
            this.speak.update(e)
            break
          default:
            this.idle.update(e)
            break
        }
  }
  updateBS(e) {
    let t = {
      browDownLeft: 0,
      browDownRight: 0,
      browInnerUp: 0,
      browOuterUpLeft: 0,
      browOuterUpRight: 0,
      mouthCheekPuff: 0,
      cheekSquintLeft: 0,
      cheekSquintRight: 0,
      eyeBlinkLeft: 0,
      eyeBlinkRight: 0,
      eyeLookDownLeft: 0,
      eyeLookDownRight: 0,
      eyeLookInLeft: 0,
      eyeLookInRight: 0,
      eyeLookOutLeft: 0,
      eyeLookOutRight: 0,
      eyeLookUpLeft: 0,
      eyeLookUpRight: 0,
      eyeSquintLeft: 0,
      eyeSquintRight: 0,
      eyeWideLeft: 0,
      eyeWideRight: 0,
      jawForward: 0,
      jawLeft: 0,
      jawOpen: 0,
      jawRight: 0,
      mouthClose: 0,
      mouthDimpleLeft: 0,
      mouthDimpleRight: 0,
      mouthFrownLeft: 0,
      mouthFrownRight: 0,
      mouthFunnel: 0,
      mouthLeft: 0,
      mouthLowerDownLeft: 0,
      mouthLowerDownRight: 0,
      mouthPressLeft: 0,
      mouthPressRight: 0,
      mouthPucker: 0,
      mouthRight: 0,
      mouthRollLower: 0,
      mouthRollUpper: 0,
      mouthShrugLower: 0,
      mouthShrugUpper: 0,
      mouthSmileLeft: 0,
      mouthSmileRight: 0,
      mouthStretchLeft: 0,
      mouthStretchRight: 0,
      mouthUpperUpLeft: 0,
      mouthUpperUpRight: 0,
      noseSneerLeft: 0,
      noseSneerRight: 0,
      tongueOut: 0,
    }
    return (e != null && (t = e), t)
  }
}
Qe.IsBlending = !1
Qe.actions = []
Qe.NeedReset = !1
Qe.NeedFullReset = !1
class of {
  constructor(e, t) {
    ;((this.isPlaying = !1),
      (this.stage = 0),
      (this.actions = []),
      (this.blendingTime = 0.5),
      (this.isGroup = !1),
      (this.actions = e),
      (this.isGroup = t))
  }
  dispose() {
    this.actions = []
  }
  update(e) {}
}
class kq extends of {
  constructor(e, t) {
    super(e, t)
  }
  update(e) {
    if (
      (Qe.CurPlaying == null &&
        e == At.Idle &&
        this.isPlaying == !1 &&
        ((this.stage = 0),
        (this.actions[this.stage].time = 0),
        Qe.SetWeight(this.actions[this.stage], 1),
        (this.actions[this.stage].loop = Vl),
        (this.actions[this.stage].clampWhenFinished = !1),
        (this.actions[this.stage].paused = !1),
        this.actions[this.stage].play(),
        Qe.LastAction != null &&
          Qe.PrepareCrossFade(Qe.LastAction, this.actions[this.stage], this.blendingTime),
        (this.isPlaying = !0)),
      Qe.CurPlaying == At.Idle &&
        e == At.Idle &&
        this.isPlaying == !0 &&
        this.actions[this.stage].time >
          this.actions[this.stage].getClip().duration - this.blendingTime)
    ) {
      let t = this.stage + 1
      ;(t >= this.actions.length && (t = 0),
        (this.actions[t].time = 0),
        Qe.SetWeight(this.actions[t], 1),
        (this.actions[t].loop = Vl),
        this.actions[t].play(),
        Qe.PrepareCrossFade(this.actions[this.stage], this.actions[t], this.blendingTime),
        (this.stage = t))
    }
  }
}
class zq extends of {
  constructor(e, t) {
    super(e, t)
  }
  update(e) {
    ;(Qe.CurPlaying == null &&
      e == At.Idle &&
      this.isPlaying == !1 &&
      ((this.stage = 0),
      (this.actions[this.stage].time = 0),
      Qe.SetWeight(this.actions[this.stage], 1),
      (this.actions[this.stage].loop = Vl),
      (this.actions[this.stage].clampWhenFinished = !1),
      (this.actions[this.stage].paused = !1),
      this.actions[this.stage].play(),
      Qe.LastAction != null &&
        Qe.PrepareCrossFade(Qe.LastAction, this.actions[this.stage], this.blendingTime),
      (this.isPlaying = !0)),
      Qe.CurPlaying == At.Idle &&
        e != At.Idle &&
        this.isPlaying == !0 &&
        this.stage == 0 &&
        ((this.actions[this.stage].loop = Jr),
        (this.actions[this.stage].clampWhenFinished = !0),
        (this.isPlaying = !1),
        (Qe.LastAction = this.actions[this.stage])))
  }
}
class Vq extends of {
  constructor(e, t) {
    super(e, t)
  }
  update(e) {
    ;(Qe.CurPlaying == null &&
      e == At.Listening &&
      this.isPlaying == !1 &&
      ((this.stage = 0),
      (this.actions[this.stage].time = 0),
      this.actions[this.stage].play(),
      Qe.SetWeight(this.actions[this.stage], 1),
      (this.actions[this.stage].loop = this.isGroup ? Jr : Vl),
      (this.actions[this.stage].clampWhenFinished = !!this.isGroup),
      Qe.LastAction != null &&
        Qe.PrepareCrossFade(Qe.LastAction, this.actions[this.stage], this.blendingTime),
      (this.isPlaying = !0)),
      this.isGroup &&
        (Qe.CurPlaying == At.Listening &&
          e == At.Listening &&
          this.isPlaying == !0 &&
          this.stage == 0 &&
          this.actions[this.stage].time >
            this.actions[this.stage].getClip().duration - this.blendingTime &&
          ((this.actions[this.stage + 1].time = 0),
          Qe.SetWeight(this.actions[this.stage + 1], 1),
          (this.actions[this.stage + 1].loop = Vl),
          this.actions[this.stage + 1].play(),
          Qe.PrepareCrossFade(
            this.actions[this.stage],
            this.actions[this.stage + 1],
            this.blendingTime
          ),
          (this.stage = 1)),
        Qe.CurPlaying == At.Listening &&
          e != At.Listening &&
          this.isPlaying == !0 &&
          (this.stage == 0 || this.stage == 1) &&
          ((this.actions[2].time = 0),
          this.actions[2].play(),
          Qe.SetWeight(this.actions[2], 1),
          (this.actions[2].loop = Jr),
          Qe.PrepareCrossFade(this.actions[this.stage], this.actions[2], this.blendingTime),
          (this.stage = 2))),
      Qe.CurPlaying == At.Listening &&
        e != At.Listening &&
        this.isPlaying == !0 &&
        this.stage == (this.isGroup ? this.actions.length - 1 : 0) &&
        ((this.actions[this.stage].loop = Jr),
        (this.actions[this.stage].clampWhenFinished = !0),
        (this.isPlaying = !1),
        (Qe.LastAction = this.actions[this.stage])))
  }
}
class Hq extends of {
  constructor(e, t) {
    super(e, t)
  }
  update(e) {
    ;(Qe.CurPlaying == null &&
      e == At.Thinking &&
      this.isPlaying == !1 &&
      ((this.stage = 0),
      (this.actions[this.stage].time = 0),
      this.actions[this.stage].play(),
      Qe.SetWeight(this.actions[this.stage], 1),
      (this.actions[this.stage].loop = Jr),
      Qe.LastAction != null &&
        Qe.PrepareCrossFade(Qe.LastAction, this.actions[this.stage], this.blendingTime),
      (this.isPlaying = !0)),
      this.isGroup &&
        (Qe.CurPlaying == At.Thinking &&
          e == At.Thinking &&
          this.isPlaying == !0 &&
          this.stage == 0 &&
          this.actions[this.stage].time >
            this.actions[this.stage].getClip().duration - this.blendingTime &&
          ((this.actions[this.stage + 1].time = 0),
          this.actions[this.stage + 1].play(),
          Qe.SetWeight(this.actions[this.stage + 1], 1),
          (this.actions[this.stage + 1].loop = Vl),
          Qe.PrepareCrossFade(
            this.actions[this.stage],
            this.actions[this.stage + 1],
            this.blendingTime
          ),
          (this.stage = 1)),
        Qe.CurPlaying == At.Thinking &&
          e != At.Thinking &&
          this.isPlaying == !0 &&
          (this.stage == 0 || this.stage == 1) &&
          ((this.actions[2].time = 0),
          this.actions[2].play(),
          Qe.SetWeight(this.actions[2], 1),
          (this.actions[2].loop = Jr),
          Qe.PrepareCrossFade(this.actions[this.stage], this.actions[2], this.blendingTime),
          (this.stage = 2))),
      Qe.CurPlaying == At.Thinking &&
        e != At.Thinking &&
        this.isPlaying == !0 &&
        this.stage == (this.isGroup ? this.actions.length - 1 : 0) &&
        ((this.actions[this.stage].loop = Jr),
        (this.actions[this.stage].clampWhenFinished = !0),
        this.actions[this.stage].time > this.actions[this.stage].getClip().duration - 0.3 &&
          ((this.isPlaying = !1), (Qe.LastAction = this.actions[this.stage]))))
  }
}
class $q extends of {
  constructor(e, t) {
    super(e, t)
  }
  getRandonNumber(e, t) {
    const i = e - t
    return t + Math.round(Math.random() * i)
  }
  update(e) {
    if (
      (Qe.CurPlaying == null &&
        e == At.Responding &&
        this.isPlaying == !1 &&
        ((this.stage = Math.ceil(this.getRandonNumber(0, this.actions.length - 1))),
        (this.actions[this.stage].time = 0),
        this.actions[this.stage].play(),
        Qe.SetWeight(this.actions[this.stage], 1),
        (this.actions[this.stage].loop = Jr),
        (this.actions[this.stage].clampWhenFinished = !0),
        Qe.LastAction != null &&
          Qe.PrepareCrossFade(Qe.LastAction, this.actions[this.stage], this.blendingTime),
        (this.isPlaying = !0)),
      Qe.CurPlaying == At.Responding &&
        e == At.Responding &&
        this.isPlaying == !0 &&
        this.actions[this.stage].time >=
          this.actions[this.stage].getClip().duration - this.blendingTime)
    ) {
      const t = this.actions[this.stage]
      ;((this.stage =
        (this.stage + Math.ceil(this.getRandonNumber(1, this.actions.length - 1))) %
        this.actions.length),
        (this.actions[this.stage].time = 0),
        this.actions[this.stage].play(),
        Qe.SetWeight(this.actions[this.stage], 1),
        (this.actions[this.stage].loop = Jr),
        (this.actions[this.stage].clampWhenFinished = !0),
        Qe.PrepareCrossFade(t, this.actions[this.stage], this.blendingTime))
    }
    Qe.CurPlaying == At.Responding &&
      e != At.Responding &&
      this.isPlaying == !0 &&
      ((this.actions[this.stage].loop = Jr),
      (this.actions[this.stage].clampWhenFinished = !0),
      (this.isPlaying = !1),
      (Qe.LastAction = this.actions[this.stage]))
  }
}
function Zb(n, e) {
  if (e === lP)
    return (
      console.warn(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.'
      ),
      n
    )
  if (e === Uy || e === R5) {
    let t = n.getIndex()
    if (t === null) {
      const o = [],
        a = n.getAttribute('position')
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l)
        ;(n.setIndex(o), (t = n.getIndex()))
      } else
        return (
          console.error(
            'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
          ),
          n
        )
    }
    const i = t.count - 2,
      r = []
    if (e === Uy)
      for (let o = 1; o <= i; o++) (r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)))
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0
          ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
          : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)))
    r.length / 3 !== i &&
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.'
      )
    const s = n.clone()
    return (s.setIndex(r), s.clearGroups(), s)
  } else
    return (
      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', e),
      n
    )
}
class Gq extends Ou {
  constructor(e) {
    ;(super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new Xq(t)
      }),
      this.register(function (t) {
        return new Kq(t)
      }),
      this.register(function (t) {
        return new sX(t)
      }),
      this.register(function (t) {
        return new oX(t)
      }),
      this.register(function (t) {
        return new aX(t)
      }),
      this.register(function (t) {
        return new Zq(t)
      }),
      this.register(function (t) {
        return new Jq(t)
      }),
      this.register(function (t) {
        return new eX(t)
      }),
      this.register(function (t) {
        return new tX(t)
      }),
      this.register(function (t) {
        return new qq(t)
      }),
      this.register(function (t) {
        return new nX(t)
      }),
      this.register(function (t) {
        return new Yq(t)
      }),
      this.register(function (t) {
        return new rX(t)
      }),
      this.register(function (t) {
        return new iX(t)
      }),
      this.register(function (t) {
        return new Qq(t)
      }),
      this.register(function (t) {
        return new lX(t)
      }),
      this.register(function (t) {
        return new cX(t)
      }))
  }
  load(e, t, i, r) {
    const s = this
    let o
    if (this.resourcePath !== '') o = this.resourcePath
    else if (this.path !== '') {
      const c = kd.extractUrlBase(e)
      o = kd.resolveURL(c, this.path)
    } else o = kd.extractUrlBase(e)
    this.manager.itemStart(e)
    const a = function (c) {
        ;(r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e))
      },
      l = new q5(this.manager)
    ;(l.setPath(this.path),
      l.setResponseType('arraybuffer'),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              o,
              function (u) {
                ;(t(u), s.manager.itemEnd(e))
              },
              a
            )
          } catch (u) {
            a(u)
          }
        },
        i,
        a
      ))
  }
  setDRACOLoader(e) {
    return ((this.dracoLoader = e), this)
  }
  setKTX2Loader(e) {
    return ((this.ktx2Loader = e), this)
  }
  setMeshoptDecoder(e) {
    return ((this.meshoptDecoder = e), this)
  }
  register(e) {
    return (this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this)
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    )
  }
  parse(e, t, i, r) {
    let s
    const o = {},
      a = {},
      l = new TextDecoder()
    if (typeof e == 'string') s = JSON.parse(e)
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === d6) {
        try {
          o[Pt.KHR_BINARY_GLTF] = new uX(e)
        } catch (d) {
          r && r(d)
          return
        }
        s = JSON.parse(o[Pt.KHR_BINARY_GLTF].content)
      } else s = JSON.parse(l.decode(e))
    else s = e
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r && r(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))
      return
    }
    const c = new bX(s, {
      path: t || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    })
    c.fileLoader.setRequestHeader(this.requestHeader)
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const d = this.pluginCallbacks[u](c)
      ;(d.name || console.error('THREE.GLTFLoader: Invalid plugin found: missing name'),
        (a[d.name] = d),
        (o[d.name] = !0))
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const d = s.extensionsUsed[u],
          h = s.extensionsRequired || []
        switch (d) {
          case Pt.KHR_MATERIALS_UNLIT:
            o[d] = new jq()
            break
          case Pt.KHR_DRACO_MESH_COMPRESSION:
            o[d] = new dX(s, this.dracoLoader)
            break
          case Pt.KHR_TEXTURE_TRANSFORM:
            o[d] = new hX()
            break
          case Pt.KHR_MESH_QUANTIZATION:
            o[d] = new fX()
            break
          default:
            h.indexOf(d) >= 0 &&
              a[d] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
        }
      }
    ;(c.setExtensions(o), c.setPlugins(a), c.parse(i, r))
  }
  parseAsync(e, t) {
    const i = this
    return new Promise(function (r, s) {
      i.parse(e, t, r, s)
    })
  }
}
function Wq() {
  let n = {}
  return {
    get: function (e) {
      return n[e]
    },
    add: function (e, t) {
      n[e] = t
    },
    remove: function (e) {
      delete n[e]
    },
    removeAll: function () {
      n = {}
    },
  }
}
const Pt = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',
}
class Qq {
  constructor(e) {
    ;((this.parser = e),
      (this.name = Pt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} }))
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || []
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i]
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light)
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = 'light:' + e
    let r = t.cache.get(i)
    if (r) return r
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e]
    let c
    const u = new gt(16777215)
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Ui)
    const d = l.range !== void 0 ? l.range : 0
    switch (l.type) {
      case 'directional':
        ;((c = new kL(u)), c.target.position.set(0, 0, -1), c.add(c.target))
        break
      case 'point':
        ;((c = new BL(u)), (c.distance = d))
        break
      case 'spot':
        ;((c = new FL(u)),
          (c.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target))
        break
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + l.type)
    }
    return (
      c.position.set(0, 0, 0),
      wo(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || 'light_' + e)),
      (r = Promise.resolve(c)),
      t.cache.add(i, r),
      r
    )
  }
  getDependency(e, t) {
    if (e === 'light') return this._loadLight(t)
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l)
        })
  }
}
class jq {
  constructor() {
    this.name = Pt.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return Yr
  }
  extendParams(e, t, i) {
    const r = []
    ;((e.color = new gt(1, 1, 1)), (e.opacity = 1))
    const s = t.pbrMetallicRoughness
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor
        ;(e.color.setRGB(o[0], o[1], o[2], Ui), (e.opacity = o[3]))
      }
      s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, 'map', s.baseColorTexture, fi))
    }
    return Promise.all(r)
  }
}
class qq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_EMISSIVE_STRENGTH))
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = r.extensions[this.name].emissiveStrength
    return (s !== void 0 && (t.emissiveIntensity = s), Promise.resolve())
  }
}
class Xq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_CLEARCOAT))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, 'clearcoatMap', o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(i.assignTexture(t, 'clearcoatRoughnessMap', o.clearcoatRoughnessTexture)),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(i.assignTexture(t, 'clearcoatNormalMap', o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale
      t.clearcoatNormalScale = new je(a, a)
    }
    return Promise.all(s)
  }
}
class Kq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_DISPERSION))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = r.extensions[this.name]
    return ((t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0), Promise.resolve())
  }
}
class Yq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_IRIDESCENCE))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, 'iridescenceMap', o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, 'iridescenceThicknessMap', o.iridescenceThicknessTexture)),
      Promise.all(s)
    )
  }
}
class Zq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_SHEEN))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = []
    ;((t.sheenColor = new gt(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1))
    const o = r.extensions[this.name]
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor
      t.sheenColor.setRGB(a[0], a[1], a[2], Ui)
    }
    return (
      o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, 'sheenColorMap', o.sheenColorTexture, fi)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(i.assignTexture(t, 'sheenRoughnessMap', o.sheenRoughnessTexture)),
      Promise.all(s)
    )
  }
}
class Jq {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_TRANSMISSION))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    return (
      o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, 'transmissionMap', o.transmissionTexture)),
      Promise.all(s)
    )
  }
}
class eX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_VOLUME))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    ;((t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, 'thicknessMap', o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0))
    const a = o.attenuationColor || [1, 1, 1]
    return ((t.attenuationColor = new gt().setRGB(a[0], a[1], a[2], Ui)), Promise.all(s))
  }
}
class tX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_IOR))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = r.extensions[this.name]
    return ((t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve())
  }
}
class nX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_SPECULAR))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    ;((t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, 'specularIntensityMap', o.specularTexture)))
    const a = o.specularColorFactor || [1, 1, 1]
    return (
      (t.specularColor = new gt().setRGB(a[0], a[1], a[2], Ui)),
      o.specularColorTexture !== void 0 &&
        s.push(i.assignTexture(t, 'specularColorMap', o.specularColorTexture, fi)),
      Promise.all(s)
    )
  }
}
class iX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.EXT_MATERIALS_BUMP))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    return (
      (t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 && s.push(i.assignTexture(t, 'bumpMap', o.bumpTexture)),
      Promise.all(s)
    )
  }
}
class rX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_MATERIALS_ANISOTROPY))
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e]
    return !i.extensions || !i.extensions[this.name] ? null : ao
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e]
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve()
    const s = [],
      o = r.extensions[this.name]
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(t, 'anisotropyMap', o.anisotropyTexture)),
      Promise.all(s)
    )
  }
}
class sX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.KHR_TEXTURE_BASISU))
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e]
    if (!r.extensions || !r.extensions[this.name]) return null
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures'
        )
      return null
    }
    return t.loadTextureImage(e, s.source, o)
  }
}
class oX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.EXT_TEXTURE_WEBP), (this.isSupported = null))
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e]
    if (!s.extensions || !s.extensions[t]) return null
    const o = s.extensions[t],
      a = r.images[o.source]
    let l = i.textureLoader
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri)
      c !== null && (l = c)
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l)
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
      return i.loadTexture(e)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image()
          ;((t.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1)
              }))
        })),
      this.isSupported
    )
  }
}
class aX {
  constructor(e) {
    ;((this.parser = e), (this.name = Pt.EXT_TEXTURE_AVIF), (this.isSupported = null))
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e]
    if (!s.extensions || !s.extensions[t]) return null
    const o = s.extensions[t],
      a = r.images[o.source]
    let l = i.textureLoader
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri)
      c !== null && (l = c)
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l)
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')
      return i.loadTexture(e)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image()
          ;((t.src =
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1)
              }))
        })),
      this.isSupported
    )
  }
}
class lX {
  constructor(e) {
    ;((this.name = Pt.EXT_MESHOPT_COMPRESSION), (this.parser = e))
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e]
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency('buffer', r.buffer),
        o = this.parser.options.meshoptDecoder
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
          )
        return null
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          c = r.byteLength || 0,
          u = r.count,
          d = r.byteStride,
          h = new Uint8Array(a, l, c)
        return o.decodeGltfBufferAsync
          ? o.decodeGltfBufferAsync(u, d, h, r.mode, r.filter).then(function (f) {
              return f.buffer
            })
          : o.ready.then(function () {
              const f = new ArrayBuffer(u * d)
              return (o.decodeGltfBuffer(new Uint8Array(f), u, d, h, r.mode, r.filter), f)
            })
      })
    } else return null
  }
}
class cX {
  constructor(e) {
    ;((this.name = Pt.EXT_MESH_GPU_INSTANCING), (this.parser = e))
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e]
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null
    const r = t.meshes[i.mesh]
    for (const c of r.primitives)
      if (
        c.mode !== Hr.TRIANGLES &&
        c.mode !== Hr.TRIANGLE_STRIP &&
        c.mode !== Hr.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {}
    for (const c in o)
      a.push(this.parser.getDependency('accessor', o[c]).then((u) => ((l[c] = u), l[c])))
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const u = c.pop(),
            d = u.isGroup ? u.children : [u],
            h = c[0].count,
            f = []
          for (const p of d) {
            const g = new qe(),
              y = new Y(),
              m = new Qt(),
              v = new Y(1, 1, 1),
              x = new pL(p.geometry, p.material, h)
            for (let _ = 0; _ < h; _++)
              (l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, _),
                l.ROTATION && m.fromBufferAttribute(l.ROTATION, _),
                l.SCALE && v.fromBufferAttribute(l.SCALE, _),
                x.setMatrixAt(_, g.compose(y, m, v)))
            for (const _ in l)
              if (_ === '_COLOR_0') {
                const S = l[_]
                x.instanceColor = new Ko(S.array, S.itemSize, S.normalized)
              } else
                _ !== 'TRANSLATION' &&
                  _ !== 'ROTATION' &&
                  _ !== 'SCALE' &&
                  p.geometry.setAttribute(_, l[_])
            ;(sn.prototype.copy.call(x, p), this.parser.assignFinalMaterial(x), f.push(x))
          }
          return u.isGroup ? (u.clear(), u.add(...f), u) : f[0]
        }))
  }
}
const d6 = 'glTF',
  _d = 12,
  Jb = { JSON: 1313821514, BIN: 5130562 }
class uX {
  constructor(e) {
    ;((this.name = Pt.KHR_BINARY_GLTF), (this.content = null), (this.body = null))
    const t = new DataView(e, 0, _d),
      i = new TextDecoder()
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== d6)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
    if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
    const r = this.header.length - _d,
      s = new DataView(e, _d)
    let o = 0
    for (; o < r; ) {
      const a = s.getUint32(o, !0)
      o += 4
      const l = s.getUint32(o, !0)
      if (((o += 4), l === Jb.JSON)) {
        const c = new Uint8Array(e, _d + o, a)
        this.content = i.decode(c)
      } else if (l === Jb.BIN) {
        const c = _d + o
        this.body = e.slice(c, c + a)
      }
      o += a
    }
    if (this.content === null) throw new Error('THREE.GLTFLoader: JSON content not found.')
  }
}
class dX {
  constructor(e, t) {
    if (!t) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
    ;((this.name = Pt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload())
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {}
    for (const u in o) {
      const d = mv[u] || u.toLowerCase()
      a[d] = o[u]
    }
    for (const u in e.attributes) {
      const d = mv[u] || u.toLowerCase()
      if (o[u] !== void 0) {
        const h = i.accessors[e.attributes[u]],
          f = Kc[h.componentType]
        ;((c[d] = f.name), (l[d] = h.normalized === !0))
      }
    }
    return t.getDependency('bufferView', s).then(function (u) {
      return new Promise(function (d, h) {
        r.decodeDracoFile(
          u,
          function (f) {
            for (const p in f.attributes) {
              const g = f.attributes[p],
                y = l[p]
              y !== void 0 && (g.normalized = y)
            }
            d(f)
          },
          a,
          c,
          Ui,
          h
        )
      })
    })
  }
}
class hX {
  constructor() {
    this.name = Pt.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    )
  }
}
class fX {
  constructor() {
    this.name = Pt.KHR_MESH_QUANTIZATION
  }
}
class h6 extends kh {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r
    for (let o = 0; o !== r; o++) t[o] = i[s + o]
    return t
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      u = r - t,
      d = (i - t) / u,
      h = d * d,
      f = h * d,
      p = e * c,
      g = p - c,
      y = -2 * f + 3 * h,
      m = f - h,
      v = 1 - y,
      x = m - h + d
    for (let _ = 0; _ !== a; _++) {
      const S = o[g + _ + a],
        C = o[g + _ + l] * u,
        A = o[p + _ + a],
        R = o[p + _] * u
      s[_] = v * S + x * C + y * A + m * R
    }
    return s
  }
}
const pX = new Qt()
class mX extends h6 {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r)
    return (pX.fromArray(s).normalize().toArray(s), s)
  }
}
const Hr = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
  },
  Kc = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  e3 = { 9728: vi, 9729: Rr, 9984: x5, 9985: Ep, 9986: Td, 9987: Ws },
  t3 = { 33071: wa, 33648: hm, 10497: uu },
  S1 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  mv = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv1',
    TEXCOORD_2: 'uv2',
    TEXCOORD_3: 'uv3',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex',
  },
  pa = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences',
  },
  gX = { CUBICSPLINE: void 0, LINEAR: uh, STEP: ch },
  A1 = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' }
function yX(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new R_({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Ts,
      })),
    n.DefaultMaterial
  )
}
function dl(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]))
}
function wo(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == 'object'
      ? Object.assign(n.userData, e.extras)
      : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras))
}
function vX(n, e, t) {
  let i = !1,
    r = !1,
    s = !1
  for (let c = 0, u = e.length; c < u; c++) {
    const d = e[c]
    if (
      (d.POSITION !== void 0 && (i = !0),
      d.NORMAL !== void 0 && (r = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break
  }
  if (!i && !r && !s) return Promise.resolve(n)
  const o = [],
    a = [],
    l = []
  for (let c = 0, u = e.length; c < u; c++) {
    const d = e[c]
    if (i) {
      const h =
        d.POSITION !== void 0 ? t.getDependency('accessor', d.POSITION) : n.attributes.position
      o.push(h)
    }
    if (r) {
      const h = d.NORMAL !== void 0 ? t.getDependency('accessor', d.NORMAL) : n.attributes.normal
      a.push(h)
    }
    if (s) {
      const h = d.COLOR_0 !== void 0 ? t.getDependency('accessor', d.COLOR_0) : n.attributes.color
      l.push(h)
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
    const u = c[0],
      d = c[1],
      h = c[2]
    return (
      i && (n.morphAttributes.position = u),
      r && (n.morphAttributes.normal = d),
      s && (n.morphAttributes.color = h),
      (n.morphTargetsRelative = !0),
      n
    )
  })
}
function _X(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t]
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {}
      for (let i = 0, r = t.length; i < r; i++) n.morphTargetDictionary[t[i]] = i
    } else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')
  }
}
function xX(n) {
  let e
  const t = n.extensions && n.extensions[Pt.KHR_DRACO_MESH_COMPRESSION]
  if (
    (t
      ? (e = 'draco:' + t.bufferView + ':' + t.indices + ':' + b1(t.attributes))
      : (e = n.indices + ':' + b1(n.attributes) + ':' + n.mode),
    n.targets !== void 0)
  )
    for (let i = 0, r = n.targets.length; i < r; i++) e += ':' + b1(n.targets[i])
  return e
}
function b1(n) {
  let e = ''
  const t = Object.keys(n).sort()
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ':' + n[t[i]] + ';'
  return e
}
function gv(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')
  }
}
function SX(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? 'image/jpeg'
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
      ? 'image/webp'
      : n.search(/\.ktx2($|\?)/i) > 0 || n.search(/^data\:image\/ktx2/) === 0
        ? 'image/ktx2'
        : 'image/png'
}
const AX = new qe()
class bX {
  constructor(e = {}, t = {}) {
    ;((this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new Wq()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}))
    let i = !1,
      r = -1,
      s = !1,
      o = -1
    if (typeof navigator < 'u') {
      const a = navigator.userAgent
      i = /^((?!chrome|android).)*safari/i.test(a) === !0
      const l = a.match(/Version\/(\d+)/)
      ;((r = i && l ? parseInt(l[1], 10) : -1),
        (s = a.indexOf('Firefox') > -1),
        (o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1))
    }
    ;(typeof createImageBitmap > 'u' || (i && r < 17) || (s && o < 98)
      ? (this.textureLoader = new LL(this.options.manager))
      : (this.textureLoader = new VL(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new q5(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      this.options.crossOrigin === 'use-credentials' && this.fileLoader.setWithCredentials(!0))
  }
  setExtensions(e) {
    this.extensions = e
  }
  setPlugins(e) {
    this.plugins = e
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions
    ;(this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs()
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot()
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies('scene'),
            i.getDependencies('animation'),
            i.getDependencies('camera'),
          ])
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          }
          return (
            dl(s, a, r),
            wo(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a)
              })
            ).then(function () {
              for (const l of a.scenes) l.updateMatrixWorld()
              e(a)
            })
          )
        })
        .catch(t))
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || []
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r]
      ;(o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera))
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o)
        l != null && this.associations.set(a, l)
        for (const [c, u] of o.children.entries()) s(u, a.children[c])
      }
    return (s(i, r), (r.name += '_instance_' + e.uses[t]++), r)
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins)
    t.push(this)
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i])
      if (r) return r
    }
    return null
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins)
    t.unshift(this)
    const i = []
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r])
      s && i.push(s)
    }
    return i
  }
  getDependency(e, t) {
    const i = e + ':' + t
    let r = this.cache.get(i)
    if (!r) {
      switch (e) {
        case 'scene':
          r = this.loadScene(t)
          break
        case 'node':
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t)
          })
          break
        case 'mesh':
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t)
          })
          break
        case 'accessor':
          r = this.loadAccessor(t)
          break
        case 'bufferView':
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t)
          })
          break
        case 'buffer':
          r = this.loadBuffer(t)
          break
        case 'material':
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t)
          })
          break
        case 'texture':
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t)
          })
          break
        case 'skin':
          r = this.loadSkin(t)
          break
        case 'animation':
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t)
          })
          break
        case 'camera':
          r = this.loadCamera(t)
          break
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t)
            })),
            !r)
          )
            throw new Error('Unknown type: ' + e)
          break
      }
      this.cache.add(i, r)
    }
    return r
  }
  getDependencies(e) {
    let t = this.cache.get(e)
    if (!t) {
      const i = this,
        r = this.json[e + (e === 'mesh' ? 'es' : 's')] || []
      ;((t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o)
        })
      )),
        this.cache.add(e, t))
    }
    return t
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader
    if (t.type && t.type !== 'arraybuffer')
      throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.')
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Pt.KHR_BINARY_GLTF].body)
    const r = this.options
    return new Promise(function (s, o) {
      i.load(kd.resolveURL(t.uri, r.path), s, void 0, function () {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
      })
    })
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e]
    return this.getDependency('buffer', t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0
      return i.slice(s, s + r)
    })
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e]
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = S1[r.type],
        a = Kc[r.componentType],
        l = r.normalized === !0,
        c = new a(r.count * o)
      return Promise.resolve(new _i(c, o, l))
    }
    const s = []
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency('bufferView', r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency('bufferView', r.sparse.indices.bufferView)),
        s.push(this.getDependency('bufferView', r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = S1[r.type],
          c = Kc[r.componentType],
          u = c.BYTES_PER_ELEMENT,
          d = u * l,
          h = r.byteOffset || 0,
          f = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0,
          p = r.normalized === !0
        let g, y
        if (f && f !== d) {
          const m = Math.floor(h / f),
            v =
              'InterleavedBuffer:' + r.bufferView + ':' + r.componentType + ':' + m + ':' + r.count
          let x = t.cache.get(v)
          ;(x ||
            ((g = new c(a, m * f, (r.count * f) / u)), (x = new w_(g, f / u)), t.cache.add(v, x)),
            (y = new l0(x, l, (h % f) / u, p)))
        } else
          (a === null ? (g = new c(r.count * l)) : (g = new c(a, h, r.count * l)),
            (y = new _i(g, l, p)))
        if (r.sparse !== void 0) {
          const m = S1.SCALAR,
            v = Kc[r.sparse.indices.componentType],
            x = r.sparse.indices.byteOffset || 0,
            _ = r.sparse.values.byteOffset || 0,
            S = new v(o[1], x, r.sparse.count * m),
            C = new c(o[2], _, r.sparse.count * l)
          ;(a !== null && (y = new _i(y.array.slice(), y.itemSize, y.normalized)),
            (y.normalized = !1))
          for (let A = 0, R = S.length; A < R; A++) {
            const w = S[A]
            if (
              (y.setX(w, C[A * l]),
              l >= 2 && y.setY(w, C[A * l + 1]),
              l >= 3 && y.setZ(w, C[A * l + 2]),
              l >= 4 && y.setW(w, C[A * l + 3]),
              l >= 5)
            )
              throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
          }
          y.normalized = p
        }
        return y
      })
    )
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s]
    let a = this.textureLoader
    if (o.uri) {
      const l = i.manager.getHandler(o.uri)
      l !== null && (a = l)
    }
    return this.loadTextureImage(e, s, a)
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ':' + o.sampler
    if (this.textureCache[l]) return this.textureCache[l]
    const c = this.loadImageSource(t, i)
      .then(function (u) {
        ;((u.flipY = !1),
          (u.name = o.name || a.name || ''),
          u.name === '' &&
            typeof a.uri == 'string' &&
            a.uri.startsWith('data:image/') === !1 &&
            (u.name = a.uri))
        const h = (s.samplers || {})[o.sampler] || {}
        return (
          (u.magFilter = e3[h.magFilter] || Rr),
          (u.minFilter = e3[h.minFilter] || Ws),
          (u.wrapS = t3[h.wrapS] || uu),
          (u.wrapT = t3[h.wrapT] || uu),
          (u.generateMipmaps = !u.isCompressedTexture && u.minFilter !== vi && u.minFilter !== Rr),
          r.associations.set(u, { textures: e }),
          u
        )
      })
      .catch(function () {
        return null
      })
    return ((this.textureCache[l] = c), c)
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options
    if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((d) => d.clone())
    const o = r.images[e],
      a = self.URL || self.webkitURL
    let l = o.uri || '',
      c = !1
    if (o.bufferView !== void 0)
      l = i.getDependency('bufferView', o.bufferView).then(function (d) {
        c = !0
        const h = new Blob([d], { type: o.mimeType })
        return ((l = a.createObjectURL(h)), l)
      })
    else if (o.uri === void 0)
      throw new Error('THREE.GLTFLoader: Image ' + e + ' is missing URI and bufferView')
    const u = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (h, f) {
          let p = h
          ;(t.isImageBitmapLoader === !0 &&
            (p = function (g) {
              const y = new Wn(g)
              ;((y.needsUpdate = !0), h(y))
            }),
            t.load(kd.resolveURL(d, s.path), p, void 0, f))
        })
      })
      .then(function (d) {
        return (
          c === !0 && a.revokeObjectURL(l),
          wo(d, o),
          (d.userData.mimeType = o.mimeType || SX(o.uri)),
          d
        )
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d)
      })
    return ((this.sourceCache[e] = u), u)
  }
  assignTexture(e, t, i, r) {
    const s = this
    return this.getDependency('texture', i.index).then(function (o) {
      if (!o) return null
      if (
        (i.texCoord !== void 0 && i.texCoord > 0 && ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[Pt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a = i.extensions !== void 0 ? i.extensions[Pt.KHR_TEXTURE_TRANSFORM] : void 0
        if (a) {
          const l = s.associations.get(o)
          ;((o = s.extensions[Pt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l))
        }
      }
      return (r !== void 0 && (o.colorSpace = r), (e[t] = o), o)
    })
  }
  assignFinalMaterial(e) {
    const t = e.geometry
    let i = e.material
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0
    if (e.isPoints) {
      const a = 'PointsMaterial:' + i.uuid
      let l = this.cache.get(a)
      ;(l ||
        ((l = new $5()),
        es.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l))
    } else if (e.isLine) {
      const a = 'LineBasicMaterial:' + i.uuid
      let l = this.cache.get(a)
      ;(l ||
        ((l = new H5()),
        es.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l))
    }
    if (r || s || o) {
      let a = 'ClonedMaterial:' + i.uuid + ':'
      ;(r && (a += 'derivative-tangents:'),
        s && (a += 'vertex-colors:'),
        o && (a += 'flat-shading:'))
      let l = this.cache.get(a)
      ;(l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l))
    }
    e.material = i
  }
  getMaterialType() {
    return R_
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e]
    let o
    const a = {},
      l = s.extensions || {},
      c = []
    if (l[Pt.KHR_MATERIALS_UNLIT]) {
      const d = r[Pt.KHR_MATERIALS_UNLIT]
      ;((o = d.getMaterialType()), c.push(d.extendParams(a, s, t)))
    } else {
      const d = s.pbrMetallicRoughness || {}
      if (((a.color = new gt(1, 1, 1)), (a.opacity = 1), Array.isArray(d.baseColorFactor))) {
        const h = d.baseColorFactor
        ;(a.color.setRGB(h[0], h[1], h[2], Ui), (a.opacity = h[3]))
      }
      ;(d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, 'map', d.baseColorTexture, fi)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (c.push(t.assignTexture(a, 'metalnessMap', d.metallicRoughnessTexture)),
          c.push(t.assignTexture(a, 'roughnessMap', d.metallicRoughnessTexture))),
        (o = this._invokeOne(function (h) {
          return h.getMaterialType && h.getMaterialType(e)
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (h) {
              return h.extendMaterialParams && h.extendMaterialParams(e, a)
            })
          )
        ))
    }
    s.doubleSided === !0 && (a.side = wr)
    const u = s.alphaMode || A1.OPAQUE
    if (
      (u === A1.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          u === A1.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== Yr &&
        (c.push(t.assignTexture(a, 'normalMap', s.normalTexture)),
        (a.normalScale = new je(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale
      a.normalScale.set(d, d)
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== Yr &&
        (c.push(t.assignTexture(a, 'aoMap', s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== Yr)
    ) {
      const d = s.emissiveFactor
      a.emissive = new gt().setRGB(d[0], d[1], d[2], Ui)
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== Yr &&
        c.push(t.assignTexture(a, 'emissiveMap', s.emissiveTexture, fi)),
      Promise.all(c).then(function () {
        const d = new o(a)
        return (
          s.name && (d.name = s.name),
          wo(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && dl(r, d, s),
          d
        )
      })
    )
  }
  createUniqueName(e) {
    const t = nn.sanitizeNodeName(e || '')
    return t in this.nodeNamesUsed
      ? t + '_' + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t)
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache
    function s(a) {
      return i[Pt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) {
        return n3(l, a, t)
      })
    }
    const o = []
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = xX(c),
        d = r[u]
      if (d) o.push(d.promise)
      else {
        let h
        ;(c.extensions && c.extensions[Pt.KHR_DRACO_MESH_COMPRESSION]
          ? (h = s(c))
          : (h = n3(new ki(), c, t)),
          (r[u] = { primitive: c, promise: h }),
          o.push(h))
      }
    }
    return Promise.all(o)
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = []
    for (let l = 0, c = o.length; l < c; l++) {
      const u =
        o[l].material === void 0 ? yX(this.cache) : this.getDependency('material', o[l].material)
      a.push(u)
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          d = []
        for (let f = 0, p = u.length; f < p; f++) {
          const g = u[f],
            y = o[f]
          let m
          const v = c[f]
          if (
            y.mode === Hr.TRIANGLES ||
            y.mode === Hr.TRIANGLE_STRIP ||
            y.mode === Hr.TRIANGLE_FAN ||
            y.mode === void 0
          )
            ((m = s.isSkinnedMesh === !0 ? new dL(g, v) : new pn(g, v)),
              m.isSkinnedMesh === !0 && m.normalizeSkinWeights(),
              y.mode === Hr.TRIANGLE_STRIP
                ? (m.geometry = Zb(m.geometry, R5))
                : y.mode === Hr.TRIANGLE_FAN && (m.geometry = Zb(m.geometry, Uy)))
          else if (y.mode === Hr.LINES) m = new yL(g, v)
          else if (y.mode === Hr.LINE_STRIP) m = new E_(g, v)
          else if (y.mode === Hr.LINE_LOOP) m = new vL(g, v)
          else if (y.mode === Hr.POINTS) m = new _L(g, v)
          else throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + y.mode)
          ;(Object.keys(m.geometry.morphAttributes).length > 0 && _X(m, s),
            (m.name = t.createUniqueName(s.name || 'mesh_' + e)),
            wo(m, s),
            y.extensions && dl(r, m, y),
            t.assignFinalMaterial(m),
            d.push(m))
        }
        for (let f = 0, p = d.length; f < p; f++)
          t.associations.set(d[f], { meshes: e, primitives: f })
        if (d.length === 1) return (s.extensions && dl(r, d[0], s), d[0])
        const h = new Tl()
        ;(s.extensions && dl(r, h, s), t.associations.set(h, { meshes: e }))
        for (let f = 0, p = d.length; f < p; f++) h.add(d[f])
        return h
      })
    )
  }
  loadCamera(e) {
    let t
    const i = this.json.cameras[e],
      r = i[i.type]
    if (!r) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.')
      return
    }
    return (
      i.type === 'perspective'
        ? (t = new Ki(Ea.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6))
        : i.type === 'orthographic' &&
          (t = new Bu(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      wo(t, i),
      Promise.resolve(t)
    )
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = []
    for (let r = 0, s = t.joints.length; r < s; r++) i.push(this._loadNodeShallow(t.joints[r]))
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency('accessor', t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = []
        for (let c = 0, u = o.length; c < u; c++) {
          const d = o[c]
          if (d) {
            a.push(d)
            const h = new qe()
            ;(s !== null && h.fromArray(s.array, c * 16), l.push(h))
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
        }
        return new c0(a, l)
      })
    )
  }
  loadAnimation(e) {
    const t = this.json,
      i = this,
      r = t.animations[e],
      s = r.name ? r.name : 'animation_' + e,
      o = [],
      a = [],
      l = [],
      c = [],
      u = []
    for (let d = 0, h = r.channels.length; d < h; d++) {
      const f = r.channels[d],
        p = r.samplers[f.sampler],
        g = f.target,
        y = g.node,
        m = r.parameters !== void 0 ? r.parameters[p.input] : p.input,
        v = r.parameters !== void 0 ? r.parameters[p.output] : p.output
      g.node !== void 0 &&
        (o.push(this.getDependency('node', y)),
        a.push(this.getDependency('accessor', m)),
        l.push(this.getDependency('accessor', v)),
        c.push(p),
        u.push(g))
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u),
    ]).then(function (d) {
      const h = d[0],
        f = d[1],
        p = d[2],
        g = d[3],
        y = d[4],
        m = []
      for (let v = 0, x = h.length; v < x; v++) {
        const _ = h[v],
          S = f[v],
          C = p[v],
          A = g[v],
          R = y[v]
        if (_ === void 0) continue
        _.updateMatrix && _.updateMatrix()
        const w = i._createAnimationTracks(_, S, C, A, R)
        if (w) for (let M = 0; M < w.length; M++) m.push(w[M])
      }
      return new zy(s, void 0, m)
    })
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e]
    return r.mesh === void 0
      ? null
      : i.getDependency('mesh', r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s)
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = r.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = r.weights[l]
              }),
            o
          )
        })
  }
  loadNode(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || []
    for (let c = 0, u = a.length; c < u; c++) o.push(i.getDependency('node', a[c]))
    const l = r.skin === void 0 ? Promise.resolve(null) : i.getDependency('skin', r.skin)
    return Promise.all([s, Promise.all(o), l]).then(function (c) {
      const u = c[0],
        d = c[1],
        h = c[2]
      h !== null &&
        u.traverse(function (f) {
          f.isSkinnedMesh && f.bind(h, AX)
        })
      for (let f = 0, p = d.length; f < p; f++) u.add(d[f])
      return u
    })
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      r = this
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e]
    const s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : '',
      a = [],
      l = r._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e)
      })
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency('camera', s.camera).then(function (c) {
            return r._getNodeRef(r.cameraCache, s.camera, c)
          })
        ),
      r
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e)
        })
        .forEach(function (c) {
          a.push(c)
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (c) {
        let u
        if (
          (s.isBone === !0
            ? (u = new fh())
            : c.length > 1
              ? (u = new Tl())
              : c.length === 1
                ? (u = c[0])
                : (u = new sn()),
          u !== c[0])
        )
          for (let d = 0, h = c.length; d < h; d++) u.add(c[d])
        if (
          (s.name && ((u.userData.name = s.name), (u.name = o)),
          wo(u, s),
          s.extensions && dl(i, u, s),
          s.matrix !== void 0)
        ) {
          const d = new qe()
          ;(d.fromArray(s.matrix), u.applyMatrix4(d))
        } else
          (s.translation !== void 0 && u.position.fromArray(s.translation),
            s.rotation !== void 0 && u.quaternion.fromArray(s.rotation),
            s.scale !== void 0 && u.scale.fromArray(s.scale))
        return (
          r.associations.has(u) || r.associations.set(u, {}),
          (r.associations.get(u).nodes = e),
          u
        )
      })),
      this.nodeCache[e]
    )
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new Tl()
    ;(i.name && (s.name = r.createUniqueName(i.name)), wo(s, i), i.extensions && dl(t, s, i))
    const o = i.nodes || [],
      a = []
    for (let l = 0, c = o.length; l < c; l++) a.push(r.getDependency('node', o[l]))
    return Promise.all(a).then(function (l) {
      for (let u = 0, d = l.length; u < d; u++) s.add(l[u])
      const c = (u) => {
        const d = new Map()
        for (const [h, f] of r.associations) (h instanceof es || h instanceof Wn) && d.set(h, f)
        return (
          u.traverse((h) => {
            const f = r.associations.get(h)
            f != null && d.set(h, f)
          }),
          d
        )
      }
      return ((r.associations = c(s)), s)
    })
  }
  _createAnimationTracks(e, t, i, r, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = []
    pa[s.path] === pa.weights
      ? e.traverse(function (h) {
          h.morphTargetInfluences && l.push(h.name ? h.name : h.uuid)
        })
      : l.push(a)
    let c
    switch (pa[s.path]) {
      case pa.weights:
        c = gu
        break
      case pa.rotation:
        c = yu
        break
      case pa.position:
      case pa.scale:
        c = vu
        break
      default:
        switch (i.itemSize) {
          case 1:
            c = gu
            break
          case 2:
          case 3:
          default:
            c = vu
            break
        }
        break
    }
    const u = r.interpolation !== void 0 ? gX[r.interpolation] : uh,
      d = this._getArrayFromAccessor(i)
    for (let h = 0, f = l.length; h < f; h++) {
      const p = new c(l[h] + '.' + pa[s.path], t.array, d, u)
      ;(r.interpolation === 'CUBICSPLINE' && this._createCubicSplineTrackInterpolant(p), o.push(p))
    }
    return o
  }
  _getArrayFromAccessor(e) {
    let t = e.array
    if (e.normalized) {
      const i = gv(t.constructor),
        r = new Float32Array(t.length)
      for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i
      t = r
    }
    return t
  }
  _createCubicSplineTrackInterpolant(e) {
    ;((e.createInterpolant = function (i) {
      const r = this instanceof yu ? mX : h6
      return new r(this.times, this.values, this.getValueSize() / 3, i)
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0))
  }
}
function TX(n, e, t) {
  const i = e.attributes,
    r = new ir()
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      c = a.max
    if (l !== void 0 && c !== void 0) {
      if ((r.set(new Y(l[0], l[1], l[2]), new Y(c[0], c[1], c[2])), a.normalized)) {
        const u = gv(Kc[a.componentType])
        ;(r.min.multiplyScalar(u), r.max.multiplyScalar(u))
      }
    } else {
      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
      return
    }
  } else return
  const s = e.targets
  if (s !== void 0) {
    const a = new Y(),
      l = new Y()
    for (let c = 0, u = s.length; c < u; c++) {
      const d = s[c]
      if (d.POSITION !== void 0) {
        const h = t.json.accessors[d.POSITION],
          f = h.min,
          p = h.max
        if (f !== void 0 && p !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))),
            l.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))),
            l.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))),
            h.normalized)
          ) {
            const g = gv(Kc[h.componentType])
            l.multiplyScalar(g)
          }
          a.max(l)
        } else console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
      }
    }
    r.expandByVector(a)
  }
  n.boundingBox = r
  const o = new oo()
  ;(r.getCenter(o.center), (o.radius = r.min.distanceTo(r.max) / 2), (n.boundingSphere = o))
}
function n3(n, e, t) {
  const i = e.attributes,
    r = []
  function s(o, a) {
    return t.getDependency('accessor', o).then(function (l) {
      n.setAttribute(a, l)
    })
  }
  for (const o in i) {
    const a = mv[o] || o.toLowerCase()
    a in n.attributes || r.push(s(i[o], a))
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency('accessor', e.indices).then(function (a) {
      n.setIndex(a)
    })
    r.push(o)
  }
  return (
    Tt.workingColorSpace !== Ui &&
      'COLOR_0' in i &&
      console.warn(
        'THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "'.concat(
          Tt.workingColorSpace,
          '" not supported.'
        )
      ),
    wo(n, e),
    TX(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? vX(n, e.targets, t) : n
    })
  )
}
var wX = {
    browDownLeft: 0,
    browDownRight: 0,
    browInnerUp: 0,
    browOuterUpLeft: 0,
    browOuterUpRight: 0,
    cheekPuff: 0,
    cheekSquintLeft: 0,
    cheekSquintRight: 0,
    eyeBlinkLeft: 0,
    eyeBlinkRight: 0,
    eyeLookDownLeft: 0,
    eyeLookDownRight: 0,
    eyeLookInLeft: 0,
    eyeLookInRight: 0,
    eyeLookOutLeft: 0,
    eyeLookOutRight: 0,
    eyeLookUpLeft: 0,
    eyeLookUpRight: 0,
    eyeSquintLeft: 0,
    eyeSquintRight: 0,
    eyeWideLeft: 0,
    eyeWideRight: 0,
    jawForward: 0,
    jawLeft: 0,
    jawOpen: 0,
    jawRight: 0,
    mouthClose: 0,
    mouthDimpleLeft: 0,
    mouthDimpleRight: 0,
    mouthFrownLeft: 0,
    mouthFrownRight: 0,
    mouthFunnel: 0,
    mouthLeft: 0,
    mouthLowerDownLeft: 0,
    mouthLowerDownRight: 0,
    mouthPressLeft: 0,
    mouthPressRight: 0,
    mouthPucker: 0,
    mouthRight: 0,
    mouthRollLower: 0,
    mouthRollUpper: 0,
    mouthShrugLower: 0,
    mouthShrugUpper: 0,
    mouthSmileLeft: 0,
    mouthSmileRight: 0,
    mouthStretchLeft: 0,
    mouthStretchRight: 0,
    mouthUpperUpLeft: 0,
    mouthUpperUpRight: 0,
    noseSneerLeft: 0,
    noseSneerRight: 0,
    tongueOut: 0,
  },
  CX = {
    browDownLeft: 1,
    browDownRight: 1,
    browInnerUp: 1,
    browOuterUpLeft: 1,
    browOuterUpRight: 1,
    cheekPuff: 1,
    cheekSquintLeft: 1,
    cheekSquintRight: 1,
    eyeBlinkLeft: 1,
    eyeBlinkRight: 1,
    eyeLookDownLeft: 1,
    eyeLookDownRight: 1,
    eyeLookInLeft: 1,
    eyeLookInRight: 1,
    eyeLookOutLeft: 1,
    eyeLookOutRight: 1,
    eyeLookUpLeft: 1,
    eyeLookUpRight: 1,
    eyeSquintLeft: 1,
    eyeSquintRight: 1,
    eyeWideLeft: 1,
    eyeWideRight: 1,
    jawForward: 1,
    jawLeft: 1,
    jawOpen: 1.2,
    jawRight: 1,
    mouthClose: 0.2,
    mouthDimpleLeft: 1.3,
    mouthDimpleRight: 1.3,
    mouthFrownLeft: 1.3,
    mouthFrownRight: 1.3,
    mouthFunnel: 1.3,
    mouthLeft: 1.3,
    mouthLowerDownLeft: 0.7,
    mouthLowerDownRight: 0.7,
    mouthPressLeft: 1.3,
    mouthPressRight: 1.3,
    mouthPucker: 1,
    mouthRight: 1.3,
    mouthRollLower: 1.3,
    mouthRollUpper: 1.3,
    mouthShrugLower: 1.3,
    mouthShrugUpper: 0.1,
    mouthSmileLeft: 1,
    mouthSmileRight: 1,
    mouthStretchLeft: 1.3,
    mouthStretchRight: 1.3,
    mouthUpperUpLeft: 1.3,
    mouthUpperUpRight: 1.3,
    noseSneerLeft: 1,
    noseSneerRight: 1,
    tongueOut: 1,
  },
  i3 = { offset: wX, scale: CX },
  EX = { size: 2, isGroup: !1 },
  MX = { size: 1, isGroup: !1 },
  RX = { size: 0, isGroup: !1 },
  IX = { size: 6, isGroup: !1 },
  NX = { size: 3, isGroup: !0 },
  PX = [],
  LX = { hello: EX, idle: MX, listen: RX, speak: IX, think: NX, other: PX },
  DX = '',
  FX = { x: 0, y: 0, z: 0 },
  OX = { x: 1, y: 1, z: 1 },
  BX = { x: 0, y: 1.8, z: 1 },
  UX = { x: -10, y: 0, z: 0 },
  kX = '0xffffff',
  zX = 'false',
  Ps = {
    name: DX,
    position: FX,
    scale: OX,
    camPos: BX,
    camRot: UX,
    backgroundColor: kX,
    useFlame: zX,
  }
class Us {
  static getInstance(e, t, i) {
    var r, s, o, a, l, c
    return ul(this, void 0, void 0, function* () {
      if (this.instance != null) return this.instance
      try {
        const u = t,
          { pathname: d } = Fq(u),
          h = d.match(/\/([^/]+?)\.zip/)
        if (!(h && h[1])) throw new Error('character model is not found')
        x1.start()
        const p = yield Bn.get(u, {
          responseType: 'arraybuffer',
          timeout: 1e5,
          onDownloadProgress: (A) => {
            if (A.lengthComputable && A && A.total) {
              const R = A.loaded / A.total
              ;(x1.set(R), i != null && i.downloadProgress && (i == null || i.downloadProgress(R)))
            }
          },
        })
        ;(i != null && i.loadProgress && (i == null || i.loadProgress(0.1)),
          x1.done(),
          console.log('download completed:', p.data))
        const g = p.data,
          y = yield Iq.loadAsync(g)
        let m = ''
        if (
          (Object.values(y.files).forEach((A) => {
            var R, w
            A.dir &&
              (m =
                (R = A.name) === null || R === void 0
                  ? void 0
                  : R.slice(0, ((w = A.name) === null || w === void 0 ? void 0 : w.length) - 1))
          }),
          !m)
        )
          throw new Error('file fold is not found')
        const v = new Us(e, y),
          x = new Y()
        ;((x.x = ((r = Ps.camPos) === null || r === void 0 ? void 0 : r.x) || 0),
          (x.y = ((s = Ps.camPos) === null || s === void 0 ? void 0 : s.y) || 0),
          (x.z = ((o = Ps.camPos) === null || o === void 0 ? void 0 : o.z) || 1))
        const _ = new Y()
        ;((_.x = ((a = Ps.camRot) === null || a === void 0 ? void 0 : a.x) || 0),
          (_.y = ((l = Ps.camRot) === null || l === void 0 ? void 0 : l.y) || 0),
          (_.z = ((c = Ps.camRot) === null || c === void 0 ? void 0 : c.z) || 0))
        let S = 16777215
        ;(Ps.backgroundColor && (S = parseInt(Ps.backgroundColor, 16)),
          i &&
            i.backgroundColor &&
            v.isHexColorStrict(i.backgroundColor) &&
            (S = parseInt(i.backgroundColor, 16)),
          (v.getChatState = i == null ? void 0 : i.getChatState),
          (v.getExpressionData = i == null ? void 0 : i.getExpressionData),
          Ps.useFlame && (v.useFlame = Ps.useFlame != 'false'),
          console.log(x, S),
          (v.viewer = new lv({
            rootElement: e,
            threejsCanvas: Us._canvas,
            cameraUp: [0, 1, 0],
            initialCameraPosition: [x.x, x.y, x.z],
            initialCameraRotation: [_.x, _.y, _.z],
            sphericalHarmonicsDegree: 0,
            backgroundColor: S,
          })),
          (v.viewer.useFlame = v.useFlame),
          v.viewer.useFlame == !0 ? yield v.loadFlameModel(m, i3) : yield v.loadModel(m, LX, i3),
          i != null && i.loadProgress && (i == null || i.loadProgress(0.2)))
        const C = yield v.unpackFileAsBlob(m + '/offset.ply')
        return (
          i != null && i.loadProgress && (i == null || i.loadProgress(0.3)),
          v.viewer
            .addSplatScene(C, {
              progressiveLoad: !0,
              sharedMemoryForWorkers: !1,
              showLoadingUI: !1,
              format: Hs.Ply,
            })
            .then(() => {
              ;(v.render(), i != null && i.loadProgress && (i == null || i.loadProgress(1)))
            }),
          v
        )
      } catch (u) {
        console.error(u)
      }
    })
  }
  constructor(e, t) {
    ;((this.zipUrls = { urls: new Map() }),
      (this.useFlame = !1),
      (this.lastTime = 0),
      (this.startTime = 0),
      (this.expressionData = {}),
      (this.chatState = At.Idle),
      Object.assign(this.zipUrls, { zip: t }))
    const { width: i, height: r } = e.getBoundingClientRect()
    ;((Us._canvas.style.visibility = 'visible'),
      (Us._canvas.width = i),
      (Us._canvas.height = r),
      e.appendChild(Us._canvas),
      (this.clock = new $L()),
      (this.startTime = performance.now() / 1e3))
  }
  dispose() {
    ;((Us._canvas.style.visibility = 'hidden'),
      this.disposeModel(),
      this.zipUrls.urls.forEach((e) => {
        URL.revokeObjectURL(e)
      }))
  }
  disposeModel() {
    var e, t
    ;(this.mixer &&
      (this.mixer.stopAllAction(),
      this.viewer && this.viewer.avatarMesh && this.mixer.uncacheRoot(this.viewer.avatarMesh),
      (this.mixer = void 0),
      (e = this.animManager) === null || e === void 0 || e.dispose()),
      (t = this.viewer) === null || t === void 0 || t.dispose())
  }
  getCamera() {
    var e
    return (e = this.viewer) === null || e === void 0 ? void 0 : e.camera
  }
  updateBS(e) {
    let t = {
      browDownLeft: 0,
      browDownRight: 0,
      browInnerUp: 0,
      browOuterUpLeft: 0,
      browOuterUpRight: 0,
      mouthCheekPuff: 0,
      cheekSquintLeft: 0,
      cheekSquintRight: 0,
      eyeBlinkLeft: 0,
      eyeBlinkRight: 0,
      eyeLookDownLeft: 0,
      eyeLookDownRight: 0,
      eyeLookInLeft: 0,
      eyeLookInRight: 0,
      eyeLookOutLeft: 0,
      eyeLookOutRight: 0,
      eyeLookUpLeft: 0,
      eyeLookUpRight: 0,
      eyeSquintLeft: 0,
      eyeSquintRight: 0,
      eyeWideLeft: 0,
      eyeWideRight: 0,
      jawForward: 0,
      jawLeft: 0,
      jawOpen: 0,
      jawRight: 0,
      mouthClose: 0,
      mouthDimpleLeft: 0,
      mouthDimpleRight: 0,
      mouthFrownLeft: 0,
      mouthFrownRight: 0,
      mouthFunnel: 0,
      mouthLeft: 0,
      mouthLowerDownLeft: 0,
      mouthLowerDownRight: 0,
      mouthPressLeft: 0,
      mouthPressRight: 0,
      mouthPucker: 0,
      mouthRight: 0,
      mouthRollLower: 0,
      mouthRollUpper: 0,
      mouthShrugLower: 0,
      mouthShrugUpper: 0,
      mouthSmileLeft: 0,
      mouthSmileRight: 0,
      mouthStretchLeft: 0,
      mouthStretchRight: 0,
      mouthUpperUpLeft: 0,
      mouthUpperUpRight: 0,
      noseSneerLeft: 0,
      noseSneerRight: 0,
      tongueOut: 0,
    }
    return (e != null && (t = e), t)
  }
  render() {
    var e
    if (this.viewer && this.viewer.selfDrivenMode) {
      if (this.viewer.webXRMode)
        this.viewer.renderer.setAnimationLoop(this.viewer.selfDrivenUpdateFunc)
      else {
        this.viewer.requestFrameId = requestAnimationFrame(() => this.render())
        const t = 1 / 30,
          r = (performance.now() / 1e3 - this.startTime) % (this.viewer.totalFrames * t),
          s = Math.floor(r / t)
        if (
          ((this.viewer.frame = s),
          this.getChatState &&
            ((this.chatState = this.getChatState()),
            (e = this.animManager) === null || e === void 0 || e.update(this.chatState)),
          this.getExpressionData && (this.expressionData = this.updateBS(this.getExpressionData())),
          this.viewer.useFlame == !1)
        ) {
          if (!this.mixer || !this.animManager) return
          const o = this.clock.getDelta()
          if ((this.mixer.update(o), this.motioncfg))
            for (const a in this.expressionData) {
              const l = this.motioncfg.offset[a],
                c = this.motioncfg.scale[a]
              l !== void 0 &&
                c !== void 0 &&
                (this.expressionData[a] = this.expressionData[a] * c + l)
            }
          this.setExpression()
        }
        ;(this.viewer.update(this.viewer.renderer, this.viewer.camera),
          this.viewer.shouldRender()
            ? (this.viewer.render(), this.viewer.consecutiveRenderFrames++)
            : (this.viewer.consecutiveRenderFrames = 0),
          (this.viewer.renderNextFrame = !1))
      }
      this.viewer.selfDrivenModeRunning = !0
    } else throw new Error('Cannot start viewer unless it is in self driven mode.')
  }
  isHexColorStrict(e) {
    return typeof e != 'string' ? !1 : /^(#|0x)[0-9A-Fa-f]{6}$/i.test(e)
  }
  setExpression() {
    ;(this.viewer &&
      this.viewer.splatMesh &&
      (this.viewer.splatMesh.bsWeight = this.expressionData),
      this.model &&
        this.model.traverse((e) => {
          if (e.isMesh || e.isSkinnedMesh) {
            const t = e.geometry.morphAttributes
            if (Object.keys(t).length > 0 === !0) {
              const r = e.morphTargetDictionary
              for (const s in r) {
                const o = r[s],
                  a = this.expressionData[s]
                a !== void 0 && (e.morphTargetInfluences[o] = Math.max(0, Math.min(1, a)))
              }
            }
          }
        }))
  }
  loadFlameModel(e, t) {
    return ul(this, void 0, void 0, function* () {
      const [i, r, s, o, a] = yield Promise.all([
        this.unpackAndLoadGlb(e + '/skin.glb'),
        this.unpackAndLoadJson(e + '/lbs_weight_20k.json'),
        this.unpackAndLoadJson(e + '/flame_params.json'),
        this.unpackAndLoadJson(e + '/vertex_order.json'),
        this.unpackAndLoadJson(e + '/bone_tree.json'),
      ])
      if (!this.viewer) throw new Error('render viewer is not initialized')
      let l, c
      ;(i.traverse((u) => {
        ;(u.isSkinnedMesh && (l = u), u instanceof fh && u.name == 'hip' && (c = u))
      }),
        (this.viewer.sortedIndexes = o),
        (this.viewer.flame_params = s),
        (this.viewer.lbs_weight_80k = r),
        (this.viewer.bone_tree = a),
        (this.viewer.totalFrames = s.expr.length),
        l != null && (this.viewer.gaussianSplatCount = l.geometry.attributes.position.count),
        (this.viewer.avatarMesh = i),
        (this.viewer.skinModel = l),
        (this.viewer.boneRoot = c),
        (this.motioncfg = t),
        l != null && this.viewer.updateMorphTarget(l),
        this.viewer.threeScene.add(i),
        (i.visible = !1),
        l != null && l.skeleton.computeBoneTexture())
    })
  }
  loadModel(e, t, i) {
    return ul(this, void 0, void 0, function* () {
      const [r, s, o] = yield Promise.all([
        this.unpackAndLoadGlb(e + '/skin.glb'),
        this.unpackAndLoadGlb(e + '/animation.glb'),
        this.unpackAndLoadJson(e + '/vertex_order.json'),
      ])
      if (!this.viewer) throw new Error('render viewer is not initialized')
      let a, l
      ;(r.traverse((c) => {
        ;(c.isSkinnedMesh && (a = c), c instanceof fh && c.name == 'hip' && (l = c))
      }),
        (this.viewer.sortedIndexes = o),
        a != null && (this.viewer.gaussianSplatCount = a.geometry.attributes.position.count),
        (this.viewer.avatarMesh = r),
        (this.viewer.skinModel = a),
        (this.viewer.boneRoot = l),
        (this.mixer = new nD(r)),
        (this.animManager = new Qe(this.mixer, s, t)),
        (this.motioncfg = i),
        a != null && this.viewer.updateMorphTarget(a),
        this.viewer.threeScene.add(r),
        (r.visible = !1),
        a != null && a.skeleton.computeBoneTexture())
    })
  }
  unpackFileAsBlob(e) {
    var t, i
    return ul(this, void 0, void 0, function* () {
      if (!this.zipUrls.urls.has(e)) {
        const r = yield (i =
            (t = this.zipUrls.zip) === null || t === void 0 ? void 0 : t.file(e)) === null ||
          i === void 0
            ? void 0
            : i.async('blob'),
          s = URL.createObjectURL(r)
        this.zipUrls.urls.set(e, s)
      }
      return this.zipUrls.urls.get(e)
    })
  }
  unpackAndLoadGlb(e) {
    var t, i
    return ul(this, void 0, void 0, function* () {
      if (!this.zipUrls.urls.has(e)) {
        const r = yield (i =
            (t = this.zipUrls.zip) === null || t === void 0 ? void 0 : t.file(e)) === null ||
          i === void 0
            ? void 0
            : i.async('arraybuffer'),
          s = new Blob([r], { type: 'model/gltf-binary' }),
          o = URL.createObjectURL(s)
        this.zipUrls.urls.set(e, o)
      }
      return this.LoadGLTF(this.zipUrls.urls.get(e))
    })
  }
  unpackAndLoadJson(e) {
    var t, i
    return ul(this, void 0, void 0, function* () {
      const r = yield (i = (t = this.zipUrls.zip) === null || t === void 0 ? void 0 : t.file(e)) ===
        null || i === void 0
        ? void 0
        : i.async('string')
      return JSON.parse(r)
    })
  }
  LoadGLTF(e) {
    return ul(this, void 0, void 0, function* () {
      return new Promise((t, i) => {
        new Gq(void 0).load(
          e,
          (s) => {
            s.animations.length > 0 ? t(s.animations) : t(s.scene)
          },
          void 0,
          (s) => {
            i(s)
          }
        )
      })
    })
  }
}
Us._canvas = document.createElement('canvas')
class VX extends d_ {
  constructor(t) {
    const { container: i, assetsPath: r, ws: s, downloadProgress: o, loadProgress: a } = t
    super()
    xe(this, '_avatarDivEle')
    xe(this, '_assetsPath', '')
    xe(this, '_ws')
    xe(this, '_downloadProgress')
    xe(this, '_loadProgress')
    xe(this, '_loadPercent', 0)
    xe(this, '_downloadPercent', 0)
    xe(this, '_processor')
    xe(this, '_renderer')
    xe(this, '_audioMute', !1)
    xe(this, 'curState', ya.Idle)
    ;((this._avatarDivEle = i),
      (this._assetsPath = r),
      (this._ws = s),
      o
        ? (this._downloadProgress = (l) => {
            ;((this._downloadPercent = l), o(l))
          })
        : (this._downloadProgress = (l) => {
            this._downloadPercent = l
          }),
      a
        ? (this._loadProgress = (l) => {
            ;((this._loadPercent = l), a(l))
          })
        : (this._loadProgress = (l) => {
            this._loadPercent = l
          }),
      this._init())
  }
  _init() {
    if (!this._avatarDivEle || !this._assetsPath || !this._ws)
      throw new Error('Lack of necessary initialization parameters for gaussian render')
    ;((this._processor = new wN(this)), this._bindEventTypes())
  }
  start() {
    ;(this.getData(), this.render())
  }
  async getData() {
    this._ws.on(Kr.WS_MESSAGE, (t) => {
      this._downloadPercent < 1 ||
        this._loadPercent < 1 ||
        (this.emit(xr.MessageReceived, this.curState),
        this._processor.add({
          avatar_motion_data: {
            first_package: !0,
            segment_num: 1,
            binary_size: t.size,
            use_binary_frame: !1,
          },
        }),
        this._processor.add({
          avatar_motion_data: {
            first_package: !1,
            motion_data_slice: t,
            is_audio_mute: this._audioMute,
          },
        }))
    })
  }
  async render() {
    this._renderer = await Us.getInstance(this._avatarDivEle, this._assetsPath, {
      getChatState: this.getChatState.bind(this),
      getExpressionData: this.getArkitFaceFrame.bind(this),
      downloadProgress: this._downloadProgress.bind(this),
      loadProgress: this._loadProgress.bind(this),
    })
  }
  setAvatarMute(t) {
    ;(this._processor.setMute(t), (this._audioMute = t))
  }
  getChatState() {
    return this.curState
  }
  getArkitFaceFrame() {
    var t
    return (t = this._processor) == null ? void 0 : t.getArkitFaceFrame().arkitFace
  }
  interrupt() {
    var t
    ;(this._ws.send('%interrupt%'),
      (t = this._processor) == null || t.interrupt(),
      (this.curState = ya.Idle),
      this.emit(xr.StateChanged, this.curState))
  }
  sendSpeech(t) {
    var i
    ;(this._ws.send(t),
      (this.curState = ya.Listening),
      this.emit(xr.StateChanged, this.curState),
      (i = this._processor) == null || i.clear())
  }
  exit() {
    var t, i
    ;((t = this._renderer) == null || t.dispose(),
      (this.curState = ya.Idle),
      (this._downloadPercent = 0),
      (this._loadPercent = 0),
      (i = this._processor) == null || i.clear(),
      this.removeAllListeners())
  }
  _bindEventTypes() {
    ;(this.on(Ul.Player_StartSpeaking, (t) => {
      ;(console.log('startSpeach'),
        (this.curState = ya.Responding),
        this.emit(xr.StateChanged, this.curState),
        this._ws.send(JSON.stringify({ header: { name: xr.StartSpeech }, payload: {} })))
    }),
      this.on(Ul.Player_EndSpeaking, (t) => {
        ;(console.log('endSpeach'),
          (this.curState = ya.Idle),
          this.emit(xr.StateChanged, this.curState),
          this._ws.send(JSON.stringify({ header: { name: xr.EndSpeech }, payload: {} })))
      }),
      this.on(xr.ErrorReceived, (t) => {
        ;(console.log('ErrorReceived', t),
          (this.curState = ya.Idle),
          this.emit(xr.StateChanged, this.curState),
          this._ws.send(JSON.stringify({ header: { name: xr.ErrorReceived }, payload: { ...t } })))
      }),
      this._ws.on(Kr.WS_CLOSE, () => {
        this.exit()
      }))
  }
}
function T1() {
  return navigator.mediaDevices.enumerateDevices()
}
async function HX(n, e, t) {
  const i = (t == null ? void 0 : t.video) ||
      t || {
        width: { ideal: 500, min: 320 },
        height: { ideal: 500, min: 320 },
        aspectRatio: { ideal: 1 },
      },
    r = (t == null ? void 0 : t.audio) ||
      t || { echoCancellation: !0, noiseSuppression: !0, autoGainControl: !0 },
    s = {
      video: typeof e == 'object' ? { ...e, ...i } : e,
      audio: typeof n == 'object' ? { ...n, ...r } : n,
    }
  return (
    console.log(s, 'constraints'),
    navigator.mediaDevices.getUserMedia(s).then((o) => (console.log(o), o))
  )
}
function r3(n, e = 'videoinput') {
  return n.filter((i) => i.kind === e)
}
let hl = null,
  xo = null
function $X(n = 1, e = 1) {
  const t = document.createElement('canvas')
  ;(document.body.appendChild(t),
    (t.width = n || 500),
    (t.height = e || 500),
    (t.style.width = '1px'),
    (t.style.height = '1px'),
    (t.style.position = 'fixed'),
    (t.style.visibility = 'hidden'))
  const i = t.getContext('2d')
  ;((i.fillStyle = 'hsl(0,0, 0, 1)'), i.fillRect(0, 0, t.width, t.height))
  function r() {
    ;((i.fillStyle = 'rgb(255, 255, 255)'),
      i.fillRect(0, 0, t.width, t.height),
      requestAnimationFrame(r))
  }
  return (
    r(),
    (hl = t.captureStream(30).getVideoTracks()[0]),
    (hl.stop = () => {
      t.remove()
    }),
    (hl.onended = () => {
      hl == null || hl.stop()
    }),
    hl
  )
}
function GX() {
  if (xo) return xo
  const n = new (window.AudioContext || window.webkitAudioContext)(),
    e = n.createOscillator()
  e.frequency.setValueAtTime(0, n.currentTime)
  const t = n.createGain()
  t.gain.setValueAtTime(0, n.currentTime)
  const i = n.createMediaStreamDestination()
  return (
    e.connect(t),
    t.connect(i),
    e.start(),
    (xo = i.stream.getAudioTracks()[0]),
    (xo.stop = () => {
      n.close()
    }),
    (xo.onended = () => {
      xo == null || xo.stop()
    }),
    xo
  )
}
function s3(n) {
  ;(console.debug('Stopping peer connection'),
    n.getTransceivers &&
      n.getTransceivers().forEach((e) => {
        e.stop && e.stop()
      }),
    n.getSenders() &&
      n.getSenders().forEach((e) => {
        ;(console.log('sender', e), e.track && e.track.stop && e.track.stop())
      }),
    setTimeout(() => {
      n.close()
    }, 500))
}
async function WX(n, e, t) {
  ;(n.getTracks().forEach(async (l) => {
    e.addTrack(l, n)
  }),
    e.addEventListener('track', (l) => {
      t && t.srcObject !== l.streams[0] && (t.srcObject = l.streams[0])
    }))
  const i = e.createDataChannel('text'),
    r = await e.createOffer()
  await e.setLocalDescription(r)
  const s = Math.random().toString(36).substring(7)
  e.onicecandidate = ({ candidate: l }) => {
    l &&
      (console.debug('Sending ICE candidate', l),
      fetch('/webrtc/offer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ candidate: l.toJSON(), webrtc_id: s, type: 'ice-candidate' }),
      }))
  }
  const a = await (
    await fetch('/webrtc/offer', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sdp: r.sdp, type: r.type, webrtc_id: s }),
    })
  ).json()
  return (await e.setRemoteDescription(a), [i, s])
}
function Sh(n) {
  '@babel/helpers - typeof'
  return (
    (Sh =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e
          }
        : function (e) {
            return e &&
              typeof Symbol == 'function' &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? 'symbol'
              : typeof e
          }),
    Sh(n)
  )
}
function QX(n, e) {
  if (Sh(n) != 'object' || !n) return n
  var t = n[Symbol.toPrimitive]
  if (t !== void 0) {
    var i = t.call(n, e)
    if (Sh(i) != 'object') return i
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (e === 'string' ? String : Number)(n)
}
function jX(n) {
  var e = QX(n, 'string')
  return Sh(e) == 'symbol' ? e : e + ''
}
function qX(n, e, t) {
  return (
    (e = jX(e)) in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
function o3(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n)
    ;(e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable
      })),
      t.push.apply(t, i))
  }
  return t
}
function Zn(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? o3(Object(t), !0).forEach(function (i) {
          qX(n, i, t[i])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : o3(Object(t)).forEach(function (i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
          })
  }
  return n
}
function ke() {
  return (
    (ke = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e]
            for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i])
          }
          return n
        }),
    ke.apply(null, arguments)
  )
}
const XX = Array.isArray,
  KX = (n) => typeof n == 'string',
  YX = (n) => n !== null && typeof n == 'object'
function Uc(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = arguments.length > 2 ? arguments[2] : void 0
  return typeof n == 'function' ? n(e) : n != null ? n : t
}
function ZX(n) {
  let e
  const t = new Promise((r) => {
      e = n(() => {
        r(!0)
      })
    }),
    i = () => {
      e == null || e()
    }
  return ((i.then = (r, s) => t.then(r, s)), (i.promise = t), i)
}
function Br() {
  const n = []
  for (let e = 0; e < arguments.length; e++) {
    const t = e < 0 || arguments.length <= e ? void 0 : arguments[e]
    if (t) {
      if (KX(t)) n.push(t)
      else if (XX(t))
        for (let i = 0; i < t.length; i++) {
          const r = Br(t[i])
          r && n.push(r)
        }
      else if (YX(t)) for (const i in t) t[i] && n.push(i)
    }
  }
  return n.join(' ')
}
const JX = (n, e) => {
  const t = ke({}, n)
  return (
    Object.keys(e).forEach((i) => {
      const r = t[i]
      if (r)
        r.type || r.default
          ? (r.default = e[i])
          : r.def
            ? r.def(e[i])
            : (t[i] = { type: r, default: e[i] })
      else throw new Error('not have '.concat(i, ' prop'))
    }),
    t
  )
}
function eK(n) {
  return (
    n &&
    (n.type === Js ||
      (n.type === Hn && n.children.length === 0) ||
      (n.type === Nu && n.children.trim() === ''))
  )
}
function Vx() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
  const e = []
  return (
    n.forEach((t) => {
      Array.isArray(t)
        ? e.push(...t)
        : (t == null ? void 0 : t.type) === Hn
          ? e.push(...Vx(t.children))
          : e.push(t)
    }),
    e.filter((t) => !eK(t))
  )
}
function tK(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'default'
  var i, r
  return (i = e[t]) !== null && i !== void 0
    ? i
    : (r = n[t]) === null || r === void 0
      ? void 0
      : r.call(n)
}
const nK = function () {
    for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t]
    return e
  },
  Hx = (n) => {
    const e = n
    return (
      (e.install = function (t) {
        t.component(e.displayName || e.name, n)
      }),
      n
    )
  }
function Sr(n) {
  return { type: Object, default: n }
}
function w1(n) {
  return { type: Boolean, default: n }
}
function yv(n, e) {
  const t = { validator: () => !0, default: n }
  return t
}
function a3(n) {
  return { type: Array, default: n }
}
function l3(n) {
  return { type: String, default: n }
}
function iK(n, e) {
  return n ? { type: n, default: e } : yv(e)
}
const $x = 'anticon',
  rK = Symbol('GlobalFormContextKey'),
  sK = (n) => {
    ra(rK, n)
  },
  oK = () => ({
    iconPrefixCls: String,
    getTargetContainer: { type: Function },
    getPopupContainer: { type: Function },
    prefixCls: String,
    getPrefixCls: { type: Function },
    renderEmpty: { type: Function },
    transformCellText: { type: Function },
    csp: Sr(),
    input: Sr(),
    autoInsertSpaceInButton: { type: Boolean, default: void 0 },
    locale: Sr(),
    pageHeader: Sr(),
    componentSize: { type: String },
    componentDisabled: { type: Boolean, default: void 0 },
    direction: { type: String, default: 'ltr' },
    space: Sr(),
    virtual: { type: Boolean, default: void 0 },
    dropdownMatchSelectWidth: { type: [Number, Boolean], default: !0 },
    form: Sr(),
    pagination: Sr(),
    theme: Sr(),
    select: Sr(),
    wave: Sr(),
  }),
  Gx = Symbol('configProvider'),
  f6 = {
    getPrefixCls: (n, e) => e || (n ? 'ant-'.concat(n) : 'ant'),
    iconPrefixCls: Ge(() => $x),
    getPopupContainer: Ge(() => () => document.body),
    direction: Ge(() => 'ltr'),
  },
  p6 = () => Zi(Gx, f6),
  aK = (n) => ra(Gx, n),
  m6 = Symbol('DisabledContextKey'),
  g6 = () => Zi(m6, Dn(void 0)),
  lK = (n) => {
    const e = g6()
    return (
      ra(
        m6,
        Ge(() => {
          var t
          return (t = n.value) !== null && t !== void 0 ? t : e.value
        })
      ),
      n
    )
  },
  cK = {
    items_per_page: '/ page',
    jump_to: 'Go to',
    jump_to_confirm: 'confirm',
    page: '',
    prev_page: 'Previous Page',
    next_page: 'Next Page',
    prev_5: 'Previous 5 Pages',
    next_5: 'Next 5 Pages',
    prev_3: 'Previous 3 Pages',
    next_3: 'Next 3 Pages',
  },
  uK = {
    locale: 'en_US',
    today: 'Today',
    now: 'Now',
    backToToday: 'Back to today',
    ok: 'Ok',
    clear: 'Clear',
    month: 'Month',
    year: 'Year',
    timeSelect: 'select time',
    dateSelect: 'select date',
    weekSelect: 'Choose a week',
    monthSelect: 'Choose a month',
    yearSelect: 'Choose a year',
    decadeSelect: 'Choose a decade',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: !0,
    previousMonth: 'Previous month (PageUp)',
    nextMonth: 'Next month (PageDown)',
    previousYear: 'Last year (Control + left)',
    nextYear: 'Next year (Control + right)',
    previousDecade: 'Last decade',
    nextDecade: 'Next decade',
    previousCentury: 'Last century',
    nextCentury: 'Next century',
  },
  y6 = { placeholder: 'Select time', rangePlaceholder: ['Start time', 'End time'] },
  c3 = {
    lang: ke(
      {
        placeholder: 'Select date',
        yearPlaceholder: 'Select year',
        quarterPlaceholder: 'Select quarter',
        monthPlaceholder: 'Select month',
        weekPlaceholder: 'Select week',
        rangePlaceholder: ['Start date', 'End date'],
        rangeYearPlaceholder: ['Start year', 'End year'],
        rangeQuarterPlaceholder: ['Start quarter', 'End quarter'],
        rangeMonthPlaceholder: ['Start month', 'End month'],
        rangeWeekPlaceholder: ['Start week', 'End week'],
      },
      uK
    ),
    timePickerLocale: ke({}, y6),
  },
  mr = '${label} is not a valid ${type}',
  Au = {
    locale: 'en',
    Pagination: cK,
    DatePicker: c3,
    TimePicker: y6,
    Calendar: c3,
    global: { placeholder: 'Please select' },
    Table: {
      filterTitle: 'Filter menu',
      filterConfirm: 'OK',
      filterReset: 'Reset',
      filterEmptyText: 'No filters',
      filterCheckall: 'Select all items',
      filterSearchPlaceholder: 'Search in filters',
      emptyText: 'No data',
      selectAll: 'Select current page',
      selectInvert: 'Invert current page',
      selectNone: 'Clear all data',
      selectionAll: 'Select all data',
      sortTitle: 'Sort',
      expand: 'Expand row',
      collapse: 'Collapse row',
      triggerDesc: 'Click to sort descending',
      triggerAsc: 'Click to sort ascending',
      cancelSort: 'Click to cancel sorting',
    },
    Tour: { Next: 'Next', Previous: 'Previous', Finish: 'Finish' },
    Modal: { okText: 'OK', cancelText: 'Cancel', justOkText: 'OK' },
    Popconfirm: { okText: 'OK', cancelText: 'Cancel' },
    Transfer: {
      titles: ['', ''],
      searchPlaceholder: 'Search here',
      itemUnit: 'item',
      itemsUnit: 'items',
      remove: 'Remove',
      selectCurrent: 'Select current page',
      removeCurrent: 'Remove current page',
      selectAll: 'Select all data',
      removeAll: 'Remove all data',
      selectInvert: 'Invert current page',
    },
    Upload: {
      uploading: 'Uploading...',
      removeFile: 'Remove file',
      uploadError: 'Upload error',
      previewFile: 'Preview file',
      downloadFile: 'Download file',
    },
    Empty: { description: 'No data' },
    Icon: { icon: 'icon' },
    Text: { edit: 'Edit', copy: 'Copy', copied: 'Copied', expand: 'Expand' },
    PageHeader: { back: 'Back' },
    Form: {
      optional: '(optional)',
      defaultValidateMessages: {
        default: 'Field validation error for ${label}',
        required: 'Please enter ${label}',
        enum: '${label} must be one of [${enum}]',
        whitespace: '${label} cannot be a blank character',
        date: {
          format: '${label} date format is invalid',
          parse: '${label} cannot be converted to a date',
          invalid: '${label} is an invalid date',
        },
        types: {
          string: mr,
          method: mr,
          array: mr,
          object: mr,
          number: mr,
          date: mr,
          boolean: mr,
          integer: mr,
          float: mr,
          regexp: mr,
          email: mr,
          url: mr,
          hex: mr,
        },
        string: {
          len: '${label} must be ${len} characters',
          min: '${label} must be at least ${min} characters',
          max: '${label} must be up to ${max} characters',
          range: '${label} must be between ${min}-${max} characters',
        },
        number: {
          len: '${label} must be equal to ${len}',
          min: '${label} must be minimum ${min}',
          max: '${label} must be maximum ${max}',
          range: '${label} must be between ${min}-${max}',
        },
        array: {
          len: 'Must be ${len} ${label}',
          min: 'At least ${min} ${label}',
          max: 'At most ${max} ${label}',
          range: 'The amount of ${label} must be between ${min}-${max}',
        },
        pattern: { mismatch: '${label} does not match the pattern ${pattern}' },
      },
    },
    Image: { preview: 'Preview' },
    QRCode: { expired: 'QR code expired', refresh: 'Refresh', scanned: 'Scanned' },
  },
  v6 = qt({
    compatConfig: { MODE: 3 },
    name: 'LocaleReceiver',
    props: {
      componentName: String,
      defaultLocale: { type: [Object, Function] },
      children: { type: Function },
    },
    setup(n, e) {
      let { slots: t } = e
      const i = Zi('localeData', {}),
        r = Ge(() => {
          const { componentName: o = 'global', defaultLocale: a } = n,
            l = a || Au[o || 'global'],
            { antLocale: c } = i,
            u = o && c ? c[o] : {}
          return ke(ke({}, typeof l == 'function' ? l() : l), u || {})
        }),
        s = Ge(() => {
          const { antLocale: o } = i,
            a = o && o.locale
          return o && o.exist && !a ? Au.locale : a
        })
      return () => {
        const o = n.children || t.default,
          { antLocale: a } = i
        return o == null ? void 0 : o(r.value, s.value, a)
      }
    },
  })
function Wx(n) {
  for (var e = 0, t, i = 0, r = n.length; r >= 4; ++i, r -= 4)
    ((t =
      (n.charCodeAt(i) & 255) |
      ((n.charCodeAt(++i) & 255) << 8) |
      ((n.charCodeAt(++i) & 255) << 16) |
      ((n.charCodeAt(++i) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16))))
  switch (r) {
    case 3:
      e ^= (n.charCodeAt(i + 2) & 255) << 16
    case 2:
      e ^= (n.charCodeAt(i + 1) & 255) << 8
    case 1:
      ;((e ^= n.charCodeAt(i) & 255), (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)))
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  )
}
const u3 = '%'
class dK {
  constructor(e) {
    ;((this.cache = new Map()), (this.instanceId = e))
  }
  get(e) {
    return this.cache.get(Array.isArray(e) ? e.join(u3) : e) || null
  }
  update(e, t) {
    const i = Array.isArray(e) ? e.join(u3) : e,
      r = this.cache.get(i),
      s = t(r)
    s === null ? this.cache.delete(i) : this.cache.set(i, s)
  }
}
const _6 = 'data-token-hash',
  Ol = 'data-css-hash',
  kc = '__cssinjs_instance__'
function Ah() {
  const n = Math.random().toString(12).slice(2)
  if (typeof document < 'u' && document.head && document.body) {
    const e = document.body.querySelectorAll('style['.concat(Ol, ']')) || [],
      { firstChild: t } = document.head
    Array.from(e).forEach((r) => {
      ;((r[kc] = r[kc] || n), r[kc] === n && document.head.insertBefore(r, t))
    })
    const i = {}
    Array.from(document.querySelectorAll('style['.concat(Ol, ']'))).forEach((r) => {
      var s
      const o = r.getAttribute(Ol)
      i[o]
        ? r[kc] === n && ((s = r.parentNode) === null || s === void 0 || s.removeChild(r))
        : (i[o] = !0)
    })
  }
  return new dK(n)
}
const x6 = Symbol('StyleContextKey'),
  hK = () => {
    var n, e, t
    const i = bs()
    let r
    if (i && i.appContext) {
      const s =
        (t =
          (e = (n = i.appContext) === null || n === void 0 ? void 0 : n.config) === null ||
          e === void 0
            ? void 0
            : e.globalProperties) === null || t === void 0
          ? void 0
          : t.__ANTDV_CSSINJS_CACHE__
      s
        ? (r = s)
        : ((r = Ah()),
          i.appContext.config.globalProperties &&
            (i.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = r))
    } else r = Ah()
    return r
  },
  S6 = { cache: Ah(), defaultCache: !0, hashPriority: 'low' },
  N0 = () => {
    const n = hK()
    return Zi(x6, ar(ke(ke({}, S6), { cache: n })))
  },
  fK = (n) => {
    const e = N0(),
      t = ar(ke(ke({}, S6), { cache: Ah() }))
    return (
      Jn(
        [() => Ke(n), e],
        () => {
          const i = ke({}, e.value),
            r = Ke(n)
          Object.keys(r).forEach((o) => {
            const a = r[o]
            r[o] !== void 0 && (i[o] = a)
          })
          const { cache: s } = r
          ;((i.cache = i.cache || Ah()),
            (i.defaultCache = !s && e.value.defaultCache),
            (t.value = i))
        },
        { immediate: !0 }
      ),
      ra(x6, t),
      t
    )
  },
  pK = () => ({
    autoClear: w1(),
    mock: l3(),
    cache: Sr(),
    defaultCache: w1(),
    hashPriority: l3(),
    container: iK(),
    ssrInline: w1(),
    transformers: a3(),
    linters: a3(),
  })
Hx(
  qt({
    name: 'AStyleProvider',
    inheritAttrs: !1,
    props: pK(),
    setup(n, e) {
      let { slots: t } = e
      return (
        fK(n),
        () => {
          var i
          return (i = t.default) === null || i === void 0 ? void 0 : i.call(t)
        }
      )
    },
  })
)
function A6(n, e, t, i) {
  const r = N0(),
    s = ar(''),
    o = ar()
  t0(() => {
    s.value = [n, ...e.value].join('%')
  })
  const a = (l) => {
    r.value.cache.update(l, (c) => {
      const [u = 0, d] = c || []
      return u - 1 === 0 ? (i == null || i(d, !1), null) : [u - 1, d]
    })
  }
  return (
    Jn(
      s,
      (l, c) => {
        ;(c && a(c),
          r.value.cache.update(l, (u) => {
            const [d = 0, h] = u || [],
              p = h || t()
            return [d + 1, p]
          }),
          (o.value = r.value.cache.get(s.value)[1]))
      },
      { immediate: !0 }
    ),
    e0(() => {
      a(s.value)
    }),
    o
  )
}
function Gu() {
  return !!(typeof window < 'u' && window.document && window.document.createElement)
}
function mK(n, e) {
  return n && n.contains ? n.contains(e) : !1
}
const d3 = 'data-vc-order',
  gK = 'vc-util-key',
  vv = new Map()
function b6() {
  let { mark: n } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  return n ? (n.startsWith('data-') ? n : 'data-'.concat(n)) : gK
}
function P0(n) {
  return n.attachTo ? n.attachTo : document.querySelector('head') || document.body
}
function yK(n) {
  return n === 'queue' ? 'prependQueue' : n ? 'prepend' : 'append'
}
function T6(n) {
  return Array.from((vv.get(n) || n).children).filter((e) => e.tagName === 'STYLE')
}
function w6(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  if (!Gu()) return null
  const { csp: t, prepend: i } = e,
    r = document.createElement('style')
  ;(r.setAttribute(d3, yK(i)),
    t != null && t.nonce && (r.nonce = t == null ? void 0 : t.nonce),
    (r.innerHTML = n))
  const s = P0(e),
    { firstChild: o } = s
  if (i) {
    if (i === 'queue') {
      const a = T6(s).filter((l) => ['prepend', 'prependQueue'].includes(l.getAttribute(d3)))
      if (a.length) return (s.insertBefore(r, a[a.length - 1].nextSibling), r)
    }
    s.insertBefore(r, o)
  } else s.appendChild(r)
  return r
}
function C6(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  const t = P0(e)
  return T6(t).find((i) => i.getAttribute(b6(e)) === n)
}
function E6(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  const t = C6(n, e)
  t && P0(e).removeChild(t)
}
function vK(n, e) {
  const t = vv.get(n)
  if (!t || !mK(document, t)) {
    const i = w6('', e),
      { parentNode: r } = i
    ;(vv.set(n, r), n.removeChild(i))
  }
}
function Bm(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
  var i, r, s
  const o = P0(t)
  vK(o, t)
  const a = C6(e, t)
  if (a)
    return (
      !((i = t.csp) === null || i === void 0) &&
        i.nonce &&
        a.nonce !== ((r = t.csp) === null || r === void 0 ? void 0 : r.nonce) &&
        (a.nonce = (s = t.csp) === null || s === void 0 ? void 0 : s.nonce),
      a.innerHTML !== n && (a.innerHTML = n),
      a
    )
  const l = w6(n, t)
  return (l.setAttribute(b6(t), e), l)
}
function _K(n, e) {
  if (n.length !== e.length) return !1
  for (let t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1
  return !0
}
class bu {
  constructor() {
    ;((this.cache = new Map()), (this.keys = []), (this.cacheCallTimes = 0))
  }
  size() {
    return this.keys.length
  }
  internalGet(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
      i = { map: this.cache }
    return (
      e.forEach((r) => {
        var s
        i
          ? (i = (s = i == null ? void 0 : i.map) === null || s === void 0 ? void 0 : s.get(r))
          : (i = void 0)
      }),
      i != null && i.value && t && (i.value[1] = this.cacheCallTimes++),
      i == null ? void 0 : i.value
    )
  }
  get(e) {
    var t
    return (t = this.internalGet(e, !0)) === null || t === void 0 ? void 0 : t[0]
  }
  has(e) {
    return !!this.internalGet(e)
  }
  set(e, t) {
    if (!this.has(e)) {
      if (this.size() + 1 > bu.MAX_CACHE_SIZE + bu.MAX_CACHE_OFFSET) {
        const [r] = this.keys.reduce(
          (s, o) => {
            const [, a] = s
            return this.internalGet(o)[1] < a ? [o, this.internalGet(o)[1]] : s
          },
          [this.keys[0], this.cacheCallTimes]
        )
        this.delete(r)
      }
      this.keys.push(e)
    }
    let i = this.cache
    e.forEach((r, s) => {
      if (s === e.length - 1) i.set(r, { value: [t, this.cacheCallTimes++] })
      else {
        const o = i.get(r)
        ;(o ? o.map || (o.map = new Map()) : i.set(r, { map: new Map() }), (i = i.get(r).map))
      }
    })
  }
  deleteByPath(e, t) {
    var i
    const r = e.get(t[0])
    if (t.length === 1)
      return (
        r.map ? e.set(t[0], { map: r.map }) : e.delete(t[0]),
        (i = r.value) === null || i === void 0 ? void 0 : i[0]
      )
    const s = this.deleteByPath(r.map, t.slice(1))
    return ((!r.map || r.map.size === 0) && !r.value && e.delete(t[0]), s)
  }
  delete(e) {
    if (this.has(e))
      return ((this.keys = this.keys.filter((t) => !_K(t, e))), this.deleteByPath(this.cache, e))
  }
}
bu.MAX_CACHE_SIZE = 20
bu.MAX_CACHE_OFFSET = 5
function xK() {}
let M6 = xK,
  h3 = 0
class R6 {
  constructor(e) {
    ;((this.derivatives = Array.isArray(e) ? e : [e]),
      (this.id = h3),
      e.length === 0 && M6(e.length > 0),
      (h3 += 1))
  }
  getDerivativeToken(e) {
    return this.derivatives.reduce((t, i) => i(e, t), void 0)
  }
}
const C1 = new bu()
function I6(n) {
  const e = Array.isArray(n) ? n : [n]
  return (C1.has(e) || C1.set(e, new R6(e)), C1.get(e))
}
const f3 = new WeakMap()
function Um(n) {
  let e = f3.get(n) || ''
  return (
    e ||
      (Object.keys(n).forEach((t) => {
        const i = n[t]
        ;((e += t),
          i instanceof R6 ? (e += i.id) : i && typeof i == 'object' ? (e += Um(i)) : (e += i))
      }),
      f3.set(n, e)),
    e
  )
}
function SK(n, e) {
  return Wx(''.concat(e, '_').concat(Um(n)))
}
const Qd = 'random-'.concat(Date.now(), '-').concat(Math.random()).replace(/\./g, ''),
  N6 = '_bAmBoO_'
function AK(n, e, t) {
  var i, r
  if (Gu()) {
    Bm(n, Qd)
    const s = document.createElement('div')
    ;((s.style.position = 'fixed'),
      (s.style.left = '0'),
      (s.style.top = '0'),
      e == null || e(s),
      document.body.appendChild(s))
    const o = t
      ? t(s)
      : (i = getComputedStyle(s).content) === null || i === void 0
        ? void 0
        : i.includes(N6)
    return ((r = s.parentNode) === null || r === void 0 || r.removeChild(s), E6(Qd), o)
  }
  return !1
}
let E1
function bK() {
  return (
    E1 === void 0 &&
      (E1 = AK(
        '@layer '.concat(Qd, ' { .').concat(Qd, ' { content: "').concat(N6, '"!important; } }'),
        (n) => {
          n.className = Qd
        }
      )),
    E1
  )
}
const p3 = {},
  TK = 'css',
  xl = new Map()
function wK(n) {
  xl.set(n, (xl.get(n) || 0) + 1)
}
function CK(n, e) {
  typeof document < 'u' &&
    document.querySelectorAll('style['.concat(_6, '="').concat(n, '"]')).forEach((i) => {
      var r
      i[kc] === e && ((r = i.parentNode) === null || r === void 0 || r.removeChild(i))
    })
}
const EK = 0
function MK(n, e) {
  xl.set(n, (xl.get(n) || 0) - 1)
  const t = Array.from(xl.keys()),
    i = t.filter((r) => (xl.get(r) || 0) <= 0)
  t.length - i.length > EK &&
    i.forEach((r) => {
      ;(CK(r, e), xl.delete(r))
    })
}
const RK = (n, e, t, i) => {
  const r = t.getDerivativeToken(n)
  let s = ke(ke({}, r), e)
  return (i && (s = i(s)), s)
}
function IK(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Dn({})
  const i = N0(),
    r = Ge(() => ke({}, ...e.value)),
    s = Ge(() => Um(r.value)),
    o = Ge(() => Um(t.value.override || p3))
  return A6(
    'token',
    Ge(() => [t.value.salt || '', n.value.id, s.value, o.value]),
    () => {
      const { salt: l = '', override: c = p3, formatToken: u, getComputedToken: d } = t.value,
        h = d ? d(r.value, c, n.value) : RK(r.value, c, n.value, u),
        f = SK(h, l)
      ;((h._tokenKey = f), wK(f))
      const p = ''.concat(TK, '-').concat(Wx(f))
      return ((h._hashId = p), [h, p])
    },
    (l) => {
      var c
      MK(l[0]._tokenKey, (c = i.value) === null || c === void 0 ? void 0 : c.cache.instanceId)
    }
  )
}
var NK = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  P6 = 'comm',
  L6 = 'rule',
  D6 = 'decl',
  PK = '@import',
  LK = '@namespace',
  DK = '@keyframes',
  FK = '@layer',
  F6 = Math.abs,
  Qx = String.fromCharCode
function O6(n) {
  return n.trim()
}
function Vp(n, e, t) {
  return n.replace(e, t)
}
function OK(n, e, t) {
  return n.indexOf(e, t)
}
function Yc(n, e) {
  return n.charCodeAt(e) | 0
}
function Tu(n, e, t) {
  return n.slice(e, t)
}
function ks(n) {
  return n.length
}
function BK(n) {
  return n.length
}
function up(n, e) {
  return (e.push(n), n)
}
var L0 = 1,
  wu = 1,
  B6 = 0,
  rs = 0,
  $n = 0,
  Wu = ''
function jx(n, e, t, i, r, s, o, a) {
  return {
    value: n,
    root: e,
    parent: t,
    type: i,
    props: r,
    children: s,
    line: L0,
    column: wu,
    length: o,
    return: '',
    siblings: a,
  }
}
function UK() {
  return $n
}
function kK() {
  return (($n = rs > 0 ? Yc(Wu, --rs) : 0), wu--, $n === 10 && ((wu = 1), L0--), $n)
}
function Ss() {
  return (($n = rs < B6 ? Yc(Wu, rs++) : 0), wu++, $n === 10 && ((wu = 1), L0++), $n)
}
function Ia() {
  return Yc(Wu, rs)
}
function Hp() {
  return rs
}
function D0(n, e) {
  return Tu(Wu, n, e)
}
function bh(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4
    case 58:
      return 3
    case 34:
    case 39:
    case 40:
    case 91:
      return 2
    case 41:
    case 93:
      return 1
  }
  return 0
}
function zK(n) {
  return ((L0 = wu = 1), (B6 = ks((Wu = n))), (rs = 0), [])
}
function VK(n) {
  return ((Wu = ''), n)
}
function M1(n) {
  return O6(D0(rs - 1, _v(n === 91 ? n + 2 : n === 40 ? n + 1 : n)))
}
function HK(n) {
  for (; ($n = Ia()) && $n < 33; ) Ss()
  return bh(n) > 2 || bh($n) > 3 ? '' : ' '
}
function $K(n, e) {
  for (; --e && Ss() && !($n < 48 || $n > 102 || ($n > 57 && $n < 65) || ($n > 70 && $n < 97)); );
  return D0(n, Hp() + (e < 6 && Ia() == 32 && Ss() == 32))
}
function _v(n) {
  for (; Ss(); )
    switch ($n) {
      case n:
        return rs
      case 34:
      case 39:
        n !== 34 && n !== 39 && _v($n)
        break
      case 40:
        n === 41 && _v(n)
        break
      case 92:
        Ss()
        break
    }
  return rs
}
function GK(n, e) {
  for (; Ss() && n + $n !== 57; ) if (n + $n === 84 && Ia() === 47) break
  return '/*' + D0(e, rs - 1) + '*' + Qx(n === 47 ? n : Ss())
}
function WK(n) {
  for (; !bh(Ia()); ) Ss()
  return D0(n, rs)
}
function QK(n) {
  return VK($p('', null, null, null, [''], (n = zK(n)), 0, [0], n))
}
function $p(n, e, t, i, r, s, o, a, l) {
  for (
    var c = 0,
      u = 0,
      d = o,
      h = 0,
      f = 0,
      p = 0,
      g = 1,
      y = 1,
      m = 1,
      v = 0,
      x = '',
      _ = r,
      S = s,
      C = i,
      A = x;
    y;

  )
    switch (((p = v), (v = Ss()))) {
      case 40:
        if (p != 108 && Yc(A, d - 1) == 58) {
          OK((A += Vp(M1(v), '&', '&\f')), '&\f', F6(c ? a[c - 1] : 0)) != -1 && (m = -1)
          break
        }
      case 34:
      case 39:
      case 91:
        A += M1(v)
        break
      case 9:
      case 10:
      case 13:
      case 32:
        A += HK(p)
        break
      case 92:
        A += $K(Hp() - 1, 7)
        continue
      case 47:
        switch (Ia()) {
          case 42:
          case 47:
            ;(up(jK(GK(Ss(), Hp()), e, t, l), l),
              (bh(p || 1) == 5 || bh(Ia() || 1) == 5) &&
                ks(A) &&
                Tu(A, -1, void 0) !== ' ' &&
                (A += ' '))
            break
          default:
            A += '/'
        }
        break
      case 123 * g:
        a[c++] = ks(A) * m
      case 125 * g:
      case 59:
      case 0:
        switch (v) {
          case 0:
          case 125:
            y = 0
          case 59 + u:
            ;(m == -1 && (A = Vp(A, /\f/g, '')),
              f > 0 &&
                (ks(A) - d || (g === 0 && p === 47)) &&
                up(
                  f > 32 ? g3(A + ';', i, t, d - 1, l) : g3(Vp(A, ' ', '') + ';', i, t, d - 2, l),
                  l
                ))
            break
          case 59:
            A += ';'
          default:
            if ((up((C = m3(A, e, t, c, u, r, a, x, (_ = []), (S = []), d, s)), s), v === 123))
              if (u === 0) $p(A, e, C, C, _, s, d, a, S)
              else {
                switch (h) {
                  case 99:
                    if (Yc(A, 3) === 110) break
                  case 108:
                    if (Yc(A, 2) === 97) break
                  default:
                    u = 0
                  case 100:
                  case 109:
                  case 115:
                }
                u
                  ? $p(
                      n,
                      C,
                      C,
                      i && up(m3(n, C, C, 0, 0, r, a, x, r, (_ = []), d, S), S),
                      r,
                      S,
                      d,
                      a,
                      i ? _ : S
                    )
                  : $p(A, C, C, C, [''], S, 0, a, S)
              }
        }
        ;((c = u = f = 0), (g = m = 1), (x = A = ''), (d = o))
        break
      case 58:
        ;((d = 1 + ks(A)), (f = p))
      default:
        if (g < 1) {
          if (v == 123) --g
          else if (v == 125 && g++ == 0 && kK() == 125) continue
        }
        switch (((A += Qx(v)), v * g)) {
          case 38:
            m = u > 0 ? 1 : ((A += '\f'), -1)
            break
          case 44:
            ;((a[c++] = (ks(A) - 1) * m), (m = 1))
            break
          case 64:
            ;(Ia() === 45 && (A += M1(Ss())), (h = Ia()), (u = d = ks((x = A += WK(Hp())))), v++)
            break
          case 45:
            p === 45 && ks(A) == 2 && (g = 0)
        }
    }
  return s
}
function m3(n, e, t, i, r, s, o, a, l, c, u, d) {
  for (var h = r - 1, f = r === 0 ? s : [''], p = BK(f), g = 0, y = 0, m = 0; g < i; ++g)
    for (var v = 0, x = Tu(n, h + 1, (h = F6((y = o[g])))), _ = n; v < p; ++v)
      (_ = O6(y > 0 ? f[v] + ' ' + x : Vp(x, /&\f/g, f[v]))) && (l[m++] = _)
  return jx(n, e, t, r === 0 ? L6 : a, l, c, u, d)
}
function jK(n, e, t, i) {
  return jx(n, e, t, P6, Qx(UK()), Tu(n, 2, -2), 0, i)
}
function g3(n, e, t, i, r) {
  return jx(n, e, t, D6, Tu(n, 0, i), Tu(n, i + 1, -1), i, r)
}
function xv(n, e) {
  for (var t = '', i = 0; i < n.length; i++) t += e(n[i], i, n, e) || ''
  return t
}
function qK(n, e, t, i) {
  switch (n.type) {
    case FK:
      if (n.children.length) break
    case PK:
    case LK:
    case D6:
      return (n.return = n.return || n.value)
    case P6:
      return ''
    case DK:
      return (n.return = n.value + '{' + xv(n.children, i) + '}')
    case L6:
      if (!ks((n.value = n.props.join(',')))) return ''
  }
  return ks((t = xv(n.children, i))) ? (n.return = n.value + '{' + t + '}') : ''
}
const y3 = 'data-ant-cssinjs-cache-path',
  XK = '_FILE_STYLE__'
let Bl,
  U6 = !0
function KK() {
  var n
  if (!Bl && ((Bl = {}), Gu())) {
    const e = document.createElement('div')
    ;((e.className = y3),
      (e.style.position = 'fixed'),
      (e.style.visibility = 'hidden'),
      (e.style.top = '-9999px'),
      document.body.appendChild(e))
    let t = getComputedStyle(e).content || ''
    ;((t = t.replace(/^"/, '').replace(/"$/, '')),
      t.split(';').forEach((r) => {
        const [s, o] = r.split(':')
        Bl[s] = o
      }))
    const i = document.querySelector('style['.concat(y3, ']'))
    ;(i && ((U6 = !1), (n = i.parentNode) === null || n === void 0 || n.removeChild(i)),
      document.body.removeChild(e))
  }
}
function YK(n) {
  return (KK(), !!Bl[n])
}
function ZK(n) {
  const e = Bl[n]
  let t = null
  if (e && Gu())
    if (U6) t = XK
    else {
      const i = document.querySelector('style['.concat(Ol, '="').concat(Bl[n], '"]'))
      i ? (t = i.innerHTML) : delete Bl[n]
    }
  return [t, e]
}
const v3 = Gu(),
  JK = '_skip_check_',
  k6 = '_multi_value_'
function _3(n) {
  return xv(QK(n), qK).replace(/\{%%%\:[^;];}/g, ';')
}
function eY(n) {
  return typeof n == 'object' && n && (JK in n || k6 in n)
}
function tY(n, e, t) {
  if (!e) return n
  const i = '.'.concat(e),
    r = t === 'low' ? ':where('.concat(i, ')') : i
  return n
    .split(',')
    .map((o) => {
      var a
      const l = o.trim().split(/\s+/)
      let c = l[0] || ''
      const u = ((a = c.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) || ''
      return ((c = ''.concat(u).concat(r).concat(c.slice(u.length))), [c, ...l.slice(1)].join(' '))
    })
    .join(',')
}
const x3 = new Set(),
  Sv = function (n) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      {
        root: t,
        injectHash: i,
        parentSelectors: r,
      } = arguments.length > 2 && arguments[2] !== void 0
        ? arguments[2]
        : { root: !0, parentSelectors: [] }
    const {
      hashId: s,
      layer: o,
      path: a,
      hashPriority: l,
      transformers: c = [],
      linters: u = [],
    } = e
    let d = '',
      h = {}
    function f(y) {
      const m = y.getName(s)
      if (!h[m]) {
        const [v] = Sv(y.style, e, { root: !1, parentSelectors: r })
        h[m] = '@keyframes '.concat(y.getName(s)).concat(v)
      }
    }
    function p(y) {
      let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
      return (
        y.forEach((v) => {
          Array.isArray(v) ? p(v, m) : v && m.push(v)
        }),
        m
      )
    }
    if (
      (p(Array.isArray(n) ? n : [n]).forEach((y) => {
        const m = typeof y == 'string' && !t ? {} : y
        if (typeof m == 'string') d += ''.concat(m, '\n')
        else if (m._keyframe) f(m)
        else {
          const v = c.reduce((x, _) => {
            var S
            return (
              ((S = _ == null ? void 0 : _.visit) === null || S === void 0
                ? void 0
                : S.call(_, x)) || x
            )
          }, m)
          Object.keys(v).forEach((x) => {
            var _
            const S = v[x]
            if (typeof S == 'object' && S && (x !== 'animationName' || !S._keyframe) && !eY(S)) {
              let C = !1,
                A = x.trim(),
                R = !1
              ;(t || i) && s
                ? A.startsWith('@')
                  ? (C = !0)
                  : (A = tY(x, s, l))
                : t && !s && (A === '&' || A === '') && ((A = ''), (R = !0))
              const [w, M] = Sv(S, e, { root: R, injectHash: C, parentSelectors: [...r, A] })
              ;((h = ke(ke({}, h), M)), (d += ''.concat(A).concat(w)))
            } else {
              let C = function (R, w) {
                const M = R.replace(/[A-Z]/g, (L) => '-'.concat(L.toLowerCase()))
                let I = w
                ;(!NK[R] && typeof I == 'number' && I !== 0 && (I = ''.concat(I, 'px')),
                  R === 'animationName' && w != null && w._keyframe && (f(w), (I = w.getName(s))),
                  (d += ''.concat(M, ':').concat(I, ';')))
              }
              const A = (_ = S == null ? void 0 : S.value) !== null && _ !== void 0 ? _ : S
              typeof S == 'object' && S != null && S[k6] && Array.isArray(A)
                ? A.forEach((R) => {
                    C(x, R)
                  })
                : C(x, A)
            }
          })
        }
      }),
      !t)
    )
      d = '{'.concat(d, '}')
    else if (o && bK()) {
      const y = o.split(','),
        m = y[y.length - 1].trim()
      ;((d = '@layer '.concat(m, ' {').concat(d, '}')),
        y.length > 1 && (d = '@layer '.concat(o, '{%%%:%}').concat(d)))
    }
    return [d, h]
  }
function nY(n, e) {
  return Wx(''.concat(n.join('%')).concat(e))
}
function Av(n, e) {
  const t = N0(),
    i = Ge(() => n.value.token._tokenKey),
    r = Ge(() => [i.value, ...n.value.path])
  let s = v3
  return (
    A6(
      'style',
      r,
      () => {
        const { path: o, hashId: a, layer: l, nonce: c, clientOnly: u, order: d = 0 } = n.value,
          h = r.value.join('|')
        if (YK(h)) {
          const [A, R] = ZK(h)
          if (A) return [A, i.value, R, {}, u, d]
        }
        const f = e(),
          { hashPriority: p, container: g, transformers: y, linters: m, cache: v } = t.value,
          [x, _] = Sv(f, {
            hashId: a,
            hashPriority: p,
            layer: l,
            path: o.join('-'),
            transformers: y,
            linters: m,
          }),
          S = _3(x),
          C = nY(r.value, S)
        if (s) {
          const A = { mark: Ol, prepend: 'queue', attachTo: g, priority: d },
            R = typeof c == 'function' ? c() : c
          R && (A.csp = { nonce: R })
          const w = Bm(S, C, A)
          ;((w[kc] = v.instanceId),
            w.setAttribute(_6, i.value),
            Object.keys(_).forEach((M) => {
              x3.has(M) ||
                (x3.add(M),
                Bm(_3(_[M]), '_effect-'.concat(M), { mark: Ol, prepend: 'queue', attachTo: g }))
            }))
        }
        return [S, i.value, C, _, u, d]
      },
      (o, a) => {
        let [, , l] = o
        ;(a || t.value.autoClear) && v3 && E6(l, { mark: Ol })
      }
    ),
    (o) => o
  )
}
class $o {
  constructor(e, t) {
    ;((this._keyframe = !0), (this.name = e), (this.style = t))
  }
  getName() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
    return e ? ''.concat(e, '-').concat(this.name) : this.name
  }
}
const iY = '4.2.6'
function Si(n, e) {
  rY(n) && (n = '100%')
  var t = sY(n)
  return (
    (n = e === 360 ? n : Math.min(e, Math.max(0, parseFloat(n)))),
    t && (n = parseInt(String(n * e), 10) / 100),
    Math.abs(n - e) < 1e-6
      ? 1
      : (e === 360
          ? (n = (n < 0 ? (n % e) + e : n % e) / parseFloat(String(e)))
          : (n = (n % e) / parseFloat(String(e))),
        n)
  )
}
function dp(n) {
  return Math.min(1, Math.max(0, n))
}
function rY(n) {
  return typeof n == 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1
}
function sY(n) {
  return typeof n == 'string' && n.indexOf('%') !== -1
}
function z6(n) {
  return ((n = parseFloat(n)), (isNaN(n) || n < 0 || n > 1) && (n = 1), n)
}
function hp(n) {
  return n <= 1 ? ''.concat(Number(n) * 100, '%') : n
}
function El(n) {
  return n.length === 1 ? '0' + n : String(n)
}
function oY(n, e, t) {
  return { r: Si(n, 255) * 255, g: Si(e, 255) * 255, b: Si(t, 255) * 255 }
}
function S3(n, e, t) {
  ;((n = Si(n, 255)), (e = Si(e, 255)), (t = Si(t, 255)))
  var i = Math.max(n, e, t),
    r = Math.min(n, e, t),
    s = 0,
    o = 0,
    a = (i + r) / 2
  if (i === r) ((o = 0), (s = 0))
  else {
    var l = i - r
    switch (((o = a > 0.5 ? l / (2 - i - r) : l / (i + r)), i)) {
      case n:
        s = (e - t) / l + (e < t ? 6 : 0)
        break
      case e:
        s = (t - n) / l + 2
        break
      case t:
        s = (n - e) / l + 4
        break
    }
    s /= 6
  }
  return { h: s, s: o, l: a }
}
function R1(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * (6 * t)
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * (2 / 3 - t) * 6
          : n
  )
}
function aY(n, e, t) {
  var i, r, s
  if (((n = Si(n, 360)), (e = Si(e, 100)), (t = Si(t, 100)), e === 0)) ((r = t), (s = t), (i = t))
  else {
    var o = t < 0.5 ? t * (1 + e) : t + e - t * e,
      a = 2 * t - o
    ;((i = R1(a, o, n + 1 / 3)), (r = R1(a, o, n)), (s = R1(a, o, n - 1 / 3)))
  }
  return { r: i * 255, g: r * 255, b: s * 255 }
}
function bv(n, e, t) {
  ;((n = Si(n, 255)), (e = Si(e, 255)), (t = Si(t, 255)))
  var i = Math.max(n, e, t),
    r = Math.min(n, e, t),
    s = 0,
    o = i,
    a = i - r,
    l = i === 0 ? 0 : a / i
  if (i === r) s = 0
  else {
    switch (i) {
      case n:
        s = (e - t) / a + (e < t ? 6 : 0)
        break
      case e:
        s = (t - n) / a + 2
        break
      case t:
        s = (n - e) / a + 4
        break
    }
    s /= 6
  }
  return { h: s, s: l, v: o }
}
function lY(n, e, t) {
  ;((n = Si(n, 360) * 6), (e = Si(e, 100)), (t = Si(t, 100)))
  var i = Math.floor(n),
    r = n - i,
    s = t * (1 - e),
    o = t * (1 - r * e),
    a = t * (1 - (1 - r) * e),
    l = i % 6,
    c = [t, o, s, s, a, t][l],
    u = [a, t, t, o, s, s][l],
    d = [s, s, a, t, t, o][l]
  return { r: c * 255, g: u * 255, b: d * 255 }
}
function Tv(n, e, t, i) {
  var r = [
    El(Math.round(n).toString(16)),
    El(Math.round(e).toString(16)),
    El(Math.round(t).toString(16)),
  ]
  return i &&
    r[0].startsWith(r[0].charAt(1)) &&
    r[1].startsWith(r[1].charAt(1)) &&
    r[2].startsWith(r[2].charAt(1))
    ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0)
    : r.join('')
}
function cY(n, e, t, i, r) {
  var s = [
    El(Math.round(n).toString(16)),
    El(Math.round(e).toString(16)),
    El(Math.round(t).toString(16)),
    El(uY(i)),
  ]
  return r &&
    s[0].startsWith(s[0].charAt(1)) &&
    s[1].startsWith(s[1].charAt(1)) &&
    s[2].startsWith(s[2].charAt(1)) &&
    s[3].startsWith(s[3].charAt(1))
    ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0)
    : s.join('')
}
function uY(n) {
  return Math.round(parseFloat(n) * 255).toString(16)
}
function A3(n) {
  return yr(n) / 255
}
function yr(n) {
  return parseInt(n, 16)
}
function dY(n) {
  return { r: n >> 16, g: (n & 65280) >> 8, b: n & 255 }
}
var wv = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  goldenrod: '#daa520',
  gold: '#ffd700',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavenderblush: '#fff0f5',
  lavender: '#e6e6fa',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32',
}
function Ic(n) {
  var e = { r: 0, g: 0, b: 0 },
    t = 1,
    i = null,
    r = null,
    s = null,
    o = !1,
    a = !1
  return (
    typeof n == 'string' && (n = pY(n)),
    typeof n == 'object' &&
      (So(n.r) && So(n.g) && So(n.b)
        ? ((e = oY(n.r, n.g, n.b)), (o = !0), (a = String(n.r).substr(-1) === '%' ? 'prgb' : 'rgb'))
        : So(n.h) && So(n.s) && So(n.v)
          ? ((i = hp(n.s)), (r = hp(n.v)), (e = lY(n.h, i, r)), (o = !0), (a = 'hsv'))
          : So(n.h) &&
            So(n.s) &&
            So(n.l) &&
            ((i = hp(n.s)), (s = hp(n.l)), (e = aY(n.h, i, s)), (o = !0), (a = 'hsl')),
      Object.prototype.hasOwnProperty.call(n, 'a') && (t = n.a)),
    (t = z6(t)),
    {
      ok: o,
      format: n.format || a,
      r: Math.min(255, Math.max(e.r, 0)),
      g: Math.min(255, Math.max(e.g, 0)),
      b: Math.min(255, Math.max(e.b, 0)),
      a: t,
    }
  )
}
var hY = '[-\\+]?\\d+%?',
  fY = '[-\\+]?\\d*\\.\\d+%?',
  Na = '(?:'.concat(fY, ')|(?:').concat(hY, ')'),
  I1 = '[\\s|\\(]+('.concat(Na, ')[,|\\s]+(').concat(Na, ')[,|\\s]+(').concat(Na, ')\\s*\\)?'),
  N1 = '[\\s|\\(]+('
    .concat(Na, ')[,|\\s]+(')
    .concat(Na, ')[,|\\s]+(')
    .concat(Na, ')[,|\\s]+(')
    .concat(Na, ')\\s*\\)?'),
  ds = {
    CSS_UNIT: new RegExp(Na),
    rgb: new RegExp('rgb' + I1),
    rgba: new RegExp('rgba' + N1),
    hsl: new RegExp('hsl' + I1),
    hsla: new RegExp('hsla' + N1),
    hsv: new RegExp('hsv' + I1),
    hsva: new RegExp('hsva' + N1),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  }
function pY(n) {
  if (((n = n.trim().toLowerCase()), n.length === 0)) return !1
  var e = !1
  if (wv[n]) ((n = wv[n]), (e = !0))
  else if (n === 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name' }
  var t = ds.rgb.exec(n)
  return t
    ? { r: t[1], g: t[2], b: t[3] }
    : ((t = ds.rgba.exec(n)),
      t
        ? { r: t[1], g: t[2], b: t[3], a: t[4] }
        : ((t = ds.hsl.exec(n)),
          t
            ? { h: t[1], s: t[2], l: t[3] }
            : ((t = ds.hsla.exec(n)),
              t
                ? { h: t[1], s: t[2], l: t[3], a: t[4] }
                : ((t = ds.hsv.exec(n)),
                  t
                    ? { h: t[1], s: t[2], v: t[3] }
                    : ((t = ds.hsva.exec(n)),
                      t
                        ? { h: t[1], s: t[2], v: t[3], a: t[4] }
                        : ((t = ds.hex8.exec(n)),
                          t
                            ? {
                                r: yr(t[1]),
                                g: yr(t[2]),
                                b: yr(t[3]),
                                a: A3(t[4]),
                                format: e ? 'name' : 'hex8',
                              }
                            : ((t = ds.hex6.exec(n)),
                              t
                                ? {
                                    r: yr(t[1]),
                                    g: yr(t[2]),
                                    b: yr(t[3]),
                                    format: e ? 'name' : 'hex',
                                  }
                                : ((t = ds.hex4.exec(n)),
                                  t
                                    ? {
                                        r: yr(t[1] + t[1]),
                                        g: yr(t[2] + t[2]),
                                        b: yr(t[3] + t[3]),
                                        a: A3(t[4] + t[4]),
                                        format: e ? 'name' : 'hex8',
                                      }
                                    : ((t = ds.hex3.exec(n)),
                                      t
                                        ? {
                                            r: yr(t[1] + t[1]),
                                            g: yr(t[2] + t[2]),
                                            b: yr(t[3] + t[3]),
                                            format: e ? 'name' : 'hex',
                                          }
                                        : !1)))))))))
}
function So(n) {
  return !!ds.CSS_UNIT.exec(String(n))
}
var yi = (function () {
    function n(e, t) {
      ;(e === void 0 && (e = ''), t === void 0 && (t = {}))
      var i
      if (e instanceof n) return e
      ;(typeof e == 'number' && (e = dY(e)), (this.originalInput = e))
      var r = Ic(e)
      ;((this.originalInput = e),
        (this.r = r.r),
        (this.g = r.g),
        (this.b = r.b),
        (this.a = r.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (i = t.format) !== null && i !== void 0 ? i : r.format),
        (this.gradientType = t.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = r.ok))
    }
    return (
      (n.prototype.isDark = function () {
        return this.getBrightness() < 128
      }),
      (n.prototype.isLight = function () {
        return !this.isDark()
      }),
      (n.prototype.getBrightness = function () {
        var e = this.toRgb()
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
      }),
      (n.prototype.getLuminance = function () {
        var e = this.toRgb(),
          t,
          i,
          r,
          s = e.r / 255,
          o = e.g / 255,
          a = e.b / 255
        return (
          s <= 0.03928 ? (t = s / 12.92) : (t = Math.pow((s + 0.055) / 1.055, 2.4)),
          o <= 0.03928 ? (i = o / 12.92) : (i = Math.pow((o + 0.055) / 1.055, 2.4)),
          a <= 0.03928 ? (r = a / 12.92) : (r = Math.pow((a + 0.055) / 1.055, 2.4)),
          0.2126 * t + 0.7152 * i + 0.0722 * r
        )
      }),
      (n.prototype.getAlpha = function () {
        return this.a
      }),
      (n.prototype.setAlpha = function (e) {
        return ((this.a = z6(e)), (this.roundA = Math.round(100 * this.a) / 100), this)
      }),
      (n.prototype.isMonochrome = function () {
        var e = this.toHsl().s
        return e === 0
      }),
      (n.prototype.toHsv = function () {
        var e = bv(this.r, this.g, this.b)
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a }
      }),
      (n.prototype.toHsvString = function () {
        var e = bv(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          i = Math.round(e.s * 100),
          r = Math.round(e.v * 100)
        return this.a === 1
          ? 'hsv('.concat(t, ', ').concat(i, '%, ').concat(r, '%)')
          : 'hsva('.concat(t, ', ').concat(i, '%, ').concat(r, '%, ').concat(this.roundA, ')')
      }),
      (n.prototype.toHsl = function () {
        var e = S3(this.r, this.g, this.b)
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a }
      }),
      (n.prototype.toHslString = function () {
        var e = S3(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          i = Math.round(e.s * 100),
          r = Math.round(e.l * 100)
        return this.a === 1
          ? 'hsl('.concat(t, ', ').concat(i, '%, ').concat(r, '%)')
          : 'hsla('.concat(t, ', ').concat(i, '%, ').concat(r, '%, ').concat(this.roundA, ')')
      }),
      (n.prototype.toHex = function (e) {
        return (e === void 0 && (e = !1), Tv(this.r, this.g, this.b, e))
      }),
      (n.prototype.toHexString = function (e) {
        return (e === void 0 && (e = !1), '#' + this.toHex(e))
      }),
      (n.prototype.toHex8 = function (e) {
        return (e === void 0 && (e = !1), cY(this.r, this.g, this.b, this.a, e))
      }),
      (n.prototype.toHex8String = function (e) {
        return (e === void 0 && (e = !1), '#' + this.toHex8(e))
      }),
      (n.prototype.toHexShortString = function (e) {
        return (e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e))
      }),
      (n.prototype.toRgb = function () {
        return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a }
      }),
      (n.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          t = Math.round(this.g),
          i = Math.round(this.b)
        return this.a === 1
          ? 'rgb('.concat(e, ', ').concat(t, ', ').concat(i, ')')
          : 'rgba('.concat(e, ', ').concat(t, ', ').concat(i, ', ').concat(this.roundA, ')')
      }),
      (n.prototype.toPercentageRgb = function () {
        var e = function (t) {
          return ''.concat(Math.round(Si(t, 255) * 100), '%')
        }
        return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a }
      }),
      (n.prototype.toPercentageRgbString = function () {
        var e = function (t) {
          return Math.round(Si(t, 255) * 100)
        }
        return this.a === 1
          ? 'rgb('.concat(e(this.r), '%, ').concat(e(this.g), '%, ').concat(e(this.b), '%)')
          : 'rgba('
              .concat(e(this.r), '%, ')
              .concat(e(this.g), '%, ')
              .concat(e(this.b), '%, ')
              .concat(this.roundA, ')')
      }),
      (n.prototype.toName = function () {
        if (this.a === 0) return 'transparent'
        if (this.a < 1) return !1
        for (
          var e = '#' + Tv(this.r, this.g, this.b, !1), t = 0, i = Object.entries(wv);
          t < i.length;
          t++
        ) {
          var r = i[t],
            s = r[0],
            o = r[1]
          if (e === o) return s
        }
        return !1
      }),
      (n.prototype.toString = function (e) {
        var t = !!e
        e = e != null ? e : this.format
        var i = !1,
          r = this.a < 1 && this.a >= 0,
          s = !t && r && (e.startsWith('hex') || e === 'name')
        return s
          ? e === 'name' && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === 'rgb' && (i = this.toRgbString()),
            e === 'prgb' && (i = this.toPercentageRgbString()),
            (e === 'hex' || e === 'hex6') && (i = this.toHexString()),
            e === 'hex3' && (i = this.toHexString(!0)),
            e === 'hex4' && (i = this.toHex8String(!0)),
            e === 'hex8' && (i = this.toHex8String()),
            e === 'name' && (i = this.toName()),
            e === 'hsl' && (i = this.toHslString()),
            e === 'hsv' && (i = this.toHsvString()),
            i || this.toHexString())
      }),
      (n.prototype.toNumber = function () {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
      }),
      (n.prototype.clone = function () {
        return new n(this.toString())
      }),
      (n.prototype.lighten = function (e) {
        e === void 0 && (e = 10)
        var t = this.toHsl()
        return ((t.l += e / 100), (t.l = dp(t.l)), new n(t))
      }),
      (n.prototype.brighten = function (e) {
        e === void 0 && (e = 10)
        var t = this.toRgb()
        return (
          (t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100))))),
          (t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100))))),
          (t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100))))),
          new n(t)
        )
      }),
      (n.prototype.darken = function (e) {
        e === void 0 && (e = 10)
        var t = this.toHsl()
        return ((t.l -= e / 100), (t.l = dp(t.l)), new n(t))
      }),
      (n.prototype.tint = function (e) {
        return (e === void 0 && (e = 10), this.mix('white', e))
      }),
      (n.prototype.shade = function (e) {
        return (e === void 0 && (e = 10), this.mix('black', e))
      }),
      (n.prototype.desaturate = function (e) {
        e === void 0 && (e = 10)
        var t = this.toHsl()
        return ((t.s -= e / 100), (t.s = dp(t.s)), new n(t))
      }),
      (n.prototype.saturate = function (e) {
        e === void 0 && (e = 10)
        var t = this.toHsl()
        return ((t.s += e / 100), (t.s = dp(t.s)), new n(t))
      }),
      (n.prototype.greyscale = function () {
        return this.desaturate(100)
      }),
      (n.prototype.spin = function (e) {
        var t = this.toHsl(),
          i = (t.h + e) % 360
        return ((t.h = i < 0 ? 360 + i : i), new n(t))
      }),
      (n.prototype.mix = function (e, t) {
        t === void 0 && (t = 50)
        var i = this.toRgb(),
          r = new n(e).toRgb(),
          s = t / 100,
          o = {
            r: (r.r - i.r) * s + i.r,
            g: (r.g - i.g) * s + i.g,
            b: (r.b - i.b) * s + i.b,
            a: (r.a - i.a) * s + i.a,
          }
        return new n(o)
      }),
      (n.prototype.analogous = function (e, t) {
        ;(e === void 0 && (e = 6), t === void 0 && (t = 30))
        var i = this.toHsl(),
          r = 360 / t,
          s = [this]
        for (i.h = (i.h - ((r * e) >> 1) + 720) % 360; --e; )
          ((i.h = (i.h + r) % 360), s.push(new n(i)))
        return s
      }),
      (n.prototype.complement = function () {
        var e = this.toHsl()
        return ((e.h = (e.h + 180) % 360), new n(e))
      }),
      (n.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6)
        for (var t = this.toHsv(), i = t.h, r = t.s, s = t.v, o = [], a = 1 / e; e--; )
          (o.push(new n({ h: i, s: r, v: s })), (s = (s + a) % 1))
        return o
      }),
      (n.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          t = e.h
        return [
          this,
          new n({ h: (t + 72) % 360, s: e.s, l: e.l }),
          new n({ h: (t + 216) % 360, s: e.s, l: e.l }),
        ]
      }),
      (n.prototype.onBackground = function (e) {
        var t = this.toRgb(),
          i = new n(e).toRgb(),
          r = t.a + i.a * (1 - t.a)
        return new n({
          r: (t.r * t.a + i.r * i.a * (1 - t.a)) / r,
          g: (t.g * t.a + i.g * i.a * (1 - t.a)) / r,
          b: (t.b * t.a + i.b * i.a * (1 - t.a)) / r,
          a: r,
        })
      }),
      (n.prototype.triad = function () {
        return this.polyad(3)
      }),
      (n.prototype.tetrad = function () {
        return this.polyad(4)
      }),
      (n.prototype.polyad = function (e) {
        for (var t = this.toHsl(), i = t.h, r = [this], s = 360 / e, o = 1; o < e; o++)
          r.push(new n({ h: (i + o * s) % 360, s: t.s, l: t.l }))
        return r
      }),
      (n.prototype.equals = function (e) {
        return this.toRgbString() === new n(e).toRgbString()
      }),
      n
    )
  })(),
  fp = 2,
  b3 = 0.16,
  mY = 0.05,
  gY = 0.05,
  yY = 0.15,
  V6 = 5,
  H6 = 4,
  vY = [
    { index: 7, opacity: 0.15 },
    { index: 6, opacity: 0.25 },
    { index: 5, opacity: 0.3 },
    { index: 5, opacity: 0.45 },
    { index: 5, opacity: 0.65 },
    { index: 5, opacity: 0.85 },
    { index: 4, opacity: 0.9 },
    { index: 3, opacity: 0.95 },
    { index: 2, opacity: 0.97 },
    { index: 1, opacity: 0.98 },
  ]
function T3(n) {
  var e = n.r,
    t = n.g,
    i = n.b,
    r = bv(e, t, i)
  return { h: r.h * 360, s: r.s, v: r.v }
}
function pp(n) {
  var e = n.r,
    t = n.g,
    i = n.b
  return '#'.concat(Tv(e, t, i, !1))
}
function _Y(n, e, t) {
  var i = t / 100,
    r = { r: (e.r - n.r) * i + n.r, g: (e.g - n.g) * i + n.g, b: (e.b - n.b) * i + n.b }
  return r
}
function w3(n, e, t) {
  var i
  return (
    Math.round(n.h) >= 60 && Math.round(n.h) <= 240
      ? (i = t ? Math.round(n.h) - fp * e : Math.round(n.h) + fp * e)
      : (i = t ? Math.round(n.h) + fp * e : Math.round(n.h) - fp * e),
    i < 0 ? (i += 360) : i >= 360 && (i -= 360),
    i
  )
}
function C3(n, e, t) {
  if (n.h === 0 && n.s === 0) return n.s
  var i
  return (
    t ? (i = n.s - b3 * e) : e === H6 ? (i = n.s + b3) : (i = n.s + mY * e),
    i > 1 && (i = 1),
    t && e === V6 && i > 0.1 && (i = 0.1),
    i < 0.06 && (i = 0.06),
    Number(i.toFixed(2))
  )
}
function E3(n, e, t) {
  var i
  return (t ? (i = n.v + gY * e) : (i = n.v - yY * e), i > 1 && (i = 1), Number(i.toFixed(2)))
}
function Gl(n) {
  for (
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      t = [],
      i = Ic(n),
      r = V6;
    r > 0;
    r -= 1
  ) {
    var s = T3(i),
      o = pp(Ic({ h: w3(s, r, !0), s: C3(s, r, !0), v: E3(s, r, !0) }))
    t.push(o)
  }
  t.push(pp(i))
  for (var a = 1; a <= H6; a += 1) {
    var l = T3(i),
      c = pp(Ic({ h: w3(l, a), s: C3(l, a), v: E3(l, a) }))
    t.push(c)
  }
  return e.theme === 'dark'
    ? vY.map(function (u) {
        var d = u.index,
          h = u.opacity,
          f = pp(_Y(Ic(e.backgroundColor || '#141414'), Ic(t[d]), h * 100))
        return f
      })
    : t
}
var P1 = {
    red: '#F5222D',
    volcano: '#FA541C',
    orange: '#FA8C16',
    gold: '#FAAD14',
    yellow: '#FADB14',
    lime: '#A0D911',
    green: '#52C41A',
    cyan: '#13C2C2',
    blue: '#1890FF',
    geekblue: '#2F54EB',
    purple: '#722ED1',
    magenta: '#EB2F96',
    grey: '#666666',
  },
  Gp = {},
  L1 = {}
Object.keys(P1).forEach(function (n) {
  ;((Gp[n] = Gl(P1[n])),
    (Gp[n].primary = Gp[n][5]),
    (L1[n] = Gl(P1[n], { theme: 'dark', backgroundColor: '#141414' })),
    (L1[n].primary = L1[n][5]))
})
var xY = Gp.blue
const SY = (n) => {
  const { controlHeight: e } = n
  return { controlHeightSM: e * 0.75, controlHeightXS: e * 0.5, controlHeightLG: e * 1.25 }
}
function AY(n) {
  const { sizeUnit: e, sizeStep: t } = n
  return {
    sizeXXL: e * (t + 8),
    sizeXL: e * (t + 4),
    sizeLG: e * (t + 2),
    sizeMD: e * (t + 1),
    sizeMS: e * t,
    size: e * t,
    sizeSM: e * (t - 1),
    sizeXS: e * (t - 2),
    sizeXXS: e * (t - 3),
  }
}
const $6 = {
    blue: '#1677ff',
    purple: '#722ED1',
    cyan: '#13C2C2',
    green: '#52C41A',
    magenta: '#EB2F96',
    pink: '#eb2f96',
    red: '#F5222D',
    orange: '#FA8C16',
    yellow: '#FADB14',
    volcano: '#FA541C',
    geekblue: '#2F54EB',
    gold: '#FAAD14',
    lime: '#A0D911',
  },
  F0 = ke(ke({}, $6), {
    colorPrimary: '#1677ff',
    colorSuccess: '#52c41a',
    colorWarning: '#faad14',
    colorError: '#ff4d4f',
    colorInfo: '#1677ff',
    colorTextBase: '',
    colorBgBase: '',
    fontFamily:
      "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,\n'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n'Noto Color Emoji'",
    fontSize: 14,
    lineWidth: 1,
    lineType: 'solid',
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: 'cubic-bezier(0.08, 0.82, 0.17, 1)',
    motionEaseInOutCirc: 'cubic-bezier(0.78, 0.14, 0.15, 0.86)',
    motionEaseOut: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
    motionEaseInOut: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
    motionEaseOutBack: 'cubic-bezier(0.12, 0.4, 0.29, 1.46)',
    motionEaseInBack: 'cubic-bezier(0.71, -0.46, 0.88, 0.6)',
    motionEaseInQuint: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
    motionEaseOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)',
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
  })
function bY(n, e) {
  let { generateColorPalettes: t, generateNeutralColorPalettes: i } = e
  const {
      colorSuccess: r,
      colorWarning: s,
      colorError: o,
      colorInfo: a,
      colorPrimary: l,
      colorBgBase: c,
      colorTextBase: u,
    } = n,
    d = t(l),
    h = t(r),
    f = t(s),
    p = t(o),
    g = t(a),
    y = i(c, u)
  return ke(ke({}, y), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: h[1],
    colorSuccessBgHover: h[2],
    colorSuccessBorder: h[3],
    colorSuccessBorderHover: h[4],
    colorSuccessHover: h[4],
    colorSuccess: h[6],
    colorSuccessActive: h[7],
    colorSuccessTextHover: h[8],
    colorSuccessText: h[9],
    colorSuccessTextActive: h[10],
    colorErrorBg: p[1],
    colorErrorBgHover: p[2],
    colorErrorBorder: p[3],
    colorErrorBorderHover: p[4],
    colorErrorHover: p[5],
    colorError: p[6],
    colorErrorActive: p[7],
    colorErrorTextHover: p[8],
    colorErrorText: p[9],
    colorErrorTextActive: p[10],
    colorWarningBg: f[1],
    colorWarningBgHover: f[2],
    colorWarningBorder: f[3],
    colorWarningBorderHover: f[4],
    colorWarningHover: f[4],
    colorWarning: f[6],
    colorWarningActive: f[7],
    colorWarningTextHover: f[8],
    colorWarningText: f[9],
    colorWarningTextActive: f[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorBgMask: new yi('#000').setAlpha(0.45).toRgbString(),
    colorWhite: '#fff',
  })
}
const TY = (n) => {
  let e = n,
    t = n,
    i = n,
    r = n
  return (
    n < 6 && n >= 5 ? (e = n + 1) : n < 16 && n >= 6 ? (e = n + 2) : n >= 16 && (e = 16),
    n < 7 && n >= 5
      ? (t = 4)
      : n < 8 && n >= 7
        ? (t = 5)
        : n < 14 && n >= 8
          ? (t = 6)
          : n < 16 && n >= 14
            ? (t = 7)
            : n >= 16 && (t = 8),
    n < 6 && n >= 2 ? (i = 1) : n >= 6 && (i = 2),
    n > 4 && n < 8 ? (r = 4) : n >= 8 && (r = 6),
    {
      borderRadius: n > 16 ? 16 : n,
      borderRadiusXS: i,
      borderRadiusSM: t,
      borderRadiusLG: e,
      borderRadiusOuter: r,
    }
  )
}
function wY(n) {
  const { motionUnit: e, motionBase: t, borderRadius: i, lineWidth: r } = n
  return ke(
    {
      motionDurationFast: ''.concat((t + e).toFixed(1), 's'),
      motionDurationMid: ''.concat((t + e * 2).toFixed(1), 's'),
      motionDurationSlow: ''.concat((t + e * 3).toFixed(1), 's'),
      lineWidthBold: r + 1,
    },
    TY(i)
  )
}
const Ao = (n, e) => new yi(n).setAlpha(e).toRgbString(),
  xd = (n, e) => new yi(n).darken(e).toHexString(),
  CY = (n) => {
    const e = Gl(n)
    return {
      1: e[0],
      2: e[1],
      3: e[2],
      4: e[3],
      5: e[4],
      6: e[5],
      7: e[6],
      8: e[4],
      9: e[5],
      10: e[6],
    }
  },
  EY = (n, e) => {
    const t = n || '#fff',
      i = e || '#000'
    return {
      colorBgBase: t,
      colorTextBase: i,
      colorText: Ao(i, 0.88),
      colorTextSecondary: Ao(i, 0.65),
      colorTextTertiary: Ao(i, 0.45),
      colorTextQuaternary: Ao(i, 0.25),
      colorFill: Ao(i, 0.15),
      colorFillSecondary: Ao(i, 0.06),
      colorFillTertiary: Ao(i, 0.04),
      colorFillQuaternary: Ao(i, 0.02),
      colorBgLayout: xd(t, 4),
      colorBgContainer: xd(t, 0),
      colorBgElevated: xd(t, 0),
      colorBgSpotlight: Ao(i, 0.85),
      colorBorder: xd(t, 15),
      colorBorderSecondary: xd(t, 6),
    }
  }
function MY(n) {
  const e = new Array(10).fill(null).map((t, i) => {
    const r = i - 1,
      s = n * Math.pow(2.71828, r / 5),
      o = i > 1 ? Math.floor(s) : Math.ceil(s)
    return Math.floor(o / 2) * 2
  })
  return (
    (e[1] = n),
    e.map((t) => {
      const i = t + 8
      return { size: t, lineHeight: i / t }
    })
  )
}
const RY = (n) => {
  const e = MY(n),
    t = e.map((r) => r.size),
    i = e.map((r) => r.lineHeight)
  return {
    fontSizeSM: t[0],
    fontSize: t[1],
    fontSizeLG: t[2],
    fontSizeXL: t[3],
    fontSizeHeading1: t[6],
    fontSizeHeading2: t[5],
    fontSizeHeading3: t[4],
    fontSizeHeading4: t[3],
    fontSizeHeading5: t[2],
    lineHeight: i[1],
    lineHeightLG: i[2],
    lineHeightSM: i[0],
    lineHeightHeading1: i[6],
    lineHeightHeading2: i[5],
    lineHeightHeading3: i[4],
    lineHeightHeading4: i[3],
    lineHeightHeading5: i[2],
  }
}
function IY(n) {
  const e = Object.keys($6)
    .map((t) => {
      const i = Gl(n[t])
      return new Array(10)
        .fill(1)
        .reduce((r, s, o) => ((r[''.concat(t, '-').concat(o + 1)] = i[o]), r), {})
    })
    .reduce((t, i) => ((t = ke(ke({}, t), i)), t), {})
  return ke(
    ke(
      ke(
        ke(
          ke(
            ke(ke({}, n), e),
            bY(n, { generateColorPalettes: CY, generateNeutralColorPalettes: EY })
          ),
          RY(n.fontSize)
        ),
        AY(n)
      ),
      SY(n)
    ),
    wY(n)
  )
}
function D1(n) {
  return n >= 0 && n <= 255
}
function mp(n, e) {
  const { r: t, g: i, b: r, a: s } = new yi(n).toRgb()
  if (s < 1) return n
  const { r: o, g: a, b: l } = new yi(e).toRgb()
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((t - o * (1 - c)) / c),
      d = Math.round((i - a * (1 - c)) / c),
      h = Math.round((r - l * (1 - c)) / c)
    if (D1(u) && D1(d) && D1(h))
      return new yi({ r: u, g: d, b: h, a: Math.round(c * 100) / 100 }).toRgbString()
  }
  return new yi({ r: t, g: i, b: r, a: 1 }).toRgbString()
}
var NY = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
function PY(n) {
  const { override: e } = n,
    t = NY(n, ['override']),
    i = ke({}, e)
  Object.keys(F0).forEach((f) => {
    delete i[f]
  })
  const r = ke(ke({}, t), i),
    s = 480,
    o = 576,
    a = 768,
    l = 992,
    c = 1200,
    u = 1600,
    d = 2e3
  return ke(
    ke(ke({}, r), {
      colorLink: r.colorInfoText,
      colorLinkHover: r.colorInfoHover,
      colorLinkActive: r.colorInfoActive,
      colorFillContent: r.colorFillSecondary,
      colorFillContentHover: r.colorFill,
      colorFillAlter: r.colorFillQuaternary,
      colorBgContainerDisabled: r.colorFillTertiary,
      colorBorderBg: r.colorBgContainer,
      colorSplit: mp(r.colorBorderSecondary, r.colorBgContainer),
      colorTextPlaceholder: r.colorTextQuaternary,
      colorTextDisabled: r.colorTextQuaternary,
      colorTextHeading: r.colorText,
      colorTextLabel: r.colorTextSecondary,
      colorTextDescription: r.colorTextTertiary,
      colorTextLightSolid: r.colorWhite,
      colorHighlight: r.colorError,
      colorBgTextHover: r.colorFillSecondary,
      colorBgTextActive: r.colorFill,
      colorIcon: r.colorTextTertiary,
      colorIconHover: r.colorText,
      colorErrorOutline: mp(r.colorErrorBg, r.colorBgContainer),
      colorWarningOutline: mp(r.colorWarningBg, r.colorBgContainer),
      fontSizeIcon: r.fontSizeSM,
      lineWidth: r.lineWidth,
      controlOutlineWidth: r.lineWidth * 2,
      controlInteractiveSize: r.controlHeight / 2,
      controlItemBgHover: r.colorFillTertiary,
      controlItemBgActive: r.colorPrimaryBg,
      controlItemBgActiveHover: r.colorPrimaryBgHover,
      controlItemBgActiveDisabled: r.colorFill,
      controlTmpOutline: r.colorFillQuaternary,
      controlOutline: mp(r.colorPrimaryBg, r.colorBgContainer),
      lineType: r.lineType,
      borderRadius: r.borderRadius,
      borderRadiusXS: r.borderRadiusXS,
      borderRadiusSM: r.borderRadiusSM,
      borderRadiusLG: r.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: 'none',
      linkHoverDecoration: 'none',
      linkFocusDecoration: 'none',
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: r.sizeXXS,
      paddingXS: r.sizeXS,
      paddingSM: r.sizeSM,
      padding: r.size,
      paddingMD: r.sizeMD,
      paddingLG: r.sizeLG,
      paddingXL: r.sizeXL,
      paddingContentHorizontalLG: r.sizeLG,
      paddingContentVerticalLG: r.sizeMS,
      paddingContentHorizontal: r.sizeMS,
      paddingContentVertical: r.sizeSM,
      paddingContentHorizontalSM: r.size,
      paddingContentVerticalSM: r.sizeXS,
      marginXXS: r.sizeXXS,
      marginXS: r.sizeXS,
      marginSM: r.sizeSM,
      margin: r.size,
      marginMD: r.sizeMD,
      marginLG: r.sizeLG,
      marginXL: r.sizeXL,
      marginXXL: r.sizeXXL,
      boxShadow:
        '\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ',
      boxShadowSecondary:
        '\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ',
      boxShadowTertiary:
        '\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ',
      screenXS: s,
      screenXSMin: s,
      screenXSMax: o - 1,
      screenSM: o,
      screenSMMin: o,
      screenSMMax: a - 1,
      screenMD: a,
      screenMDMin: a,
      screenMDMax: l - 1,
      screenLG: l,
      screenLGMin: l,
      screenLGMax: c - 1,
      screenXL: c,
      screenXLMin: c,
      screenXLMax: u - 1,
      screenXXL: u,
      screenXXLMin: u,
      screenXXLMax: d - 1,
      screenXXXL: d,
      screenXXXLMin: d,
      boxShadowPopoverArrow: '3px 3px 7px rgba(0, 0, 0, 0.1)',
      boxShadowCard: '\n      0 1px 2px -2px '
        .concat(new yi('rgba(0, 0, 0, 0.16)').toRgbString(), ',\n      0 3px 6px 0 ')
        .concat(new yi('rgba(0, 0, 0, 0.12)').toRgbString(), ',\n      0 5px 12px 4px ')
        .concat(new yi('rgba(0, 0, 0, 0.09)').toRgbString(), '\n    '),
      boxShadowDrawerRight:
        '\n      -6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      -3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      -9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ',
      boxShadowDrawerLeft:
        '\n      6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ',
      boxShadowDrawerUp:
        '\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ',
      boxShadowDrawerDown:
        '\n      0 -6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 -3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 -9px 28px 8px rgba(0, 0, 0, 0.05)\n    ',
      boxShadowTabsOverflowLeft: 'inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)',
      boxShadowTabsOverflowRight: 'inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)',
      boxShadowTabsOverflowTop: 'inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)',
      boxShadowTabsOverflowBottom: 'inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)',
    }),
    i
  )
}
const qx = (n) => ({
    boxSizing: 'border-box',
    margin: 0,
    padding: 0,
    color: n.colorText,
    fontSize: n.fontSize,
    lineHeight: n.lineHeight,
    listStyle: 'none',
    fontFamily: n.fontFamily,
  }),
  LY = () => ({
    display: 'inline-flex',
    alignItems: 'center',
    color: 'inherit',
    fontStyle: 'normal',
    lineHeight: 0,
    textAlign: 'center',
    textTransform: 'none',
    verticalAlign: '-0.125em',
    textRendering: 'optimizeLegibility',
    '-webkit-font-smoothing': 'antialiased',
    '-moz-osx-font-smoothing': 'grayscale',
    '> *': { lineHeight: 1 },
    svg: { display: 'inline-block' },
  }),
  DY = (n) => ({
    a: {
      color: n.colorLink,
      textDecoration: n.linkDecoration,
      backgroundColor: 'transparent',
      outline: 'none',
      cursor: 'pointer',
      transition: 'color '.concat(n.motionDurationSlow),
      '-webkit-text-decoration-skip': 'objects',
      '&:hover': { color: n.colorLinkHover },
      '&:active': { color: n.colorLinkActive },
      '&:active,\n  &:hover': { textDecoration: n.linkHoverDecoration, outline: 0 },
      '&:focus': { textDecoration: n.linkFocusDecoration, outline: 0 },
      '&[disabled]': { color: n.colorTextDisabled, cursor: 'not-allowed' },
    },
  }),
  FY = (n, e) => {
    const { fontFamily: t, fontSize: i } = n,
      r = '[class^="'.concat(e, '"], [class*=" ').concat(e, '"]')
    return {
      [r]: {
        fontFamily: t,
        fontSize: i,
        boxSizing: 'border-box',
        '&::before, &::after': { boxSizing: 'border-box' },
        [r]: { boxSizing: 'border-box', '&::before, &::after': { boxSizing: 'border-box' } },
      },
    }
  }
function O0(n, e, t) {
  return (i) => {
    const r = Ge(() => (i == null ? void 0 : i.value)),
      [s, o, a] = B0(),
      { getPrefixCls: l, iconPrefixCls: c } = p6(),
      u = Ge(() => l()),
      d = Ge(() => ({ theme: s.value, token: o.value, hashId: a.value, path: ['Shared', u.value] }))
    Av(d, () => [{ '&': DY(o.value) }])
    const h = Ge(() => ({
      theme: s.value,
      token: o.value,
      hashId: a.value,
      path: [n, r.value, c.value],
    }))
    return [
      Av(h, () => {
        const { token: f, flush: p } = BY(o.value),
          g = typeof t == 'function' ? t(f) : t,
          y = ke(ke({}, g), o.value[n]),
          m = '.'.concat(r.value),
          v = af(
            f,
            {
              componentCls: m,
              prefixCls: r.value,
              iconCls: '.'.concat(c.value),
              antCls: '.'.concat(u.value),
            },
            y
          ),
          x = e(v, {
            hashId: a.value,
            prefixCls: r.value,
            rootPrefixCls: u.value,
            iconPrefixCls: c.value,
            overrideComponentToken: o.value[n],
          })
        return (p(n, y), [FY(o.value, r.value), x])
      }),
      a,
    ]
  }
}
const G6 = typeof CSSINJS_STATISTIC < 'u'
let Cv = !0
function af() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t]
  if (!G6) return ke({}, ...e)
  Cv = !1
  const i = {}
  return (
    e.forEach((r) => {
      Object.keys(r).forEach((o) => {
        Object.defineProperty(i, o, { configurable: !0, enumerable: !0, get: () => r[o] })
      })
    }),
    (Cv = !0),
    i
  )
}
function OY() {}
function BY(n) {
  let e,
    t = n,
    i = OY
  return (
    G6 &&
      ((e = new Set()),
      (t = new Proxy(n, {
        get(r, s) {
          return (Cv && e.add(s), r[s])
        },
      })),
      (i = (r, s) => {
        Array.from(e)
      })),
    { token: t, keys: e, flush: i }
  )
}
const UY = I6(IY),
  W6 = { token: F0, hashed: !0 },
  Q6 = Symbol('DesignTokenContext'),
  Ev = ar(),
  kY = (n) => {
    ;(ra(Q6, n),
      Jn(
        n,
        () => {
          ;((Ev.value = Ke(n)), JI(Ev))
        },
        { immediate: !0, deep: !0 }
      ))
  },
  zY = qt({
    props: { value: Sr() },
    setup(n, e) {
      let { slots: t } = e
      return (
        kY(Ge(() => n.value)),
        () => {
          var i
          return (i = t.default) === null || i === void 0 ? void 0 : i.call(t)
        }
      )
    },
  })
function B0() {
  const n = Zi(
      Q6,
      Ge(() => Ev.value || W6)
    ),
    e = Ge(() => ''.concat(iY, '-').concat(n.value.hashed || '')),
    t = Ge(() => n.value.theme || UY),
    i = IK(
      t,
      Ge(() => [F0, n.value.token]),
      Ge(() => ({
        salt: e.value,
        override: ke({ override: n.value.token }, n.value.components),
        formatToken: PY,
      }))
    )
  return [t, Ge(() => i.value[0]), Ge(() => (n.value.hashed ? i.value[1] : ''))]
}
const Xx = qt({
  compatConfig: { MODE: 3 },
  setup() {
    const [, n] = B0(),
      e = Ge(() => (new yi(n.value.colorBgBase).toHsl().l < 0.5 ? { opacity: 0.65 } : {}))
    return () =>
      Te(
        'svg',
        {
          style: e.value,
          width: '184',
          height: '152',
          viewBox: '0 0 184 152',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        [
          Te('g', { fill: 'none', 'fill-rule': 'evenodd' }, [
            Te('g', { transform: 'translate(24 31.67)' }, [
              Te(
                'ellipse',
                {
                  'fill-opacity': '.8',
                  fill: '#F5F5F7',
                  cx: '67.797',
                  cy: '106.89',
                  rx: '67.797',
                  ry: '12.668',
                },
                null
              ),
              Te(
                'path',
                {
                  d: 'M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z',
                  fill: '#AEB8C2',
                },
                null
              ),
              Te(
                'path',
                {
                  d: 'M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z',
                  fill: 'url(#linearGradient-1)',
                  transform: 'translate(13.56)',
                },
                null
              ),
              Te(
                'path',
                {
                  d: 'M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z',
                  fill: '#F5F5F7',
                },
                null
              ),
              Te(
                'path',
                {
                  d: 'M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z',
                  fill: '#DCE0E6',
                },
                null
              ),
            ]),
            Te(
              'path',
              {
                d: 'M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z',
                fill: '#DCE0E6',
              },
              null
            ),
            Te('g', { transform: 'translate(149.65 15.383)', fill: '#FFF' }, [
              Te('ellipse', { cx: '20.654', cy: '3.167', rx: '2.849', ry: '2.815' }, null),
              Te('path', { d: 'M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z' }, null),
            ]),
          ]),
        ]
      )
  },
})
Xx.PRESENTED_IMAGE_DEFAULT = !0
const j6 = qt({
  compatConfig: { MODE: 3 },
  setup() {
    const [, n] = B0(),
      e = Ge(() => {
        const {
          colorFill: t,
          colorFillTertiary: i,
          colorFillQuaternary: r,
          colorBgContainer: s,
        } = n.value
        return {
          borderColor: new yi(t).onBackground(s).toHexString(),
          shadowColor: new yi(i).onBackground(s).toHexString(),
          contentColor: new yi(r).onBackground(s).toHexString(),
        }
      })
    return () =>
      Te(
        'svg',
        { width: '64', height: '41', viewBox: '0 0 64 41', xmlns: 'http://www.w3.org/2000/svg' },
        [
          Te('g', { transform: 'translate(0 1)', fill: 'none', 'fill-rule': 'evenodd' }, [
            Te(
              'ellipse',
              { fill: e.value.shadowColor, cx: '32', cy: '33', rx: '32', ry: '7' },
              null
            ),
            Te('g', { 'fill-rule': 'nonzero', stroke: e.value.borderColor }, [
              Te(
                'path',
                {
                  d: 'M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z',
                },
                null
              ),
              Te(
                'path',
                {
                  d: 'M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z',
                  fill: e.value.contentColor,
                },
                null
              ),
            ]),
          ]),
        ]
      )
  },
})
j6.PRESENTED_IMAGE_SIMPLE = !0
const VY = (n) => {
    const { componentCls: e, margin: t, marginXS: i, marginXL: r, fontSize: s, lineHeight: o } = n
    return {
      [e]: {
        marginInline: i,
        fontSize: s,
        lineHeight: o,
        textAlign: 'center',
        [''.concat(e, '-image')]: {
          height: n.emptyImgHeight,
          marginBottom: i,
          opacity: n.opacityImage,
          img: { height: '100%' },
          svg: { height: '100%', margin: 'auto' },
        },
        [''.concat(e, '-footer')]: { marginTop: t },
        '&-normal': {
          marginBlock: r,
          color: n.colorTextDisabled,
          [''.concat(e, '-image')]: { height: n.emptyImgHeightMD },
        },
        '&-small': {
          marginBlock: i,
          color: n.colorTextDisabled,
          [''.concat(e, '-image')]: { height: n.emptyImgHeightSM },
        },
      },
    }
  },
  HY = O0('Empty', (n) => {
    const { componentCls: e, controlHeightLG: t } = n,
      i = af(n, {
        emptyImgCls: ''.concat(e, '-img'),
        emptyImgHeight: t * 2.5,
        emptyImgHeightMD: t,
        emptyImgHeightSM: t * 0.875,
      })
    return [VY(i)]
  })
var $Y = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const GY = () => ({ prefixCls: String, imageStyle: Sr(), image: yv(), description: yv() }),
  Kx = qt({
    name: 'AEmpty',
    compatConfig: { MODE: 3 },
    inheritAttrs: !1,
    props: GY(),
    setup(n, e) {
      let { slots: t = {}, attrs: i } = e
      const { direction: r, prefixCls: s } = lf('empty', n),
        [o, a] = HY(s)
      return () => {
        var l, c
        const u = s.value,
          d = ke(ke({}, n), i),
          {
            image: h = ((l = t.image) === null || l === void 0 ? void 0 : l.call(t)) || Ba(Xx),
            description: f = ((c = t.description) === null || c === void 0 ? void 0 : c.call(t)) ||
              void 0,
            imageStyle: p,
            class: g = '',
          } = d,
          y = $Y(d, ['image', 'description', 'imageStyle', 'class']),
          m = typeof h == 'function' ? h() : h,
          v = typeof m == 'object' && 'type' in m && m.type.PRESENTED_IMAGE_SIMPLE
        return o(
          Te(
            v6,
            {
              componentName: 'Empty',
              children: (x) => {
                const _ = typeof f < 'u' ? f : x.description,
                  S = typeof _ == 'string' ? _ : 'empty'
                let C = null
                return (
                  typeof m == 'string' ? (C = Te('img', { alt: S, src: m }, null)) : (C = m),
                  Te(
                    'div',
                    Zn(
                      {
                        class: Br(u, g, a.value, {
                          [''.concat(u, '-normal')]: v,
                          [''.concat(u, '-rtl')]: r.value === 'rtl',
                        }),
                      },
                      y
                    ),
                    [
                      Te('div', { class: ''.concat(u, '-image'), style: p }, [C]),
                      _ && Te('p', { class: ''.concat(u, '-description') }, [_]),
                      t.default && Te('div', { class: ''.concat(u, '-footer') }, [Vx(t.default())]),
                    ]
                  )
                )
              },
            },
            null
          )
        )
      }
    },
  })
Kx.PRESENTED_IMAGE_DEFAULT = () => Ba(Xx)
Kx.PRESENTED_IMAGE_SIMPLE = () => Ba(j6)
const Sd = Hx(Kx),
  q6 = (n) => {
    const { prefixCls: e } = lf('empty', n)
    return ((i) => {
      switch (i) {
        case 'Table':
        case 'List':
          return Te(Sd, { image: Sd.PRESENTED_IMAGE_SIMPLE }, null)
        case 'Select':
        case 'TreeSelect':
        case 'Cascader':
        case 'Transfer':
        case 'Mentions':
          return Te(
            Sd,
            { image: Sd.PRESENTED_IMAGE_SIMPLE, class: ''.concat(e.value, '-small') },
            null
          )
        default:
          return Te(Sd, null, null)
      }
    })(n.componentName)
  }
function WY(n) {
  return Te(q6, { componentName: n }, null)
}
const X6 = Symbol('SizeContextKey'),
  K6 = () => Zi(X6, Dn(void 0)),
  QY = (n) => {
    const e = K6()
    return (
      ra(
        X6,
        Ge(() => n.value || e.value)
      ),
      n
    )
  },
  lf = (n, e) => {
    const t = K6(),
      i = g6(),
      r = Zi(Gx, ke(ke({}, f6), { renderEmpty: (A) => Ba(q6, { componentName: A }) })),
      s = Ge(() => r.getPrefixCls(n, e.prefixCls)),
      o = Ge(() => {
        var A, R
        return (A = e.direction) !== null && A !== void 0
          ? A
          : (R = r.direction) === null || R === void 0
            ? void 0
            : R.value
      }),
      a = Ge(() => {
        var A
        return (A = e.iconPrefixCls) !== null && A !== void 0 ? A : r.iconPrefixCls.value
      }),
      l = Ge(() => r.getPrefixCls()),
      c = Ge(() => {
        var A
        return (A = r.autoInsertSpaceInButton) === null || A === void 0 ? void 0 : A.value
      }),
      u = r.renderEmpty,
      d = r.space,
      h = r.pageHeader,
      f = r.form,
      p = Ge(() => {
        var A, R
        return (A = e.getTargetContainer) !== null && A !== void 0
          ? A
          : (R = r.getTargetContainer) === null || R === void 0
            ? void 0
            : R.value
      }),
      g = Ge(() => {
        var A, R, w
        return (R = (A = e.getContainer) !== null && A !== void 0 ? A : e.getPopupContainer) !==
          null && R !== void 0
          ? R
          : (w = r.getPopupContainer) === null || w === void 0
            ? void 0
            : w.value
      }),
      y = Ge(() => {
        var A, R
        return (A = e.dropdownMatchSelectWidth) !== null && A !== void 0
          ? A
          : (R = r.dropdownMatchSelectWidth) === null || R === void 0
            ? void 0
            : R.value
      }),
      m = Ge(() => {
        var A
        return (
          (e.virtual === void 0
            ? ((A = r.virtual) === null || A === void 0 ? void 0 : A.value) !== !1
            : e.virtual !== !1) && y.value !== !1
        )
      }),
      v = Ge(() => e.size || t.value),
      x = Ge(() => {
        var A, R, w
        return (A = e.autocomplete) !== null && A !== void 0
          ? A
          : (w = (R = r.input) === null || R === void 0 ? void 0 : R.value) === null || w === void 0
            ? void 0
            : w.autocomplete
      }),
      _ = Ge(() => {
        var A
        return (A = e.disabled) !== null && A !== void 0 ? A : i.value
      }),
      S = Ge(() => {
        var A
        return (A = e.csp) !== null && A !== void 0 ? A : r.csp
      }),
      C = Ge(() => {
        var A, R
        return (A = e.wave) !== null && A !== void 0
          ? A
          : (R = r.wave) === null || R === void 0
            ? void 0
            : R.value
      })
    return {
      configProvider: r,
      prefixCls: s,
      direction: o,
      size: v,
      getTargetContainer: p,
      getPopupContainer: g,
      space: d,
      pageHeader: h,
      form: f,
      autoInsertSpaceInButton: c,
      renderEmpty: u,
      virtual: m,
      dropdownMatchSelectWidth: y,
      rootPrefixCls: l,
      getPrefixCls: r.getPrefixCls,
      autocomplete: x,
      csp: S,
      iconPrefixCls: a,
      disabled: _,
      select: r.select,
      wave: C,
    }
  }
function jY(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t]
    ;((i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      'value' in i && (i.writable = !0),
      Object.defineProperty(n, i.key, i))
  }
}
function Y6(n, e, t) {
  return (t && jY(n, t), n)
}
function Wp() {
  return (Wp =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e]
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
      }
      return n
    }).apply(this, arguments)
}
function Z6(n, e) {
  ;((n.prototype = Object.create(e.prototype)), (n.prototype.constructor = n), (n.__proto__ = e))
}
function J6(n, e) {
  if (n == null) return {}
  var t,
    i,
    r = {},
    s = Object.keys(n)
  for (i = 0; i < s.length; i++) e.indexOf((t = s[i])) >= 0 || (r[t] = n[t])
  return r
}
function M3(n) {
  return (
    ((e = n) != null && typeof e == 'object' && Array.isArray(e) === !1) == 1 &&
    Object.prototype.toString.call(n) === '[object Object]'
  )
  var e
}
var eR = Object.prototype,
  tR = eR.toString,
  qY = eR.hasOwnProperty,
  nR = /^\s*function (\w+)/
function R3(n) {
  var e,
    t = (e = n == null ? void 0 : n.type) !== null && e !== void 0 ? e : n
  if (t) {
    var i = t.toString().match(nR)
    return i ? i[1] : ''
  }
  return ''
}
var Wl = function (n) {
    var e, t
    return (
      M3(n) !== !1 &&
      typeof (e = n.constructor) == 'function' &&
      M3((t = e.prototype)) !== !1 &&
      t.hasOwnProperty('isPrototypeOf') !== !1
    )
  },
  XY = function (n) {
    return n
  },
  Lr = XY,
  Th = function (n, e) {
    return qY.call(n, e)
  },
  KY =
    Number.isInteger ||
    function (n) {
      return typeof n == 'number' && isFinite(n) && Math.floor(n) === n
    },
  Cu =
    Array.isArray ||
    function (n) {
      return tR.call(n) === '[object Array]'
    },
  Eu = function (n) {
    return tR.call(n) === '[object Function]'
  },
  km = function (n) {
    return Wl(n) && Th(n, '_vueTypes_name')
  },
  iR = function (n) {
    return (
      Wl(n) &&
      (Th(n, 'type') ||
        ['_vueTypes_name', 'validator', 'default', 'required'].some(function (e) {
          return Th(n, e)
        }))
    )
  }
function Yx(n, e) {
  return Object.defineProperty(n.bind(e), '__original', { value: n })
}
function Kl(n, e, t) {
  var i,
    r = !0,
    s = ''
  i = Wl(n) ? n : { type: n }
  var o = km(i) ? i._vueTypes_name + ' - ' : ''
  if (iR(i) && i.type !== null) {
    if (i.type === void 0 || i.type === !0 || (!i.required && e === void 0)) return r
    Cu(i.type)
      ? ((r = i.type.some(function (d) {
          return Kl(d, e) === !0
        })),
        (s = i.type
          .map(function (d) {
            return R3(d)
          })
          .join(' or ')))
      : (r =
          (s = R3(i)) === 'Array'
            ? Cu(e)
            : s === 'Object'
              ? Wl(e)
              : s === 'String' || s === 'Number' || s === 'Boolean' || s === 'Function'
                ? (function (d) {
                    if (d == null) return ''
                    var h = d.constructor.toString().match(nR)
                    return h ? h[1] : ''
                  })(e) === s
                : e instanceof i.type)
  }
  if (!r) {
    var a = o + 'value "' + e + '" should be of type "' + s + '"'
    return a
  }
  if (Th(i, 'validator') && Eu(i.validator)) {
    var l = Lr,
      c = []
    if (
      ((Lr = function (d) {
        c.push(d)
      }),
      (r = i.validator(e)),
      (Lr = l),
      !r)
    ) {
      var u = (c.length > 1 ? '* ' : '') + c.join('\n* ')
      return ((c.length = 0), u)
    }
  }
  return r
}
function Fr(n, e) {
  var t = Object.defineProperties(e, {
      _vueTypes_name: { value: n, writable: !0 },
      isRequired: {
        get: function () {
          return ((this.required = !0), this)
        },
      },
      def: {
        value: function (r) {
          return r !== void 0 || this.default
            ? Eu(r) || Kl(this, r) === !0
              ? ((this.default = Cu(r)
                  ? function () {
                      return [].concat(r)
                    }
                  : Wl(r)
                    ? function () {
                        return Object.assign({}, r)
                      }
                    : r),
                this)
              : (Lr(this._vueTypes_name + ' - invalid default value: "' + r + '"'), this)
            : this
        },
      },
    }),
    i = t.validator
  return (Eu(i) && (t.validator = Yx(i, t)), t)
}
function ro(n, e) {
  var t = Fr(n, e)
  return Object.defineProperty(t, 'validate', {
    value: function (i) {
      return (
        Eu(this.validator) &&
          Lr(
            this._vueTypes_name +
              ' - calling .validate() will overwrite the current custom validator function. Validator info:\n' +
              JSON.stringify(this)
          ),
        (this.validator = Yx(i, this)),
        this
      )
    },
  })
}
function I3(n, e, t) {
  var i,
    r,
    s =
      ((i = e),
      (r = {}),
      Object.getOwnPropertyNames(i).forEach(function (d) {
        r[d] = Object.getOwnPropertyDescriptor(i, d)
      }),
      Object.defineProperties({}, r))
  if (((s._vueTypes_name = n), !Wl(t))) return s
  var o,
    a,
    l = t.validator,
    c = J6(t, ['validator'])
  if (Eu(l)) {
    var u = s.validator
    ;(u && (u = (a = (o = u).__original) !== null && a !== void 0 ? a : o),
      (s.validator = Yx(
        u
          ? function (d) {
              return u.call(this, d) && l.call(this, d)
            }
          : l,
        s
      )))
  }
  return Object.assign(s, c)
}
function U0(n) {
  return n.replace(/^(?!\s*$)/gm, '  ')
}
var YY = function () {
    return ro('any', {})
  },
  ZY = function () {
    return ro('function', { type: Function })
  },
  JY = function () {
    return ro('boolean', { type: Boolean })
  },
  eZ = function () {
    return ro('string', { type: String })
  },
  tZ = function () {
    return ro('number', { type: Number })
  },
  nZ = function () {
    return ro('array', { type: Array })
  },
  iZ = function () {
    return ro('object', { type: Object })
  },
  rZ = function () {
    return Fr('integer', {
      type: Number,
      validator: function (n) {
        return KY(n)
      },
    })
  },
  sZ = function () {
    return Fr('symbol', {
      validator: function (n) {
        return typeof n == 'symbol'
      },
    })
  }
function oZ(n, e) {
  if ((e === void 0 && (e = 'custom validation failed'), typeof n != 'function'))
    throw new TypeError('[VueTypes error]: You must provide a function as argument')
  return Fr(n.name || '<<anonymous function>>', {
    validator: function (t) {
      var i = n(t)
      return (i || Lr(this._vueTypes_name + ' - ' + e), i)
    },
  })
}
function aZ(n) {
  if (!Cu(n)) throw new TypeError('[VueTypes error]: You must provide an array as argument.')
  var e = 'oneOf - value should be one of "' + n.join('", "') + '".',
    t = n.reduce(function (i, r) {
      if (r != null) {
        var s = r.constructor
        i.indexOf(s) === -1 && i.push(s)
      }
      return i
    }, [])
  return Fr('oneOf', {
    type: t.length > 0 ? t : void 0,
    validator: function (i) {
      var r = n.indexOf(i) !== -1
      return (r || Lr(e), r)
    },
  })
}
function lZ(n) {
  if (!Cu(n)) throw new TypeError('[VueTypes error]: You must provide an array as argument')
  for (var e = !1, t = [], i = 0; i < n.length; i += 1) {
    var r = n[i]
    if (iR(r)) {
      if (km(r) && r._vueTypes_name === 'oneOf') {
        t = t.concat(r.type)
        continue
      }
      if ((Eu(r.validator) && (e = !0), r.type !== !0 && r.type)) {
        t = t.concat(r.type)
        continue
      }
    }
    t.push(r)
  }
  return (
    (t = t.filter(function (s, o) {
      return t.indexOf(s) === o
    })),
    Fr(
      'oneOfType',
      e
        ? {
            type: t,
            validator: function (s) {
              var o = [],
                a = n.some(function (l) {
                  var c = Kl(km(l) && l._vueTypes_name === 'oneOf' ? l.type || null : l, s)
                  return (typeof c == 'string' && o.push(c), c === !0)
                })
              return (
                a ||
                  Lr(
                    'oneOfType - provided value does not match any of the ' +
                      o.length +
                      ' passed-in validators:\n' +
                      U0(o.join('\n'))
                  ),
                a
              )
            },
          }
        : { type: t }
    )
  )
}
function cZ(n) {
  return Fr('arrayOf', {
    type: Array,
    validator: function (e) {
      var t,
        i = e.every(function (r) {
          return (t = Kl(n, r)) === !0
        })
      return (i || Lr('arrayOf - value validation error:\n' + U0(t)), i)
    },
  })
}
function uZ(n) {
  return Fr('instanceOf', { type: n })
}
function dZ(n) {
  return Fr('objectOf', {
    type: Object,
    validator: function (e) {
      var t,
        i = Object.keys(e).every(function (r) {
          return (t = Kl(n, e[r])) === !0
        })
      return (i || Lr('objectOf - value validation error:\n' + U0(t)), i)
    },
  })
}
function hZ(n) {
  var e = Object.keys(n),
    t = e.filter(function (r) {
      var s
      return !!(!((s = n[r]) === null || s === void 0) && s.required)
    }),
    i = Fr('shape', {
      type: Object,
      validator: function (r) {
        var s = this
        if (!Wl(r)) return !1
        var o = Object.keys(r)
        if (
          t.length > 0 &&
          t.some(function (l) {
            return o.indexOf(l) === -1
          })
        ) {
          var a = t.filter(function (l) {
            return o.indexOf(l) === -1
          })
          return (
            Lr(
              a.length === 1
                ? 'shape - required property "' + a[0] + '" is not defined.'
                : 'shape - required properties "' + a.join('", "') + '" are not defined.'
            ),
            !1
          )
        }
        return o.every(function (l) {
          if (e.indexOf(l) === -1)
            return (
              s._vueTypes_isLoose === !0 ||
              (Lr(
                'shape - shape definition does not include a "' +
                  l +
                  '" property. Allowed keys: "' +
                  e.join('", "') +
                  '".'
              ),
              !1)
            )
          var c = Kl(n[l], r[l])
          return (
            typeof c == 'string' && Lr('shape - "' + l + '" property validation error:\n ' + U0(c)),
            c === !0
          )
        })
      },
    })
  return (
    Object.defineProperty(i, '_vueTypes_isLoose', { writable: !0, value: !1 }),
    Object.defineProperty(i, 'loose', {
      get: function () {
        return ((this._vueTypes_isLoose = !0), this)
      },
    }),
    i
  )
}
var Os = (function () {
  function n() {}
  return (
    (n.extend = function (e) {
      var t = this
      if (Cu(e))
        return (
          e.forEach(function (d) {
            return t.extend(d)
          }),
          this
        )
      var i = e.name,
        r = e.validate,
        s = r !== void 0 && r,
        o = e.getter,
        a = o !== void 0 && o,
        l = J6(e, ['name', 'validate', 'getter'])
      if (Th(this, i)) throw new TypeError('[VueTypes error]: Type "' + i + '" already defined')
      var c,
        u = l.type
      return km(u)
        ? (delete l.type,
          Object.defineProperty(
            this,
            i,
            a
              ? {
                  get: function () {
                    return I3(i, u, l)
                  },
                }
              : {
                  value: function () {
                    var d,
                      h = I3(i, u, l)
                    return (
                      h.validator &&
                        (h.validator = (d = h.validator).bind.apply(
                          d,
                          [h].concat([].slice.call(arguments))
                        )),
                      h
                    )
                  },
                }
          ))
        : ((c = a
            ? {
                get: function () {
                  var d = Object.assign({}, l)
                  return s ? ro(i, d) : Fr(i, d)
                },
                enumerable: !0,
              }
            : {
                value: function () {
                  var d,
                    h,
                    f = Object.assign({}, l)
                  return (
                    (d = s ? ro(i, f) : Fr(i, f)),
                    f.validator &&
                      (d.validator = (h = f.validator).bind.apply(
                        h,
                        [d].concat([].slice.call(arguments))
                      )),
                    d
                  )
                },
                enumerable: !0,
              }),
          Object.defineProperty(this, i, c))
    }),
    Y6(n, null, [
      {
        key: 'any',
        get: function () {
          return YY()
        },
      },
      {
        key: 'func',
        get: function () {
          return ZY().def(this.defaults.func)
        },
      },
      {
        key: 'bool',
        get: function () {
          return JY().def(this.defaults.bool)
        },
      },
      {
        key: 'string',
        get: function () {
          return eZ().def(this.defaults.string)
        },
      },
      {
        key: 'number',
        get: function () {
          return tZ().def(this.defaults.number)
        },
      },
      {
        key: 'array',
        get: function () {
          return nZ().def(this.defaults.array)
        },
      },
      {
        key: 'object',
        get: function () {
          return iZ().def(this.defaults.object)
        },
      },
      {
        key: 'integer',
        get: function () {
          return rZ().def(this.defaults.integer)
        },
      },
      {
        key: 'symbol',
        get: function () {
          return sZ()
        },
      },
    ]),
    n
  )
})()
function rR(n) {
  var e
  return (
    n === void 0 &&
      (n = {
        func: function () {},
        bool: !0,
        string: '',
        number: 0,
        array: function () {
          return []
        },
        object: function () {
          return {}
        },
        integer: 0,
      }),
    ((e = (function (t) {
      function i() {
        return t.apply(this, arguments) || this
      }
      return (
        Z6(i, t),
        Y6(i, null, [
          {
            key: 'sensibleDefaults',
            get: function () {
              return Wp({}, this.defaults)
            },
            set: function (r) {
              this.defaults = r !== !1 ? Wp({}, r !== !0 ? r : n) : {}
            },
          },
        ]),
        i
      )
    })(Os)).defaults = Wp({}, n)),
    e
  )
}
;((Os.defaults = {}),
  (Os.custom = oZ),
  (Os.oneOf = aZ),
  (Os.instanceOf = uZ),
  (Os.oneOfType = lZ),
  (Os.arrayOf = cZ),
  (Os.objectOf = dZ),
  (Os.shape = hZ),
  (Os.utils = {
    validate: function (n, e) {
      return Kl(e, n) === !0
    },
    toType: function (n, e, t) {
      return (t === void 0 && (t = !1), t ? ro(n, e) : Fr(n, e))
    },
  }))
;(function (n) {
  function e() {
    return n.apply(this, arguments) || this
  }
  return (Z6(e, n), e)
})(rR())
const zm = rR({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0,
})
zm.extend([
  { name: 'looseBool', getter: !0, type: Boolean, default: void 0 },
  { name: 'style', getter: !0, type: [String, Object], default: void 0 },
  { name: 'VueNode', getter: !0, type: null },
])
function fZ(n) {
  let { prefixCls: e, animation: t, transitionName: i } = n
  return t ? { name: ''.concat(e, '-').concat(t) } : i ? { name: i } : {}
}
nK('bottomLeft', 'bottomRight', 'topLeft', 'topRight')
const sR = function (n) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    return ke(
      n
        ? {
            name: n,
            appear: !0,
            appearActiveClass: ''.concat(n),
            appearToClass: ''.concat(n, '-appear ').concat(n, '-appear-active'),
            enterFromClass: ''
              .concat(n, '-appear ')
              .concat(n, '-enter ')
              .concat(n, '-appear-prepare ')
              .concat(n, '-enter-prepare'),
            enterActiveClass: ''.concat(n),
            enterToClass: ''
              .concat(n, '-enter ')
              .concat(n, '-appear ')
              .concat(n, '-appear-active ')
              .concat(n, '-enter-active'),
            leaveActiveClass: ''.concat(n, ' ').concat(n, '-leave'),
            leaveToClass: ''.concat(n, '-leave-active'),
          }
        : { css: !1 },
      e
    )
  },
  oR = Symbol('PortalContextKey'),
  pZ = function (n) {
    let e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { inTriggerContext: !0 }
    ra(oR, {
      inTriggerContext: e.inTriggerContext,
      shouldRender: Ge(() => {
        const { sPopupVisible: t, popupRef: i, forceRender: r, autoDestroy: s } = n || {}
        let o = !1
        return ((t || i || r) && (o = !0), !t && s && (o = !1), o)
      }),
    })
  },
  mZ = () => {
    pZ({}, { inTriggerContext: !1 })
    const n = Zi(oR, { shouldRender: Ge(() => !1), inTriggerContext: !1 })
    return { shouldRender: Ge(() => n.shouldRender.value || n.inTriggerContext === !1) }
  },
  gZ = qt({
    compatConfig: { MODE: 3 },
    name: 'Portal',
    inheritAttrs: !1,
    props: { getContainer: zm.func.isRequired, didUpdate: Function },
    setup(n, e) {
      let { slots: t } = e,
        i = !0,
        r
      const { shouldRender: s } = mZ()
      function o() {
        s.value && (r = n.getContainer())
      }
      ;(ww(() => {
        ;((i = !1), o())
      }),
        Va(() => {
          r || o()
        }))
      const a = Jn(s, () => {
        ;(s.value && !r && (r = n.getContainer()), r && a())
      })
      return (
        r_(() => {
          Dh(() => {
            var l
            s.value && ((l = n.didUpdate) === null || l === void 0 || l.call(n, n))
          })
        }),
        () => {
          var l
          return s.value
            ? i
              ? (l = t.default) === null || l === void 0
                ? void 0
                : l.call(t)
              : r
                ? Te(_w, { to: r }, t)
                : null
            : null
        }
      )
    },
  })
var yZ = Symbol('iconContext'),
  aR = function () {
    return Zi(yZ, { prefixCls: Dn('anticon'), rootClassName: Dn(''), csp: Dn() })
  }
function Zx() {
  return !!(typeof window < 'u' && window.document && window.document.createElement)
}
function vZ(n, e) {
  return n && n.contains ? n.contains(e) : !1
}
var N3 = 'data-vc-order',
  _Z = 'vc-icon-key',
  Mv = new Map()
function lR() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = n.mark
  return e ? (e.startsWith('data-') ? e : 'data-'.concat(e)) : _Z
}
function Jx(n) {
  if (n.attachTo) return n.attachTo
  var e = document.querySelector('head')
  return e || document.body
}
function xZ(n) {
  return n === 'queue' ? 'prependQueue' : n ? 'prepend' : 'append'
}
function cR(n) {
  return Array.from((Mv.get(n) || n).children).filter(function (e) {
    return e.tagName === 'STYLE'
  })
}
function uR(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  if (!Zx()) return null
  var t = e.csp,
    i = e.prepend,
    r = document.createElement('style')
  ;(r.setAttribute(N3, xZ(i)), t && t.nonce && (r.nonce = t.nonce), (r.innerHTML = n))
  var s = Jx(e),
    o = s.firstChild
  if (i) {
    if (i === 'queue') {
      var a = cR(s).filter(function (l) {
        return ['prepend', 'prependQueue'].includes(l.getAttribute(N3))
      })
      if (a.length) return (s.insertBefore(r, a[a.length - 1].nextSibling), r)
    }
    s.insertBefore(r, o)
  } else s.appendChild(r)
  return r
}
function SZ(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = Jx(e)
  return cR(t).find(function (i) {
    return i.getAttribute(lR(e)) === n
  })
}
function AZ(n, e) {
  var t = Mv.get(n)
  if (!t || !vZ(document, t)) {
    var i = uR('', e),
      r = i.parentNode
    ;(Mv.set(n, r), n.removeChild(i))
  }
}
function bZ(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    i = Jx(t)
  AZ(i, t)
  var r = SZ(e, t)
  if (r)
    return (
      t.csp && t.csp.nonce && r.nonce !== t.csp.nonce && (r.nonce = t.csp.nonce),
      r.innerHTML !== n && (r.innerHTML = n),
      r
    )
  var s = uR(n, t)
  return (s.setAttribute(lR(t), e), s)
}
function P3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        TZ(n, r, t[r])
      }))
  }
  return n
}
function TZ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
function L3(n) {
  return (
    typeof n == 'object' &&
    typeof n.name == 'string' &&
    typeof n.theme == 'string' &&
    (typeof n.icon == 'object' || typeof n.icon == 'function')
  )
}
function Rv(n, e, t) {
  return t
    ? Ba(
        n.tag,
        P3({ key: e }, t, n.attrs),
        (n.children || []).map(function (i, r) {
          return Rv(i, ''.concat(e, '-').concat(n.tag, '-').concat(r))
        })
      )
    : Ba(
        n.tag,
        P3({ key: e }, n.attrs),
        (n.children || []).map(function (i, r) {
          return Rv(i, ''.concat(e, '-').concat(n.tag, '-').concat(r))
        })
      )
}
function dR(n) {
  return Gl(n)[0]
}
function hR(n) {
  return n ? (Array.isArray(n) ? n : [n]) : []
}
var wZ =
  '\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n'
function fR(n) {
  return n && n.getRootNode && n.getRootNode()
}
function CZ(n) {
  return Zx() ? fR(n) instanceof ShadowRoot : !1
}
function EZ(n) {
  return CZ(n) ? fR(n) : null
}
var MZ = function () {
    var e = aR(),
      t = e.prefixCls,
      i = e.csp,
      r = bs(),
      s = wZ
    ;(t && (s = s.replace(/anticon/g, t.value)),
      Dh(function () {
        if (Zx()) {
          var o = r.vnode.el,
            a = EZ(o)
          bZ(s, '@ant-design-vue-icons', { prepend: !0, csp: i.value, attachTo: a })
        }
      }))
  },
  RZ = ['icon', 'primaryColor', 'secondaryColor']
function IZ(n, e) {
  if (n == null) return {}
  var t = NZ(n, e),
    i,
    r
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (r = 0; r < s.length; r++)
      ((i = s[r]),
        !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i]))
  }
  return t
}
function NZ(n, e) {
  if (n == null) return {}
  var t = {},
    i = Object.keys(n),
    r,
    s
  for (s = 0; s < i.length; s++) ((r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]))
  return t
}
function Qp(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        PZ(n, r, t[r])
      }))
  }
  return n
}
function PZ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var jd = Zs({ primaryColor: '#333', secondaryColor: '#E6E6E6', calculated: !1 })
function LZ(n) {
  var e = n.primaryColor,
    t = n.secondaryColor
  ;((jd.primaryColor = e), (jd.secondaryColor = t || dR(e)), (jd.calculated = !!t))
}
function DZ() {
  return Qp({}, jd)
}
var Wa = function (e, t) {
  var i = Qp({}, e, t.attrs),
    r = i.icon,
    s = i.primaryColor,
    o = i.secondaryColor,
    a = IZ(i, RZ),
    l = jd
  if ((s && (l = { primaryColor: s, secondaryColor: o || dR(s) }), L3(r), !L3(r))) return null
  var c = r
  return (
    c &&
      typeof c.icon == 'function' &&
      (c = Qp({}, c, { icon: c.icon(l.primaryColor, l.secondaryColor) })),
    Rv(
      c.icon,
      'svg-'.concat(c.name),
      Qp({}, a, {
        'data-icon': c.name,
        width: '1em',
        height: '1em',
        fill: 'currentColor',
        'aria-hidden': 'true',
      })
    )
  )
}
Wa.props = { icon: Object, primaryColor: String, secondaryColor: String, focusable: String }
Wa.inheritAttrs = !1
Wa.displayName = 'IconBase'
Wa.getTwoToneColors = DZ
Wa.setTwoToneColors = LZ
function FZ(n, e) {
  return kZ(n) || UZ(n, e) || BZ(n, e) || OZ()
}
function OZ() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function BZ(n, e) {
  if (n) {
    if (typeof n == 'string') return D3(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if ((t === 'Object' && n.constructor && (t = n.constructor.name), t === 'Map' || t === 'Set'))
      return Array.from(n)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return D3(n, e)
  }
}
function D3(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function UZ(n, e) {
  var t = n == null ? null : (typeof Symbol < 'u' && n[Symbol.iterator]) || n['@@iterator']
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (l) {
      ;((s = !0), (a = l))
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function kZ(n) {
  if (Array.isArray(n)) return n
}
function pR(n) {
  var e = hR(n),
    t = FZ(e, 2),
    i = t[0],
    r = t[1]
  return Wa.setTwoToneColors({ primaryColor: i, secondaryColor: r })
}
function zZ() {
  var n = Wa.getTwoToneColors()
  return n.calculated ? [n.primaryColor, n.secondaryColor] : n.primaryColor
}
var VZ = qt({
    name: 'InsertStyles',
    setup: function () {
      return (
        MZ(),
        function () {
          return null
        }
      )
    },
  }),
  HZ = ['class', 'icon', 'spin', 'rotate', 'tabindex', 'twoToneColor', 'onClick']
function $Z(n, e) {
  return jZ(n) || QZ(n, e) || WZ(n, e) || GZ()
}
function GZ() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function WZ(n, e) {
  if (n) {
    if (typeof n == 'string') return F3(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if ((t === 'Object' && n.constructor && (t = n.constructor.name), t === 'Map' || t === 'Set'))
      return Array.from(n)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return F3(n, e)
  }
}
function F3(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function QZ(n, e) {
  var t = n == null ? null : (typeof Symbol < 'u' && n[Symbol.iterator]) || n['@@iterator']
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (l) {
      ;((s = !0), (a = l))
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function jZ(n) {
  if (Array.isArray(n)) return n
}
function O3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        Cd(n, r, t[r])
      }))
  }
  return n
}
function Cd(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
function qZ(n, e) {
  if (n == null) return {}
  var t = XZ(n, e),
    i,
    r
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (r = 0; r < s.length; r++)
      ((i = s[r]),
        !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i]))
  }
  return t
}
function XZ(n, e) {
  if (n == null) return {}
  var t = {},
    i = Object.keys(n),
    r,
    s
  for (s = 0; s < i.length; s++) ((r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]))
  return t
}
pR(xY.primary)
var zi = function (e, t) {
  var i,
    r = O3({}, e, t.attrs),
    s = r.class,
    o = r.icon,
    a = r.spin,
    l = r.rotate,
    c = r.tabindex,
    u = r.twoToneColor,
    d = r.onClick,
    h = qZ(r, HZ),
    f = aR(),
    p = f.prefixCls,
    g = f.rootClassName,
    y =
      ((i = {}),
      Cd(i, g.value, !!g.value),
      Cd(i, p.value, !0),
      Cd(i, ''.concat(p.value, '-').concat(o.name), !!o.name),
      Cd(i, ''.concat(p.value, '-spin'), !!a || o.name === 'loading'),
      i),
    m = c
  m === void 0 && d && (m = -1)
  var v = l
      ? { msTransform: 'rotate('.concat(l, 'deg)'), transform: 'rotate('.concat(l, 'deg)') }
      : void 0,
    x = hR(u),
    _ = $Z(x, 2),
    S = _[0],
    C = _[1]
  return Te(
    'span',
    O3({ role: 'img', 'aria-label': o.name }, h, { onClick: d, class: [y, s], tabindex: m }),
    [Te(Wa, { icon: o, primaryColor: S, secondaryColor: C, style: v }, null), Te(VZ, null, null)]
  )
}
zi.props = { spin: Boolean, rotate: Number, icon: Object, twoToneColor: [String, Array] }
zi.displayName = 'AntdIcon'
zi.inheritAttrs = !1
zi.getTwoToneColor = zZ
zi.setTwoToneColor = pR
var KZ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '0 0 1024 1024', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z',
        },
      },
    ],
  },
  name: 'loading',
  theme: 'outlined',
}
function B3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        YZ(n, r, t[r])
      }))
  }
  return n
}
function YZ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var cf = function (e, t) {
  var i = B3({}, e, t.attrs)
  return Te(zi, B3({}, i, { icon: KZ }), null)
}
cf.displayName = 'LoadingOutlined'
cf.inheritAttrs = !1
var ZZ = {
  icon: {
    tag: 'svg',
    attrs: { 'fill-rule': 'evenodd', viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z',
        },
      },
    ],
  },
  name: 'close',
  theme: 'outlined',
}
function U3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        JZ(n, r, t[r])
      }))
  }
  return n
}
function JZ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var uf = function (e, t) {
  var i = U3({}, e, t.attrs)
  return Te(zi, U3({}, i, { icon: ZZ }), null)
}
uf.displayName = 'CloseOutlined'
uf.inheritAttrs = !1
var eJ = {
  icon: {
    tag: 'svg',
    attrs: { 'fill-rule': 'evenodd', viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z',
        },
      },
    ],
  },
  name: 'close-circle',
  theme: 'filled',
}
function k3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        tJ(n, r, t[r])
      }))
  }
  return n
}
function tJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var Qu = function (e, t) {
  var i = k3({}, e, t.attrs)
  return Te(zi, k3({}, i, { icon: eJ }), null)
}
Qu.displayName = 'CloseCircleFilled'
Qu.inheritAttrs = !1
var nJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z',
        },
      },
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z',
        },
      },
    ],
  },
  name: 'check-circle',
  theme: 'outlined',
}
function z3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        iJ(n, r, t[r])
      }))
  }
  return n
}
function iJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var e2 = function (e, t) {
  var i = z3({}, e, t.attrs)
  return Te(zi, z3({}, i, { icon: nJ }), null)
}
e2.displayName = 'CheckCircleOutlined'
e2.inheritAttrs = !1
var rJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z',
        },
      },
      {
        tag: 'path',
        attrs: {
          d: 'M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z',
        },
      },
    ],
  },
  name: 'exclamation-circle',
  theme: 'outlined',
}
function V3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        sJ(n, r, t[r])
      }))
  }
  return n
}
function sJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var t2 = function (e, t) {
  var i = V3({}, e, t.attrs)
  return Te(zi, V3({}, i, { icon: rJ }), null)
}
t2.displayName = 'ExclamationCircleOutlined'
t2.inheritAttrs = !1
var oJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z',
        },
      },
      {
        tag: 'path',
        attrs: {
          d: 'M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z',
        },
      },
    ],
  },
  name: 'info-circle',
  theme: 'outlined',
}
function H3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        aJ(n, r, t[r])
      }))
  }
  return n
}
function aJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var n2 = function (e, t) {
  var i = H3({}, e, t.attrs)
  return Te(zi, H3({}, i, { icon: oJ }), null)
}
n2.displayName = 'InfoCircleOutlined'
n2.inheritAttrs = !1
var lJ = {
  icon: {
    tag: 'svg',
    attrs: { 'fill-rule': 'evenodd', viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z',
        },
      },
    ],
  },
  name: 'close-circle',
  theme: 'outlined',
}
function $3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        cJ(n, r, t[r])
      }))
  }
  return n
}
function cJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var i2 = function (e, t) {
  var i = $3({}, e, t.attrs)
  return Te(zi, $3({}, i, { icon: lJ }), null)
}
i2.displayName = 'CloseCircleOutlined'
i2.inheritAttrs = !1
var uJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z',
        },
      },
    ],
  },
  name: 'check-circle',
  theme: 'filled',
}
function G3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        dJ(n, r, t[r])
      }))
  }
  return n
}
function dJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var ju = function (e, t) {
  var i = G3({}, e, t.attrs)
  return Te(zi, G3({}, i, { icon: uJ }), null)
}
ju.displayName = 'CheckCircleFilled'
ju.inheritAttrs = !1
var hJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z',
        },
      },
    ],
  },
  name: 'exclamation-circle',
  theme: 'filled',
}
function W3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        fJ(n, r, t[r])
      }))
  }
  return n
}
function fJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var qu = function (e, t) {
  var i = W3({}, e, t.attrs)
  return Te(zi, W3({}, i, { icon: hJ }), null)
}
qu.displayName = 'ExclamationCircleFilled'
qu.inheritAttrs = !1
var pJ = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z',
        },
      },
    ],
  },
  name: 'info-circle',
  theme: 'filled',
}
function Q3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        mJ(n, r, t[r])
      }))
  }
  return n
}
function mJ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var Xu = function (e, t) {
  var i = Q3({}, e, t.attrs)
  return Te(zi, Q3({}, i, { icon: pJ }), null)
}
Xu.displayName = 'InfoCircleFilled'
Xu.inheritAttrs = !1
let F1 = ke({}, Au.Modal)
function gJ(n) {
  n ? (F1 = ke(ke({}, F1), n)) : (F1 = ke({}, Au.Modal))
}
const Iv = 'internalMark',
  jp = qt({
    compatConfig: { MODE: 3 },
    name: 'ALocaleProvider',
    props: { locale: { type: Object }, ANT_MARK__: String },
    setup(n, e) {
      let { slots: t } = e
      M6(n.ANT_MARK__ === Iv)
      const i = Zs({ antLocale: ke(ke({}, n.locale), { exist: !0 }), ANT_MARK__: Iv })
      return (
        ra('localeData', i),
        Jn(
          () => n.locale,
          (r) => {
            ;(gJ(r && r.Modal), (i.antLocale = ke(ke({}, r), { exist: !0 })))
          },
          { immediate: !0 }
        ),
        () => {
          var r
          return (r = t.default) === null || r === void 0 ? void 0 : r.call(t)
        }
      )
    },
  })
jp.install = function (n) {
  return (n.component(jp.name, jp), n)
}
const yJ = Hx(jp),
  mR = qt({
    name: 'Notice',
    inheritAttrs: !1,
    props: [
      'prefixCls',
      'duration',
      'updateMark',
      'noticeKey',
      'closeIcon',
      'closable',
      'props',
      'onClick',
      'onClose',
      'holder',
      'visible',
    ],
    setup(n, e) {
      let { attrs: t, slots: i } = e,
        r,
        s = !1
      const o = Ge(() => (n.duration === void 0 ? 4.5 : n.duration)),
        a = () => {
          o.value &&
            !s &&
            (r = setTimeout(() => {
              c()
            }, o.value * 1e3))
        },
        l = () => {
          r && (clearTimeout(r), (r = null))
        },
        c = (d) => {
          ;(d && d.stopPropagation(), l())
          const { onClose: h, noticeKey: f } = n
          h && h(f)
        },
        u = () => {
          ;(l(), a())
        }
      return (
        Va(() => {
          a()
        }),
        Fh(() => {
          ;((s = !0), l())
        }),
        Jn(
          [o, () => n.updateMark, () => n.visible],
          (d, h) => {
            let [f, p, g] = d,
              [y, m, v] = h
            ;(f !== y || p !== m || (g !== v && v)) && u()
          },
          { flush: 'post' }
        ),
        () => {
          var d, h
          const {
              prefixCls: f,
              closable: p,
              closeIcon: g = (d = i.closeIcon) === null || d === void 0 ? void 0 : d.call(i),
              onClick: y,
              holder: m,
            } = n,
            { class: v, style: x } = t,
            _ = ''.concat(f, '-notice'),
            S = Object.keys(t).reduce(
              (A, R) => (
                (R.startsWith('data-') || R.startsWith('aria-') || R === 'role') && (A[R] = t[R]),
                A
              ),
              {}
            ),
            C = Te(
              'div',
              Zn(
                {
                  class: Br(_, v, { [''.concat(_, '-closable')]: p }),
                  style: x,
                  onMouseenter: l,
                  onMouseleave: a,
                  onClick: y,
                },
                S
              ),
              [
                Te('div', { class: ''.concat(_, '-content') }, [
                  (h = i.default) === null || h === void 0 ? void 0 : h.call(i),
                ]),
                p
                  ? Te('a', { tabindex: 0, onClick: c, class: ''.concat(_, '-close') }, [
                      g || Te('span', { class: ''.concat(_, '-close-x') }, null),
                    ])
                  : null,
              ]
            )
          return m ? Te(_w, { to: m }, { default: () => C }) : C
        }
      )
    },
  })
var vJ = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
let j3 = 0
const _J = Date.now()
function q3() {
  const n = j3
  return ((j3 += 1), 'rcNotification_'.concat(_J, '_').concat(n))
}
const Vm = qt({
  name: 'Notification',
  inheritAttrs: !1,
  props: ['prefixCls', 'transitionName', 'animation', 'maxCount', 'closeIcon', 'hashId'],
  setup(n, e) {
    let { attrs: t, expose: i, slots: r } = e
    const s = new Map(),
      o = Dn([]),
      a = Ge(() => {
        const { prefixCls: u, animation: d = 'fade' } = n
        let h = n.transitionName
        return (!h && d && (h = ''.concat(u, '-').concat(d)), sR(h))
      }),
      l = (u, d) => {
        const h = u.key || q3(),
          f = ke(ke({}, u), { key: h }),
          { maxCount: p } = n,
          g = o.value.map((m) => m.notice.key).indexOf(h),
          y = o.value.concat()
        ;(g !== -1
          ? y.splice(g, 1, { notice: f, holderCallback: d })
          : (p &&
              o.value.length >= p &&
              ((f.key = y[0].notice.key), (f.updateMark = q3()), (f.userPassKey = h), y.shift()),
            y.push({ notice: f, holderCallback: d })),
          (o.value = y))
      },
      c = (u) => {
        o.value = Ot(o.value).filter((d) => {
          let {
            notice: { key: h, userPassKey: f },
          } = d
          return (f || h) !== u
        })
      }
    return (
      i({ add: l, remove: c, notices: o }),
      () => {
        var u
        const {
            prefixCls: d,
            closeIcon: h = (u = r.closeIcon) === null || u === void 0
              ? void 0
              : u.call(r, { prefixCls: d }),
          } = n,
          f = o.value.map((g, y) => {
            let { notice: m, holderCallback: v } = g
            const x = y === o.value.length - 1 ? m.updateMark : void 0,
              { key: _, userPassKey: S } = m,
              { content: C } = m,
              A = ke(
                ke(
                  ke(
                    { prefixCls: d, closeIcon: typeof h == 'function' ? h({ prefixCls: d }) : h },
                    m
                  ),
                  m.props
                ),
                {
                  key: _,
                  noticeKey: S || _,
                  updateMark: x,
                  onClose: (R) => {
                    var w
                    ;(c(R), (w = m.onClose) === null || w === void 0 || w.call(m))
                  },
                  onClick: m.onClick,
                }
              )
            return v
              ? Te(
                  'div',
                  {
                    key: _,
                    class: ''.concat(d, '-hook-holder'),
                    ref: (R) => {
                      typeof _ > 'u' || (R ? (s.set(_, R), v(R, A)) : s.delete(_))
                    },
                  },
                  null
                )
              : Te(mR, Zn(Zn({}, A), {}, { class: Br(A.class, n.hashId) }), {
                  default: () => [typeof C == 'function' ? C({ prefixCls: d }) : C],
                })
          }),
          p = { [d]: 1, [t.class]: !!t.class, [n.hashId]: !0 }
        return Te('div', { class: p, style: t.style || { top: '65px', left: '50%' } }, [
          Te(e5, Zn({ tag: 'div' }, a.value), { default: () => [f] }),
        ])
      }
    )
  },
})
Vm.newInstance = function (e, t) {
  const i = e || {},
    {
      name: r = 'notification',
      getContainer: s,
      appContext: o,
      prefixCls: a,
      rootPrefixCls: l,
      transitionName: c,
      hasTransitionName: u,
      useStyle: d,
    } = i,
    h = vJ(i, [
      'name',
      'getContainer',
      'appContext',
      'prefixCls',
      'rootPrefixCls',
      'transitionName',
      'hasTransitionName',
      'useStyle',
    ]),
    f = document.createElement('div')
  s ? s().appendChild(f) : document.body.appendChild(f)
  const g = Te(
    qt({
      compatConfig: { MODE: 3 },
      name: 'NotificationWrapper',
      setup(y, m) {
        let { attrs: v } = m
        const x = ar(),
          _ = Ge(() => Ii.getPrefixCls(r, a)),
          [, S] = d(_)
        return (
          Va(() => {
            t({
              notice(C) {
                var A
                ;(A = x.value) === null || A === void 0 || A.add(C)
              },
              removeNotice(C) {
                var A
                ;(A = x.value) === null || A === void 0 || A.remove(C)
              },
              destroy() {
                ;(oS(null, f), f.parentNode && f.parentNode.removeChild(f))
              },
              component: x,
            })
          }),
          () => {
            const C = Ii,
              A = C.getRootPrefixCls(l, _.value),
              R = u ? c : ''.concat(_.value, '-').concat(c)
            return Te(Jc, Zn(Zn({}, C), {}, { prefixCls: A }), {
              default: () => [
                Te(
                  Vm,
                  Zn(
                    Zn({ ref: x }, v),
                    {},
                    { prefixCls: _.value, transitionName: R, hashId: S.value }
                  ),
                  null
                ),
              ],
            })
          }
        )
      },
    }),
    h
  )
  ;((g.appContext = o || g.appContext), oS(g, f))
}
let X3 = 0
const xJ = Date.now()
function K3() {
  const n = X3
  return ((X3 += 1), 'rcNotification_'.concat(xJ, '_').concat(n))
}
const SJ = qt({
  name: 'HookNotification',
  inheritAttrs: !1,
  props: [
    'prefixCls',
    'transitionName',
    'animation',
    'maxCount',
    'closeIcon',
    'hashId',
    'remove',
    'notices',
    'getStyles',
    'getClassName',
    'onAllRemoved',
    'getContainer',
  ],
  setup(n, e) {
    let { attrs: t, slots: i } = e
    const r = new Map(),
      s = Ge(() => n.notices),
      o = Ge(() => {
        let u = n.transitionName
        if (!u && n.animation)
          switch (typeof n.animation) {
            case 'string':
              u = n.animation
              break
            case 'function':
              u = n.animation().name
              break
            case 'object':
              u = n.animation.name
              break
            default:
              u = ''.concat(n.prefixCls, '-fade')
              break
          }
        return sR(u)
      }),
      a = (u) => n.remove(u),
      l = Dn({})
    Jn(s, () => {
      const u = {}
      ;(Object.keys(l.value).forEach((d) => {
        u[d] = []
      }),
        n.notices.forEach((d) => {
          const { placement: h = 'topRight' } = d.notice
          h && ((u[h] = u[h] || []), u[h].push(d))
        }),
        (l.value = u))
    })
    const c = Ge(() => Object.keys(l.value))
    return () => {
      var u
      const {
          prefixCls: d,
          closeIcon: h = (u = i.closeIcon) === null || u === void 0
            ? void 0
            : u.call(i, { prefixCls: d }),
        } = n,
        f = c.value.map((p) => {
          var g, y
          const m = l.value[p],
            v = (g = n.getClassName) === null || g === void 0 ? void 0 : g.call(n, p),
            x = (y = n.getStyles) === null || y === void 0 ? void 0 : y.call(n, p),
            _ = m.map((A, R) => {
              let { notice: w, holderCallback: M } = A
              const I = R === s.value.length - 1 ? w.updateMark : void 0,
                { key: L, userPassKey: U } = w,
                { content: T } = w,
                F = ke(
                  ke(
                    ke(
                      { prefixCls: d, closeIcon: typeof h == 'function' ? h({ prefixCls: d }) : h },
                      w
                    ),
                    w.props
                  ),
                  {
                    key: L,
                    noticeKey: U || L,
                    updateMark: I,
                    onClose: (V) => {
                      var W
                      ;(a(V), (W = w.onClose) === null || W === void 0 || W.call(w))
                    },
                    onClick: w.onClick,
                  }
                )
              return M
                ? Te(
                    'div',
                    {
                      key: L,
                      class: ''.concat(d, '-hook-holder'),
                      ref: (V) => {
                        typeof L > 'u' || (V ? (r.set(L, V), M(V, F)) : r.delete(L))
                      },
                    },
                    null
                  )
                : Te(mR, Zn(Zn({}, F), {}, { class: Br(F.class, n.hashId) }), {
                    default: () => [typeof T == 'function' ? T({ prefixCls: d }) : T],
                  })
            }),
            S = {
              [d]: 1,
              [''.concat(d, '-').concat(p)]: 1,
              [t.class]: !!t.class,
              [n.hashId]: !0,
              [v]: !!v,
            }
          function C() {
            var A
            m.length > 0 ||
              (Reflect.deleteProperty(l.value, p),
              (A = n.onAllRemoved) === null || A === void 0 || A.call(n))
          }
          return Te(
            'div',
            { key: p, class: S, style: t.style || x || { top: '65px', left: '50%' } },
            [
              Te(e5, Zn(Zn({ tag: 'div' }, o.value), {}, { onAfterLeave: C }), {
                default: () => [_],
              }),
            ]
          )
        })
      return Te(gZ, { getContainer: n.getContainer }, { default: () => [f] })
    }
  },
})
var AJ = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const bJ = () => document.body
let Y3 = 0
function TJ() {
  const n = {}
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  return (
    t.forEach((r) => {
      r &&
        Object.keys(r).forEach((s) => {
          const o = r[s]
          o !== void 0 && (n[s] = o)
        })
    }),
    n
  )
}
function gR() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const {
      getContainer: e = bJ,
      motion: t,
      prefixCls: i,
      maxCount: r,
      getClassName: s,
      getStyles: o,
      onAllRemoved: a,
    } = n,
    l = AJ(n, [
      'getContainer',
      'motion',
      'prefixCls',
      'maxCount',
      'getClassName',
      'getStyles',
      'onAllRemoved',
    ]),
    c = ar([]),
    u = ar(),
    d = (m, v) => {
      const x = m.key || K3(),
        _ = ke(ke({}, m), { key: x }),
        S = c.value.map((A) => A.notice.key).indexOf(x),
        C = c.value.concat()
      ;(S !== -1
        ? C.splice(S, 1, { notice: _, holderCallback: v })
        : (r &&
            c.value.length >= r &&
            ((_.key = C[0].notice.key), (_.updateMark = K3()), (_.userPassKey = x), C.shift()),
          C.push({ notice: _, holderCallback: v })),
        (c.value = C))
    },
    h = (m) => {
      c.value = c.value.filter((v) => {
        let {
          notice: { key: x, userPassKey: _ },
        } = v
        return (_ || x) !== m
      })
    },
    f = () => {
      c.value = []
    },
    p = () =>
      Te(
        SJ,
        {
          ref: u,
          prefixCls: i,
          maxCount: r,
          notices: c.value,
          remove: h,
          getClassName: s,
          getStyles: o,
          animation: t,
          hashId: n.hashId,
          onAllRemoved: a,
          getContainer: e,
        },
        null
      ),
    g = ar([]),
    y = {
      open: (m) => {
        const v = TJ(l, m)
        ;((v.key === null || v.key === void 0) &&
          ((v.key = 'vc-notification-'.concat(Y3)), (Y3 += 1)),
          (g.value = [...g.value, { type: 'open', config: v }]))
      },
      close: (m) => {
        g.value = [...g.value, { type: 'close', key: m }]
      },
      destroy: () => {
        g.value = [...g.value, { type: 'destroy' }]
      },
    }
  return (
    Jn(g, () => {
      g.value.length &&
        (g.value.forEach((m) => {
          switch (m.type) {
            case 'open':
              d(m.config)
              break
            case 'close':
              h(m.key)
              break
            case 'destroy':
              f()
              break
          }
        }),
        (g.value = []))
    }),
    [y, p]
  )
}
const wJ = (n) => {
    const {
        componentCls: e,
        iconCls: t,
        boxShadowSecondary: i,
        colorBgElevated: r,
        colorSuccess: s,
        colorError: o,
        colorWarning: a,
        colorInfo: l,
        fontSizeLG: c,
        motionEaseInOutCirc: u,
        motionDurationSlow: d,
        marginXS: h,
        paddingXS: f,
        borderRadiusLG: p,
        zIndexPopup: g,
        messageNoticeContentPadding: y,
      } = n,
      m = new $o('MessageMoveIn', {
        '0%': { padding: 0, transform: 'translateY(-100%)', opacity: 0 },
        '100%': { padding: f, transform: 'translateY(0)', opacity: 1 },
      }),
      v = new $o('MessageMoveOut', {
        '0%': { maxHeight: n.height, padding: f, opacity: 1 },
        '100%': { maxHeight: 0, padding: 0, opacity: 0 },
      })
    return [
      {
        [e]: ke(ke({}, qx(n)), {
          position: 'fixed',
          top: h,
          left: '50%',
          transform: 'translateX(-50%)',
          width: '100%',
          pointerEvents: 'none',
          zIndex: g,
          [''.concat(e, '-move-up')]: { animationFillMode: 'forwards' },
          ['\n        '
            .concat(e, '-move-up-appear,\n        ')
            .concat(e, '-move-up-enter\n      ')]: {
            animationName: m,
            animationDuration: d,
            animationPlayState: 'paused',
            animationTimingFunction: u,
          },
          ['\n        '
            .concat(e, '-move-up-appear')
            .concat(e, '-move-up-appear-active,\n        ')
            .concat(e, '-move-up-enter')
            .concat(e, '-move-up-enter-active\n      ')]: { animationPlayState: 'running' },
          [''.concat(e, '-move-up-leave')]: {
            animationName: v,
            animationDuration: d,
            animationPlayState: 'paused',
            animationTimingFunction: u,
          },
          [''.concat(e, '-move-up-leave').concat(e, '-move-up-leave-active')]: {
            animationPlayState: 'running',
          },
          '&-rtl': { direction: 'rtl', span: { direction: 'rtl' } },
        }),
      },
      {
        [''.concat(e, '-notice')]: {
          padding: f,
          textAlign: 'center',
          [t]: { verticalAlign: 'text-bottom', marginInlineEnd: h, fontSize: c },
          [''.concat(e, '-notice-content')]: {
            display: 'inline-block',
            padding: y,
            background: r,
            borderRadius: p,
            boxShadow: i,
            pointerEvents: 'all',
          },
          [''.concat(e, '-success ').concat(t)]: { color: s },
          [''.concat(e, '-error ').concat(t)]: { color: o },
          [''.concat(e, '-warning ').concat(t)]: { color: a },
          ['\n        '
            .concat(e, '-info ')
            .concat(t, ',\n        ')
            .concat(e, '-loading ')
            .concat(t)]: { color: l },
        },
      },
      { [''.concat(e, '-notice-pure-panel')]: { padding: 0, textAlign: 'start' } },
    ]
  },
  yR = O0(
    'Message',
    (n) => {
      const e = af(n, {
        messageNoticeContentPadding: ''
          .concat((n.controlHeightLG - n.fontSize * n.lineHeight) / 2, 'px ')
          .concat(n.paddingSM, 'px'),
      })
      return [wJ(e)]
    },
    (n) => ({ height: 150, zIndexPopup: n.zIndexPopupBase + 10 })
  ),
  CJ = {
    info: Te(Xu, null, null),
    success: Te(ju, null, null),
    error: Te(Qu, null, null),
    warning: Te(qu, null, null),
    loading: Te(cf, null, null),
  },
  EJ = qt({
    name: 'PureContent',
    inheritAttrs: !1,
    props: ['prefixCls', 'type', 'icon'],
    setup(n, e) {
      let { slots: t } = e
      return () => {
        var i
        return Te(
          'div',
          {
            class: Br(
              ''.concat(n.prefixCls, '-custom-content'),
              ''.concat(n.prefixCls, '-').concat(n.type)
            ),
          },
          [
            n.icon || CJ[n.type],
            Te('span', null, [(i = t.default) === null || i === void 0 ? void 0 : i.call(t)]),
          ]
        )
      }
    },
  })
var MJ = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const RJ = 8,
  IJ = 3,
  NJ = qt({
    name: 'Holder',
    inheritAttrs: !1,
    props: [
      'top',
      'prefixCls',
      'getContainer',
      'maxCount',
      'duration',
      'rtl',
      'transitionName',
      'onAllRemoved',
      'animation',
      'staticGetContainer',
    ],
    setup(n, e) {
      let { expose: t } = e
      var i, r
      const { getPrefixCls: s, getPopupContainer: o } = lf('message', n),
        a = Ge(() => s('message', n.prefixCls)),
        [, l] = yR(a),
        c = () => {
          var g
          const y = (g = n.top) !== null && g !== void 0 ? g : RJ
          return {
            left: '50%',
            transform: 'translateX(-50%)',
            top: typeof y == 'number' ? ''.concat(y, 'px') : y,
          }
        },
        u = () => Br(l.value, n.rtl ? ''.concat(a.value, '-rtl') : ''),
        d = () => {
          var g
          return fZ({
            prefixCls: a.value,
            animation: (g = n.animation) !== null && g !== void 0 ? g : 'move-up',
            transitionName: n.transitionName,
          })
        },
        h = Te('span', { class: ''.concat(a.value, '-close-x') }, [
          Te(uf, { class: ''.concat(a.value, '-close-icon') }, null),
        ]),
        [f, p] = gR({
          getStyles: c,
          prefixCls: a.value,
          getClassName: u,
          motion: d,
          closable: !1,
          closeIcon: h,
          duration: (i = n.duration) !== null && i !== void 0 ? i : IJ,
          getContainer: (r = n.staticGetContainer) !== null && r !== void 0 ? r : o.value,
          maxCount: n.maxCount,
          onAllRemoved: n.onAllRemoved,
        })
      return (t(ke(ke({}, f), { prefixCls: a, hashId: l })), p)
    },
  })
let Z3 = 0
function PJ(n) {
  const e = ar(null),
    t = Symbol('messageHolderKey'),
    i = (l) => {
      var c
      ;(c = e.value) === null || c === void 0 || c.close(l)
    },
    r = (l) => {
      if (!e.value) {
        const S = () => {}
        return ((S.then = () => {}), S)
      }
      const { open: c, prefixCls: u, hashId: d } = e.value,
        h = ''.concat(u, '-notice'),
        { content: f, icon: p, type: g, key: y, class: m, onClose: v } = l,
        x = MJ(l, ['content', 'icon', 'type', 'key', 'class', 'onClose'])
      let _ = y
      return (
        _ == null && ((Z3 += 1), (_ = 'antd-message-'.concat(Z3))),
        ZX(
          (S) => (
            c(
              ke(ke({}, x), {
                key: _,
                content: () =>
                  Te(
                    EJ,
                    { prefixCls: u, type: g, icon: typeof p == 'function' ? p() : p },
                    { default: () => [typeof f == 'function' ? f() : f] }
                  ),
                placement: 'top',
                class: Br(g && ''.concat(h, '-').concat(g), d, m),
                onClose: () => {
                  ;(v == null || v(), S())
                },
              })
            ),
            () => {
              i(_)
            }
          )
        )
      )
    },
    o = {
      open: r,
      destroy: (l) => {
        var c
        l !== void 0 ? i(l) : (c = e.value) === null || c === void 0 || c.destroy()
      },
    }
  return (
    ['info', 'success', 'warning', 'error', 'loading'].forEach((l) => {
      const c = (u, d, h) => {
        let f
        u && typeof u == 'object' && 'content' in u ? (f = u) : (f = { content: u })
        let p, g
        typeof d == 'function' ? (g = d) : ((p = d), (g = h))
        const y = ke(ke({ onClose: g, duration: p }, f), { type: l })
        return r(y)
      }
      o[l] = c
    }),
    [o, () => Te(NJ, Zn(Zn({ key: t }, n), {}, { ref: e }), null)]
  )
}
function LJ(n) {
  return PJ(n)
}
let vR = 3,
  _R,
  Yi,
  DJ = 1,
  xR = '',
  SR = 'move-up',
  AR = !1,
  bR = () => document.body,
  TR,
  wR = !1
function FJ() {
  return DJ++
}
function OJ(n) {
  ;(n.top !== void 0 && ((_R = n.top), (Yi = null)),
    n.duration !== void 0 && (vR = n.duration),
    n.prefixCls !== void 0 && (xR = n.prefixCls),
    n.getContainer !== void 0 && ((bR = n.getContainer), (Yi = null)),
    n.transitionName !== void 0 && ((SR = n.transitionName), (Yi = null), (AR = !0)),
    n.maxCount !== void 0 && ((TR = n.maxCount), (Yi = null)),
    n.rtl !== void 0 && (wR = n.rtl))
}
function BJ(n, e) {
  if (Yi) {
    e(Yi)
    return
  }
  Vm.newInstance(
    {
      appContext: n.appContext,
      prefixCls: n.prefixCls || xR,
      rootPrefixCls: n.rootPrefixCls,
      transitionName: SR,
      hasTransitionName: AR,
      style: { top: _R },
      getContainer: bR || n.getPopupContainer,
      maxCount: TR,
      name: 'message',
      useStyle: yR,
    },
    (t) => {
      if (Yi) {
        e(Yi)
        return
      }
      ;((Yi = t), e(t))
    }
  )
}
const CR = { info: Xu, success: ju, error: Qu, warning: qu, loading: cf },
  UJ = Object.keys(CR)
function kJ(n) {
  const e = n.duration !== void 0 ? n.duration : vR,
    t = n.key || FJ(),
    i = new Promise((s) => {
      const o = () => (typeof n.onClose == 'function' && n.onClose(), s(!0))
      BJ(n, (a) => {
        a.notice({
          key: t,
          duration: e,
          style: n.style || {},
          class: n.class,
          content: (l) => {
            let { prefixCls: c } = l
            const u = CR[n.type],
              d = u ? Te(u, null, null) : '',
              h = Br(''.concat(c, '-custom-content'), {
                [''.concat(c, '-').concat(n.type)]: n.type,
                [''.concat(c, '-rtl')]: wR === !0,
              })
            return Te('div', { class: h }, [
              typeof n.icon == 'function' ? n.icon() : n.icon || d,
              Te('span', null, [typeof n.content == 'function' ? n.content() : n.content]),
            ])
          },
          onClose: o,
          onClick: n.onClick,
        })
      })
    }),
    r = () => {
      Yi && Yi.removeNotice(t)
    }
  return ((r.then = (s, o) => i.then(s, o)), (r.promise = i), r)
}
function zJ(n) {
  return Object.prototype.toString.call(n) === '[object Object]' && !!n.content
}
const Gs = {
  open: kJ,
  config: OJ,
  destroy(n) {
    if (Yi)
      if (n) {
        const { removeNotice: e } = Yi
        e(n)
      } else {
        const { destroy: e } = Yi
        ;(e(), (Yi = null))
      }
  },
}
function VJ(n, e) {
  n[e] = (t, i, r) =>
    zJ(t)
      ? n.open(ke(ke({}, t), { type: e }))
      : (typeof i == 'function' && ((r = i), (i = void 0)),
        n.open({ content: t, duration: i, type: e, onClose: r }))
}
UJ.forEach((n) => VJ(Gs, n))
Gs.warn = Gs.warning
Gs.useMessage = LJ
const HJ = (n) => {
    const { componentCls: e, width: t, notificationMarginEdge: i } = n,
      r = new $o('antNotificationTopFadeIn', {
        '0%': { marginTop: '-100%', opacity: 0 },
        '100%': { marginTop: 0, opacity: 1 },
      }),
      s = new $o('antNotificationBottomFadeIn', {
        '0%': { marginBottom: '-100%', opacity: 0 },
        '100%': { marginBottom: 0, opacity: 1 },
      }),
      o = new $o('antNotificationLeftFadeIn', {
        '0%': { right: { _skip_check_: !0, value: t }, opacity: 0 },
        '100%': { right: { _skip_check_: !0, value: 0 }, opacity: 1 },
      })
    return {
      ['&'.concat(e, '-top, &').concat(e, '-bottom')]: { marginInline: 0 },
      ['&'.concat(e, '-top')]: {
        [''
          .concat(e, '-fade-enter')
          .concat(e, '-fade-enter-active, ')
          .concat(e, '-fade-appear')
          .concat(e, '-fade-appear-active')]: { animationName: r },
      },
      ['&'.concat(e, '-bottom')]: {
        [''
          .concat(e, '-fade-enter')
          .concat(e, '-fade-enter-active, ')
          .concat(e, '-fade-appear')
          .concat(e, '-fade-appear-active')]: { animationName: s },
      },
      ['&'.concat(e, '-topLeft, &').concat(e, '-bottomLeft')]: {
        marginInlineEnd: 0,
        marginInlineStart: i,
        [''
          .concat(e, '-fade-enter')
          .concat(e, '-fade-enter-active, ')
          .concat(e, '-fade-appear')
          .concat(e, '-fade-appear-active')]: { animationName: o },
      },
    }
  },
  $J = (n) => {
    const {
        iconCls: e,
        componentCls: t,
        boxShadowSecondary: i,
        fontSizeLG: r,
        notificationMarginBottom: s,
        borderRadiusLG: o,
        colorSuccess: a,
        colorInfo: l,
        colorWarning: c,
        colorError: u,
        colorTextHeading: d,
        notificationBg: h,
        notificationPadding: f,
        notificationMarginEdge: p,
        motionDurationMid: g,
        motionEaseInOut: y,
        fontSize: m,
        lineHeight: v,
        width: x,
        notificationIconSize: _,
      } = n,
      S = ''.concat(t, '-notice'),
      C = new $o('antNotificationFadeIn', {
        '0%': { left: { _skip_check_: !0, value: x }, opacity: 0 },
        '100%': { left: { _skip_check_: !0, value: 0 }, opacity: 1 },
      }),
      A = new $o('antNotificationFadeOut', {
        '0%': { maxHeight: n.animationMaxHeight, marginBottom: s, opacity: 1 },
        '100%': { maxHeight: 0, marginBottom: 0, paddingTop: 0, paddingBottom: 0, opacity: 0 },
      })
    return [
      {
        [t]: ke(
          ke(
            ke(ke({}, qx(n)), {
              position: 'fixed',
              zIndex: n.zIndexPopup,
              marginInlineEnd: p,
              [''.concat(t, '-hook-holder')]: { position: 'relative' },
              ['&'.concat(t, '-top, &').concat(t, '-bottom')]: {
                [''.concat(t, '-notice')]: { marginInline: 'auto auto' },
              },
              ['&'.concat(t, '-topLeft, &').concat(t, '-bottomLeft')]: {
                [''.concat(t, '-notice')]: { marginInlineEnd: 'auto', marginInlineStart: 0 },
              },
              [''.concat(t, '-fade-enter, ').concat(t, '-fade-appear')]: {
                animationDuration: n.motionDurationMid,
                animationTimingFunction: y,
                animationFillMode: 'both',
                opacity: 0,
                animationPlayState: 'paused',
              },
              [''.concat(t, '-fade-leave')]: {
                animationTimingFunction: y,
                animationFillMode: 'both',
                animationDuration: g,
                animationPlayState: 'paused',
              },
              [''
                .concat(t, '-fade-enter')
                .concat(t, '-fade-enter-active, ')
                .concat(t, '-fade-appear')
                .concat(t, '-fade-appear-active')]: {
                animationName: C,
                animationPlayState: 'running',
              },
              [''.concat(t, '-fade-leave').concat(t, '-fade-leave-active')]: {
                animationName: A,
                animationPlayState: 'running',
              },
            }),
            HJ(n)
          ),
          { '&-rtl': { direction: 'rtl', [''.concat(t, '-notice-btn')]: { float: 'left' } } }
        ),
      },
      {
        [S]: {
          position: 'relative',
          width: x,
          maxWidth: 'calc(100vw - '.concat(p * 2, 'px)'),
          marginBottom: s,
          marginInlineStart: 'auto',
          padding: f,
          overflow: 'hidden',
          lineHeight: v,
          wordWrap: 'break-word',
          background: h,
          borderRadius: o,
          boxShadow: i,
          [''.concat(t, '-close-icon')]: { fontSize: m, cursor: 'pointer' },
          [''.concat(S, '-message')]: {
            marginBottom: n.marginXS,
            color: d,
            fontSize: r,
            lineHeight: n.lineHeightLG,
          },
          [''.concat(S, '-description')]: { fontSize: m },
          ['&'.concat(S, '-closable ').concat(S, '-message')]: { paddingInlineEnd: n.paddingLG },
          [''.concat(S, '-with-icon ').concat(S, '-message')]: {
            marginBottom: n.marginXS,
            marginInlineStart: n.marginSM + _,
            fontSize: r,
          },
          [''.concat(S, '-with-icon ').concat(S, '-description')]: {
            marginInlineStart: n.marginSM + _,
            fontSize: m,
          },
          [''.concat(S, '-icon')]: {
            position: 'absolute',
            fontSize: _,
            lineHeight: 0,
            ['&-success'.concat(e)]: { color: a },
            ['&-info'.concat(e)]: { color: l },
            ['&-warning'.concat(e)]: { color: c },
            ['&-error'.concat(e)]: { color: u },
          },
          [''.concat(S, '-close')]: {
            position: 'absolute',
            top: n.notificationPaddingVertical,
            insetInlineEnd: n.notificationPaddingHorizontal,
            color: n.colorIcon,
            outline: 'none',
            width: n.notificationCloseButtonSize,
            height: n.notificationCloseButtonSize,
            borderRadius: n.borderRadiusSM,
            transition: 'background-color '
              .concat(n.motionDurationMid, ', color ')
              .concat(n.motionDurationMid),
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            '&:hover': {
              color: n.colorIconHover,
              backgroundColor: n.wireframe ? 'transparent' : n.colorFillContent,
            },
          },
          [''.concat(S, '-btn')]: { float: 'right', marginTop: n.marginSM },
        },
      },
      { [''.concat(S, '-pure-panel')]: { margin: 0 } },
    ]
  },
  ER = O0(
    'Notification',
    (n) => {
      const e = n.paddingMD,
        t = n.paddingLG,
        i = af(n, {
          notificationBg: n.colorBgElevated,
          notificationPaddingVertical: e,
          notificationPaddingHorizontal: t,
          notificationPadding: ''
            .concat(n.paddingMD, 'px ')
            .concat(n.paddingContentHorizontalLG, 'px'),
          notificationMarginBottom: n.margin,
          notificationMarginEdge: n.marginLG,
          animationMaxHeight: 150,
          notificationIconSize: n.fontSizeLG * n.lineHeightLG,
          notificationCloseButtonSize: n.controlHeightLG * 0.55,
        })
      return [$J(i)]
    },
    (n) => ({ zIndexPopup: n.zIndexPopupBase + 50, width: 384 })
  )
function GJ(n, e) {
  return (
    e ||
    Te('span', { class: ''.concat(n, '-close-x') }, [
      Te(uf, { class: ''.concat(n, '-close-icon') }, null),
    ])
  )
}
;(Te(Xu, null, null),
  Te(ju, null, null),
  Te(Qu, null, null),
  Te(qu, null, null),
  Te(cf, null, null))
const WJ = { success: ju, info: Xu, error: Qu, warning: qu }
function QJ(n) {
  let { prefixCls: e, icon: t, type: i, message: r, description: s, btn: o } = n,
    a = null
  if (t) a = Te('span', { class: ''.concat(e, '-icon') }, [Uc(t)])
  else if (i) {
    const l = WJ[i]
    a = Te(l, { class: ''.concat(e, '-icon ').concat(e, '-icon-').concat(i) }, null)
  }
  return Te('div', { class: Br({ [''.concat(e, '-with-icon')]: a }), role: 'alert' }, [
    a,
    Te('div', { class: ''.concat(e, '-message') }, [r]),
    Te('div', { class: ''.concat(e, '-description') }, [s]),
    o && Te('div', { class: ''.concat(e, '-btn') }, [o]),
  ])
}
function MR(n, e, t) {
  let i
  switch (
    ((e = typeof e == 'number' ? ''.concat(e, 'px') : e),
    (t = typeof t == 'number' ? ''.concat(t, 'px') : t),
    n)
  ) {
    case 'top':
      i = { left: '50%', transform: 'translateX(-50%)', right: 'auto', top: e, bottom: 'auto' }
      break
    case 'topLeft':
      i = { left: 0, top: e, bottom: 'auto' }
      break
    case 'topRight':
      i = { right: 0, top: e, bottom: 'auto' }
      break
    case 'bottom':
      i = { left: '50%', transform: 'translateX(-50%)', right: 'auto', top: 'auto', bottom: t }
      break
    case 'bottomLeft':
      i = { left: 0, top: 'auto', bottom: t }
      break
    default:
      i = { right: 0, top: 'auto', bottom: t }
      break
  }
  return i
}
function jJ(n) {
  return { name: ''.concat(n, '-fade') }
}
var qJ = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const J3 = 24,
  XJ = 4.5,
  KJ = qt({
    name: 'Holder',
    inheritAttrs: !1,
    props: ['prefixCls', 'class', 'type', 'icon', 'content', 'onAllRemoved'],
    setup(n, e) {
      let { expose: t } = e
      const { getPrefixCls: i, getPopupContainer: r } = lf('notification', n),
        s = Ge(() => n.prefixCls || i('notification')),
        o = (h) => {
          var f, p
          return MR(
            h,
            (f = n.top) !== null && f !== void 0 ? f : J3,
            (p = n.bottom) !== null && p !== void 0 ? p : J3
          )
        },
        [, a] = ER(s),
        l = () => Br(a.value, { [''.concat(s.value, '-rtl')]: n.rtl }),
        c = () => jJ(s.value),
        [u, d] = gR({
          prefixCls: s.value,
          getStyles: o,
          getClassName: l,
          motion: c,
          closable: !0,
          closeIcon: GJ(s.value),
          duration: XJ,
          getContainer: () => {
            var h, f
            return (
              ((h = n.getPopupContainer) === null || h === void 0 ? void 0 : h.call(n)) ||
              ((f = r.value) === null || f === void 0 ? void 0 : f.call(r)) ||
              document.body
            )
          },
          maxCount: n.maxCount,
          hashId: a.value,
          onAllRemoved: n.onAllRemoved,
        })
      return (t(ke(ke({}, u), { prefixCls: s.value, hashId: a })), d)
    },
  })
function YJ(n) {
  const e = ar(null),
    t = Symbol('notificationHolderKey'),
    i = (a) => {
      if (!e.value) return
      const { open: l, prefixCls: c, hashId: u } = e.value,
        d = ''.concat(c, '-notice'),
        { message: h, description: f, icon: p, type: g, btn: y, class: m } = a,
        v = qJ(a, ['message', 'description', 'icon', 'type', 'btn', 'class'])
      return l(
        ke(ke({ placement: 'topRight' }, v), {
          content: () =>
            Te(
              QJ,
              {
                prefixCls: d,
                icon: typeof p == 'function' ? p() : p,
                type: g,
                message: typeof h == 'function' ? h() : h,
                description: typeof f == 'function' ? f() : f,
                btn: typeof y == 'function' ? y() : y,
              },
              null
            ),
          class: Br(g && ''.concat(d, '-').concat(g), u, m),
        })
      )
    },
    s = {
      open: i,
      destroy: (a) => {
        var l, c
        a !== void 0
          ? (l = e.value) === null || l === void 0 || l.close(a)
          : (c = e.value) === null || c === void 0 || c.destroy()
      },
    }
  return (
    ['success', 'info', 'warning', 'error'].forEach((a) => {
      s[a] = (l) => i(ke(ke({}, l), { type: a }))
    }),
    [s, () => Te(KJ, Zn(Zn({ key: t }, n), {}, { ref: e }), null)]
  )
}
function ZJ(n) {
  return YJ(n)
}
const Sl = {}
let RR = 4.5,
  IR = '24px',
  NR = '24px',
  Nv = '',
  PR = 'topRight',
  LR = () => document.body,
  DR = null,
  Pv = !1,
  FR
function JJ(n) {
  const {
    duration: e,
    placement: t,
    bottom: i,
    top: r,
    getContainer: s,
    closeIcon: o,
    prefixCls: a,
  } = n
  ;(a !== void 0 && (Nv = a),
    e !== void 0 && (RR = e),
    t !== void 0 && (PR = t),
    i !== void 0 && (NR = typeof i == 'number' ? ''.concat(i, 'px') : i),
    r !== void 0 && (IR = typeof r == 'number' ? ''.concat(r, 'px') : r),
    s !== void 0 && (LR = s),
    o !== void 0 && (DR = o),
    n.rtl !== void 0 && (Pv = n.rtl),
    n.maxCount !== void 0 && (FR = n.maxCount))
}
function eee(n, e) {
  let {
    prefixCls: t,
    placement: i = PR,
    getContainer: r = LR,
    top: s,
    bottom: o,
    closeIcon: a = DR,
    appContext: l,
  } = n
  const { getPrefixCls: c } = hee(),
    u = c('notification', t || Nv),
    d = ''.concat(u, '-').concat(i, '-').concat(Pv),
    h = Sl[d]
  if (h) {
    Promise.resolve(h).then((p) => {
      e(p)
    })
    return
  }
  const f = Br(''.concat(u, '-').concat(i), { [''.concat(u, '-rtl')]: Pv === !0 })
  Vm.newInstance(
    {
      name: 'notification',
      prefixCls: t || Nv,
      useStyle: ER,
      class: f,
      style: MR(i, s != null ? s : IR, o != null ? o : NR),
      appContext: l,
      getContainer: r,
      closeIcon: (p) => {
        let { prefixCls: g } = p
        return Te('span', { class: ''.concat(g, '-close-x') }, [
          Uc(a, {}, Te(uf, { class: ''.concat(g, '-close-icon') }, null)),
        ])
      },
      maxCount: FR,
      hasTransitionName: !0,
    },
    (p) => {
      ;((Sl[d] = p), e(p))
    }
  )
}
const tee = { success: e2, info: n2, error: i2, warning: t2 }
function nee(n) {
  const { icon: e, type: t, description: i, message: r, btn: s } = n,
    o = n.duration === void 0 ? RR : n.duration
  eee(n, (a) => {
    a.notice({
      content: (l) => {
        let { prefixCls: c } = l
        const u = ''.concat(c, '-notice')
        let d = null
        if (e) d = () => Te('span', { class: ''.concat(u, '-icon') }, [Uc(e)])
        else if (t) {
          const h = tee[t]
          d = () => Te(h, { class: ''.concat(u, '-icon ').concat(u, '-icon-').concat(t) }, null)
        }
        return Te('div', { class: d ? ''.concat(u, '-with-icon') : '' }, [
          d && d(),
          Te('div', { class: ''.concat(u, '-message') }, [
            !i && d
              ? Te('span', { class: ''.concat(u, '-message-single-line-auto-margin') }, null)
              : null,
            Uc(r),
          ]),
          Te('div', { class: ''.concat(u, '-description') }, [Uc(i)]),
          s ? Te('span', { class: ''.concat(u, '-btn') }, [Uc(s)]) : null,
        ])
      },
      duration: o,
      closable: !0,
      onClose: n.onClose,
      onClick: n.onClick,
      key: n.key,
      style: n.style || {},
      class: n.class,
    })
  })
}
const Mu = {
    open: nee,
    close(n) {
      Object.keys(Sl).forEach((e) =>
        Promise.resolve(Sl[e]).then((t) => {
          t.removeNotice(n)
        })
      )
    },
    config: JJ,
    destroy() {
      Object.keys(Sl).forEach((n) => {
        ;(Promise.resolve(Sl[n]).then((e) => {
          e.destroy()
        }),
          delete Sl[n])
      })
    },
  },
  iee = ['success', 'info', 'warning', 'error']
iee.forEach((n) => {
  Mu[n] = (e) => Mu.open(ke(ke({}, e), { type: n }))
})
Mu.warn = Mu.warning
Mu.useNotification = ZJ
const ree = '-ant-'.concat(Date.now(), '-').concat(Math.random())
function see(n, e) {
  const t = {},
    i = (o, a) => {
      let l = o.clone()
      return ((l = (a == null ? void 0 : a(l)) || l), l.toRgbString())
    },
    r = (o, a) => {
      const l = new yi(o),
        c = Gl(l.toRgbString())
      ;((t[''.concat(a, '-color')] = i(l)),
        (t[''.concat(a, '-color-disabled')] = c[1]),
        (t[''.concat(a, '-color-hover')] = c[4]),
        (t[''.concat(a, '-color-active')] = c[6]),
        (t[''.concat(a, '-color-outline')] = l.clone().setAlpha(0.2).toRgbString()),
        (t[''.concat(a, '-color-deprecated-bg')] = c[0]),
        (t[''.concat(a, '-color-deprecated-border')] = c[2]))
    }
  if (e.primaryColor) {
    r(e.primaryColor, 'primary')
    const o = new yi(e.primaryColor),
      a = Gl(o.toRgbString())
    ;(a.forEach((c, u) => {
      t['primary-'.concat(u + 1)] = c
    }),
      (t['primary-color-deprecated-l-35'] = i(o, (c) => c.lighten(35))),
      (t['primary-color-deprecated-l-20'] = i(o, (c) => c.lighten(20))),
      (t['primary-color-deprecated-t-20'] = i(o, (c) => c.tint(20))),
      (t['primary-color-deprecated-t-50'] = i(o, (c) => c.tint(50))),
      (t['primary-color-deprecated-f-12'] = i(o, (c) => c.setAlpha(c.getAlpha() * 0.12))))
    const l = new yi(a[0])
    ;((t['primary-color-active-deprecated-f-30'] = i(l, (c) => c.setAlpha(c.getAlpha() * 0.3))),
      (t['primary-color-active-deprecated-d-02'] = i(l, (c) => c.darken(2))))
  }
  ;(e.successColor && r(e.successColor, 'success'),
    e.warningColor && r(e.warningColor, 'warning'),
    e.errorColor && r(e.errorColor, 'error'),
    e.infoColor && r(e.infoColor, 'info'))
  const s = Object.keys(t).map((o) => '--'.concat(n, '-').concat(o, ': ').concat(t[o], ';'))
  return '\n  :root {\n    '.concat(s.join('\n'), '\n  }\n  ').trim()
}
function oee(n, e) {
  const t = see(n, e)
  Gu() && Bm(t, ''.concat(ree, '-dynamic-theme'))
}
const aee = (n) => {
  const [e, t] = B0()
  return Av(
    Ge(() => ({ theme: e.value, token: t.value, hashId: '', path: ['ant-design-icons', n.value] })),
    () => [
      {
        ['.'.concat(n.value)]: ke(ke({}, LY()), {
          ['.'.concat(n.value, ' .').concat(n.value, '-icon')]: { display: 'block' },
        }),
      },
    ]
  )
}
function lee(n, e) {
  const t = Ge(() => (n == null ? void 0 : n.value) || {}),
    i = Ge(() => (t.value.inherit === !1 || !(e != null && e.value) ? W6 : e.value))
  return Ge(() => {
    if (!(n != null && n.value)) return e == null ? void 0 : e.value
    const s = ke({}, i.value.components)
    return (
      Object.keys(n.value.components || {}).forEach((o) => {
        s[o] = ke(ke({}, s[o]), n.value.components[o])
      }),
      ke(ke(ke({}, i.value), t.value), {
        token: ke(ke({}, i.value.token), t.value.token),
        components: s,
      })
    )
  })
}
var cee = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const uee = 'ant'
function Zc() {
  return Ii.prefixCls || uee
}
function OR() {
  return Ii.iconPrefixCls || $x
}
const r2 = Zs({}),
  Ii = Zs({})
t0(() => {
  ;(ke(Ii, r2),
    (Ii.prefixCls = Zc()),
    (Ii.iconPrefixCls = OR()),
    (Ii.getPrefixCls = (n, e) => e || (n ? ''.concat(Ii.prefixCls, '-').concat(n) : Ii.prefixCls)),
    (Ii.getRootPrefixCls = () => (Ii.prefixCls ? Ii.prefixCls : Zc())))
})
let O1
const dee = (n) => {
    ;(O1 && O1(),
      (O1 = t0(() => {
        ;(ke(r2, Zs(n)), ke(Ii, Zs(n)))
      })),
      n.theme && oee(Zc(), n.theme))
  },
  hee = () => ({
    getPrefixCls: (n, e) => e || (n ? ''.concat(Zc(), '-').concat(n) : Zc()),
    getIconPrefixCls: OR,
    getRootPrefixCls: () => (Ii.prefixCls ? Ii.prefixCls : Zc()),
  }),
  Jc = qt({
    compatConfig: { MODE: 3 },
    name: 'AConfigProvider',
    inheritAttrs: !1,
    props: oK(),
    setup(n, e) {
      let { slots: t } = e
      const i = p6(),
        r = (F, V) => {
          const { prefixCls: W = 'ant' } = n
          if (V) return V
          const ee = W || i.getPrefixCls('')
          return F ? ''.concat(ee, '-').concat(F) : ee
        },
        s = Ge(() => n.iconPrefixCls || i.iconPrefixCls.value || $x),
        o = Ge(() => s.value !== i.iconPrefixCls.value),
        a = Ge(() => {
          var F
          return n.csp || ((F = i.csp) === null || F === void 0 ? void 0 : F.value)
        }),
        l = aee(s),
        c = lee(
          Ge(() => n.theme),
          Ge(() => {
            var F
            return (F = i.theme) === null || F === void 0 ? void 0 : F.value
          })
        ),
        u = (F) => (n.renderEmpty || t.renderEmpty || i.renderEmpty || WY)(F),
        d = Ge(() => {
          var F, V
          return (F = n.autoInsertSpaceInButton) !== null && F !== void 0
            ? F
            : (V = i.autoInsertSpaceInButton) === null || V === void 0
              ? void 0
              : V.value
        }),
        h = Ge(() => {
          var F
          return n.locale || ((F = i.locale) === null || F === void 0 ? void 0 : F.value)
        })
      Jn(
        h,
        () => {
          r2.locale = h.value
        },
        { immediate: !0 }
      )
      const f = Ge(() => {
          var F
          return n.direction || ((F = i.direction) === null || F === void 0 ? void 0 : F.value)
        }),
        p = Ge(() => {
          var F, V
          return (F = n.space) !== null && F !== void 0
            ? F
            : (V = i.space) === null || V === void 0
              ? void 0
              : V.value
        }),
        g = Ge(() => {
          var F, V
          return (F = n.virtual) !== null && F !== void 0
            ? F
            : (V = i.virtual) === null || V === void 0
              ? void 0
              : V.value
        }),
        y = Ge(() => {
          var F, V
          return (F = n.dropdownMatchSelectWidth) !== null && F !== void 0
            ? F
            : (V = i.dropdownMatchSelectWidth) === null || V === void 0
              ? void 0
              : V.value
        }),
        m = Ge(() => {
          var F
          return n.getTargetContainer !== void 0
            ? n.getTargetContainer
            : (F = i.getTargetContainer) === null || F === void 0
              ? void 0
              : F.value
        }),
        v = Ge(() => {
          var F
          return n.getPopupContainer !== void 0
            ? n.getPopupContainer
            : (F = i.getPopupContainer) === null || F === void 0
              ? void 0
              : F.value
        }),
        x = Ge(() => {
          var F
          return n.pageHeader !== void 0
            ? n.pageHeader
            : (F = i.pageHeader) === null || F === void 0
              ? void 0
              : F.value
        }),
        _ = Ge(() => {
          var F
          return n.input !== void 0
            ? n.input
            : (F = i.input) === null || F === void 0
              ? void 0
              : F.value
        }),
        S = Ge(() => {
          var F
          return n.pagination !== void 0
            ? n.pagination
            : (F = i.pagination) === null || F === void 0
              ? void 0
              : F.value
        }),
        C = Ge(() => {
          var F
          return n.form !== void 0
            ? n.form
            : (F = i.form) === null || F === void 0
              ? void 0
              : F.value
        }),
        A = Ge(() => {
          var F
          return n.select !== void 0
            ? n.select
            : (F = i.select) === null || F === void 0
              ? void 0
              : F.value
        }),
        R = Ge(() => n.componentSize),
        w = Ge(() => n.componentDisabled),
        M = Ge(() => {
          var F, V
          return (F = n.wave) !== null && F !== void 0
            ? F
            : (V = i.wave) === null || V === void 0
              ? void 0
              : V.value
        }),
        I = {
          csp: a,
          autoInsertSpaceInButton: d,
          locale: h,
          direction: f,
          space: p,
          virtual: g,
          dropdownMatchSelectWidth: y,
          getPrefixCls: r,
          iconPrefixCls: s,
          theme: Ge(() => {
            var F, V
            return (F = c.value) !== null && F !== void 0
              ? F
              : (V = i.theme) === null || V === void 0
                ? void 0
                : V.value
          }),
          renderEmpty: u,
          getTargetContainer: m,
          getPopupContainer: v,
          pageHeader: x,
          input: _,
          pagination: S,
          form: C,
          select: A,
          componentSize: R,
          componentDisabled: w,
          transformCellText: Ge(() => n.transformCellText),
          wave: M,
        },
        L = Ge(() => {
          const F = c.value || {},
            { algorithm: V, token: W } = F,
            ee = cee(F, ['algorithm', 'token']),
            se = V && (!Array.isArray(V) || V.length > 0) ? I6(V) : void 0
          return ke(ke({}, ee), { theme: se, token: ke(ke({}, F0), W) })
        }),
        U = Ge(() => {
          var F, V
          let W = {}
          return (
            h.value &&
              (W =
                ((F = h.value.Form) === null || F === void 0
                  ? void 0
                  : F.defaultValidateMessages) ||
                ((V = Au.Form) === null || V === void 0 ? void 0 : V.defaultValidateMessages) ||
                {}),
            n.form && n.form.validateMessages && (W = ke(ke({}, W), n.form.validateMessages)),
            W
          )
        })
      ;(aK(I), sK({ validateMessages: U }), QY(R), lK(w))
      const T = (F) => {
        var V, W
        let ee = o.value
          ? l((V = t.default) === null || V === void 0 ? void 0 : V.call(t))
          : (W = t.default) === null || W === void 0
            ? void 0
            : W.call(t)
        if (n.theme) {
          const se = (function () {
            return ee
          })()
          ee = Te(zY, { value: L.value }, { default: () => [se] })
        }
        return Te(yJ, { locale: h.value || F, ANT_MARK__: Iv }, { default: () => [ee] })
      }
      return (
        t0(() => {
          f.value && (Gs.config({ rtl: f.value === 'rtl' }), Mu.config({ rtl: f.value === 'rtl' }))
        }),
        () => Te(v6, { children: (F, V, W) => T(W) }, null)
      )
    },
  })
Jc.config = dee
Jc.install = function (n) {
  n.component(Jc.name, Jc)
}
function fee(n, e, t) {
  var i = t || {},
    r = i.noTrailing,
    s = r === void 0 ? !1 : r,
    o = i.noLeading,
    a = o === void 0 ? !1 : o,
    l = i.debounceMode,
    c = l === void 0 ? void 0 : l,
    u,
    d = !1,
    h = 0
  function f() {
    u && clearTimeout(u)
  }
  function p(y) {
    var m = y || {},
      v = m.upcomingOnly,
      x = v === void 0 ? !1 : v
    ;(f(), (d = !x))
  }
  function g() {
    for (var y = arguments.length, m = new Array(y), v = 0; v < y; v++) m[v] = arguments[v]
    var x = this,
      _ = Date.now() - h
    if (d) return
    function S() {
      ;((h = Date.now()), e.apply(x, m))
    }
    function C() {
      u = void 0
    }
    ;(!a && c && !u && S(),
      f(),
      c === void 0 && _ > n
        ? a
          ? ((h = Date.now()), s || (u = setTimeout(c ? C : S, n)))
          : S()
        : s !== !0 && (u = setTimeout(c ? C : S, c === void 0 ? n - _ : n)))
  }
  return ((g.cancel = p), g)
}
function pee(n, e, t) {
  var i = {},
    r = i.atBegin,
    s = r === void 0 ? !1 : r
  return fee(n, e, { debounceMode: s !== !1 })
}
const mee = new $o('antSpinMove', { to: { opacity: 1 } }),
  gee = new $o('antRotate', { to: { transform: 'rotate(405deg)' } }),
  yee = (n) => ({
    [''.concat(n.componentCls)]: ke(ke({}, qx(n)), {
      position: 'absolute',
      display: 'none',
      color: n.colorPrimary,
      textAlign: 'center',
      verticalAlign: 'middle',
      opacity: 0,
      transition: 'transform '.concat(n.motionDurationSlow, ' ').concat(n.motionEaseInOutCirc),
      '&-spinning': { position: 'static', display: 'inline-block', opacity: 1 },
      '&-nested-loading': {
        position: 'relative',
        ['> div > '.concat(n.componentCls)]: {
          position: 'absolute',
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: 'block',
          width: '100%',
          height: '100%',
          maxHeight: n.contentHeight,
          [''.concat(n.componentCls, '-dot')]: {
            position: 'absolute',
            top: '50%',
            insetInlineStart: '50%',
            margin: -n.spinDotSize / 2,
          },
          [''.concat(n.componentCls, '-text')]: {
            position: 'absolute',
            top: '50%',
            width: '100%',
            paddingTop: (n.spinDotSize - n.fontSize) / 2 + 2,
            textShadow: '0 1px 2px '.concat(n.colorBgContainer),
          },
          ['&'.concat(n.componentCls, '-show-text ').concat(n.componentCls, '-dot')]: {
            marginTop: -(n.spinDotSize / 2) - 10,
          },
          '&-sm': {
            [''.concat(n.componentCls, '-dot')]: { margin: -n.spinDotSizeSM / 2 },
            [''.concat(n.componentCls, '-text')]: {
              paddingTop: (n.spinDotSizeSM - n.fontSize) / 2 + 2,
            },
            ['&'.concat(n.componentCls, '-show-text ').concat(n.componentCls, '-dot')]: {
              marginTop: -(n.spinDotSizeSM / 2) - 10,
            },
          },
          '&-lg': {
            [''.concat(n.componentCls, '-dot')]: { margin: -(n.spinDotSizeLG / 2) },
            [''.concat(n.componentCls, '-text')]: {
              paddingTop: (n.spinDotSizeLG - n.fontSize) / 2 + 2,
            },
            ['&'.concat(n.componentCls, '-show-text ').concat(n.componentCls, '-dot')]: {
              marginTop: -(n.spinDotSizeLG / 2) - 10,
            },
          },
        },
        [''.concat(n.componentCls, '-container')]: {
          position: 'relative',
          transition: 'opacity '.concat(n.motionDurationSlow),
          '&::after': {
            position: 'absolute',
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: '100%',
            height: '100%',
            background: n.colorBgContainer,
            opacity: 0,
            transition: 'all '.concat(n.motionDurationSlow),
            content: '""',
            pointerEvents: 'none',
          },
        },
        [''.concat(n.componentCls, '-blur')]: {
          clear: 'both',
          opacity: 0.5,
          userSelect: 'none',
          pointerEvents: 'none',
          '&::after': { opacity: 0.4, pointerEvents: 'auto' },
        },
      },
      '&-tip': { color: n.spinDotDefault },
      [''.concat(n.componentCls, '-dot')]: {
        position: 'relative',
        display: 'inline-block',
        fontSize: n.spinDotSize,
        width: '1em',
        height: '1em',
        '&-item': {
          position: 'absolute',
          display: 'block',
          width: (n.spinDotSize - n.marginXXS / 2) / 2,
          height: (n.spinDotSize - n.marginXXS / 2) / 2,
          backgroundColor: n.colorPrimary,
          borderRadius: '100%',
          transform: 'scale(0.75)',
          transformOrigin: '50% 50%',
          opacity: 0.3,
          animationName: mee,
          animationDuration: '1s',
          animationIterationCount: 'infinite',
          animationTimingFunction: 'linear',
          animationDirection: 'alternate',
          '&:nth-child(1)': { top: 0, insetInlineStart: 0 },
          '&:nth-child(2)': { top: 0, insetInlineEnd: 0, animationDelay: '0.4s' },
          '&:nth-child(3)': { insetInlineEnd: 0, bottom: 0, animationDelay: '0.8s' },
          '&:nth-child(4)': { bottom: 0, insetInlineStart: 0, animationDelay: '1.2s' },
        },
        '&-spin': {
          transform: 'rotate(45deg)',
          animationName: gee,
          animationDuration: '1.2s',
          animationIterationCount: 'infinite',
          animationTimingFunction: 'linear',
        },
      },
      ['&-sm '.concat(n.componentCls, '-dot')]: {
        fontSize: n.spinDotSizeSM,
        i: {
          width: (n.spinDotSizeSM - n.marginXXS / 2) / 2,
          height: (n.spinDotSizeSM - n.marginXXS / 2) / 2,
        },
      },
      ['&-lg '.concat(n.componentCls, '-dot')]: {
        fontSize: n.spinDotSizeLG,
        i: {
          width: (n.spinDotSizeLG - n.marginXXS) / 2,
          height: (n.spinDotSizeLG - n.marginXXS) / 2,
        },
      },
      ['&'.concat(n.componentCls, '-show-text ').concat(n.componentCls, '-text')]: {
        display: 'block',
      },
    }),
  }),
  vee = O0(
    'Spin',
    (n) => {
      const e = af(n, {
        spinDotDefault: n.colorTextDescription,
        spinDotSize: n.controlHeightLG / 2,
        spinDotSizeSM: n.controlHeightLG * 0.35,
        spinDotSizeLG: n.controlHeight,
      })
      return [yee(e)]
    },
    { contentHeight: 400 }
  )
var _ee = function (n, e) {
  var t = {}
  for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i])
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]])
  return t
}
const xee = () => ({
  prefixCls: String,
  spinning: { type: Boolean, default: void 0 },
  size: String,
  wrapperClassName: String,
  tip: zm.any,
  delay: Number,
  indicator: zm.any,
})
let qp = null
function See(n, e) {
  return !!n && !!e && !isNaN(Number(e))
}
function Aee(n) {
  const e = n.indicator
  qp = typeof e == 'function' ? e : () => Te(e, null, null)
}
const qd = qt({
  compatConfig: { MODE: 3 },
  name: 'ASpin',
  inheritAttrs: !1,
  props: JX(xee(), { size: 'default', spinning: !0, wrapperClassName: '' }),
  setup(n, e) {
    let { attrs: t, slots: i } = e
    const { prefixCls: r, size: s, direction: o } = lf('spin', n),
      [a, l] = vee(r),
      c = ar(n.spinning && !See(n.spinning, n.delay))
    let u
    return (
      Jn(
        [() => n.spinning, () => n.delay],
        () => {
          ;(u == null || u.cancel(),
            (u = pee(n.delay, () => {
              c.value = n.spinning
            })),
            u == null || u())
        },
        { immediate: !0, flush: 'post' }
      ),
      e0(() => {
        u == null || u.cancel()
      }),
      () => {
        var d, h
        const { class: f } = t,
          p = _ee(t, ['class']),
          { tip: g = (d = i.tip) === null || d === void 0 ? void 0 : d.call(i) } = n,
          y = (h = i.default) === null || h === void 0 ? void 0 : h.call(i),
          m = {
            [l.value]: !0,
            [r.value]: !0,
            [''.concat(r.value, '-sm')]: s.value === 'small',
            [''.concat(r.value, '-lg')]: s.value === 'large',
            [''.concat(r.value, '-spinning')]: c.value,
            [''.concat(r.value, '-show-text')]: !!g,
            [''.concat(r.value, '-rtl')]: o.value === 'rtl',
            [f]: !!f,
          }
        function v(_) {
          const S = ''.concat(_, '-dot')
          let C = tK(i, n, 'indicator')
          return C === null
            ? null
            : (Array.isArray(C) && (C = C.length === 1 ? C[0] : C),
              au(C)
                ? qo(C, { class: S })
                : qp && au(qp())
                  ? qo(qp(), { class: S })
                  : Te('span', { class: ''.concat(S, ' ').concat(_, '-dot-spin') }, [
                      Te('i', { class: ''.concat(_, '-dot-item') }, null),
                      Te('i', { class: ''.concat(_, '-dot-item') }, null),
                      Te('i', { class: ''.concat(_, '-dot-item') }, null),
                      Te('i', { class: ''.concat(_, '-dot-item') }, null),
                    ]))
        }
        const x = Te(
          'div',
          Zn(Zn({}, p), {}, { class: m, 'aria-live': 'polite', 'aria-busy': c.value }),
          [v(r.value), g ? Te('div', { class: ''.concat(r.value, '-text') }, [g]) : null]
        )
        if (y && Vx(y).length) {
          const _ = {
            [''.concat(r.value, '-container')]: !0,
            [''.concat(r.value, '-blur')]: c.value,
          }
          return a(
            Te(
              'div',
              { class: [''.concat(r.value, '-nested-loading'), n.wrapperClassName, l.value] },
              [
                c.value && Te('div', { key: 'loading' }, [x]),
                Te('div', { class: _, key: 'container' }, [y]),
              ]
            )
          )
        }
        return a(x)
      }
    )
  },
})
qd.setDefaultIndicator = Aee
qd.install = function (n) {
  return (n.component(qd.name, qd), n)
}
const bee = {
  items_per_page: '条/页',
  jump_to: '跳至',
  jump_to_confirm: '确定',
  page: '页',
  prev_page: '上一页',
  next_page: '下一页',
  prev_5: '向前 5 页',
  next_5: '向后 5 页',
  prev_3: '向前 3 页',
  next_3: '向后 3 页',
}
var Tee = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M912 302.3L784 376V224c0-35.3-28.7-64-64-64H128c-35.3 0-64 28.7-64 64v576c0 35.3 28.7 64 64 64h592c35.3 0 64-28.7 64-64V648l128 73.7c21.3 12.3 48-3.1 48-27.6V330c0-24.6-26.7-40-48-27.7zM712 792H136V232h576v560zm176-167l-104-59.8V458.9L888 399v226zM208 360h112c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H208c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z',
        },
      },
    ],
  },
  name: 'video-camera',
  theme: 'outlined',
}
function eT(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t)
    ;(typeof Object.getOwnPropertySymbols == 'function' &&
      (i = i.concat(
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable
        })
      )),
      i.forEach(function (r) {
        wee(n, r, t[r])
      }))
  }
  return n
}
function wee(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (n[e] = t),
    n
  )
}
var s2 = function (e, t) {
  var i = eT({}, e, t.attrs)
  return Te(zi, eT({}, i, { icon: Tee }), null)
}
s2.displayName = 'VideoCameraOutlined'
s2.inheritAttrs = !1
const ba = o5('visionStore', {
    state: () => ({
      wrapperRect: { width: 0, height: 0 },
      wrapperRef: void 0,
      localVideoRef: void 0,
      localVideoContainerRef: void 0,
      remoteVideoRef: void 0,
      remoteVideoContainerRef: void 0,
      isLandscape: !0,
      showChatRecords: !1,
    }),
    actions: {},
  }),
  Cee = {
    video: {
      width: { ideal: 500, min: 320 },
      height: { ideal: 500, min: 320 },
      aspectRatio: { ideal: 1 },
    },
    audio: !0,
  },
  k0 = o5('videoChatStore', {
    state: () => ({
      devices: [],
      availableVideoDevices: [],
      availableAudioDevices: [],
      selectedVideoDevice: null,
      selectedAudioDevice: null,
      streamState: qi.closed,
      stream: null,
      peerConnection: null,
      localStream: null,
      webRTCId: '',
      webcamAccessed: !1,
      avatarType: '',
      avatarWSRoute: '',
      avatarAssetsPath: '',
      rtcConfig: void 0,
      trackConstraints: Cee,
      gsLoadPercent: 0,
      volumeMuted: !1,
      micMuted: !1,
      cameraOff: !1,
      hasCamera: !1,
      hasCameraPermission: !0,
      hasMic: !1,
      hasMicPermission: !0,
      showChatRecords: !1,
      localAvatarRenderer: null,
      chatDataChannel: null,
      replying: !1,
      chatRecords: [],
    }),
    getters: {},
    actions: {
      async accessDevice() {
        try {
          const e = ba().localVideoRef
          if (
            ((this.micMuted = !1),
            (this.cameraOff = !1),
            (this.volumeMuted = !1),
            !navigator.mediaDevices)
          ) {
            Gs.error('无法获取媒体设备，请确保用localhost访问或https协议访问')
            return
          }
          ;(await navigator.mediaDevices.getUserMedia({ audio: !0 }).catch(() => {
            ;(console.log('no audio permission'), (this.hasMicPermission = !1))
          }),
            await navigator.mediaDevices.getUserMedia({ video: !0 }).catch(() => {
              ;(console.log('no video permission'), (this.hasCameraPermission = !1))
            }))
          const t = await T1()
          ;((this.devices = t), console.log('🚀 ~ access_webcam ~ devices:', t))
          const i =
              this.selectedVideoDevice &&
              t.some((s) => {
                var o
                return s.deviceId === ((o = this.selectedVideoDevice) == null ? void 0 : o.deviceId)
              })
                ? this.selectedVideoDevice.deviceId
                : '',
            r =
              this.selectedAudioDevice &&
              t.some((s) => {
                var o
                return s.deviceId === ((o = this.selectedAudioDevice) == null ? void 0 : o.deviceId)
              })
                ? this.selectedAudioDevice.deviceId
                : ''
          ;(console.log(i, r, ' access web device'),
            this.fillStream(r, i),
            (this.webcamAccessed = !0))
        } catch (n) {
          ;(console.log(n), Gs.error(n))
        }
      },
      async init() {
        fetch('/openavatarchat/initconfig')
          .then((n) => n.json())
          .then((n) => {
            ;(n.rtc_configuration && (this.rtcConfig = n.rtc_configuration),
              console.log(n),
              n.avatar_config &&
                ((this.avatarType = n.avatar_config.avatar_type),
                (this.avatarWSRoute = n.avatar_config.avatar_ws_route),
                (this.avatarAssetsPath = n.avatar_config.avatar_assets_path)),
              n.track_constraints && (this.trackConstraints = n.track_constraints))
          })
          .catch(() => {
            Gs.error('服务端链接失败，请检查是否能正确访问到 OpenAvatarChat 服务端')
          })
      },
      handleCameraOff() {
        var n
        ;((this.cameraOff = !this.cameraOff),
          (n = this.stream) == null ||
            n.getTracks().forEach((e) => {
              e.kind.includes('video') && (e.enabled = !this.cameraOff)
            }))
      },
      handleMicMuted() {
        var n
        ;((this.micMuted = !this.micMuted),
          (n = this.stream) == null ||
            n.getTracks().forEach((e) => {
              e.kind.includes('audio') && (e.enabled = !this.micMuted)
            }))
      },
      handleVolumeMute() {
        var n
        ;((this.volumeMuted = !this.volumeMuted),
          this.avatarType === 'lam' &&
            ((n = this.localAvatarRenderer) == null || n.setAvatarMute(this.volumeMuted)))
      },
      async handleDeviceChange(n) {
        const e = n,
          t = await T1()
        ;((this.devices = t), console.log('🚀 ~ handle_device_change ~ devices:', t))
        let i =
            this.selectedVideoDevice &&
            t.some((s) => {
              var o
              return s.deviceId === ((o = this.selectedVideoDevice) == null ? void 0 : o.deviceId)
            })
              ? this.selectedVideoDevice.deviceId
              : '',
          r =
            this.selectedAudioDevice &&
            t.some((s) => {
              var o
              return s.deviceId === ((o = this.selectedAudioDevice) == null ? void 0 : o.deviceId)
            })
              ? this.selectedAudioDevice.deviceId
              : ''
        ;(this.availableVideoDevices.find((s) => s.deviceId === e)
          ? ((i = e), (this.cameraOff = !1))
          : this.availableAudioDevices.find((s) => s.deviceId === e) &&
            ((r = e), (this.micMuted = !1)),
          this.fillStream(r, i))
      },
      handleSubtitleToggle() {
        this.showChatRecords = !this.showChatRecords
        const n = ba(),
          { wrapperRef: e, wrapperRect: t } = n
        ;(console.log(t, e),
          !(!e || !t) &&
            (e.getBoundingClientRect(),
            (t.width = e.clientWidth),
            (t.height = e.clientHeight),
            (n.isLandscape = t.width > t.height)))
      },
      async updateAvailableDevices() {
        const n = await T1()
        ;((this.availableVideoDevices = r3(n, 'videoinput')),
          (this.availableAudioDevices = r3(n, 'audioinput')))
      },
      async fillStream(n, e) {
        const { devices: t } = this,
          r = ba().localVideoRef
        ;((this.hasMic =
          t.some((s) => s.kind === 'audioinput' && s.deviceId) && this.hasMicPermission),
          (this.hasCamera =
            t.some((s) => s.kind === 'videoinput' && s.deviceId) && this.hasCameraPermission),
          await HX(
            n && n !== 'default' ? { deviceId: { exact: n } } : this.hasMic,
            e && e !== 'default' ? { deviceId: { exact: e } } : this.hasCamera,
            this.trackConstraints
          )
            .then(async (s) => {
              ;(console.log('local_stream', s), (this.stream = s), this.updateAvailableDevices())
            })
            .then(() => {
              ;(this.stream
                .getTracks()
                .map((o) => {
                  var a
                  return (a = o.getSettings()) == null ? void 0 : a.deviceId
                })
                .forEach((o) => {
                  const a = t.find((l) => l.deviceId === o)
                  a && a != null && a.kind.includes('video')
                    ? (this.selectedVideoDevice = a)
                    : a && a != null && a.kind.includes('audio') && (this.selectedAudioDevice = a)
                }),
                !this.selectedVideoDevice &&
                  (this.selectedVideoDevice = this.availableVideoDevices[0]))
            })
            .catch((s) => {
              console.error('image.no_webcam_support', s)
            })
            .finally(() => {
              ;(console.log(this.stream),
                this.stream || (this.stream = new MediaStream()),
                console.log(this.stream.getTracks()),
                this.stream.getTracks().find((s) => s.kind === 'audio') ||
                  this.stream.addTrack(GX()),
                this.stream.getTracks().find((s) => s.kind === 'video') ||
                  this.stream.addTrack($X()),
                console.log(this.hasCamera, this.hasMic),
                (this.webcamAccessed = !0),
                (this.localStream = this.stream),
                r && ((r.srcObject = this.localStream), (r.muted = !0), r == null || r.play()))
            }))
      },
      async startWebRTC() {
        var e
        const n = ba()
        this.streamState === 'closed'
          ? ((this.chatRecords = []),
            (this.peerConnection = new RTCPeerConnection(this.rtcConfig)),
            this.peerConnection.addEventListener('connectionstatechange', async (t) => {
              switch (this.peerConnection.connectionState) {
                case 'connected':
                  this.streamState = qi.open
                  break
                case 'disconnected':
                  ;((this.streamState = qi.closed), s3(this.peerConnection))
                  break
              }
            }),
            (this.streamState = qi.waiting),
            await WX(this.stream, this.peerConnection, n.remoteVideoRef)
              .then(([t, i]) => {
                if (
                  ((this.streamState = qi.open),
                  (this.webRTCId = i),
                  (this.chatDataChannel = t),
                  this.avatarType && this.avatarWSRoute)
                ) {
                  const r = this.initWebsocket(this.avatarWSRoute, this.webRTCId)
                  this.avatarType === 'lam' && (this.localAvatarRenderer = this.doGaussianRender(r))
                }
              })
              .catch((t) => {
                ;(console.info('catching', t),
                  (this.streamState = qi.closed),
                  Gs.error(t),
                  Gs.error('请检查是否超过数字人并发上限'))
              }))
          : this.streamState === 'waiting' ||
            (s3(this.peerConnection),
            (this.streamState = qi.closed),
            (this.chatRecords = []),
            (this.chatDataChannel = null),
            (this.replying = !1),
            await this.accessDevice(),
            this.avatarType === 'lam' &&
              ((e = this.localAvatarRenderer) == null || e.exit(), (this.gsLoadPercent = 0)))
      },
      initWebsocket(n, e) {
        const t = new oN(
          ''
            .concat(window.location.protocol.includes('https') ? 'wss' : 'ws', '://')
            .concat(window.location.host)
            .concat(n, '/')
            .concat(e)
        )
        return (
          t.on(Kr.WS_OPEN, () => {
            console.log('socket opened')
          }),
          t.on(Kr.WS_CLOSE, () => {
            console.log('socket closed')
          }),
          t.on(Kr.WS_ERROR, (i) => {
            console.log('socket error', i)
          }),
          t.on(Kr.WS_MESSAGE, (i) => {
            console.log('socket on message', i)
          }),
          t
        )
      },
      doGaussianRender(n) {
        const e = ba(),
          t = new VX({
            container: e.remoteVideoContainerRef,
            assetsPath: this.avatarAssetsPath,
            ws: n,
            loadProgress: (i) => {
              ;(console.log('gs loadProgress', i), (this.gsLoadPercent = i))
            },
          })
        return (t.start(), t)
      },
    },
  }),
  Eee = { class: 'icon-wrap' },
  Mee = '点击允许访问摄像头和麦克风',
  Ree = qt({
    __name: 'WebcamPermission',
    emits: ['click'],
    setup(n, { emit: e }) {
      const t = k0()
      ba()
      const i = async () => {
        t.accessDevice()
      }
      return (
        Va(() => {}),
        (r, s) => (
          mt(),
          Ct('div', { class: 'access-wrap', onClick: i }, [
            kt('span', Eee, [Te(Ke(s2))]),
            om(' ' + su(Mee)),
          ])
        )
      )
    },
  }),
  si = (n, e) => {
    const t = n.__vccOpts || n
    for (const [i, r] of e) t[i] = r
    return t
  },
  Iee = si(Ree, [['__scopeId', 'data-v-2804bf05']])
/*!
 * shared v11.1.12
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */ function Nee(n, e) {
  typeof console < 'u' && (console.warn('[intlify] ' + n), e && console.warn(e.stack))
}
const Hm = typeof window < 'u',
  Qa = (n, e = !1) => (e ? Symbol.for(n) : Symbol(n)),
  Pee = (n, e, t) => Lee({ l: n, k: e, s: t }),
  Lee = (n) =>
    JSON.stringify(n)
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029')
      .replace(/\u0027/g, '\\u0027'),
  Gn = (n) => typeof n == 'number' && isFinite(n),
  Dee = (n) => o2(n) === '[object Date]',
  Ru = (n) => o2(n) === '[object RegExp]',
  z0 = (n) => Lt(n) && Object.keys(n).length === 0,
  ei = Object.assign,
  Fee = Object.create,
  dn = (n = null) => Fee(n)
let tT
const Ml = () =>
  tT ||
  (tT =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : dn())
function nT(n) {
  return n
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/\//g, '&#x2F;')
    .replace(/=/g, '&#x3D;')
}
function iT(n) {
  return n
    .replace(/&(?![a-zA-Z0-9#]{2,6};)/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}
function Oee(n) {
  return (
    (n = n.replace(/(\w+)\s*=\s*"([^"]*)"/g, (i, r, s) => ''.concat(r, '="').concat(iT(s), '"'))),
    (n = n.replace(/(\w+)\s*=\s*'([^']*)'/g, (i, r, s) => ''.concat(r, "='").concat(iT(s), "'"))),
    /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi.test(n) &&
      (n = n.replace(/(\s+)(on)(\w+\s*=)/gi, '$1&#111;n$3')),
    [
      /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
      /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi,
    ].forEach((i) => {
      n = n.replace(i, '$1javascript&#58;')
    }),
    n
  )
}
const Bee = Object.prototype.hasOwnProperty
function ys(n, e) {
  return Bee.call(n, e)
}
const In = Array.isArray,
  yn = (n) => typeof n == 'function',
  st = (n) => typeof n == 'string',
  $t = (n) => typeof n == 'boolean',
  jt = (n) => n !== null && typeof n == 'object',
  Uee = (n) => jt(n) && yn(n.then) && yn(n.catch),
  BR = Object.prototype.toString,
  o2 = (n) => BR.call(n),
  Lt = (n) => o2(n) === '[object Object]',
  kee = (n) =>
    n == null ? '' : In(n) || (Lt(n) && n.toString === BR) ? JSON.stringify(n, null, 2) : String(n)
function a2(n, e = '') {
  return n.reduce((t, i, r) => (r === 0 ? t + i : t + e + i), '')
}
const gp = (n) => !jt(n) || In(n)
function Xp(n, e) {
  if (gp(n) || gp(e)) throw new Error('Invalid value')
  const t = [{ src: n, des: e }]
  for (; t.length; ) {
    const { src: i, des: r } = t.pop()
    Object.keys(i).forEach((s) => {
      s !== '__proto__' &&
        (jt(i[s]) && !jt(r[s]) && (r[s] = Array.isArray(i[s]) ? [] : dn()),
        gp(r[s]) || gp(i[s]) ? (r[s] = i[s]) : t.push({ src: i[s], des: r[s] }))
    })
  }
}
/*!
 * message-compiler v11.1.12
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */ function zee(n, e, t) {
  return { line: n, column: e, offset: t }
}
function Lv(n, e, t) {
  return { start: n, end: e }
}
const en = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
  },
  Vee = 17
function V0(n, e, t = {}) {
  const { domain: i, messages: r, args: s } = t,
    o = n,
    a = new SyntaxError(String(o))
  return ((a.code = n), e && (a.location = e), (a.domain = i), a)
}
function Hee(n) {
  throw n
}
const Ls = ' ',
  $ee = '\r',
  Mi = '\n',
  Gee = '\u2028',
  Wee = '\u2029'
function Qee(n) {
  const e = n
  let t = 0,
    i = 1,
    r = 1,
    s = 0
  const o = (A) => e[A] === $ee && e[A + 1] === Mi,
    a = (A) => e[A] === Mi,
    l = (A) => e[A] === Wee,
    c = (A) => e[A] === Gee,
    u = (A) => o(A) || a(A) || l(A) || c(A),
    d = () => t,
    h = () => i,
    f = () => r,
    p = () => s,
    g = (A) => (o(A) || l(A) || c(A) ? Mi : e[A]),
    y = () => g(t),
    m = () => g(t + s)
  function v() {
    return ((s = 0), u(t) && (i++, (r = 0)), o(t) && t++, t++, r++, e[t])
  }
  function x() {
    return (o(t + s) && s++, s++, e[t + s])
  }
  function _() {
    ;((t = 0), (i = 1), (r = 1), (s = 0))
  }
  function S(A = 0) {
    s = A
  }
  function C() {
    const A = t + s
    for (; A !== t; ) v()
    s = 0
  }
  return {
    index: d,
    line: h,
    column: f,
    peekOffset: p,
    charAt: g,
    currentChar: y,
    currentPeek: m,
    next: v,
    peek: x,
    reset: _,
    resetPeek: S,
    skipToPeek: C,
  }
}
const bo = void 0,
  jee = '.',
  rT = "'",
  qee = 'tokenizer'
function Xee(n, e = {}) {
  const t = e.location !== !1,
    i = Qee(n),
    r = () => i.index(),
    s = () => zee(i.line(), i.column(), i.index()),
    o = s(),
    a = r(),
    l = {
      currentType: 13,
      offset: a,
      startLoc: o,
      endLoc: o,
      lastType: 13,
      lastOffset: a,
      lastStartLoc: o,
      lastEndLoc: o,
      braceNest: 0,
      inLinked: !1,
      text: '',
    },
    c = () => l,
    { onError: u } = e
  function d(P, k, j, ...B) {
    const D = c()
    if (((k.column += j), (k.offset += j), u)) {
      const Q = t ? Lv(D.startLoc, k) : null,
        G = V0(P, Q, { domain: qee, args: B })
      u(G)
    }
  }
  function h(P, k, j) {
    ;((P.endLoc = s()), (P.currentType = k))
    const B = { type: k }
    return (t && (B.loc = Lv(P.startLoc, P.endLoc)), j != null && (B.value = j), B)
  }
  const f = (P) => h(P, 13)
  function p(P, k) {
    return P.currentChar() === k ? (P.next(), k) : (d(en.EXPECTED_TOKEN, s(), 0, k), '')
  }
  function g(P) {
    let k = ''
    for (; P.currentPeek() === Ls || P.currentPeek() === Mi; ) ((k += P.currentPeek()), P.peek())
    return k
  }
  function y(P) {
    const k = g(P)
    return (P.skipToPeek(), k)
  }
  function m(P) {
    if (P === bo) return !1
    const k = P.charCodeAt(0)
    return (k >= 97 && k <= 122) || (k >= 65 && k <= 90) || k === 95
  }
  function v(P) {
    if (P === bo) return !1
    const k = P.charCodeAt(0)
    return k >= 48 && k <= 57
  }
  function x(P, k) {
    const { currentType: j } = k
    if (j !== 2) return !1
    g(P)
    const B = m(P.currentPeek())
    return (P.resetPeek(), B)
  }
  function _(P, k) {
    const { currentType: j } = k
    if (j !== 2) return !1
    g(P)
    const B = P.currentPeek() === '-' ? P.peek() : P.currentPeek(),
      D = v(B)
    return (P.resetPeek(), D)
  }
  function S(P, k) {
    const { currentType: j } = k
    if (j !== 2) return !1
    g(P)
    const B = P.currentPeek() === rT
    return (P.resetPeek(), B)
  }
  function C(P, k) {
    const { currentType: j } = k
    if (j !== 7) return !1
    g(P)
    const B = P.currentPeek() === '.'
    return (P.resetPeek(), B)
  }
  function A(P, k) {
    const { currentType: j } = k
    if (j !== 8) return !1
    g(P)
    const B = m(P.currentPeek())
    return (P.resetPeek(), B)
  }
  function R(P, k) {
    const { currentType: j } = k
    if (!(j === 7 || j === 11)) return !1
    g(P)
    const B = P.currentPeek() === ':'
    return (P.resetPeek(), B)
  }
  function w(P, k) {
    const { currentType: j } = k
    if (j !== 9) return !1
    const B = () => {
        const Q = P.currentPeek()
        return Q === '{'
          ? m(P.peek())
          : Q === '@' || Q === '|' || Q === ':' || Q === '.' || Q === Ls || !Q
            ? !1
            : Q === Mi
              ? (P.peek(), B())
              : I(P, !1)
      },
      D = B()
    return (P.resetPeek(), D)
  }
  function M(P) {
    g(P)
    const k = P.currentPeek() === '|'
    return (P.resetPeek(), k)
  }
  function I(P, k = !0) {
    const j = (D = !1, Q = '') => {
        const G = P.currentPeek()
        return G === '{' || G === '@' || !G
          ? D
          : G === '|'
            ? !(Q === Ls || Q === Mi)
            : G === Ls
              ? (P.peek(), j(!0, Ls))
              : G === Mi
                ? (P.peek(), j(!0, Mi))
                : !0
      },
      B = j()
    return (k && P.resetPeek(), B)
  }
  function L(P, k) {
    const j = P.currentChar()
    return j === bo ? bo : k(j) ? (P.next(), j) : null
  }
  function U(P) {
    const k = P.charCodeAt(0)
    return (
      (k >= 97 && k <= 122) || (k >= 65 && k <= 90) || (k >= 48 && k <= 57) || k === 95 || k === 36
    )
  }
  function T(P) {
    return L(P, U)
  }
  function F(P) {
    const k = P.charCodeAt(0)
    return (
      (k >= 97 && k <= 122) ||
      (k >= 65 && k <= 90) ||
      (k >= 48 && k <= 57) ||
      k === 95 ||
      k === 36 ||
      k === 45
    )
  }
  function V(P) {
    return L(P, F)
  }
  function W(P) {
    const k = P.charCodeAt(0)
    return k >= 48 && k <= 57
  }
  function ee(P) {
    return L(P, W)
  }
  function se(P) {
    const k = P.charCodeAt(0)
    return (k >= 48 && k <= 57) || (k >= 65 && k <= 70) || (k >= 97 && k <= 102)
  }
  function he(P) {
    return L(P, se)
  }
  function ne(P) {
    let k = '',
      j = ''
    for (; (k = ee(P)); ) j += k
    return j
  }
  function ie(P) {
    let k = ''
    for (;;) {
      const j = P.currentChar()
      if (j === '{' || j === '}' || j === '@' || j === '|' || !j) break
      if (j === Ls || j === Mi)
        if (I(P)) ((k += j), P.next())
        else {
          if (M(P)) break
          ;((k += j), P.next())
        }
      else ((k += j), P.next())
    }
    return k
  }
  function be(P) {
    y(P)
    let k = '',
      j = ''
    for (; (k = V(P)); ) j += k
    const B = P.currentChar()
    if (B && B !== '}' && B !== bo && B !== Ls && B !== Mi && B !== '　') {
      const D = Be(P)
      return (d(en.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, j + D), j + D)
    }
    return (P.currentChar() === bo && d(en.UNTERMINATED_CLOSING_BRACE, s(), 0), j)
  }
  function le(P) {
    y(P)
    let k = ''
    return (
      P.currentChar() === '-' ? (P.next(), (k += '-'.concat(ne(P)))) : (k += ne(P)),
      P.currentChar() === bo && d(en.UNTERMINATED_CLOSING_BRACE, s(), 0),
      k
    )
  }
  function fe(P) {
    return P !== rT && P !== Mi
  }
  function we(P) {
    ;(y(P), p(P, "'"))
    let k = '',
      j = ''
    for (; (k = L(P, fe)); ) k === '\\' ? (j += Ee(P)) : (j += k)
    const B = P.currentChar()
    return B === Mi || B === bo
      ? (d(en.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0),
        B === Mi && (P.next(), p(P, "'")),
        j)
      : (p(P, "'"), j)
  }
  function Ee(P) {
    const k = P.currentChar()
    switch (k) {
      case '\\':
      case "'":
        return (P.next(), '\\'.concat(k))
      case 'u':
        return Ie(P, k, 4)
      case 'U':
        return Ie(P, k, 6)
      default:
        return (d(en.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, k), '')
    }
  }
  function Ie(P, k, j) {
    p(P, k)
    let B = ''
    for (let D = 0; D < j; D++) {
      const Q = he(P)
      if (!Q) {
        d(
          en.INVALID_UNICODE_ESCAPE_SEQUENCE,
          s(),
          0,
          '\\'.concat(k).concat(B).concat(P.currentChar())
        )
        break
      }
      B += Q
    }
    return '\\'.concat(k).concat(B)
  }
  function ze(P) {
    return P !== '{' && P !== '}' && P !== Ls && P !== Mi
  }
  function Be(P) {
    y(P)
    let k = '',
      j = ''
    for (; (k = L(P, ze)); ) j += k
    return j
  }
  function it(P) {
    let k = '',
      j = ''
    for (; (k = T(P)); ) j += k
    return j
  }
  function te(P) {
    const k = (j) => {
      const B = P.currentChar()
      return B === '{' || B === '@' || B === '|' || B === '(' || B === ')' || !B || B === Ls
        ? j
        : ((j += B), P.next(), k(j))
    }
    return k('')
  }
  function re(P) {
    y(P)
    const k = p(P, '|')
    return (y(P), k)
  }
  function b(P, k) {
    let j = null
    switch (P.currentChar()) {
      case '{':
        return (
          k.braceNest >= 1 && d(en.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0),
          P.next(),
          (j = h(k, 2, '{')),
          y(P),
          k.braceNest++,
          j
        )
      case '}':
        return (
          k.braceNest > 0 && k.currentType === 2 && d(en.EMPTY_PLACEHOLDER, s(), 0),
          P.next(),
          (j = h(k, 3, '}')),
          k.braceNest--,
          k.braceNest > 0 && y(P),
          k.inLinked && k.braceNest === 0 && (k.inLinked = !1),
          j
        )
      case '@':
        return (
          k.braceNest > 0 && d(en.UNTERMINATED_CLOSING_BRACE, s(), 0),
          (j = oe(P, k) || f(k)),
          (k.braceNest = 0),
          j
        )
      default: {
        let D = !0,
          Q = !0,
          G = !0
        if (M(P))
          return (
            k.braceNest > 0 && d(en.UNTERMINATED_CLOSING_BRACE, s(), 0),
            (j = h(k, 1, re(P))),
            (k.braceNest = 0),
            (k.inLinked = !1),
            j
          )
        if (k.braceNest > 0 && (k.currentType === 4 || k.currentType === 5 || k.currentType === 6))
          return (d(en.UNTERMINATED_CLOSING_BRACE, s(), 0), (k.braceNest = 0), J(P, k))
        if ((D = x(P, k))) return ((j = h(k, 4, be(P))), y(P), j)
        if ((Q = _(P, k))) return ((j = h(k, 5, le(P))), y(P), j)
        if ((G = S(P, k))) return ((j = h(k, 6, we(P))), y(P), j)
        if (!D && !Q && !G)
          return (
            (j = h(k, 12, Be(P))),
            d(en.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, j.value),
            y(P),
            j
          )
        break
      }
    }
    return j
  }
  function oe(P, k) {
    const { currentType: j } = k
    let B = null
    const D = P.currentChar()
    switch (
      ((j === 7 || j === 8 || j === 11 || j === 9) &&
        (D === Mi || D === Ls) &&
        d(en.INVALID_LINKED_FORMAT, s(), 0),
      D)
    ) {
      case '@':
        return (P.next(), (B = h(k, 7, '@')), (k.inLinked = !0), B)
      case '.':
        return (y(P), P.next(), h(k, 8, '.'))
      case ':':
        return (y(P), P.next(), h(k, 9, ':'))
      default:
        return M(P)
          ? ((B = h(k, 1, re(P))), (k.braceNest = 0), (k.inLinked = !1), B)
          : C(P, k) || R(P, k)
            ? (y(P), oe(P, k))
            : A(P, k)
              ? (y(P), h(k, 11, it(P)))
              : w(P, k)
                ? (y(P), D === '{' ? b(P, k) || B : h(k, 10, te(P)))
                : (j === 7 && d(en.INVALID_LINKED_FORMAT, s(), 0),
                  (k.braceNest = 0),
                  (k.inLinked = !1),
                  J(P, k))
    }
  }
  function J(P, k) {
    let j = { type: 13 }
    if (k.braceNest > 0) return b(P, k) || f(k)
    if (k.inLinked) return oe(P, k) || f(k)
    switch (P.currentChar()) {
      case '{':
        return b(P, k) || f(k)
      case '}':
        return (d(en.UNBALANCED_CLOSING_BRACE, s(), 0), P.next(), h(k, 3, '}'))
      case '@':
        return oe(P, k) || f(k)
      default: {
        if (M(P)) return ((j = h(k, 1, re(P))), (k.braceNest = 0), (k.inLinked = !1), j)
        if (I(P)) return h(k, 0, ie(P))
        break
      }
    }
    return j
  }
  function H() {
    const { currentType: P, offset: k, startLoc: j, endLoc: B } = l
    return (
      (l.lastType = P),
      (l.lastOffset = k),
      (l.lastStartLoc = j),
      (l.lastEndLoc = B),
      (l.offset = r()),
      (l.startLoc = s()),
      i.currentChar() === bo ? h(l, 13) : J(i, l)
    )
  }
  return { nextToken: H, currentOffset: r, currentPosition: s, context: c }
}
const Kee = 'parser',
  Yee = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g
function Zee(n, e, t) {
  switch (n) {
    case '\\\\':
      return '\\'
    case "\\'":
      return "'"
    default: {
      const i = parseInt(e || t, 16)
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : '�'
    }
  }
}
function Jee(n = {}) {
  const e = n.location !== !1,
    { onError: t } = n
  function i(m, v, x, _, ...S) {
    const C = m.currentPosition()
    if (((C.offset += _), (C.column += _), t)) {
      const A = e ? Lv(x, C) : null,
        R = V0(v, A, { domain: Kee, args: S })
      t(R)
    }
  }
  function r(m, v, x) {
    const _ = { type: m }
    return (e && ((_.start = v), (_.end = v), (_.loc = { start: x, end: x })), _)
  }
  function s(m, v, x, _) {
    e && ((m.end = v), m.loc && (m.loc.end = x))
  }
  function o(m, v) {
    const x = m.context(),
      _ = r(3, x.offset, x.startLoc)
    return ((_.value = v), s(_, m.currentOffset(), m.currentPosition()), _)
  }
  function a(m, v) {
    const x = m.context(),
      { lastOffset: _, lastStartLoc: S } = x,
      C = r(5, _, S)
    return (
      (C.index = parseInt(v, 10)),
      m.nextToken(),
      s(C, m.currentOffset(), m.currentPosition()),
      C
    )
  }
  function l(m, v) {
    const x = m.context(),
      { lastOffset: _, lastStartLoc: S } = x,
      C = r(4, _, S)
    return ((C.key = v), m.nextToken(), s(C, m.currentOffset(), m.currentPosition()), C)
  }
  function c(m, v) {
    const x = m.context(),
      { lastOffset: _, lastStartLoc: S } = x,
      C = r(9, _, S)
    return (
      (C.value = v.replace(Yee, Zee)),
      m.nextToken(),
      s(C, m.currentOffset(), m.currentPosition()),
      C
    )
  }
  function u(m) {
    const v = m.nextToken(),
      x = m.context(),
      { lastOffset: _, lastStartLoc: S } = x,
      C = r(8, _, S)
    return v.type !== 11
      ? (i(m, en.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0),
        (C.value = ''),
        s(C, _, S),
        { nextConsumeToken: v, node: C })
      : (v.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, Ds(v)),
        (C.value = v.value || ''),
        s(C, m.currentOffset(), m.currentPosition()),
        { node: C })
  }
  function d(m, v) {
    const x = m.context(),
      _ = r(7, x.offset, x.startLoc)
    return ((_.value = v), s(_, m.currentOffset(), m.currentPosition()), _)
  }
  function h(m) {
    const v = m.context(),
      x = r(6, v.offset, v.startLoc)
    let _ = m.nextToken()
    if (_.type === 8) {
      const S = u(m)
      ;((x.modifier = S.node), (_ = S.nextConsumeToken || m.nextToken()))
    }
    switch (
      (_.type !== 9 && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(_)),
      (_ = m.nextToken()),
      _.type === 2 && (_ = m.nextToken()),
      _.type)
    ) {
      case 10:
        ;(_.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(_)),
          (x.key = d(m, _.value || '')))
        break
      case 4:
        ;(_.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(_)),
          (x.key = l(m, _.value || '')))
        break
      case 5:
        ;(_.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(_)),
          (x.key = a(m, _.value || '')))
        break
      case 6:
        ;(_.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(_)),
          (x.key = c(m, _.value || '')))
        break
      default: {
        i(m, en.UNEXPECTED_EMPTY_LINKED_KEY, v.lastStartLoc, 0)
        const S = m.context(),
          C = r(7, S.offset, S.startLoc)
        return (
          (C.value = ''),
          s(C, S.offset, S.startLoc),
          (x.key = C),
          s(x, S.offset, S.startLoc),
          { nextConsumeToken: _, node: x }
        )
      }
    }
    return (s(x, m.currentOffset(), m.currentPosition()), { node: x })
  }
  function f(m) {
    const v = m.context(),
      x = v.currentType === 1 ? m.currentOffset() : v.offset,
      _ = v.currentType === 1 ? v.endLoc : v.startLoc,
      S = r(2, x, _)
    S.items = []
    let C = null
    do {
      const w = C || m.nextToken()
      switch (((C = null), w.type)) {
        case 0:
          ;(w.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(w)),
            S.items.push(o(m, w.value || '')))
          break
        case 5:
          ;(w.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(w)),
            S.items.push(a(m, w.value || '')))
          break
        case 4:
          ;(w.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(w)),
            S.items.push(l(m, w.value || '')))
          break
        case 6:
          ;(w.value == null && i(m, en.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Ds(w)),
            S.items.push(c(m, w.value || '')))
          break
        case 7: {
          const M = h(m)
          ;(S.items.push(M.node), (C = M.nextConsumeToken || null))
          break
        }
      }
    } while (v.currentType !== 13 && v.currentType !== 1)
    const A = v.currentType === 1 ? v.lastOffset : m.currentOffset(),
      R = v.currentType === 1 ? v.lastEndLoc : m.currentPosition()
    return (s(S, A, R), S)
  }
  function p(m, v, x, _) {
    const S = m.context()
    let C = _.items.length === 0
    const A = r(1, v, x)
    ;((A.cases = []), A.cases.push(_))
    do {
      const R = f(m)
      ;(C || (C = R.items.length === 0), A.cases.push(R))
    } while (S.currentType !== 13)
    return (
      C && i(m, en.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0),
      s(A, m.currentOffset(), m.currentPosition()),
      A
    )
  }
  function g(m) {
    const v = m.context(),
      { offset: x, startLoc: _ } = v,
      S = f(m)
    return v.currentType === 13 ? S : p(m, x, _, S)
  }
  function y(m) {
    const v = Xee(m, ei({}, n)),
      x = v.context(),
      _ = r(0, x.offset, x.startLoc)
    return (
      e && _.loc && (_.loc.source = m),
      (_.body = g(v)),
      n.onCacheKey && (_.cacheKey = n.onCacheKey(m)),
      x.currentType !== 13 &&
        i(v, en.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, m[x.offset] || ''),
      s(_, v.currentOffset(), v.currentPosition()),
      _
    )
  }
  return { parse: y }
}
function Ds(n) {
  if (n.type === 13) return 'EOF'
  const e = (n.value || '').replace(/\r?\n/gu, '\\n')
  return e.length > 10 ? e.slice(0, 9) + '…' : e
}
function ete(n, e = {}) {
  const t = { ast: n, helpers: new Set() }
  return { context: () => t, helper: (s) => (t.helpers.add(s), s) }
}
function sT(n, e) {
  for (let t = 0; t < n.length; t++) l2(n[t], e)
}
function l2(n, e) {
  switch (n.type) {
    case 1:
      ;(sT(n.cases, e), e.helper('plural'))
      break
    case 2:
      sT(n.items, e)
      break
    case 6: {
      ;(l2(n.key, e), e.helper('linked'), e.helper('type'))
      break
    }
    case 5:
      ;(e.helper('interpolate'), e.helper('list'))
      break
    case 4:
      ;(e.helper('interpolate'), e.helper('named'))
      break
  }
}
function tte(n, e = {}) {
  const t = ete(n)
  ;(t.helper('normalize'), n.body && l2(n.body, t))
  const i = t.context()
  n.helpers = Array.from(i.helpers)
}
function nte(n) {
  const e = n.body
  return (e.type === 2 ? oT(e) : e.cases.forEach((t) => oT(t)), n)
}
function oT(n) {
  if (n.items.length === 1) {
    const e = n.items[0]
    ;(e.type === 3 || e.type === 9) && ((n.static = e.value), delete e.value)
  } else {
    const e = []
    for (let t = 0; t < n.items.length; t++) {
      const i = n.items[t]
      if (!(i.type === 3 || i.type === 9) || i.value == null) break
      e.push(i.value)
    }
    if (e.length === n.items.length) {
      n.static = a2(e)
      for (let t = 0; t < n.items.length; t++) {
        const i = n.items[t]
        ;(i.type === 3 || i.type === 9) && delete i.value
      }
    }
  }
}
function Nc(n) {
  switch (((n.t = n.type), n.type)) {
    case 0: {
      const e = n
      ;(Nc(e.body), (e.b = e.body), delete e.body)
      break
    }
    case 1: {
      const e = n,
        t = e.cases
      for (let i = 0; i < t.length; i++) Nc(t[i])
      ;((e.c = t), delete e.cases)
      break
    }
    case 2: {
      const e = n,
        t = e.items
      for (let i = 0; i < t.length; i++) Nc(t[i])
      ;((e.i = t), delete e.items, e.static && ((e.s = e.static), delete e.static))
      break
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = n
      e.value && ((e.v = e.value), delete e.value)
      break
    }
    case 6: {
      const e = n
      ;(Nc(e.key),
        (e.k = e.key),
        delete e.key,
        e.modifier && (Nc(e.modifier), (e.m = e.modifier), delete e.modifier))
      break
    }
    case 5: {
      const e = n
      ;((e.i = e.index), delete e.index)
      break
    }
    case 4: {
      const e = n
      ;((e.k = e.key), delete e.key)
      break
    }
  }
  delete n.type
}
function ite(n, e) {
  const { filename: t, breakLineCode: i, needIndent: r } = e,
    s = e.location !== !1,
    o = {
      filename: t,
      code: '',
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: i,
      needIndent: r,
      indentLevel: 0,
    }
  s && n.loc && (o.source = n.loc.source)
  const a = () => o
  function l(g, y) {
    o.code += g
  }
  function c(g, y = !0) {
    const m = y ? i : ''
    l(r ? m + '  '.repeat(g) : m)
  }
  function u(g = !0) {
    const y = ++o.indentLevel
    g && c(y)
  }
  function d(g = !0) {
    const y = --o.indentLevel
    g && c(y)
  }
  function h() {
    c(o.indentLevel)
  }
  return {
    context: a,
    push: l,
    indent: u,
    deindent: d,
    newline: h,
    helper: (g) => '_'.concat(g),
    needIndent: () => o.needIndent,
  }
}
function rte(n, e) {
  const { helper: t } = n
  ;(n.push(''.concat(t('linked'), '(')),
    Iu(n, e.key),
    e.modifier
      ? (n.push(', '), Iu(n, e.modifier), n.push(', _type'))
      : n.push(', undefined, _type'),
    n.push(')'))
}
function ste(n, e) {
  const { helper: t, needIndent: i } = n
  ;(n.push(''.concat(t('normalize'), '([')), n.indent(i()))
  const r = e.items.length
  for (let s = 0; s < r && (Iu(n, e.items[s]), s !== r - 1); s++) n.push(', ')
  ;(n.deindent(i()), n.push('])'))
}
function ote(n, e) {
  const { helper: t, needIndent: i } = n
  if (e.cases.length > 1) {
    ;(n.push(''.concat(t('plural'), '([')), n.indent(i()))
    const r = e.cases.length
    for (let s = 0; s < r && (Iu(n, e.cases[s]), s !== r - 1); s++) n.push(', ')
    ;(n.deindent(i()), n.push('])'))
  }
}
function ate(n, e) {
  e.body ? Iu(n, e.body) : n.push('null')
}
function Iu(n, e) {
  const { helper: t } = n
  switch (e.type) {
    case 0:
      ate(n, e)
      break
    case 1:
      ote(n, e)
      break
    case 2:
      ste(n, e)
      break
    case 6:
      rte(n, e)
      break
    case 8:
      n.push(JSON.stringify(e.value), e)
      break
    case 7:
      n.push(JSON.stringify(e.value), e)
      break
    case 5:
      n.push(''.concat(t('interpolate'), '(').concat(t('list'), '(').concat(e.index, '))'), e)
      break
    case 4:
      n.push(
        ''
          .concat(t('interpolate'), '(')
          .concat(t('named'), '(')
          .concat(JSON.stringify(e.key), '))'),
        e
      )
      break
    case 9:
      n.push(JSON.stringify(e.value), e)
      break
    case 3:
      n.push(JSON.stringify(e.value), e)
      break
  }
}
const lte = (n, e = {}) => {
  const t = st(e.mode) ? e.mode : 'normal',
    i = st(e.filename) ? e.filename : 'message.intl'
  e.sourceMap
  const r = e.breakLineCode != null ? e.breakLineCode : t === 'arrow' ? ';' : '\n',
    s = e.needIndent ? e.needIndent : t !== 'arrow',
    o = n.helpers || [],
    a = ite(n, { filename: i, breakLineCode: r, needIndent: s })
  ;(a.push(t === 'normal' ? 'function __msg__ (ctx) {' : '(ctx) => {'),
    a.indent(s),
    o.length > 0 &&
      (a.push(
        'const { '.concat(
          a2(
            o.map((u) => ''.concat(u, ': _').concat(u)),
            ', '
          ),
          ' } = ctx'
        )
      ),
      a.newline()),
    a.push('return '),
    Iu(a, n),
    a.deindent(s),
    a.push('}'),
    delete n.helpers)
  const { code: l, map: c } = a.context()
  return { ast: n, code: l, map: c ? c.toJSON() : void 0 }
}
function cte(n, e = {}) {
  const t = ei({}, e),
    i = !!t.jit,
    r = !!t.minify,
    s = t.optimize == null ? !0 : t.optimize,
    a = Jee(t).parse(n)
  return i ? (s && nte(a), r && Nc(a), { ast: a, code: '' }) : (tte(a, t), lte(a, t))
}
/*!
 * core-base v11.1.12
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */ function ute() {
  ;(typeof __INTLIFY_PROD_DEVTOOLS__ != 'boolean' && (Ml().__INTLIFY_PROD_DEVTOOLS__ = !1),
    typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != 'boolean' &&
      (Ml().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1))
}
function Ys(n) {
  return jt(n) && c2(n) === 0 && (ys(n, 'b') || ys(n, 'body'))
}
const UR = ['b', 'body']
function dte(n) {
  return ja(n, UR)
}
const kR = ['c', 'cases']
function hte(n) {
  return ja(n, kR, [])
}
const zR = ['s', 'static']
function fte(n) {
  return ja(n, zR)
}
const VR = ['i', 'items']
function pte(n) {
  return ja(n, VR, [])
}
const HR = ['t', 'type']
function c2(n) {
  return ja(n, HR)
}
const $R = ['v', 'value']
function yp(n, e) {
  const t = ja(n, $R)
  if (t != null) return t
  throw wh(e)
}
const GR = ['m', 'modifier']
function mte(n) {
  return ja(n, GR)
}
const WR = ['k', 'key']
function gte(n) {
  const e = ja(n, WR)
  if (e) return e
  throw wh(6)
}
function ja(n, e, t) {
  for (let i = 0; i < e.length; i++) {
    const r = e[i]
    if (ys(n, r) && n[r] != null) return n[r]
  }
  return t
}
const QR = [...UR, ...kR, ...zR, ...VR, ...WR, ...GR, ...$R, ...HR]
function wh(n) {
  return new Error('unhandled node type: '.concat(n))
}
function B1(n) {
  return (t) => yte(t, n)
}
function yte(n, e) {
  const t = dte(e)
  if (t == null) throw wh(0)
  if (c2(t) === 1) {
    const s = hte(t)
    return n.plural(s.reduce((o, a) => [...o, aT(n, a)], []))
  } else return aT(n, t)
}
function aT(n, e) {
  const t = fte(e)
  if (t != null) return n.type === 'text' ? t : n.normalize([t])
  {
    const i = pte(e).reduce((r, s) => [...r, Dv(n, s)], [])
    return n.normalize(i)
  }
}
function Dv(n, e) {
  const t = c2(e)
  switch (t) {
    case 3:
      return yp(e, t)
    case 9:
      return yp(e, t)
    case 4: {
      const i = e
      if (ys(i, 'k') && i.k) return n.interpolate(n.named(i.k))
      if (ys(i, 'key') && i.key) return n.interpolate(n.named(i.key))
      throw wh(t)
    }
    case 5: {
      const i = e
      if (ys(i, 'i') && Gn(i.i)) return n.interpolate(n.list(i.i))
      if (ys(i, 'index') && Gn(i.index)) return n.interpolate(n.list(i.index))
      throw wh(t)
    }
    case 6: {
      const i = e,
        r = mte(i),
        s = gte(i)
      return n.linked(Dv(n, s), r ? Dv(n, r) : void 0, n.type)
    }
    case 7:
      return yp(e, t)
    case 8:
      return yp(e, t)
    default:
      throw new Error('unhandled node on format message part: '.concat(t))
  }
}
const vte = (n) => n
let vp = dn()
function _te(n, e = {}) {
  let t = !1
  const i = e.onError || Hee
  return (
    (e.onError = (r) => {
      ;((t = !0), i(r))
    }),
    { ...cte(n, e), detectError: t }
  )
}
function xte(n, e) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && st(n)) {
    $t(e.warnHtmlMessage) && e.warnHtmlMessage
    const i = (e.onCacheKey || vte)(n),
      r = vp[i]
    if (r) return r
    const { ast: s, detectError: o } = _te(n, { ...e, location: !1, jit: !0 }),
      a = B1(s)
    return o ? a : (vp[i] = a)
  } else {
    const t = n.cacheKey
    if (t) {
      const i = vp[t]
      return i || (vp[t] = B1(n))
    } else return B1(n)
  }
}
let Ch = null
function Ste(n) {
  Ch = n
}
function Ate(n, e, t) {
  Ch && Ch.emit('i18n:init', { timestamp: Date.now(), i18n: n, version: e, meta: t })
}
const bte = Tte('function:translate')
function Tte(n) {
  return (e) => Ch && Ch.emit(n, e)
}
const Bo = {
    INVALID_ARGUMENT: Vee,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23,
  },
  wte = 24
function Uo(n) {
  return V0(n, null, void 0)
}
function u2(n, e) {
  return e.locale != null ? lT(e.locale) : lT(n.locale)
}
let U1
function lT(n) {
  if (st(n)) return n
  if (yn(n)) {
    if (n.resolvedOnce && U1 != null) return U1
    if (n.constructor.name === 'Function') {
      const e = n()
      if (Uee(e)) throw Uo(Bo.NOT_SUPPORT_LOCALE_PROMISE_VALUE)
      return (U1 = e)
    } else throw Uo(Bo.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
  } else throw Uo(Bo.NOT_SUPPORT_LOCALE_TYPE)
}
function Cte(n, e, t) {
  return [...new Set([t, ...(In(e) ? e : jt(e) ? Object.keys(e) : st(e) ? [e] : [t])])]
}
function jR(n, e, t) {
  const i = st(t) ? t : Eh,
    r = n
  r.__localeChainCache || (r.__localeChainCache = new Map())
  let s = r.__localeChainCache.get(i)
  if (!s) {
    s = []
    let o = [t]
    for (; In(o); ) o = cT(s, o, e)
    const a = In(e) || !Lt(e) ? e : e.default ? e.default : null
    ;((o = st(a) ? [a] : a), In(o) && cT(s, o, !1), r.__localeChainCache.set(i, s))
  }
  return s
}
function cT(n, e, t) {
  let i = !0
  for (let r = 0; r < e.length && $t(i); r++) {
    const s = e[r]
    st(s) && (i = Ete(n, e[r], t))
  }
  return i
}
function Ete(n, e, t) {
  let i
  const r = e.split('-')
  do {
    const s = r.join('-')
    ;((i = Mte(n, s, t)), r.splice(-1, 1))
  } while (r.length && i === !0)
  return i
}
function Mte(n, e, t) {
  let i = !1
  if (!n.includes(e) && ((i = !0), e)) {
    i = e[e.length - 1] !== '!'
    const r = e.replace(/!/g, '')
    ;(n.push(r), (In(t) || Lt(t)) && t[r] && (i = t[r]))
  }
  return i
}
const qa = []
qa[0] = { w: [0], i: [3, 0], '[': [4], o: [7] }
qa[1] = { w: [1], '.': [2], '[': [4], o: [7] }
qa[2] = { w: [2], i: [3, 0], 0: [3, 0] }
qa[3] = { i: [3, 0], 0: [3, 0], w: [1, 1], '.': [2, 1], '[': [4, 1], o: [7, 1] }
qa[4] = { "'": [5, 0], '"': [6, 0], '[': [4, 2], ']': [1, 3], o: 8, l: [4, 0] }
qa[5] = { "'": [4, 0], o: 8, l: [5, 0] }
qa[6] = { '"': [4, 0], o: 8, l: [6, 0] }
const Rte = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/
function Ite(n) {
  return Rte.test(n)
}
function Nte(n) {
  const e = n.charCodeAt(0),
    t = n.charCodeAt(n.length - 1)
  return e === t && (e === 34 || e === 39) ? n.slice(1, -1) : n
}
function Pte(n) {
  if (n == null) return 'o'
  switch (n.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return n
    case 95:
    case 36:
    case 45:
      return 'i'
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return 'w'
  }
  return 'i'
}
function Lte(n) {
  const e = n.trim()
  return n.charAt(0) === '0' && isNaN(parseInt(n)) ? !1 : Ite(e) ? Nte(e) : '*' + e
}
function Dte(n) {
  const e = []
  let t = -1,
    i = 0,
    r = 0,
    s,
    o,
    a,
    l,
    c,
    u,
    d
  const h = []
  ;((h[0] = () => {
    o === void 0 ? (o = a) : (o += a)
  }),
    (h[1] = () => {
      o !== void 0 && (e.push(o), (o = void 0))
    }),
    (h[2] = () => {
      ;(h[0](), r++)
    }),
    (h[3] = () => {
      if (r > 0) (r--, (i = 4), h[0]())
      else {
        if (((r = 0), o === void 0 || ((o = Lte(o)), o === !1))) return !1
        h[1]()
      }
    }))
  function f() {
    const p = n[t + 1]
    if ((i === 5 && p === "'") || (i === 6 && p === '"')) return (t++, (a = '\\' + p), h[0](), !0)
  }
  for (; i !== null; )
    if ((t++, (s = n[t]), !(s === '\\' && f()))) {
      if (
        ((l = Pte(s)),
        (d = qa[i]),
        (c = d[l] || d.l || 8),
        c === 8 || ((i = c[0]), c[1] !== void 0 && ((u = h[c[1]]), u && ((a = s), u() === !1))))
      )
        return
      if (i === 7) return e
    }
}
const uT = new Map()
function Fte(n, e) {
  return jt(n) ? n[e] : null
}
function Ote(n, e) {
  if (!jt(n)) return null
  let t = uT.get(e)
  if ((t || ((t = Dte(e)), t && uT.set(e, t)), !t)) return null
  const i = t.length
  let r = n,
    s = 0
  for (; s < i; ) {
    const o = t[s]
    if (QR.includes(o) && Ys(r)) return null
    const a = r[o]
    if (a === void 0 || yn(r)) return null
    ;((r = a), s++)
  }
  return r
}
const Bte = '11.1.12',
  H0 = -1,
  Eh = 'en-US',
  dT = '',
  hT = (n) => ''.concat(n.charAt(0).toLocaleUpperCase()).concat(n.substr(1))
function Ute() {
  return {
    upper: (n, e) =>
      e === 'text' && st(n)
        ? n.toUpperCase()
        : e === 'vnode' && jt(n) && '__v_isVNode' in n
          ? n.children.toUpperCase()
          : n,
    lower: (n, e) =>
      e === 'text' && st(n)
        ? n.toLowerCase()
        : e === 'vnode' && jt(n) && '__v_isVNode' in n
          ? n.children.toLowerCase()
          : n,
    capitalize: (n, e) =>
      e === 'text' && st(n)
        ? hT(n)
        : e === 'vnode' && jt(n) && '__v_isVNode' in n
          ? hT(n.children)
          : n,
  }
}
let qR
function kte(n) {
  qR = n
}
let XR
function zte(n) {
  XR = n
}
let KR
function Vte(n) {
  KR = n
}
let YR = null
const Hte = (n) => {
    YR = n
  },
  $te = () => YR
let ZR = null
const fT = (n) => {
    ZR = n
  },
  Gte = () => ZR
let pT = 0
function Wte(n = {}) {
  const e = yn(n.onWarn) ? n.onWarn : Nee,
    t = st(n.version) ? n.version : Bte,
    i = st(n.locale) || yn(n.locale) ? n.locale : Eh,
    r = yn(i) ? Eh : i,
    s =
      In(n.fallbackLocale) ||
      Lt(n.fallbackLocale) ||
      st(n.fallbackLocale) ||
      n.fallbackLocale === !1
        ? n.fallbackLocale
        : r,
    o = Lt(n.messages) ? n.messages : k1(r),
    a = Lt(n.datetimeFormats) ? n.datetimeFormats : k1(r),
    l = Lt(n.numberFormats) ? n.numberFormats : k1(r),
    c = ei(dn(), n.modifiers, Ute()),
    u = n.pluralRules || dn(),
    d = yn(n.missing) ? n.missing : null,
    h = $t(n.missingWarn) || Ru(n.missingWarn) ? n.missingWarn : !0,
    f = $t(n.fallbackWarn) || Ru(n.fallbackWarn) ? n.fallbackWarn : !0,
    p = !!n.fallbackFormat,
    g = !!n.unresolving,
    y = yn(n.postTranslation) ? n.postTranslation : null,
    m = Lt(n.processor) ? n.processor : null,
    v = $t(n.warnHtmlMessage) ? n.warnHtmlMessage : !0,
    x = !!n.escapeParameter,
    _ = yn(n.messageCompiler) ? n.messageCompiler : qR,
    S = yn(n.messageResolver) ? n.messageResolver : XR || Fte,
    C = yn(n.localeFallbacker) ? n.localeFallbacker : KR || Cte,
    A = jt(n.fallbackContext) ? n.fallbackContext : void 0,
    R = n,
    w = jt(R.__datetimeFormatters) ? R.__datetimeFormatters : new Map(),
    M = jt(R.__numberFormatters) ? R.__numberFormatters : new Map(),
    I = jt(R.__meta) ? R.__meta : {}
  pT++
  const L = {
    version: t,
    cid: pT,
    locale: i,
    fallbackLocale: s,
    messages: o,
    modifiers: c,
    pluralRules: u,
    missing: d,
    missingWarn: h,
    fallbackWarn: f,
    fallbackFormat: p,
    unresolving: g,
    postTranslation: y,
    processor: m,
    warnHtmlMessage: v,
    escapeParameter: x,
    messageCompiler: _,
    messageResolver: S,
    localeFallbacker: C,
    fallbackContext: A,
    onWarn: e,
    __meta: I,
  }
  return (
    (L.datetimeFormats = a),
    (L.numberFormats = l),
    (L.__datetimeFormatters = w),
    (L.__numberFormatters = M),
    __INTLIFY_PROD_DEVTOOLS__ && Ate(L, t, I),
    L
  )
}
const k1 = (n) => ({ [n]: dn() })
function d2(n, e, t, i, r) {
  const { missing: s, onWarn: o } = n
  if (s !== null) {
    const a = s(n, t, e, r)
    return st(a) ? a : e
  } else return e
}
function Ad(n, e, t) {
  const i = n
  ;((i.__localeChainCache = new Map()), n.localeFallbacker(n, t, e))
}
function Qte(n, e) {
  return n === e ? !1 : n.split('-')[0] === e.split('-')[0]
}
function jte(n, e) {
  const t = e.indexOf(n)
  if (t === -1) return !1
  for (let i = t + 1; i < e.length; i++) if (Qte(n, e[i])) return !0
  return !1
}
function mT(n, ...e) {
  const {
      datetimeFormats: t,
      unresolving: i,
      fallbackLocale: r,
      onWarn: s,
      localeFallbacker: o,
    } = n,
    { __datetimeFormatters: a } = n,
    [l, c, u, d] = Fv(...e),
    h = $t(u.missingWarn) ? u.missingWarn : n.missingWarn
  $t(u.fallbackWarn) ? u.fallbackWarn : n.fallbackWarn
  const f = !!u.part,
    p = u2(n, u),
    g = o(n, r, p)
  if (!st(l) || l === '') return new Intl.DateTimeFormat(p, d).format(c)
  let y = {},
    m,
    v = null
  const x = 'datetime format'
  for (let C = 0; C < g.length && ((m = g[C]), (y = t[m] || {}), (v = y[l]), !Lt(v)); C++)
    d2(n, l, m, h, x)
  if (!Lt(v) || !st(m)) return i ? H0 : l
  let _ = ''.concat(m, '__').concat(l)
  z0(d) || (_ = ''.concat(_, '__').concat(JSON.stringify(d)))
  let S = a.get(_)
  return (
    S || ((S = new Intl.DateTimeFormat(m, ei({}, v, d))), a.set(_, S)),
    f ? S.formatToParts(c) : S.format(c)
  )
}
const JR = [
  'localeMatcher',
  'weekday',
  'era',
  'year',
  'month',
  'day',
  'hour',
  'minute',
  'second',
  'timeZoneName',
  'formatMatcher',
  'hour12',
  'timeZone',
  'dateStyle',
  'timeStyle',
  'calendar',
  'dayPeriod',
  'numberingSystem',
  'hourCycle',
  'fractionalSecondDigits',
]
function Fv(...n) {
  const [e, t, i, r] = n,
    s = dn()
  let o = dn(),
    a
  if (st(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/)
    if (!l) throw Uo(Bo.INVALID_ISO_DATE_ARGUMENT)
    const c = l[3]
      ? l[3].trim().startsWith('T')
        ? ''.concat(l[1].trim()).concat(l[3].trim())
        : ''.concat(l[1].trim(), 'T').concat(l[3].trim())
      : l[1].trim()
    a = new Date(c)
    try {
      a.toISOString()
    } catch (u) {
      throw Uo(Bo.INVALID_ISO_DATE_ARGUMENT)
    }
  } else if (Dee(e)) {
    if (isNaN(e.getTime())) throw Uo(Bo.INVALID_DATE_ARGUMENT)
    a = e
  } else if (Gn(e)) a = e
  else throw Uo(Bo.INVALID_ARGUMENT)
  return (
    st(t)
      ? (s.key = t)
      : Lt(t) &&
        Object.keys(t).forEach((l) => {
          JR.includes(l) ? (o[l] = t[l]) : (s[l] = t[l])
        }),
    st(i) ? (s.locale = i) : Lt(i) && (o = i),
    Lt(r) && (o = r),
    [s.key || '', a, s, o]
  )
}
function gT(n, e, t) {
  const i = n
  for (const r in t) {
    const s = ''.concat(e, '__').concat(r)
    i.__datetimeFormatters.has(s) && i.__datetimeFormatters.delete(s)
  }
}
function yT(n, ...e) {
  const { numberFormats: t, unresolving: i, fallbackLocale: r, onWarn: s, localeFallbacker: o } = n,
    { __numberFormatters: a } = n,
    [l, c, u, d] = Ov(...e),
    h = $t(u.missingWarn) ? u.missingWarn : n.missingWarn
  $t(u.fallbackWarn) ? u.fallbackWarn : n.fallbackWarn
  const f = !!u.part,
    p = u2(n, u),
    g = o(n, r, p)
  if (!st(l) || l === '') return new Intl.NumberFormat(p, d).format(c)
  let y = {},
    m,
    v = null
  const x = 'number format'
  for (let C = 0; C < g.length && ((m = g[C]), (y = t[m] || {}), (v = y[l]), !Lt(v)); C++)
    d2(n, l, m, h, x)
  if (!Lt(v) || !st(m)) return i ? H0 : l
  let _ = ''.concat(m, '__').concat(l)
  z0(d) || (_ = ''.concat(_, '__').concat(JSON.stringify(d)))
  let S = a.get(_)
  return (
    S || ((S = new Intl.NumberFormat(m, ei({}, v, d))), a.set(_, S)),
    f ? S.formatToParts(c) : S.format(c)
  )
}
const eI = [
  'localeMatcher',
  'style',
  'currency',
  'currencyDisplay',
  'currencySign',
  'useGrouping',
  'minimumIntegerDigits',
  'minimumFractionDigits',
  'maximumFractionDigits',
  'minimumSignificantDigits',
  'maximumSignificantDigits',
  'compactDisplay',
  'notation',
  'signDisplay',
  'unit',
  'unitDisplay',
  'roundingMode',
  'roundingPriority',
  'roundingIncrement',
  'trailingZeroDisplay',
]
function Ov(...n) {
  const [e, t, i, r] = n,
    s = dn()
  let o = dn()
  if (!Gn(e)) throw Uo(Bo.INVALID_ARGUMENT)
  const a = e
  return (
    st(t)
      ? (s.key = t)
      : Lt(t) &&
        Object.keys(t).forEach((l) => {
          eI.includes(l) ? (o[l] = t[l]) : (s[l] = t[l])
        }),
    st(i) ? (s.locale = i) : Lt(i) && (o = i),
    Lt(r) && (o = r),
    [s.key || '', a, s, o]
  )
}
function vT(n, e, t) {
  const i = n
  for (const r in t) {
    const s = ''.concat(e, '__').concat(r)
    i.__numberFormatters.has(s) && i.__numberFormatters.delete(s)
  }
}
const qte = (n) => n,
  Xte = (n) => '',
  Kte = 'text',
  Yte = (n) => (n.length === 0 ? '' : a2(n)),
  Zte = kee
function _T(n, e) {
  return ((n = Math.abs(n)), e === 2 ? (n ? (n > 1 ? 1 : 0) : 1) : n ? Math.min(n, 2) : 0)
}
function Jte(n) {
  const e = Gn(n.pluralIndex) ? n.pluralIndex : -1
  return n.named && (Gn(n.named.count) || Gn(n.named.n))
    ? Gn(n.named.count)
      ? n.named.count
      : Gn(n.named.n)
        ? n.named.n
        : e
    : e
}
function ene(n, e) {
  ;(e.count || (e.count = n), e.n || (e.n = n))
}
function tne(n = {}) {
  const e = n.locale,
    t = Jte(n),
    i = jt(n.pluralRules) && st(e) && yn(n.pluralRules[e]) ? n.pluralRules[e] : _T,
    r = jt(n.pluralRules) && st(e) && yn(n.pluralRules[e]) ? _T : void 0,
    s = (m) => m[i(t, m.length, r)],
    o = n.list || [],
    a = (m) => o[m],
    l = n.named || dn()
  Gn(n.pluralIndex) && ene(t, l)
  const c = (m) => l[m]
  function u(m, v) {
    const x = yn(n.messages) ? n.messages(m, !!v) : jt(n.messages) ? n.messages[m] : !1
    return x || (n.parent ? n.parent.message(m) : Xte)
  }
  const d = (m) => (n.modifiers ? n.modifiers[m] : qte),
    h = Lt(n.processor) && yn(n.processor.normalize) ? n.processor.normalize : Yte,
    f = Lt(n.processor) && yn(n.processor.interpolate) ? n.processor.interpolate : Zte,
    p = Lt(n.processor) && st(n.processor.type) ? n.processor.type : Kte,
    y = {
      list: a,
      named: c,
      plural: s,
      linked: (m, ...v) => {
        const [x, _] = v
        let S = 'text',
          C = ''
        v.length === 1
          ? jt(x)
            ? ((C = x.modifier || C), (S = x.type || S))
            : st(x) && (C = x || C)
          : v.length === 2 && (st(x) && (C = x || C), st(_) && (S = _ || S))
        const A = u(m, !0)(y),
          R = S === 'vnode' && In(A) && C ? A[0] : A
        return C ? d(C)(R, S) : R
      },
      message: u,
      type: p,
      interpolate: f,
      normalize: h,
      values: ei(dn(), o, l),
    }
  return y
}
const xT = () => '',
  Xr = (n) => yn(n)
function ST(n, ...e) {
  const {
      fallbackFormat: t,
      postTranslation: i,
      unresolving: r,
      messageCompiler: s,
      fallbackLocale: o,
      messages: a,
    } = n,
    [l, c] = Bv(...e),
    u = $t(c.missingWarn) ? c.missingWarn : n.missingWarn,
    d = $t(c.fallbackWarn) ? c.fallbackWarn : n.fallbackWarn,
    h = $t(c.escapeParameter) ? c.escapeParameter : n.escapeParameter,
    f = !!c.resolvedMessage,
    p =
      st(c.default) || $t(c.default)
        ? $t(c.default)
          ? s
            ? l
            : () => l
          : c.default
        : t
          ? s
            ? l
            : () => l
          : null,
    g = t || (p != null && (st(p) || yn(p))),
    y = u2(n, c)
  h && nne(c)
  let [m, v, x] = f ? [l, y, a[y] || dn()] : tI(n, l, y, o, d, u),
    _ = m,
    S = l
  if (
    (!f && !(st(_) || Ys(_) || Xr(_)) && g && ((_ = p), (S = _)),
    !f && (!(st(_) || Ys(_) || Xr(_)) || !st(v)))
  )
    return r ? H0 : l
  let C = !1
  const A = () => {
      C = !0
    },
    R = Xr(_) ? _ : nI(n, l, v, _, S, A)
  if (C) return _
  const w = sne(n, v, x, c),
    M = tne(w),
    I = ine(n, R, M)
  let L = i ? i(I, l) : I
  if ((h && st(L) && (L = Oee(L)), __INTLIFY_PROD_DEVTOOLS__)) {
    const U = {
      timestamp: Date.now(),
      key: st(l) ? l : Xr(_) ? _.key : '',
      locale: v || (Xr(_) ? _.locale : ''),
      format: st(_) ? _ : Xr(_) ? _.source : '',
      message: L,
    }
    ;((U.meta = ei({}, n.__meta, $te() || {})), bte(U))
  }
  return L
}
function nne(n) {
  In(n.list)
    ? (n.list = n.list.map((e) => (st(e) ? nT(e) : e)))
    : jt(n.named) &&
      Object.keys(n.named).forEach((e) => {
        st(n.named[e]) && (n.named[e] = nT(n.named[e]))
      })
}
function tI(n, e, t, i, r, s) {
  const { messages: o, onWarn: a, messageResolver: l, localeFallbacker: c } = n,
    u = c(n, i, t)
  let d = dn(),
    h,
    f = null
  const p = 'translate'
  for (
    let g = 0;
    g < u.length &&
    ((h = u[g]),
    (d = o[h] || dn()),
    (f = l(d, e)) === null && (f = d[e]),
    !(st(f) || Ys(f) || Xr(f)));
    g++
  )
    if (!jte(h, u)) {
      const y = d2(n, e, h, s, p)
      y !== e && (f = y)
    }
  return [f, h, d]
}
function nI(n, e, t, i, r, s) {
  const { messageCompiler: o, warnHtmlMessage: a } = n
  if (Xr(i)) {
    const c = i
    return ((c.locale = c.locale || t), (c.key = c.key || e), c)
  }
  if (o == null) {
    const c = () => i
    return ((c.locale = t), (c.key = e), c)
  }
  const l = o(i, rne(n, t, r, i, a, s))
  return ((l.locale = t), (l.key = e), (l.source = i), l)
}
function ine(n, e, t) {
  return e(t)
}
function Bv(...n) {
  const [e, t, i] = n,
    r = dn()
  if (!st(e) && !Gn(e) && !Xr(e) && !Ys(e)) throw Uo(Bo.INVALID_ARGUMENT)
  const s = Gn(e) ? String(e) : (Xr(e), e)
  return (
    Gn(t)
      ? (r.plural = t)
      : st(t)
        ? (r.default = t)
        : Lt(t) && !z0(t)
          ? (r.named = t)
          : In(t) && (r.list = t),
    Gn(i) ? (r.plural = i) : st(i) ? (r.default = i) : Lt(i) && ei(r, i),
    [s, r]
  )
}
function rne(n, e, t, i, r, s) {
  return {
    locale: e,
    key: t,
    warnHtmlMessage: r,
    onError: (o) => {
      throw (s && s(o), o)
    },
    onCacheKey: (o) => Pee(e, t, o),
  }
}
function sne(n, e, t, i) {
  const {
      modifiers: r,
      pluralRules: s,
      messageResolver: o,
      fallbackLocale: a,
      fallbackWarn: l,
      missingWarn: c,
      fallbackContext: u,
    } = n,
    h = {
      locale: e,
      modifiers: r,
      pluralRules: s,
      messages: (f, p) => {
        let g = o(t, f)
        if (g == null && (u || p)) {
          const [, , y] = tI(u || n, f, e, a, l, c)
          g = o(y, f)
        }
        if (st(g) || Ys(g)) {
          let y = !1
          const v = nI(n, f, e, g, f, () => {
            y = !0
          })
          return y ? xT : v
        } else return Xr(g) ? g : xT
      },
    }
  return (
    n.processor && (h.processor = n.processor),
    i.list && (h.list = i.list),
    i.named && (h.named = i.named),
    Gn(i.plural) && (h.pluralIndex = i.plural),
    h
  )
}
ute()
/*!
 * vue-i18n v11.1.12
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */ const one = '11.1.12'
function ane() {
  ;(typeof __VUE_I18N_FULL_INSTALL__ != 'boolean' && (Ml().__VUE_I18N_FULL_INSTALL__ = !0),
    typeof __VUE_I18N_LEGACY_API__ != 'boolean' && (Ml().__VUE_I18N_LEGACY_API__ = !0),
    typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != 'boolean' &&
      (Ml().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1),
    typeof __INTLIFY_PROD_DEVTOOLS__ != 'boolean' && (Ml().__INTLIFY_PROD_DEVTOOLS__ = !1))
}
const ur = {
  UNEXPECTED_RETURN_TYPE: wte,
  INVALID_ARGUMENT: 25,
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  UNEXPECTED_ERROR: 32,
}
function Or(n, ...e) {
  return V0(n, null, void 0)
}
const Uv = Qa('__translateVNode'),
  kv = Qa('__datetimeParts'),
  zv = Qa('__numberParts'),
  iI = Qa('__setPluralRules'),
  rI = Qa('__injectWithOption'),
  Vv = Qa('__dispose')
function Mh(n) {
  if (!jt(n) || Ys(n)) return n
  for (const e in n)
    if (ys(n, e))
      if (!e.includes('.')) jt(n[e]) && Mh(n[e])
      else {
        const t = e.split('.'),
          i = t.length - 1
        let r = n,
          s = !1
        for (let o = 0; o < i; o++) {
          if (t[o] === '__proto__') throw new Error('unsafe key: '.concat(t[o]))
          if ((t[o] in r || (r[t[o]] = dn()), !jt(r[t[o]]))) {
            s = !0
            break
          }
          r = r[t[o]]
        }
        if (
          (s || (Ys(r) ? QR.includes(t[i]) || delete n[e] : ((r[t[i]] = n[e]), delete n[e])),
          !Ys(r))
        ) {
          const o = r[t[i]]
          jt(o) && Mh(o)
        }
      }
  return n
}
function h2(n, e) {
  const { messages: t, __i18n: i, messageResolver: r, flatJson: s } = e,
    o = Lt(t) ? t : In(i) ? dn() : { [n]: dn() }
  if (
    (In(i) &&
      i.forEach((a) => {
        if ('locale' in a && 'resource' in a) {
          const { locale: l, resource: c } = a
          l ? ((o[l] = o[l] || dn()), Xp(c, o[l])) : Xp(c, o)
        } else st(a) && Xp(JSON.parse(a), o)
      }),
    r == null && s)
  )
    for (const a in o) ys(o, a) && Mh(o[a])
  return o
}
function sI(n) {
  return n.type
}
function oI(n, e, t) {
  let i = jt(e.messages) ? e.messages : dn()
  '__i18nGlobal' in t && (i = h2(n.locale.value, { messages: i, __i18n: t.__i18nGlobal }))
  const r = Object.keys(i)
  r.length &&
    r.forEach((s) => {
      n.mergeLocaleMessage(s, i[s])
    })
  {
    if (jt(e.datetimeFormats)) {
      const s = Object.keys(e.datetimeFormats)
      s.length &&
        s.forEach((o) => {
          n.mergeDateTimeFormat(o, e.datetimeFormats[o])
        })
    }
    if (jt(e.numberFormats)) {
      const s = Object.keys(e.numberFormats)
      s.length &&
        s.forEach((o) => {
          n.mergeNumberFormat(o, e.numberFormats[o])
        })
    }
  }
}
function AT(n) {
  return Te(Nu, null, n, 0)
}
const bT = '__INTLIFY_META__',
  TT = () => [],
  lne = () => !1
let wT = 0
function CT(n) {
  return (e, t, i, r) => n(t, i, bs() || void 0, r)
}
const cne = () => {
  const n = bs()
  let e = null
  return n && (e = sI(n)[bT]) ? { [bT]: e } : null
}
function f2(n = {}) {
  const { __root: e, __injectWithOption: t } = n,
    i = e === void 0,
    r = n.flatJson,
    s = Hm ? Dn : ar
  let o = $t(n.inheritLocale) ? n.inheritLocale : !0
  const a = s(e && o ? e.locale.value : st(n.locale) ? n.locale : Eh),
    l = s(
      e && o
        ? e.fallbackLocale.value
        : st(n.fallbackLocale) ||
            In(n.fallbackLocale) ||
            Lt(n.fallbackLocale) ||
            n.fallbackLocale === !1
          ? n.fallbackLocale
          : a.value
    ),
    c = s(h2(a.value, n)),
    u = s(Lt(n.datetimeFormats) ? n.datetimeFormats : { [a.value]: {} }),
    d = s(Lt(n.numberFormats) ? n.numberFormats : { [a.value]: {} })
  let h = e ? e.missingWarn : $t(n.missingWarn) || Ru(n.missingWarn) ? n.missingWarn : !0,
    f = e ? e.fallbackWarn : $t(n.fallbackWarn) || Ru(n.fallbackWarn) ? n.fallbackWarn : !0,
    p = e ? e.fallbackRoot : $t(n.fallbackRoot) ? n.fallbackRoot : !0,
    g = !!n.fallbackFormat,
    y = yn(n.missing) ? n.missing : null,
    m = yn(n.missing) ? CT(n.missing) : null,
    v = yn(n.postTranslation) ? n.postTranslation : null,
    x = e ? e.warnHtmlMessage : $t(n.warnHtmlMessage) ? n.warnHtmlMessage : !0,
    _ = !!n.escapeParameter
  const S = e ? e.modifiers : Lt(n.modifiers) ? n.modifiers : {}
  let C = n.pluralRules || (e && e.pluralRules),
    A
  ;((A = (() => {
    i && fT(null)
    const G = {
      version: one,
      locale: a.value,
      fallbackLocale: l.value,
      messages: c.value,
      modifiers: S,
      pluralRules: C,
      missing: m === null ? void 0 : m,
      missingWarn: h,
      fallbackWarn: f,
      fallbackFormat: g,
      unresolving: !0,
      postTranslation: v === null ? void 0 : v,
      warnHtmlMessage: x,
      escapeParameter: _,
      messageResolver: n.messageResolver,
      messageCompiler: n.messageCompiler,
      __meta: { framework: 'vue' },
    }
    ;((G.datetimeFormats = u.value),
      (G.numberFormats = d.value),
      (G.__datetimeFormatters = Lt(A) ? A.__datetimeFormatters : void 0),
      (G.__numberFormatters = Lt(A) ? A.__numberFormatters : void 0))
    const X = Wte(G)
    return (i && fT(X), X)
  })()),
    Ad(A, a.value, l.value))
  function w() {
    return [a.value, l.value, c.value, u.value, d.value]
  }
  const M = Ge({
      get: () => a.value,
      set: (G) => {
        ;((A.locale = G), (a.value = G))
      },
    }),
    I = Ge({
      get: () => l.value,
      set: (G) => {
        ;((A.fallbackLocale = G), (l.value = G), Ad(A, a.value, G))
      },
    }),
    L = Ge(() => c.value),
    U = Ge(() => u.value),
    T = Ge(() => d.value)
  function F() {
    return yn(v) ? v : null
  }
  function V(G) {
    ;((v = G), (A.postTranslation = G))
  }
  function W() {
    return y
  }
  function ee(G) {
    ;(G !== null && (m = CT(G)), (y = G), (A.missing = m))
  }
  const se = (G, X, ue, z, E, N) => {
    w()
    let q
    try {
      ;(__INTLIFY_PROD_DEVTOOLS__, i || (A.fallbackContext = e ? Gte() : void 0), (q = G(A)))
    } finally {
      ;(__INTLIFY_PROD_DEVTOOLS__, i || (A.fallbackContext = void 0))
    }
    if ((ue !== 'translate exists' && Gn(q) && q === H0) || (ue === 'translate exists' && !q)) {
      const [Z, $] = X()
      return e && p ? z(e) : E(Z)
    } else {
      if (N(q)) return q
      throw Or(ur.UNEXPECTED_RETURN_TYPE)
    }
  }
  function he(...G) {
    return se(
      (X) => Reflect.apply(ST, null, [X, ...G]),
      () => Bv(...G),
      'translate',
      (X) => Reflect.apply(X.t, X, [...G]),
      (X) => X,
      (X) => st(X)
    )
  }
  function ne(...G) {
    const [X, ue, z] = G
    if (z && !jt(z)) throw Or(ur.INVALID_ARGUMENT)
    return he(X, ue, ei({ resolvedMessage: !0 }, z || {}))
  }
  function ie(...G) {
    return se(
      (X) => Reflect.apply(mT, null, [X, ...G]),
      () => Fv(...G),
      'datetime format',
      (X) => Reflect.apply(X.d, X, [...G]),
      () => dT,
      (X) => st(X) || In(X)
    )
  }
  function be(...G) {
    return se(
      (X) => Reflect.apply(yT, null, [X, ...G]),
      () => Ov(...G),
      'number format',
      (X) => Reflect.apply(X.n, X, [...G]),
      () => dT,
      (X) => st(X) || In(X)
    )
  }
  function le(G) {
    return G.map((X) => (st(X) || Gn(X) || $t(X) ? AT(String(X)) : X))
  }
  const we = { normalize: le, interpolate: (G) => G, type: 'vnode' }
  function Ee(...G) {
    return se(
      (X) => {
        let ue
        const z = X
        try {
          ;((z.processor = we), (ue = Reflect.apply(ST, null, [z, ...G])))
        } finally {
          z.processor = null
        }
        return ue
      },
      () => Bv(...G),
      'translate',
      (X) => X[Uv](...G),
      (X) => [AT(X)],
      (X) => In(X)
    )
  }
  function Ie(...G) {
    return se(
      (X) => Reflect.apply(yT, null, [X, ...G]),
      () => Ov(...G),
      'number format',
      (X) => X[zv](...G),
      TT,
      (X) => st(X) || In(X)
    )
  }
  function ze(...G) {
    return se(
      (X) => Reflect.apply(mT, null, [X, ...G]),
      () => Fv(...G),
      'datetime format',
      (X) => X[kv](...G),
      TT,
      (X) => st(X) || In(X)
    )
  }
  function Be(G) {
    ;((C = G), (A.pluralRules = C))
  }
  function it(G, X) {
    return se(
      () => {
        if (!G) return !1
        const ue = st(X) ? X : a.value,
          z = b(ue),
          E = A.messageResolver(z, G)
        return Ys(E) || Xr(E) || st(E)
      },
      () => [G],
      'translate exists',
      (ue) => Reflect.apply(ue.te, ue, [G, X]),
      lne,
      (ue) => $t(ue)
    )
  }
  function te(G) {
    let X = null
    const ue = jR(A, l.value, a.value)
    for (let z = 0; z < ue.length; z++) {
      const E = c.value[ue[z]] || {},
        N = A.messageResolver(E, G)
      if (N != null) {
        X = N
        break
      }
    }
    return X
  }
  function re(G) {
    const X = te(G)
    return X != null ? X : e ? e.tm(G) || {} : {}
  }
  function b(G) {
    return c.value[G] || {}
  }
  function oe(G, X) {
    if (r) {
      const ue = { [G]: X }
      for (const z in ue) ys(ue, z) && Mh(ue[z])
      X = ue[G]
    }
    ;((c.value[G] = X), (A.messages = c.value))
  }
  function J(G, X) {
    c.value[G] = c.value[G] || {}
    const ue = { [G]: X }
    if (r) for (const z in ue) ys(ue, z) && Mh(ue[z])
    ;((X = ue[G]), Xp(X, c.value[G]), (A.messages = c.value))
  }
  function H(G) {
    return u.value[G] || {}
  }
  function P(G, X) {
    ;((u.value[G] = X), (A.datetimeFormats = u.value), gT(A, G, X))
  }
  function k(G, X) {
    ;((u.value[G] = ei(u.value[G] || {}, X)), (A.datetimeFormats = u.value), gT(A, G, X))
  }
  function j(G) {
    return d.value[G] || {}
  }
  function B(G, X) {
    ;((d.value[G] = X), (A.numberFormats = d.value), vT(A, G, X))
  }
  function D(G, X) {
    ;((d.value[G] = ei(d.value[G] || {}, X)), (A.numberFormats = d.value), vT(A, G, X))
  }
  ;(wT++,
    e &&
      Hm &&
      (Jn(e.locale, (G) => {
        o && ((a.value = G), (A.locale = G), Ad(A, a.value, l.value))
      }),
      Jn(e.fallbackLocale, (G) => {
        o && ((l.value = G), (A.fallbackLocale = G), Ad(A, a.value, l.value))
      })))
  const Q = {
    id: wT,
    locale: M,
    fallbackLocale: I,
    get inheritLocale() {
      return o
    },
    set inheritLocale(G) {
      ;((o = G),
        G &&
          e &&
          ((a.value = e.locale.value), (l.value = e.fallbackLocale.value), Ad(A, a.value, l.value)))
    },
    get availableLocales() {
      return Object.keys(c.value).sort()
    },
    messages: L,
    get modifiers() {
      return S
    },
    get pluralRules() {
      return C || {}
    },
    get isGlobal() {
      return i
    },
    get missingWarn() {
      return h
    },
    set missingWarn(G) {
      ;((h = G), (A.missingWarn = h))
    },
    get fallbackWarn() {
      return f
    },
    set fallbackWarn(G) {
      ;((f = G), (A.fallbackWarn = f))
    },
    get fallbackRoot() {
      return p
    },
    set fallbackRoot(G) {
      p = G
    },
    get fallbackFormat() {
      return g
    },
    set fallbackFormat(G) {
      ;((g = G), (A.fallbackFormat = g))
    },
    get warnHtmlMessage() {
      return x
    },
    set warnHtmlMessage(G) {
      ;((x = G), (A.warnHtmlMessage = G))
    },
    get escapeParameter() {
      return _
    },
    set escapeParameter(G) {
      ;((_ = G), (A.escapeParameter = G))
    },
    t: he,
    getLocaleMessage: b,
    setLocaleMessage: oe,
    mergeLocaleMessage: J,
    getPostTranslationHandler: F,
    setPostTranslationHandler: V,
    getMissingHandler: W,
    setMissingHandler: ee,
    [iI]: Be,
  }
  return (
    (Q.datetimeFormats = U),
    (Q.numberFormats = T),
    (Q.rt = ne),
    (Q.te = it),
    (Q.tm = re),
    (Q.d = ie),
    (Q.n = be),
    (Q.getDateTimeFormat = H),
    (Q.setDateTimeFormat = P),
    (Q.mergeDateTimeFormat = k),
    (Q.getNumberFormat = j),
    (Q.setNumberFormat = B),
    (Q.mergeNumberFormat = D),
    (Q[rI] = t),
    (Q[Uv] = Ee),
    (Q[kv] = ze),
    (Q[zv] = Ie),
    Q
  )
}
function une(n) {
  const e = st(n.locale) ? n.locale : Eh,
    t =
      st(n.fallbackLocale) ||
      In(n.fallbackLocale) ||
      Lt(n.fallbackLocale) ||
      n.fallbackLocale === !1
        ? n.fallbackLocale
        : e,
    i = yn(n.missing) ? n.missing : void 0,
    r = $t(n.silentTranslationWarn) || Ru(n.silentTranslationWarn) ? !n.silentTranslationWarn : !0,
    s = $t(n.silentFallbackWarn) || Ru(n.silentFallbackWarn) ? !n.silentFallbackWarn : !0,
    o = $t(n.fallbackRoot) ? n.fallbackRoot : !0,
    a = !!n.formatFallbackMessages,
    l = Lt(n.modifiers) ? n.modifiers : {},
    c = n.pluralizationRules,
    u = yn(n.postTranslation) ? n.postTranslation : void 0,
    d = st(n.warnHtmlInMessage) ? n.warnHtmlInMessage !== 'off' : !0,
    h = !!n.escapeParameterHtml,
    f = $t(n.sync) ? n.sync : !0
  let p = n.messages
  if (Lt(n.sharedMessages)) {
    const S = n.sharedMessages
    p = Object.keys(S).reduce((A, R) => {
      const w = A[R] || (A[R] = {})
      return (ei(w, S[R]), A)
    }, p || {})
  }
  const { __i18n: g, __root: y, __injectWithOption: m } = n,
    v = n.datetimeFormats,
    x = n.numberFormats,
    _ = n.flatJson
  return {
    locale: e,
    fallbackLocale: t,
    messages: p,
    flatJson: _,
    datetimeFormats: v,
    numberFormats: x,
    missing: i,
    missingWarn: r,
    fallbackWarn: s,
    fallbackRoot: o,
    fallbackFormat: a,
    modifiers: l,
    pluralRules: c,
    postTranslation: u,
    warnHtmlMessage: d,
    escapeParameter: h,
    messageResolver: n.messageResolver,
    inheritLocale: f,
    __i18n: g,
    __root: y,
    __injectWithOption: m,
  }
}
function Hv(n = {}) {
  const e = f2(une(n)),
    { __extender: t } = n,
    i = {
      id: e.id,
      get locale() {
        return e.locale.value
      },
      set locale(r) {
        e.locale.value = r
      },
      get fallbackLocale() {
        return e.fallbackLocale.value
      },
      set fallbackLocale(r) {
        e.fallbackLocale.value = r
      },
      get messages() {
        return e.messages.value
      },
      get datetimeFormats() {
        return e.datetimeFormats.value
      },
      get numberFormats() {
        return e.numberFormats.value
      },
      get availableLocales() {
        return e.availableLocales
      },
      get missing() {
        return e.getMissingHandler()
      },
      set missing(r) {
        e.setMissingHandler(r)
      },
      get silentTranslationWarn() {
        return $t(e.missingWarn) ? !e.missingWarn : e.missingWarn
      },
      set silentTranslationWarn(r) {
        e.missingWarn = $t(r) ? !r : r
      },
      get silentFallbackWarn() {
        return $t(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn
      },
      set silentFallbackWarn(r) {
        e.fallbackWarn = $t(r) ? !r : r
      },
      get modifiers() {
        return e.modifiers
      },
      get formatFallbackMessages() {
        return e.fallbackFormat
      },
      set formatFallbackMessages(r) {
        e.fallbackFormat = r
      },
      get postTranslation() {
        return e.getPostTranslationHandler()
      },
      set postTranslation(r) {
        e.setPostTranslationHandler(r)
      },
      get sync() {
        return e.inheritLocale
      },
      set sync(r) {
        e.inheritLocale = r
      },
      get warnHtmlInMessage() {
        return e.warnHtmlMessage ? 'warn' : 'off'
      },
      set warnHtmlInMessage(r) {
        e.warnHtmlMessage = r !== 'off'
      },
      get escapeParameterHtml() {
        return e.escapeParameter
      },
      set escapeParameterHtml(r) {
        e.escapeParameter = r
      },
      get pluralizationRules() {
        return e.pluralRules || {}
      },
      __composer: e,
      t(...r) {
        return Reflect.apply(e.t, e, [...r])
      },
      rt(...r) {
        return Reflect.apply(e.rt, e, [...r])
      },
      te(r, s) {
        return e.te(r, s)
      },
      tm(r) {
        return e.tm(r)
      },
      getLocaleMessage(r) {
        return e.getLocaleMessage(r)
      },
      setLocaleMessage(r, s) {
        e.setLocaleMessage(r, s)
      },
      mergeLocaleMessage(r, s) {
        e.mergeLocaleMessage(r, s)
      },
      d(...r) {
        return Reflect.apply(e.d, e, [...r])
      },
      getDateTimeFormat(r) {
        return e.getDateTimeFormat(r)
      },
      setDateTimeFormat(r, s) {
        e.setDateTimeFormat(r, s)
      },
      mergeDateTimeFormat(r, s) {
        e.mergeDateTimeFormat(r, s)
      },
      n(...r) {
        return Reflect.apply(e.n, e, [...r])
      },
      getNumberFormat(r) {
        return e.getNumberFormat(r)
      },
      setNumberFormat(r, s) {
        e.setNumberFormat(r, s)
      },
      mergeNumberFormat(r, s) {
        e.mergeNumberFormat(r, s)
      },
    }
  return ((i.__extender = t), i)
}
function dne(n, e, t) {
  return {
    beforeCreate() {
      const i = bs()
      if (!i) throw Or(ur.UNEXPECTED_ERROR)
      const r = this.$options
      if (r.i18n) {
        const s = r.i18n
        if ((r.__i18n && (s.__i18n = r.__i18n), (s.__root = e), this === this.$root))
          this.$i18n = ET(n, s)
        else {
          ;((s.__injectWithOption = !0), (s.__extender = t.__vueI18nExtend), (this.$i18n = Hv(s)))
          const o = this.$i18n
          o.__extender && (o.__disposer = o.__extender(this.$i18n))
        }
      } else if (r.__i18n)
        if (this === this.$root) this.$i18n = ET(n, r)
        else {
          this.$i18n = Hv({
            __i18n: r.__i18n,
            __injectWithOption: !0,
            __extender: t.__vueI18nExtend,
            __root: e,
          })
          const s = this.$i18n
          s.__extender && (s.__disposer = s.__extender(this.$i18n))
        }
      else this.$i18n = n
      ;(r.__i18nGlobal && oI(e, r, r),
        (this.$t = (...s) => this.$i18n.t(...s)),
        (this.$rt = (...s) => this.$i18n.rt(...s)),
        (this.$te = (s, o) => this.$i18n.te(s, o)),
        (this.$d = (...s) => this.$i18n.d(...s)),
        (this.$n = (...s) => this.$i18n.n(...s)),
        (this.$tm = (s) => this.$i18n.tm(s)),
        t.__setInstance(i, this.$i18n))
    },
    mounted() {},
    unmounted() {
      const i = bs()
      if (!i) throw Or(ur.UNEXPECTED_ERROR)
      const r = this.$i18n
      ;(delete this.$t,
        delete this.$rt,
        delete this.$te,
        delete this.$d,
        delete this.$n,
        delete this.$tm,
        r.__disposer && (r.__disposer(), delete r.__disposer, delete r.__extender),
        t.__deleteInstance(i),
        delete this.$i18n)
    },
  }
}
function ET(n, e) {
  ;((n.locale = e.locale || n.locale),
    (n.fallbackLocale = e.fallbackLocale || n.fallbackLocale),
    (n.missing = e.missing || n.missing),
    (n.silentTranslationWarn = e.silentTranslationWarn || n.silentFallbackWarn),
    (n.silentFallbackWarn = e.silentFallbackWarn || n.silentFallbackWarn),
    (n.formatFallbackMessages = e.formatFallbackMessages || n.formatFallbackMessages),
    (n.postTranslation = e.postTranslation || n.postTranslation),
    (n.warnHtmlInMessage = e.warnHtmlInMessage || n.warnHtmlInMessage),
    (n.escapeParameterHtml = e.escapeParameterHtml || n.escapeParameterHtml),
    (n.sync = e.sync || n.sync),
    n.__composer[iI](e.pluralizationRules || n.pluralizationRules))
  const t = h2(n.locale, { messages: e.messages, __i18n: e.__i18n })
  return (
    Object.keys(t).forEach((i) => n.mergeLocaleMessage(i, t[i])),
    e.datetimeFormats &&
      Object.keys(e.datetimeFormats).forEach((i) => n.mergeDateTimeFormat(i, e.datetimeFormats[i])),
    e.numberFormats &&
      Object.keys(e.numberFormats).forEach((i) => n.mergeNumberFormat(i, e.numberFormats[i])),
    n
  )
}
const p2 = {
  tag: { type: [String, Object] },
  locale: { type: String },
  scope: { type: String, validator: (n) => n === 'parent' || n === 'global', default: 'parent' },
  i18n: { type: Object },
}
function hne({ slots: n }, e) {
  return e.length === 1 && e[0] === 'default'
    ? (n.default ? n.default() : []).reduce(
        (i, r) => [...i, ...(r.type === Hn ? r.children : [r])],
        []
      )
    : e.reduce((t, i) => {
        const r = n[i]
        return (r && (t[i] = r()), t)
      }, dn())
}
function aI() {
  return Hn
}
const fne = qt({
    name: 'i18n-t',
    props: ei(
      {
        keypath: { type: String, required: !0 },
        plural: { type: [Number, String], validator: (n) => Gn(n) || !isNaN(n) },
      },
      p2
    ),
    setup(n, e) {
      const { slots: t, attrs: i } = e,
        r = n.i18n || m2({ useScope: n.scope, __useComponent: !0 })
      return () => {
        const s = Object.keys(t).filter((d) => d[0] !== '_'),
          o = dn()
        ;(n.locale && (o.locale = n.locale),
          n.plural !== void 0 && (o.plural = st(n.plural) ? +n.plural : n.plural))
        const a = hne(e, s),
          l = r[Uv](n.keypath, a, o),
          c = ei(dn(), i),
          u = st(n.tag) || jt(n.tag) ? n.tag : aI()
        return Ba(u, c, l)
      }
    },
  }),
  MT = fne
function pne(n) {
  return In(n) && !st(n[0])
}
function lI(n, e, t, i) {
  const { slots: r, attrs: s } = e
  return () => {
    const o = { part: !0 }
    let a = dn()
    ;(n.locale && (o.locale = n.locale),
      st(n.format)
        ? (o.key = n.format)
        : jt(n.format) &&
          (st(n.format.key) && (o.key = n.format.key),
          (a = Object.keys(n.format).reduce(
            (h, f) => (t.includes(f) ? ei(dn(), h, { [f]: n.format[f] }) : h),
            dn()
          ))))
    const l = i(n.value, o, a)
    let c = [o.key]
    In(l)
      ? (c = l.map((h, f) => {
          const p = r[h.type],
            g = p ? p({ [h.type]: h.value, index: f, parts: l }) : [h.value]
          return (pne(g) && (g[0].key = ''.concat(h.type, '-').concat(f)), g)
        }))
      : st(l) && (c = [l])
    const u = ei(dn(), s),
      d = st(n.tag) || jt(n.tag) ? n.tag : aI()
    return Ba(d, u, c)
  }
}
const mne = qt({
    name: 'i18n-n',
    props: ei({ value: { type: Number, required: !0 }, format: { type: [String, Object] } }, p2),
    setup(n, e) {
      const t = n.i18n || m2({ useScope: n.scope, __useComponent: !0 })
      return lI(n, e, eI, (...i) => t[zv](...i))
    },
  }),
  RT = mne
function gne(n, e) {
  const t = n
  if (n.mode === 'composition') return t.__getInstance(e) || n.global
  {
    const i = t.__getInstance(e)
    return i != null ? i.__composer : n.global.__composer
  }
}
function yne(n) {
  const e = (o) => {
    const { instance: a, value: l } = o
    if (!a || !a.$) throw Or(ur.UNEXPECTED_ERROR)
    const c = gne(n, a.$),
      u = IT(l)
    return [Reflect.apply(c.t, c, [...NT(u)]), c]
  }
  return {
    created: (o, a) => {
      const [l, c] = e(a)
      ;(Hm &&
        n.global === c &&
        (o.__i18nWatcher = Jn(c.locale, () => {
          a.instance && a.instance.$forceUpdate()
        })),
        (o.__composer = c),
        (o.textContent = l))
    },
    unmounted: (o) => {
      ;(Hm &&
        o.__i18nWatcher &&
        (o.__i18nWatcher(), (o.__i18nWatcher = void 0), delete o.__i18nWatcher),
        o.__composer && ((o.__composer = void 0), delete o.__composer))
    },
    beforeUpdate: (o, { value: a }) => {
      if (o.__composer) {
        const l = o.__composer,
          c = IT(a)
        o.textContent = Reflect.apply(l.t, l, [...NT(c)])
      }
    },
    getSSRProps: (o) => {
      const [a] = e(o)
      return { textContent: a }
    },
  }
}
function IT(n) {
  if (st(n)) return { path: n }
  if (Lt(n)) {
    if (!('path' in n)) throw Or(ur.REQUIRED_VALUE, 'path')
    return n
  } else throw Or(ur.INVALID_VALUE)
}
function NT(n) {
  const { path: e, locale: t, args: i, choice: r, plural: s } = n,
    o = {},
    a = i || {}
  return (st(t) && (o.locale = t), Gn(r) && (o.plural = r), Gn(s) && (o.plural = s), [e, a, o])
}
function vne(n, e, ...t) {
  const i = Lt(t[0]) ? t[0] : {}
  ;(($t(i.globalInstall) ? i.globalInstall : !0) &&
    ([MT.name, 'I18nT'].forEach((s) => n.component(s, MT)),
    [RT.name, 'I18nN'].forEach((s) => n.component(s, RT)),
    [LT.name, 'I18nD'].forEach((s) => n.component(s, LT))),
    n.directive('t', yne(e)))
}
const _ne = Qa('global-vue-i18n')
function xne(n = {}) {
  const e = __VUE_I18N_LEGACY_API__ && $t(n.legacy) ? n.legacy : __VUE_I18N_LEGACY_API__,
    t = $t(n.globalInjection) ? n.globalInjection : !0,
    i = new Map(),
    [r, s] = Sne(n, e),
    o = Qa('')
  function a(d) {
    return i.get(d) || null
  }
  function l(d, h) {
    i.set(d, h)
  }
  function c(d) {
    i.delete(d)
  }
  const u = {
    get mode() {
      return __VUE_I18N_LEGACY_API__ && e ? 'legacy' : 'composition'
    },
    async install(d, ...h) {
      if (((d.__VUE_I18N_SYMBOL__ = o), d.provide(d.__VUE_I18N_SYMBOL__, u), Lt(h[0]))) {
        const g = h[0]
        ;((u.__composerExtend = g.__composerExtend), (u.__vueI18nExtend = g.__vueI18nExtend))
      }
      let f = null
      ;(!e && t && (f = Rne(d, u.global)),
        __VUE_I18N_FULL_INSTALL__ && vne(d, u, ...h),
        __VUE_I18N_LEGACY_API__ && e && d.mixin(dne(s, s.__composer, u)))
      const p = d.unmount
      d.unmount = () => {
        ;(f && f(), u.dispose(), p())
      }
    },
    get global() {
      return s
    },
    dispose() {
      r.stop()
    },
    __instances: i,
    __getInstance: a,
    __setInstance: l,
    __deleteInstance: c,
  }
  return u
}
function m2(n = {}) {
  const e = bs()
  if (e == null) throw Or(ur.MUST_BE_CALL_SETUP_TOP)
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw Or(ur.NOT_INSTALLED)
  const t = Ane(e),
    i = Tne(t),
    r = sI(e),
    s = bne(n, r)
  if (s === 'global') return (oI(i, n, r), i)
  if (s === 'parent') {
    let l = wne(t, e, n.__useComponent)
    return (l == null && (l = i), l)
  }
  const o = t
  let a = o.__getInstance(e)
  if (a == null) {
    const l = ei({}, n)
    ;('__i18n' in r && (l.__i18n = r.__i18n),
      i && (l.__root = i),
      (a = f2(l)),
      o.__composerExtend && (a[Vv] = o.__composerExtend(a)),
      Ene(o, e, a),
      o.__setInstance(e, a))
  }
  return a
}
function Sne(n, e) {
  const t = qv(),
    i = __VUE_I18N_LEGACY_API__ && e ? t.run(() => Hv(n)) : t.run(() => f2(n))
  if (i == null) throw Or(ur.UNEXPECTED_ERROR)
  return [t, i]
}
function Ane(n) {
  const e = Zi(n.isCE ? _ne : n.appContext.app.__VUE_I18N_SYMBOL__)
  if (!e) throw Or(n.isCE ? ur.NOT_INSTALLED_WITH_PROVIDE : ur.UNEXPECTED_ERROR)
  return e
}
function bne(n, e) {
  return z0(n) ? ('__i18n' in e ? 'local' : 'global') : n.useScope ? n.useScope : 'local'
}
function Tne(n) {
  return n.mode === 'composition' ? n.global : n.global.__composer
}
function wne(n, e, t = !1) {
  let i = null
  const r = e.root
  let s = Cne(e, t)
  for (; s != null; ) {
    const o = n
    if (n.mode === 'composition') i = o.__getInstance(s)
    else if (__VUE_I18N_LEGACY_API__) {
      const a = o.__getInstance(s)
      a != null && ((i = a.__composer), t && i && !i[rI] && (i = null))
    }
    if (i != null || r === s) break
    s = s.parent
  }
  return i
}
function Cne(n, e = !1) {
  return n == null ? null : (e && n.vnode.ctx) || n.parent
}
function Ene(n, e, t) {
  ;(Va(() => {}, e),
    Fh(() => {
      const i = t
      n.__deleteInstance(e)
      const r = i[Vv]
      r && (r(), delete i[Vv])
    }, e))
}
const Mne = ['locale', 'fallbackLocale', 'availableLocales'],
  PT = ['t', 'rt', 'd', 'n', 'tm', 'te']
function Rne(n, e) {
  const t = Object.create(null)
  return (
    Mne.forEach((r) => {
      const s = Object.getOwnPropertyDescriptor(e, r)
      if (!s) throw Or(ur.UNEXPECTED_ERROR)
      const o = bn(s.value)
        ? {
            get() {
              return s.value.value
            },
            set(a) {
              s.value.value = a
            },
          }
        : {
            get() {
              return s.get && s.get()
            },
          }
      Object.defineProperty(t, r, o)
    }),
    (n.config.globalProperties.$i18n = t),
    PT.forEach((r) => {
      const s = Object.getOwnPropertyDescriptor(e, r)
      if (!s || !s.value) throw Or(ur.UNEXPECTED_ERROR)
      Object.defineProperty(n.config.globalProperties, '$'.concat(r), s)
    }),
    () => {
      ;(delete n.config.globalProperties.$i18n,
        PT.forEach((r) => {
          delete n.config.globalProperties['$'.concat(r)]
        }))
    }
  )
}
const Ine = qt({
    name: 'i18n-d',
    props: ei(
      { value: { type: [Number, Date], required: !0 }, format: { type: [String, Object] } },
      p2
    ),
    setup(n, e) {
      const t = n.i18n || m2({ useScope: n.scope, __useComponent: !0 })
      return lI(n, e, JR, (...i) => t[kv](...i))
    },
  }),
  LT = Ine
ane()
kte(xte)
zte(Ote)
Vte(jR)
if (__INTLIFY_PROD_DEVTOOLS__) {
  const n = Ml()
  ;((n.__INTLIFY__ = !0), Ste(n.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__))
}
const Nne = {
    locale: 'zh_CN',
    today: '今天',
    now: '此刻',
    backToToday: '返回今天',
    ok: '确定',
    timeSelect: '选择时间',
    dateSelect: '选择日期',
    weekSelect: '选择周',
    clear: '清除',
    month: '月',
    year: '年',
    previousMonth: '上个月 (翻页上键)',
    nextMonth: '下个月 (翻页下键)',
    monthSelect: '选择月份',
    yearSelect: '选择年份',
    decadeSelect: '选择年代',
    yearFormat: 'YYYY年',
    dayFormat: 'D日',
    dateFormat: 'YYYY年M月D日',
    dateTimeFormat: 'YYYY年M月D日 HH时mm分ss秒',
    previousYear: '上一年 (Control键加左方向键)',
    nextYear: '下一年 (Control键加右方向键)',
    previousDecade: '上一年代',
    nextDecade: '下一年代',
    previousCentury: '上一世纪',
    nextCentury: '下一世纪',
  },
  cI = { placeholder: '请选择时间', rangePlaceholder: ['开始时间', '结束时间'] },
  $v = {
    lang: ke(
      {
        placeholder: '请选择日期',
        yearPlaceholder: '请选择年份',
        quarterPlaceholder: '请选择季度',
        monthPlaceholder: '请选择月份',
        weekPlaceholder: '请选择周',
        rangePlaceholder: ['开始日期', '结束日期'],
        rangeYearPlaceholder: ['开始年份', '结束年份'],
        rangeMonthPlaceholder: ['开始月份', '结束月份'],
        rangeQuarterPlaceholder: ['开始季度', '结束季度'],
        rangeWeekPlaceholder: ['开始周', '结束周'],
      },
      Nne
    ),
    timePickerLocale: ke({}, cI),
  }
$v.lang.ok = '确定'
const gr = '${label}不是一个有效的${type}',
  Pne = {
    locale: 'zh-cn',
    Pagination: bee,
    DatePicker: $v,
    TimePicker: cI,
    Calendar: $v,
    global: { placeholder: '请选择' },
    Table: {
      filterTitle: '筛选',
      filterConfirm: '确定',
      filterReset: '重置',
      filterEmptyText: '无筛选项',
      filterCheckall: '全选',
      filterSearchPlaceholder: '在筛选项中搜索',
      selectAll: '全选当页',
      selectInvert: '反选当页',
      selectNone: '清空所有',
      selectionAll: '全选所有',
      sortTitle: '排序',
      expand: '展开行',
      collapse: '关闭行',
      triggerDesc: '点击降序',
      triggerAsc: '点击升序',
      cancelSort: '取消排序',
    },
    Tour: { Next: '下一步', Previous: '上一步', Finish: '结束导览' },
    Modal: { okText: '确定', cancelText: '取消', justOkText: '知道了' },
    Popconfirm: { cancelText: '取消', okText: '确定' },
    Transfer: {
      searchPlaceholder: '请输入搜索内容',
      itemUnit: '项',
      itemsUnit: '项',
      remove: '删除',
      selectCurrent: '全选当页',
      removeCurrent: '删除当页',
      selectAll: '全选所有',
      removeAll: '删除全部',
      selectInvert: '反选当页',
    },
    Upload: {
      uploading: '文件上传中',
      removeFile: '删除文件',
      uploadError: '上传错误',
      previewFile: '预览文件',
      downloadFile: '下载文件',
    },
    Empty: { description: '暂无数据' },
    Icon: { icon: '图标' },
    Text: { edit: '编辑', copy: '复制', copied: '复制成功', expand: '展开' },
    PageHeader: { back: '返回' },
    Form: {
      optional: '（可选）',
      defaultValidateMessages: {
        default: '字段验证错误${label}',
        required: '请输入${label}',
        enum: '${label}必须是其中一个[${enum}]',
        whitespace: '${label}不能为空字符',
        date: {
          format: '${label}日期格式无效',
          parse: '${label}不能转换为日期',
          invalid: '${label}是一个无效日期',
        },
        types: {
          string: gr,
          method: gr,
          array: gr,
          object: gr,
          number: gr,
          date: gr,
          boolean: gr,
          integer: gr,
          float: gr,
          regexp: gr,
          email: gr,
          url: gr,
          hex: gr,
        },
        string: {
          len: '${label}须为${len}个字符',
          min: '${label}最少${min}个字符',
          max: '${label}最多${max}个字符',
          range: '${label}须在${min}-${max}字符之间',
        },
        number: {
          len: '${label}必须等于${len}',
          min: '${label}最小值为${min}',
          max: '${label}最大值为${max}',
          range: '${label}须在${min}-${max}之间',
        },
        array: {
          len: '须为${len}个${label}',
          min: '最少${min}个${label}',
          max: '最多${max}个${label}',
          range: '${label}数量须在${min}-${max}之间',
        },
        pattern: { mismatch: '${label}与模式不匹配${pattern}' },
      },
    },
    Image: { preview: '预览' },
    QRCode: { expired: '二维码已过期', refresh: '点击刷新', scanned: '已扫描' },
  },
  Lne = { message: { hello: 'hello world' } },
  Dne = { message: { hello: '你好，世界' } },
  uI = Dn('zh'),
  Fne = { zh: Pne, en: Au },
  One = { en: Lne, zh: Dne },
  Bne = xne({ legacy: !1, locale: uI.value, messages: One }),
  Une = qt({
    __name: 'index',
    props: { color: {}, fontSize: {}, icon: {} },
    emits: [],
    setup(n, { emit: e }) {
      return (t, i) => (
        mt(),
        ou(
          C8(t.icon),
          { class: 'icon', style: Go({ fontSize: t.fontSize + 'px', color: t.color }) },
          null,
          8,
          ['style']
        )
      )
    },
  }),
  Ed = si(Une, [['__scopeId', 'data-v-91f3cb32']]),
  kne = {},
  zne = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function Vne(n, e) {
  return (
    mt(),
    Ct('svg', zne, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_13_287/13_279"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath><clipPath id="master_svg1_13_287/13_279/13_018"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_13_287/13_279)"><g clip-path="url(#master_svg1_13_287/13_279/13_018)"><g><rect x="0" y="0" width="20" height="20" rx="0" fill="#FFFFFF" fill-opacity="0.009999999776482582" style="mix-blend-mode:passthrough;"></rect></g><g><path d="M7.55256390625,4.9999589765625Q7.52622390625,5.0016259765625,7.49983390625,5.0016259765625Q7.41759390625,5.0016259765625,7.33693390625,4.9855819765625Q7.25627390625,4.9695369765625,7.18029390625,4.9380649765625Q7.10431390625,4.9065929765625,7.03593390625,4.8609029765625Q6.96755390625,4.8152129765625,6.90940390625,4.7570599765625Q6.85125390625,4.6989069765625,6.80556390625,4.6305269765625Q6.75986390625,4.5621469765625005,6.72839390625,4.4861669765625Q6.69692390625,4.4101859765625,6.68088390625,4.3295259765625Q6.66483390625,4.2488662765625,6.66483390625,4.1666259765625Q6.66483390625,4.0843856765625,6.68088390625,4.0037259765625Q6.69692390625,3.9230659765625,6.72839390625,3.8470849765625Q6.75986390625,3.7711049765625,6.80556390625,3.7027249765625Q6.85125390625,3.6343449765624998,6.90940390625,3.5761919765625Q6.96755390625,3.5180389765625,7.03593390625,3.4723489765625Q7.10431390625,3.4266589765625,7.18029390625,3.3951869765625Q7.25627390625,3.3637149765625,7.33693390625,3.3476699765625Q7.41759390625,3.3316259765625,7.49983390625,3.3316259765625Q7.52622390625,3.3316259765625,7.55256390625,3.3332929765625L14.99980390625,3.3332929765625Q15.08190390625,3.3332929765625,15.16240390625,3.3493049765625003Q15.24290390625,3.3653169765625,15.31870390625,3.3967269765625Q15.39460390625,3.4281359765625,15.46280390625,3.4737349765625Q15.53100390625,3.5193339765625,15.58910390625,3.5773699765625Q15.64710390625,3.6354069765625,15.69270390625,3.7036509765625Q15.73830390625,3.7718949765625,15.76970390625,3.8477229765625Q15.80110390625,3.9235519765625,15.81720390625,4.0040509765625Q15.83320390625,4.0845497765625,15.83320390625,4.1666259765625L15.83320390625,11.1972259765625Q15.83480390625,11.2235659765625,15.83480390625,11.2499559765625Q15.83480390625,11.332195976562499,15.81880390625,11.4128559765625Q15.80270390625,11.493515976562499,15.77130390625,11.5694959765625Q15.73980390625,11.645475976562501,15.69410390625,11.713855976562499Q15.64840390625,11.7822359765625,15.59030390625,11.840395976562501Q15.53210390625,11.898545976562499,15.46370390625,11.9442359765625Q15.39540390625,11.9899259765625,15.31940390625,12.0213959765625Q15.24340390625,12.0528659765625,15.16270390625,12.0689159765625Q15.08210390625,12.084955976562501,14.99980390625,12.084955976562501Q14.91760390625,12.084955976562501,14.83690390625,12.0689159765625Q14.75630390625,12.0528659765625,14.68030390625,12.0213959765625Q14.60430390625,11.9899259765625,14.53590390625,11.9442359765625Q14.46760390625,11.898545976562499,14.40940390625,11.840395976562501Q14.35120390625,11.7822359765625,14.30560390625,11.713855976562499Q14.25990390625,11.645475976562501,14.22840390625,11.5694959765625Q14.19690390625,11.493515976562499,14.18090390625,11.4128559765625Q14.16480390625,11.332195976562499,14.16480390625,11.2499559765625Q14.16480390625,11.2235659765625,14.16650390625,11.1972259765625L14.16650390625,4.9999589765625L7.55256390625,4.9999589765625ZM2.49983690625,5.0526899765625Q2.50150390625,5.0263509765625,2.50150390625,4.9999589765625Q2.50150390625,4.9177189765625,2.48545990625,4.8370589765625Q2.46941490625,4.7563989765625,2.43794290625,4.6804189765625Q2.40647090625,4.6044379765625,2.36078090625,4.5360579765625Q2.31509090625,4.4676779765625,2.25693790625,4.4095249765625Q2.1987849062500002,4.3513719765625,2.13040490625,4.3056819765625Q2.06202490625,4.2599918765625,1.98604490625,4.2285198765625Q1.91006390625,4.1970478765625,1.82940390625,4.1810035765625Q1.74874420625,4.1649593165625,1.66650390625,4.1649593065625Q1.58426360625,4.1649593165625,1.50360390625,4.1810035765625Q1.42294390625,4.1970478765625,1.34696290625,4.2285198765625Q1.27098290625,4.2599918765625,1.20260290625,4.3056819765625Q1.13422290625,4.3513719765625,1.0760699062499999,4.4095249765625Q1.01791690625,4.4676779765625,0.97222690625,4.5360579765625Q0.92653690625,4.6044379765625,0.89506490625,4.6804189765625Q0.86359290625,4.7563989765625,0.84754790625,4.8370589765625Q0.83150390625,4.9177189765625,0.83150390625,4.9999589765625Q0.83150390625,5.0263509765625,0.83317090625,5.0526899765625L0.83317090625,15.8333259765625Q0.83317090625,15.9153259765625,0.84918290625,15.9958259765625Q0.86519490625,16.0763259765625,0.89660490625,16.152225976562498Q0.92801390625,16.2280259765625,0.97361290625,16.2962259765625Q1.01921190625,16.3645259765625,1.07724790625,16.4225259765625Q1.13528490625,16.4806259765625,1.2035289062499999,16.5262259765625Q1.27177290625,16.5718259765625,1.34760090625,16.6032259765625Q1.42342990625,16.6346259765625,1.50392890625,16.6506259765625Q1.58442770625,16.6666259765625,1.66650390625,16.6666259765625L12.44710390625,16.6666259765625Q12.47340390625,16.6683259765625,12.49980390625,16.6683259765625Q12.58210390625,16.6683259765625,12.66270390625,16.652225976562498Q12.74340390625,16.6362259765625,12.81940390625,16.6047259765625Q12.89540390625,16.573225976562497,12.96370390625,16.5275259765625Q13.03210390625,16.4819259765625,13.09030390625,16.4237259765625Q13.14840390625,16.365525976562502,13.19410390625,16.2972259765625Q13.23980390625,16.2288259765625,13.27130390625,16.1528259765625Q13.30270390625,16.0768259765625,13.31880390625,15.9962259765625Q13.33480390625,15.9155259765625,13.33480390625,15.8333259765625Q13.33480390625,15.7510259765625,13.31880390625,15.6704259765625Q13.30270390625,15.5897259765625,13.27130390625,15.5137259765625Q13.23980390625,15.4377259765625,13.19410390625,15.3694259765625Q13.14840390625,15.3010259765625,13.09030390625,15.2428259765625Q13.03210390625,15.1847259765625,12.96370390625,15.1390259765625Q12.89540390625,15.0933259765625,12.81940390625,15.0618259765625Q12.74340390625,15.0304259765625,12.66270390625,15.0143259765625Q12.58210390625,14.9983259765625,12.49980390625,14.9983259765625Q12.47340390625,14.9983259765625,12.44710390625,14.9999259765625L2.49983690625,14.9999259765625L2.49983690625,5.0526899765625Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M18.97024,14.7041040234375Q19.06538,14.5913440234375,19.11602,14.4527940234375Q19.16667,14.3142340234375,19.16667,14.1667040234375L19.16667,5.8333740234375Q19.16667,5.7512978234375,19.15065,5.6707990234375Q19.13464,5.5903000234375,19.10323,5.5144710234375Q19.07182,5.4386430234375,19.026220000000002,5.3703990234375Q18.98063,5.3021550234375,18.92259,5.2441180234375Q18.86455,5.1860820234375,18.79631,5.1404830234375Q18.72806,5.0948840234375,18.65224,5.0634750234375Q18.57641,5.0320650234375,18.49591,5.0160530234375Q18.41541,5.0000410234375,18.33333,5.0000410234375Q18.18581,5.0000410234375,18.04725,5.0506860234375Q17.90869,5.1013300234375,17.79594,5.1964640234375L14.462608,8.0089640234375Q14.393074,8.067634023437499,14.337838,8.1399240234375Q14.282601,8.2122140234375,14.244265,8.2947240234375Q14.205928,8.377224023437499,14.186297,8.4660640234375Q14.166667,8.5548940234375,14.166667,8.6458740234375L14.166667,11.3542040234375Q14.166667,11.4451840234375,14.186297,11.5340240234375Q14.205928,11.622854023437501,14.244265,11.7053640234375Q14.282601,11.7878640234375,14.337838,11.860154023437499Q14.393074,11.932444023437501,14.462608,11.9911140234375L17.79594,14.8036140234375Q17.922629999999998,14.9105140234375,18.08058,14.9607840234375Q18.23853,15.0110640234375,18.4037,14.9970640234375Q18.56887,14.9830640234375,18.71611,14.9069240234375Q18.86335,14.8307940234375,18.97024,14.7041040234375ZM17.5,12.3732440234375L17.5,7.6268340234375L15.833333,9.0330840234375L15.833333,10.9669940234375L17.5,12.3732440234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M1.1145349062499998,2.2931679765625Q0.97958490625,2.1742799765625,0.90554390625,2.0103779765625Q0.83150390625,1.8464759765625,0.83150390625,1.6666259765625Q0.83150390625,1.5843856765625,0.84754790625,1.5037259765625Q0.86359290625,1.4230659765625,0.89506490625,1.3470849765625Q0.92653690625,1.2711049765625,0.97222690625,1.2027249765625Q1.01791690625,1.1343449765625,1.0760699062499999,1.0761919765624999Q1.13422290625,1.0180389765625,1.20260290625,0.9723489765625Q1.27098290625,0.9266589765625,1.34696290625,0.8951869765625Q1.42294390625,0.8637149765625,1.50360390625,0.8476699765625Q1.58426360625,0.8316259765625,1.66650390625,0.8316259765625Q1.84635390625,0.8316259765625,2.01025590625,0.9056659765625Q2.17415790625,0.9797069765625,2.29304590625,1.1146569765624998L18.88520390625,17.7067259765625Q19.02010390625,17.8256259765625,19.09410390625,17.9895259765625Q19.16820390625,18.1534259765625,19.16820390625,18.3333259765625Q19.16820390625,18.4155259765625,19.15210390625,18.4962259765625Q19.13610390625,18.5768259765625,19.10460390625,18.6528259765625Q19.07310390625,18.7288259765625,19.02740390625,18.7972259765625Q18.98170390625,18.8655259765625,18.92360390625,18.9237259765625Q18.86540390625,18.9818259765625,18.79710390625,19.0275259765625Q18.72870390625,19.0732259765625,18.65270390625,19.1047259765625Q18.57670390625,19.1362259765625,18.49610390625,19.1522259765625Q18.41540390625,19.1683259765625,18.33320390625,19.1683259765625Q18.15330390625,19.1683259765625,17.98940390625,19.0942259765625Q17.82550390625,19.0202259765625,17.70660390625,18.8853259765625L1.1145349062499998,2.2931679765625Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g></g>',
            2
          ),
        ])),
    ])
  )
}
const Hne = si(kne, [['render', Vne]]),
  $ne = {},
  Gne = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function Wne(n, e) {
  return (
    mt(),
    Ct('svg', Gne, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_13_279"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath><clipPath id="master_svg1_13_279/13_007"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_13_279)"><g clip-path="url(#master_svg1_13_279/13_007)"><g><rect x="0" y="0" width="20" height="20" rx="0" fill="#FFFFFF" fill-opacity="0.009999999776482582" style="mix-blend-mode:passthrough;"></rect></g><g><path d="M0.83317090625,15.8333259765625L0.83317090625,4.1666259765625Q0.83317090625,4.0845497765625,0.84918290625,4.0040509765625Q0.86519490625,3.9235519765625,0.89660490625,3.8477229765625Q0.92801390625,3.7718949765625,0.97361290625,3.7036509765625Q1.01921190625,3.6354069765625,1.07724790625,3.5773699765625Q1.13528490625,3.5193339765625,1.2035289062499999,3.4737349765625Q1.27177290625,3.4281359765625,1.34760090625,3.3967269765625Q1.42342990625,3.3653169765625,1.50392890625,3.3493049765625003Q1.58442770625,3.3332929765625,1.66650390625,3.3332929765625L14.99980390625,3.3332929765625Q15.08190390625,3.3332929765625,15.16240390625,3.3493049765625003Q15.24290390625,3.3653169765625,15.31870390625,3.3967269765625Q15.39460390625,3.4281359765625,15.46280390625,3.4737349765625Q15.53100390625,3.5193339765625,15.58910390625,3.5773699765625Q15.64710390625,3.6354069765625,15.69270390625,3.7036509765625Q15.73830390625,3.7718949765625,15.76970390625,3.8477229765625Q15.80110390625,3.9235519765625,15.81720390625,4.0040509765625Q15.83320390625,4.0845497765625,15.83320390625,4.1666259765625L15.83320390625,15.8333259765625Q15.83320390625,15.9153259765625,15.81720390625,15.9958259765625Q15.80110390625,16.0763259765625,15.76970390625,16.152225976562498Q15.73830390625,16.2280259765625,15.69270390625,16.2962259765625Q15.64710390625,16.3645259765625,15.58910390625,16.4225259765625Q15.53100390625,16.4806259765625,15.46280390625,16.5262259765625Q15.39460390625,16.5718259765625,15.31870390625,16.6032259765625Q15.24290390625,16.6346259765625,15.16240390625,16.6506259765625Q15.08190390625,16.6666259765625,14.99980390625,16.6666259765625L1.66650390625,16.6666259765625Q1.58442770625,16.6666259765625,1.50392890625,16.6506259765625Q1.42342990625,16.6346259765625,1.34760090625,16.6032259765625Q1.27177290625,16.5718259765625,1.2035289062499999,16.5262259765625Q1.13528490625,16.4806259765625,1.07724790625,16.4225259765625Q1.01921190625,16.3645259765625,0.97361290625,16.2962259765625Q0.92801390625,16.2280259765625,0.89660490625,16.152225976562498Q0.86519490625,16.0763259765625,0.84918290625,15.9958259765625Q0.83317090625,15.9153259765625,0.83317090625,15.8333259765625ZM2.49983690625,4.9999589765625L2.49983690625,14.9999259765625L14.16650390625,14.9999259765625L14.16650390625,4.9999589765625L2.49983690625,4.9999589765625Z" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M18.97024,14.7041040234375Q19.06538,14.5913440234375,19.11602,14.4527940234375Q19.16667,14.3142340234375,19.16667,14.1667040234375L19.16667,5.8333740234375Q19.16667,5.7512978234375,19.15065,5.6707990234375Q19.13464,5.5903000234375,19.10323,5.5144710234375Q19.07182,5.4386430234375,19.026220000000002,5.3703990234375Q18.98063,5.3021550234375,18.92259,5.2441180234375Q18.86455,5.1860820234375,18.79631,5.1404830234375Q18.72806,5.0948840234375,18.65224,5.0634750234375Q18.57641,5.0320650234375,18.49591,5.0160530234375Q18.41541,5.0000410234375,18.33333,5.0000410234375Q18.18581,5.0000410234375,18.04725,5.0506860234375Q17.90869,5.1013300234375,17.79594,5.1964640234375L14.462608,8.0089640234375Q14.393074,8.067634023437499,14.337838,8.1399240234375Q14.282601,8.2122140234375,14.244265,8.2947240234375Q14.205928,8.377224023437499,14.186297,8.4660640234375Q14.166667,8.5548940234375,14.166667,8.6458740234375L14.166667,11.3542040234375Q14.166667,11.4451840234375,14.186297,11.5340240234375Q14.205928,11.622854023437501,14.244265,11.7053640234375Q14.282601,11.7878640234375,14.337838,11.860154023437499Q14.393074,11.932444023437501,14.462608,11.9911140234375L17.79594,14.8036140234375Q17.922629999999998,14.9105140234375,18.08058,14.9607840234375Q18.23853,15.0110640234375,18.4037,14.9970640234375Q18.56887,14.9830640234375,18.71611,14.9069240234375Q18.86335,14.8307940234375,18.97024,14.7041040234375ZM17.5,12.3732440234375L17.5,7.6268340234375L15.833333,9.0330840234375L15.833333,10.9669940234375L17.5,12.3732440234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M7.65749209375,7.3101989765625L10.11698609375,9.3597759765625Q10.17518609375,9.4082759765625,10.22367609375,9.4664759765625Q10.32979609375,9.5938159765625,10.37910609375,9.7520659765625Q10.42841609375,9.9103259765625,10.41340609375,10.0754059765625Q10.39839609375,10.2404859765625,10.321366093750001,10.3872559765625Q10.24432609375,10.5340259765625,10.11698609375,10.6401459765625L7.65748809375,12.6897259765625Q7.54118509375,12.7998059765625,7.39241009375,12.8590459765625Q7.24363409375,12.9182959765625,7.08349609375,12.9182959765625Q7.00125579375,12.9182959765625,6.92059609375,12.9022459765625Q6.83993609375,12.8862059765625,6.76395509375,12.8547359765625Q6.6879750937499995,12.8232559765625,6.61959509375,12.7775659765625Q6.55121509375,12.731875976562499,6.49306209375,12.673725976562501Q6.43490909375,12.6155759765625,6.38921909375,12.547195976562499Q6.34352909375,12.478815976562501,6.31205709375,12.4028359765625Q6.28058509375,12.3268559765625,6.26454009375,12.2461959765625Q6.24849609375,12.1655359765625,6.24849609375,12.0832959765625Q6.24849609375,11.9848059765625,6.27141009375,11.8890159765625Q6.29432409375,11.7932359765625,6.33889509375,11.7054159765625Q6.38346609375,11.6175859765625,6.44724609375,11.5425459765625Q6.51102709375,11.4674959765625,6.59051809375,11.4093459765625L8.28178609375,9.9999559765625L6.59051809375,8.5905679765625Q6.51102709375,8.5324209765625,6.44724609375,8.4573769765625Q6.38346509375,8.3823319765625,6.33889509375,8.2945069765625Q6.29432409375,8.2066819765625,6.27141009375,8.1108979765625Q6.24849609375,8.0151131765625,6.24849609375,7.9166259765625Q6.24849609375,7.8343856765625,6.26454009375,7.7537259765625Q6.28058509375,7.6730659765625,6.31205709375,7.5970849765625Q6.34352909375,7.5211049765624995,6.38921909375,7.4527249765625Q6.43490909375,7.3843449765625,6.49306209375,7.3261919765625Q6.55121509375,7.2680389765625,6.61959509375,7.2223489765625Q6.6879750937499995,7.1766589765625,6.76395509375,7.1451869765625Q6.83993609375,7.1137149765625,6.92059609375,7.0976699765625Q7.00125579375,7.0816259765625,7.08349609375,7.0816259765625Q7.24363509375,7.0816259765625,7.39241209375,7.1408709765625Q7.54118909375,7.2001159765625005,7.65749209375,7.3101989765625Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g></g>',
            2
          ),
        ])),
    ])
  )
}
const Qne = si($ne, [['render', Wne]]),
  jne = {},
  qne = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '14.000000357627869',
    height: '10.000000357627869',
    viewBox: '0 0 14.000000357627869 10.000000357627869',
  }
function Xne(n, e) {
  return (
    mt(),
    Ct('svg', qne, [
      ...(e[0] ||
        (e[0] = [
          kt(
            'g',
            null,
            [
              kt('path', {
                d: 'M13.802466686534881,1.1380186865348816Q13.89646668653488,1.0444176865348815,13.947366686534881,0.9218876865348815Q13.998366686534881,0.7993576865348816,13.998366686534881,0.6666666865348816Q13.998366686534881,0.6011698865348816,13.98556668653488,0.5369316865348817Q13.972766686534882,0.4726936865348816,13.947666686534882,0.4121826865348816Q13.922666686534882,0.3516706865348816,13.886266686534881,0.2972126865348816Q13.849866686534881,0.2427536865348816,13.803566686534882,0.19644068653488161Q13.757266686534882,0.15012768653488162,13.702766686534881,0.11373968653488165Q13.648366686534882,0.07735168653488156,13.587866686534882,0.052286686534881555Q13.527266686534881,0.02722268653488158,13.463066686534882,0.014444686534881623Q13.398866686534882,0.0016666865348815563,13.333366686534882,0.0016666865348815563Q13.201466686534882,0.0016666865348815563,13.079566686534882,0.051981686534881555Q12.957666686534882,0.10229768653488158,12.864266686534881,0.1953146865348816L12.863066686534882,0.19413268653488158L4.624996686534882,8.392776686534882L1.1369396865348815,4.921396686534882L1.1357636865348817,4.922586686534881Q1.0422996865348817,4.829566686534881,0.9204146865348816,4.779246686534882Q0.7985286865348816,4.728936686534881,0.6666666865348816,4.728936686534881Q0.6011698865348816,4.728936686534881,0.5369316865348817,4.741706686534882Q0.4726936865348816,4.754486686534881,0.4121826865348816,4.779556686534882Q0.3516706865348816,4.804616686534882,0.2972126865348816,4.8410066865348815Q0.2427536865348816,4.8773966865348815,0.19644068653488161,4.9237066865348815Q0.15012768653488162,4.970016686534882,0.11373968653488165,5.024476686534881Q0.07735168653488156,5.078936686534882,0.052286686534881555,5.139446686534882Q0.02722268653488158,5.199956686534882,0.014444686534881623,5.2641966865348815Q0.0016666865348815563,5.328436686534881,0.0016666865348815563,5.3939366865348815Q0.0016666865348815563,5.526626686534882,0.05259268653488158,5.649156686534882Q0.10351768653488158,5.771686686534881,0.1975696865348816,5.865286686534882L0.1963936865348816,5.866466686534881L4.1547266865348815,9.805866686534882Q4.201126686534882,9.852046686534882,4.255616686534882,9.888306686534882Q4.310106686534882,9.924576686534882,4.3706166865348814,9.949556686534882Q4.431126686534881,9.974536686534881,4.495326686534882,9.987266686534882Q4.559536686534882,9.999996686534882,4.624996686534882,9.999996686534882Q4.690456686534882,9.999996686534882,4.754666686534882,9.987266686534882Q4.818876686534882,9.974536686534881,4.879386686534882,9.949556686534882Q4.939886686534882,9.924576686534882,4.994386686534882,9.888306686534882Q5.048876686534881,9.852046686534882,5.0952766865348815,9.805866686534882L13.803566686534882,1.1392006865348816L13.802466686534881,1.1380186865348816Z',
                'fill-rule': 'evenodd',
                fill: '#E0E0FC',
                'fill-opacity': '1',
                style: { 'mix-blend-mode': 'passthrough' },
              }),
            ],
            -1
          ),
        ])),
    ])
  )
}
const DT = si(jne, [['render', Xne]]),
  Kne = {},
  Yne = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function Zne(n, e) {
  return (
    mt(),
    Ct('svg', Yne, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_13_287/13_278"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath><clipPath id="master_svg1_13_287/13_278/13_040"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_13_287/13_278)"><g clip-path="url(#master_svg1_13_287/13_278/13_040)"><g><path d="M7.34851109375,12.6516259765625Q8.44685609375,13.7499259765625,10.00016609375,13.7499259765625Q11.55346609375,13.7499259765625,12.65181609375,12.6516259765625Q13.75016609375,11.5532659765625,13.75016609375,9.9999559765625L13.75016609375,4.5832959765625Q13.75016609375,3.0299959765624997,12.65181609375,1.9316429765625Q11.55346609375,0.8332929765625,10.00016609375,0.8332919765625Q8.44685609375,0.8332929765625,7.34851109375,1.9316429765625Q6.25016309375,3.0299959765624997,6.25016309375,4.5832959765625L6.25016309375,9.9999559765625Q6.25016309375,11.5532659765625,7.34851109375,12.6516259765625ZM11.47330609375,11.4730959765625Q10.86310609375,12.0833259765625,10.00016609375,12.0833259765625Q9.13721609375,12.0833259765625,8.527026093749999,11.4730959765625Q7.91682909375,10.8629059765625,7.91682909375,9.9999559765625L7.91683009375,4.5832959765625Q7.91683009375,3.7203459765625,8.527026093749999,3.1101559765625Q9.13721609375,2.4999589765625,10.00016609375,2.4999589765625Q10.86310609375,2.4999589765625,11.47330609375,3.1101559765625Q12.08349609375,3.7203459765625,12.08349609375,4.5832959765625L12.08349609375,9.9999559765625Q12.08349609375,10.8629059765625,11.47330609375,11.4730959765625Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M17.08315046875,9.6393233234375Q17.08502046875,9.6113801234375,17.08502046875,9.5833740234375Q17.08502046875,9.5011337234375,17.06898046875,9.4204740234375Q17.05293046875,9.3398140234375,17.02146046875,9.2638330234375Q16.98999046875,9.1878530234375,16.94430046875,9.1194730234375Q16.89861046875,9.0510930234375,16.84046046875,8.9929400234375Q16.78230046875,8.9347870234375,16.71392346875,8.8890970234375Q16.64554246875,8.8434070234375,16.56956246875,8.8119350234375Q16.49358246875,8.7804630234375,16.41292246875,8.7644180234375Q16.33226246875,8.7483740234375,16.25002246875,8.7483740234375Q16.16778146875,8.7483740234375,16.08712146875,8.7644180234375Q16.00646146875,8.7804630234375,15.93048146875,8.8119350234375Q15.85450146875,8.8434070234375,15.78612106875,8.8890970234375Q15.71774076875,8.9347870234375,15.65958806875,8.9929400234375Q15.60143546875,9.0510930234375,15.55574546875,9.1194730234375Q15.51005446875,9.1878530234375,15.47858246875,9.2638330234375Q15.44711046875,9.3398140234375,15.43106646875,9.4204740234375Q15.41502246875,9.5011337234375,15.41502246875,9.5833740234375Q15.41502246875,9.6080265234375,15.41647646875,9.6326360234375Q15.40712446875,10.7164940234375,14.98582546875,11.7046140234375Q14.89498046875,11.8831040234375,14.89498046875,12.0833740234375Q14.89498046875,12.1656140234375,14.91102446875,12.2462740234375Q14.92706946875,12.3269340234375,14.95854146875,12.4029140234375Q14.99001346875,12.4788940234375,15.03570346875,12.5472740234375Q15.08139346875,12.6156540234375,15.13954646875,12.6738040234375Q15.19769946875,12.7319640234375,15.26607946875,12.7776540234375Q15.33445946875,12.8233440234375,15.41043946875,12.8548140234375Q15.48642046875,12.8862840234375,15.56708046875,12.9023340234375Q15.64774016875,12.9183740234375,15.72998046875,12.9183740234375Q15.79409136875,12.9183740234375,15.85745046875,12.9085840234375Q15.92081046875,12.8988040234375,15.98193346875,12.8794540234375Q16.04305546875,12.8601140234375,16.10050846875,12.8316640234375Q16.15796246875,12.8032140234375,16.21039846875,12.7663240234375Q16.26283546875,12.7294440234375,16.309026468749998,12.6849840234375Q16.35521746875,12.6405240234375,16.39408046875,12.5895340234375Q16.43294246875,12.538544023437499,16.46356646875,12.4822240234375Q16.49418946875,12.4258940234375,16.51585446875,12.3655540234375Q17.07244046875,11.0643540234375,17.08315046875,9.6393233234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M4.583527,9.6329521234375Q4.585,9.6081849234375,4.585,9.5833740234375Q4.585,9.5011337234375,4.568956,9.4204740234375Q4.552911,9.3398140234375,4.521439,9.2638330234375Q4.489967,9.1878530234375,4.444277,9.1194730234375Q4.398587,9.0510930234375,4.340434,8.9929400234375Q4.282281,8.9347870234375,4.213901,8.8890970234375Q4.1455210000000005,8.8434070234375,4.069541,8.8119350234375Q3.99356,8.7804630234375,3.9129,8.7644180234375Q3.8322403,8.7483740234375,3.75,8.7483740234375Q3.6677597,8.7483740234375,3.5871,8.7644180234375Q3.50644,8.7804630234375,3.430459,8.8119350234375Q3.354479,8.8434070234375,3.286099,8.8890970234375Q3.2177189999999998,8.9347870234375,3.159566,8.9929400234375Q3.101413,9.0510930234375,3.055723,9.1194730234375Q3.010033,9.1878530234375,2.978561,9.2638330234375Q2.947089,9.3398140234375,2.931044,9.4204740234375Q2.915,9.5011337234375,2.915,9.5833740234375Q2.915,9.6112012234375,2.916853,9.6389666234375Q2.9363479999999997,12.5370740234375,4.99132,14.5920540234375Q7.06598,16.6667040234375,10,16.6667040234375Q11.1917,16.6667040234375,12.30806,16.2819440234375Q12.37346,16.2636640234375,12.43505,16.235064023437502Q12.49663,16.2064640234375,12.55279,16.1682840234375Q12.60894,16.1301040234375,12.65819,16.0833540234375Q12.70744,16.036604023437498,12.74849,15.9825140234375Q12.78954,15.9284240234375,12.82131,15.868404023437499Q12.85308,15.8083940234375,12.87473,15.7440340234375Q12.89639,15.6796740234375,12.90736,15.6126640234375Q12.91833,15.5456540234375,12.91833,15.4777440234375Q12.91833,15.3955040234375,12.90229,15.3148440234375Q12.88624,15.2341840234375,12.85477,15.1582040234375Q12.8233,15.082224023437501,12.77761,15.0138440234375Q12.73192,14.9454640234375,12.67377,14.8873140234375Q12.61561,14.8291640234375,12.54723,14.783474023437499Q12.47885,14.7377840234375,12.40287,14.7063140234375Q12.32689,14.6748340234375,12.24623,14.658794023437501Q12.16557,14.6427540234375,12.08333,14.642744023437501Q11.91469,14.642744023437501,11.75926,14.7082040234375Q10.9093,15.0000440234375,10,15.0000440234375Q7.75633,15.0000440234375,6.16983,13.413544023437499Q4.6008890000000005,11.8445940234375,4.583527,9.6329521234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M10.833333,15.8861049234375Q10.835,15.8597658234375,10.835,15.8333740234375Q10.835,15.7511337234375,10.818956,15.6704740234375Q10.802911,15.5898140234375,10.771439,15.5138330234375Q10.739967,15.4378530234375,10.694277,15.3694730234375Q10.648587,15.3010930234375,10.590434,15.2429400234375Q10.532281,15.1847870234375,10.463901,15.1390970234375Q10.395521,15.0934070234375,10.319541,15.0619350234375Q10.24356,15.0304630234375,10.1629,15.0144180234375Q10.0822403,14.9983740234375,10,14.9983740234375Q9.9177597,14.9983740234375,9.8371,15.0144180234375Q9.75644,15.0304630234375,9.680459,15.0619350234375Q9.604479,15.0934070234375,9.536099,15.1390970234375Q9.467719,15.1847870234375,9.409566,15.2429400234375Q9.351413,15.3010930234375,9.305723,15.3694730234375Q9.260033,15.4378530234375,9.228561,15.5138330234375Q9.197089,15.5898140234375,9.181044,15.6704740234375Q9.165,15.7511337234375,9.165,15.8333740234375Q9.165,15.8597658234375,9.166667,15.8861049234375L9.166667,18.2806440234375Q9.165,18.3069840234375,9.165,18.3333740234375Q9.165,18.4156140234375,9.181044,18.4962740234375Q9.197089,18.5769340234375,9.228561,18.6529140234375Q9.260033,18.7288940234375,9.305723,18.7972740234375Q9.351413,18.8656540234375,9.409566,18.9238040234375Q9.467719,18.9819640234375,9.536099,19.0276540234375Q9.604479,19.0733440234375,9.680459,19.1048140234375Q9.75644,19.1362840234375,9.8371,19.1523340234375Q9.9177597,19.1683740234375,10,19.1683740234375Q10.0822403,19.1683740234375,10.1629,19.1523340234375Q10.24356,19.1362840234375,10.319541,19.1048140234375Q10.395521,19.0733440234375,10.463901,19.0276540234375Q10.532281,18.9819640234375,10.590434,18.9238040234375Q10.648587,18.8656540234375,10.694277,18.7972740234375Q10.739967,18.7288940234375,10.771439,18.6529140234375Q10.802911,18.5769340234375,10.818956,18.4962740234375Q10.835,18.4156140234375,10.835,18.3333740234375Q10.835,18.3069840234375,10.833333,18.2806440234375L10.833333,15.8861049234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M1.9480309999999998,3.126542Q1.813081,3.007654,1.7390400000000001,2.843752Q1.665,2.67985,1.665,2.5Q1.665,2.4177597,1.681044,2.3371Q1.697089,2.25644,1.728561,2.180459Q1.760033,2.104479,1.805723,2.036099Q1.851413,1.967719,1.9095659999999999,1.9095659999999999Q1.967719,1.851413,2.036099,1.805723Q2.104479,1.760033,2.180459,1.728561Q2.25644,1.697089,2.3371,1.681044Q2.4177597,1.665,2.5,1.665Q2.67985,1.665,2.843752,1.7390400000000001Q3.007654,1.813081,3.126542,1.9480309999999998L18.052,16.8735Q18.1869,16.9923,18.261,17.1562Q18.335,17.3202,18.335,17.5Q18.335,17.5822,18.319000000000003,17.6629Q18.3029,17.7436,18.2714,17.819499999999998Q18.240000000000002,17.8955,18.1943,17.963900000000002Q18.148600000000002,18.0323,18.090400000000002,18.090400000000002Q18.0323,18.148600000000002,17.963900000000002,18.1943Q17.8955,18.240000000000002,17.819499999999998,18.2714Q17.7436,18.3029,17.6629,18.319000000000003Q17.5822,18.335,17.5,18.335Q17.3202,18.335,17.1562,18.261Q16.9923,18.1869,16.8735,18.052L1.9480309999999998,3.126542Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g></g>',
            2
          ),
        ])),
    ])
  )
}
const Jne = si(Kne, [['render', Zne]]),
  eie = {},
  tie = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function nie(n, e) {
  return (
    mt(),
    Ct('svg', tie, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_13_278"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath><clipPath id="master_svg1_13_278/13_029"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_13_278)"><g clip-path="url(#master_svg1_13_278/13_029)"><g><rect x="0" y="0" width="20" height="20" rx="0" fill="#FFFFFF" fill-opacity="0.009999999776482582" style="mix-blend-mode:passthrough;"></rect></g><g><path d="M6.249918953125,9.9999559765625L6.249918953125,4.5832959765625Q6.249918953125,3.0299959765624997,7.348267953125,1.9316419765625Q8.446621953125,0.8332929765625,9.999921953125,0.8332929765625Q11.553221953125,0.8332929765625,12.651571953125,1.9316419765625Q13.749921953125,3.0299959765624997,13.749921953125,4.5832959765625L13.749921953125,9.9999559765625Q13.749921953125,11.5532559765625,12.651571953125,12.6516259765625Q11.553221953125,13.7499259765625,9.999921953125,13.7499259765625Q8.446621953125,13.7499259765625,7.348267953125,12.6516259765625Q6.249918953125,11.5532559765625,6.249918953125,9.9999559765625ZM7.916584953125,9.9999559765625Q7.916584953125,10.8629059765625,8.526781953124999,11.4730959765625Q9.136971953125,12.0833259765625,9.999921953125,12.0833259765625Q10.862861953125,12.0833259765625,11.473061953125,11.4730959765625Q12.083251953125,10.8629059765625,12.083251953125,9.9999559765625L12.083251953125,4.5832959765625Q12.083251953125,3.7203459765625,11.473061953125,3.1101559765625Q10.862861953125,2.4999589765625,9.999921953125,2.4999589765625Q9.136971953125,2.4999589765625,8.526781953124999,3.1101559765625Q7.916584953125,3.7203459765625,7.916584953125,4.5832959765625L7.916584953125,9.9999559765625Z" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M4.583527,9.6329521234375Q4.585,9.6081849234375,4.585,9.5833740234375Q4.585,9.5011337234375,4.568956,9.4204740234375Q4.552911,9.3398140234375,4.521439,9.2638330234375Q4.489967,9.1878530234375,4.444277,9.1194730234375Q4.398587,9.0510930234375,4.340434,8.9929400234375Q4.282281,8.9347870234375,4.213901,8.8890970234375Q4.1455210000000005,8.8434070234375,4.069541,8.8119350234375Q3.99356,8.7804630234375,3.9129,8.7644180234375Q3.8322403,8.7483740234375,3.75,8.7483740234375Q3.6677597,8.7483740234375,3.5871,8.7644180234375Q3.50644,8.7804630234375,3.430459,8.8119350234375Q3.354479,8.8434070234375,3.286099,8.8890970234375Q3.2177189999999998,8.9347870234375,3.159566,8.9929400234375Q3.101413,9.0510930234375,3.055723,9.1194730234375Q3.010033,9.1878530234375,2.978561,9.2638330234375Q2.947089,9.3398140234375,2.931044,9.4204740234375Q2.915,9.5011337234375,2.915,9.5833740234375Q2.915,9.6112012234375,2.916853,9.6389666234375Q2.9363479999999997,12.5370740234375,4.99132,14.5920540234375Q7.06598,16.6667040234375,10,16.6667040234375Q12.93402,16.6667040234375,15.0087,14.5920540234375Q17.0636,12.5370940234375,17.0831,9.6390003234375Q17.085,9.6112181234375,17.085,9.5833740234375Q17.085,9.5011337234375,17.069000000000003,9.4204740234375Q17.0529,9.3398140234375,17.0214,9.2638330234375Q16.990000000000002,9.1878530234375,16.9443,9.1194730234375Q16.898600000000002,9.0510930234375,16.840400000000002,8.9929400234375Q16.7823,8.9347870234375,16.713900000000002,8.8890970234375Q16.6455,8.8434070234375,16.569499999999998,8.8119350234375Q16.4936,8.7804630234375,16.4129,8.7644180234375Q16.3322,8.7483740234375,16.25,8.7483740234375Q16.1678,8.7483740234375,16.0871,8.7644180234375Q16.0064,8.7804630234375,15.9305,8.8119350234375Q15.8545,8.8434070234375,15.7861,8.8890970234375Q15.7177,8.9347870234375,15.6596,8.9929400234375Q15.6014,9.0510930234375,15.5557,9.1194730234375Q15.51,9.1878530234375,15.4786,9.2638330234375Q15.4471,9.3398140234375,15.431,9.4204740234375Q15.415,9.5011337234375,15.415,9.5833740234375Q15.415,9.6081817234375,15.4165,9.6329456234375Q15.3991,11.8445940234375,13.8302,13.413544023437499Q12.24366,15.0000440234375,10,15.0000440234375Q7.75633,15.0000440234375,6.16983,13.413544023437499Q4.6008890000000005,11.8445940234375,4.583527,9.6329521234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M10.833333,15.8861049234375Q10.835,15.8597658234375,10.835,15.8333740234375Q10.835,15.7511337234375,10.818956,15.6704740234375Q10.802911,15.5898140234375,10.771439,15.5138330234375Q10.739967,15.4378530234375,10.694277,15.3694730234375Q10.648587,15.3010930234375,10.590434,15.2429400234375Q10.532281,15.1847870234375,10.463901,15.1390970234375Q10.395521,15.0934070234375,10.319541,15.0619350234375Q10.24356,15.0304630234375,10.1629,15.0144180234375Q10.0822403,14.9983740234375,10,14.9983740234375Q9.9177597,14.9983740234375,9.8371,15.0144180234375Q9.75644,15.0304630234375,9.680459,15.0619350234375Q9.604479,15.0934070234375,9.536099,15.1390970234375Q9.467719,15.1847870234375,9.409566,15.2429400234375Q9.351413,15.3010930234375,9.305723,15.3694730234375Q9.260033,15.4378530234375,9.228561,15.5138330234375Q9.197089,15.5898140234375,9.181044,15.6704740234375Q9.165,15.7511337234375,9.165,15.8333740234375Q9.165,15.8597658234375,9.166667,15.8861049234375L9.166667,18.2806440234375Q9.165,18.3069840234375,9.165,18.3333740234375Q9.165,18.4156140234375,9.181044,18.4962740234375Q9.197089,18.5769340234375,9.228561,18.6529140234375Q9.260033,18.7288940234375,9.305723,18.7972740234375Q9.351413,18.8656540234375,9.409566,18.9238040234375Q9.467719,18.9819640234375,9.536099,19.0276540234375Q9.604479,19.0733440234375,9.680459,19.1048140234375Q9.75644,19.1362840234375,9.8371,19.1523340234375Q9.9177597,19.1683740234375,10,19.1683740234375Q10.0822403,19.1683740234375,10.1629,19.1523340234375Q10.24356,19.1362840234375,10.319541,19.1048140234375Q10.395521,19.0733440234375,10.463901,19.0276540234375Q10.532281,18.9819640234375,10.590434,18.9238040234375Q10.648587,18.8656540234375,10.694277,18.7972740234375Q10.739967,18.7288940234375,10.771439,18.6529140234375Q10.802911,18.5769340234375,10.818956,18.4962740234375Q10.835,18.4156140234375,10.835,18.3333740234375Q10.835,18.3069840234375,10.833333,18.2806440234375L10.833333,15.8861049234375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g></g>',
            2
          ),
        ])),
    ])
  )
}
const iie = si(eie, [['render', nie]]),
  rie = {},
  sie = {
    class: 'icon',
    viewBox: '0 0 1024 1024',
    version: '1.1',
    xmlns: 'http://www.w3.org/2000/svg',
  }
function oie(n, e) {
  return (
    mt(),
    Ct('svg', sie, [
      ...(e[0] ||
        (e[0] = [
          kt(
            'path',
            {
              d: 'M899.925333 172.080762a48.761905 48.761905 0 0 1 0 28.525714l-207.969523 679.448381a48.761905 48.761905 0 0 1-81.115429 20.187429l-150.552381-150.552381-96.304762 96.329143a24.380952 24.380952 0 0 1-41.593905-17.237334v-214.966857l275.821715-243.370667-355.57181 161.596953-103.253333-103.228953a48.761905 48.761905 0 0 1 20.23619-81.091047L838.997333 139.702857a48.761905 48.761905 0 0 1 60.903619 32.353524z',
            },
            null,
            -1
          ),
        ])),
    ])
  )
}
const aie = si(rie, [['render', oie]]),
  lie = {},
  cie = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function uie(n, e) {
  return (
    mt(),
    Ct('svg', cie, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_20_113"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_20_113)"><g><path d="M17.52452171875,9.078936578124999Q17.659471718749998,8.960048578125,17.73351171875,8.796145578125Q17.80755171875,8.632242578125,17.80755171875,8.452392578125Q17.80755171875,8.370152278125,17.79151171875,8.289492578125Q17.77546171875,8.208832578125,17.74399171875,8.132851578125Q17.71252171875,8.056871578125,17.66683171875,7.988491578125Q17.62114171875,7.920111578125,17.56299171875,7.861958578125Q17.50483171875,7.803805578125,17.43645171875,7.758115578125Q17.36807171875,7.712425578125,17.29209171875,7.680953578125Q17.21611171875,7.649481578125,17.13545171875,7.633436578125Q17.05479171875,7.617392578125,16.97255171875,7.617392578125Q16.79270171875,7.617392578125,16.62880171875,7.691433578125Q16.46490171875,7.765474578125,16.34601171875,7.900425578125L12.88504271875,11.361392578124999Q12.75009271875,11.480282578125,12.67605171875,11.644182578125001Q12.60201171875,11.808082578125,12.60201171875,11.987932578125001Q12.60201171875,12.070172578125,12.61805571875,12.150832578125Q12.63410071875,12.231492578125,12.66557271875,12.307472578125001Q12.69704471875,12.383452578125,12.74273471875,12.451832578125Q12.78842471875,12.520212578125001,12.84657771875,12.578362578124999Q12.90473071875,12.636522578125,12.97311071875,12.682212578125Q13.04149071875,12.727902578125,13.11747071875,12.759372578125Q13.19345171875,12.790842578125,13.27411171875,12.806892578125Q13.35477141875,12.822932578125,13.43701171875,12.822932578125Q13.61685971875,12.822932578125,13.78076071875,12.748892578125Q13.94466171875,12.674852578125,14.06354971875,12.539902578125L17.52452171875,9.078936578124999Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M12.88553,9.078933578125Q12.75058,8.960045578125,12.67654,8.796143578125Q12.6025,8.632241578125,12.6025,8.452392578125Q12.6025,8.370152278125,12.618544,8.289492578125Q12.634589,8.208832578125,12.666061,8.132851578125Q12.697533,8.056871578125,12.743223,7.988491578125Q12.788913,7.920111578125,12.847066,7.861958578125Q12.905219,7.803805578125,12.973599,7.758115578125Q13.041979,7.712425578125,13.117959,7.680953578125Q13.19394,7.649481578125,13.2746,7.633436578125Q13.3552597,7.617392578125,13.4375,7.617392578125Q13.617349,7.617392578125,13.781251,7.691432578125Q13.945153,7.765472578125,14.064041,7.900422578125L17.52501,11.361392578124999Q17.659959999999998,11.480282578125,17.734,11.644182578125001Q17.80804,11.808082578125,17.80804,11.987932578125001Q17.80804,12.070172578125,17.792,12.150832578125Q17.77595,12.231492578125,17.74448,12.307472578125001Q17.71301,12.383452578125,17.66732,12.451832578125Q17.62163,12.520212578125001,17.56347,12.578362578124999Q17.50532,12.636522578125,17.43694,12.682212578125Q17.36856,12.727902578125,17.29258,12.759372578125Q17.2166,12.790842578125,17.13594,12.806892578125Q17.05528,12.822932578125,16.97304,12.822932578125Q16.79319,12.822932578125,16.62929,12.748892578125Q16.46539,12.674852578125,16.3465,12.539902578125L12.88553,9.078933578125Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M4.44364390625,5.42117L2.49983690625,5.42117Q1.80948090625,5.42117,1.32132890625,5.90931Q0.83317090625,6.39747,0.83317090625,7.08783L0.83317090625,12.8496Q0.83317090625,13.54,1.32132990625,14.0281Q1.80948090625,14.5163,2.49983690625,14.5163L4.43961390625,14.5163Q6.77175390625,18.3333,9.99983390625,18.3333Q10.08191390625,18.3333,10.16241390625,18.3173Q10.24291390625,18.301299999999998,10.31874390625,18.2699Q10.39456390625,18.238500000000002,10.46281390625,18.1929Q10.53105390625,18.1473,10.58909390625,18.0893Q10.64713390625,18.0312,10.69272390625,17.963Q10.73832390625,17.8947,10.76973390625,17.8189Q10.80114390625,17.7431,10.81715390625,17.662599999999998Q10.83317390625,17.5821,10.83317390625,17.5L10.83317390625,2.5Q10.83317390625,2.4179238,10.81715390625,2.337425Q10.80114390625,2.256926,10.76973390625,2.181097Q10.73832390625,2.105269,10.69272390625,2.037025Q10.64712390625,1.968781,10.58909390625,1.910744Q10.53105390625,1.852708,10.46281390625,1.807109Q10.39456390625,1.76151,10.31874390625,1.7301009999999999Q10.24291390625,1.698691,10.16241390625,1.682679Q10.08191390625,1.666667,9.99983390625,1.666667Q6.77619390625,1.666667,4.44364390625,5.42117ZM4.91587390625,7.08783Q5.02559390625,7.08783,5.13157390625,7.05943Q5.23755390625,7.03103,5.3325739062499995,6.97617Q5.42758390625,6.92131,5.50516390625,6.84372Q5.58274390625,6.76614,5.63759390625,6.67111Q7.22859390625,3.91495,9.16650390625,3.434681L9.16650390625,16.563299999999998Q7.23188390625,16.074199999999998,5.6405439062500005,13.2715Q5.58600390625,13.1754,5.50830390625,13.0969Q5.4306139062500005,13.0184,5.33514390625,12.9628Q5.23966390625,12.9072,5.1330139062499995,12.8784Q5.02635390625,12.8496,4.91587390625,12.8496L2.49983690625,12.8496L2.49983790625,7.08783L4.91587390625,7.08783Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g>',
            2
          ),
        ])),
    ])
  )
}
const die = si(lie, [['render', uie]]),
  hie = {},
  fie = {
    xmlns: 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    fill: 'none',
    version: '1.1',
    width: '20',
    height: '20',
    viewBox: '0 0 20 20',
  }
function pie(n, e) {
  return (
    mt(),
    Ct('svg', fie, [
      ...(e[0] ||
        (e[0] = [
          Pu(
            '<defs><clipPath id="master_svg0_13_280"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath><clipPath id="master_svg1_13_280/13_053"><rect x="0" y="0" width="20" height="20" rx="0"></rect></clipPath></defs><g clip-path="url(#master_svg0_13_280)"><g clip-path="url(#master_svg1_13_280/13_053)"><g><rect x="0" y="0" width="20" height="20" rx="0" fill="#FFFFFF" fill-opacity="0.009999999776482582" style="mix-blend-mode:passthrough;"></rect></g><g><path d="M4.443888046875,5.42117L2.500081046875,5.42117Q1.809725046875,5.42117,1.321573046875,5.90931Q0.833415046875,6.39747,0.833415046875,7.08783L0.833415046875,12.8496Q0.833415046875,13.54,1.321574046875,14.0281Q1.809725046875,14.5163,2.500081046875,14.5163L4.439858046875,14.5163Q6.771998046875,18.3333,10.000078046875,18.3333Q10.082158046875,18.3333,10.162658046875,18.3173Q10.243158046875,18.301299999999998,10.318988046875,18.2699Q10.394808046875,18.238500000000002,10.463058046875,18.1929Q10.531298046875,18.1473,10.589338046875,18.0893Q10.647378046875,18.0312,10.692968046875,17.963Q10.738568046875,17.8947,10.769978046875,17.8189Q10.801388046875,17.7431,10.817398046875,17.662599999999998Q10.833418046875,17.5821,10.833418046875,17.5L10.833418046875,2.5Q10.833418046875,2.4179238,10.817398046875,2.337425Q10.801388046875,2.256926,10.769978046875,2.181097Q10.738568046875,2.105269,10.692968046875,2.037025Q10.647368046875,1.968781,10.589338046875,1.910744Q10.531298046875,1.852708,10.463058046875,1.807109Q10.394808046875,1.76151,10.318988046875,1.7301009999999999Q10.243158046875,1.698691,10.162658046875,1.682679Q10.082158046875,1.666667,10.000078046875,1.666667Q6.776438046875,1.666667,4.443888046875,5.42117ZM4.916118046875,7.08783Q5.025838046875,7.08783,5.131818046875,7.05943Q5.237798046875,7.03103,5.3328180468749995,6.97617Q5.427828046875,6.92131,5.505408046875,6.84372Q5.582988046875,6.76614,5.637838046875,6.67111Q7.228838046875,3.91495,9.166748046875,3.434681L9.166748046875,16.563299999999998Q7.232128046875,16.074199999999998,5.6407880468750005,13.2715Q5.586248046875,13.1754,5.508548046875,13.0969Q5.4308580468750005,13.0184,5.335388046875,12.9628Q5.239908046875,12.9072,5.1332580468749995,12.8784Q5.026598046875,12.8496,4.916118046875,12.8496L2.500081046875,12.8496L2.500082046875,7.08783L4.916118046875,7.08783Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M12.813896953124999,6.903831Q12.740067953125,6.845187,12.681175953125,6.771557Q12.622282953125,6.697926,12.581291953125,6.613017Q12.540300953125,6.528109,12.519276953125,6.436197Q12.498251953125,6.3442856,12.498251953125,6.25Q12.498251953125,6.1677597,12.514295953125,6.0871Q12.530340953125,6.00644,12.561812953125,5.930459Q12.593284953125,5.8544789999999995,12.638974953125,5.786099Q12.684664953125,5.717719,12.742817953125,5.659566Q12.800970953125,5.601413,12.869350953125,5.555723Q12.937730953125,5.510033,13.013710953125,5.478561Q13.089691953125,5.447089,13.170351953125,5.431044Q13.251011653125,5.415,13.333251953125,5.415Q13.501904953125,5.415,13.657335953125,5.4804580000000005Q13.812766953125,5.545916,13.930607953125,5.66657Q14.362131953125001,6.059567,14.707911953125,6.532997Q15.248111953125001,7.2726299999999995,15.535961953125,8.14354Q15.833251953125,9.04304,15.833251953125,10Q15.833251953125,10.94869,15.540941953125,11.84127Q15.257921953125,12.70551,14.726221953125,13.4418Q14.373671953125,13.92992,13.930609953125,14.33343Q13.812768953125,14.45408,13.657336953125,14.51954Q13.501904953125,14.585,13.333251953125,14.585Q13.251011653125,14.585,13.170351953125,14.56895Q13.089691953125,14.55291,13.013710953125,14.52144Q12.937730953125,14.48997,12.869350953125,14.44428Q12.800970953125,14.39859,12.742817953125,14.34043Q12.684664953125,14.28228,12.638974953125,14.213899999999999Q12.593284953125,14.145520000000001,12.561812953125,14.06954Q12.530340953125,13.99356,12.514295953125,13.9129Q12.498251953125,13.832239999999999,12.498251953125,13.75Q12.498251953125,13.655719999999999,12.519276953125,13.5638Q12.540300953125,13.47189,12.581291953125,13.386980000000001Q12.622282953125,13.30207,12.681174953125,13.228439999999999Q12.740067953125,13.154810000000001,12.813895953125,13.09617Q13.125969953125,12.8109,13.375114153125,12.46595Q14.166584953125,11.36993,14.166584953125,10Q14.166584953125,8.61762,13.362005753125,7.516Q13.117749953125,7.181583,12.813896953124999,6.903831Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g><g><path d="M14.863105578125,2.228405984375Q16.823672578125,3.456592984375,17.969842578125,5.468508984375Q19.166602578125,7.569218984375,19.166602578125,10.000018984375Q19.166602578125,12.469708984375,17.933552578125,14.594658984375Q16.751772578125,16.631258984375002,14.739248578125,17.847858984375Q14.525103578125,17.995758984375,14.264892578125,17.995758984375Q14.182652278125,17.995758984375,14.101992578125,17.979658984375Q14.021332578125,17.963658984375,13.945351578125,17.932158984375Q13.869371578125,17.900658984375,13.800991578125,17.854958984375Q13.732611578125,17.809358984375002,13.674458578125,17.751158984375Q13.616305578125,17.692958984375,13.570615578125,17.624658984375Q13.524925578125,17.556258984375,13.493453578125,17.480258984375Q13.461981578125,17.404258984374998,13.445936578125,17.323658984375Q13.429892578125,17.242958984375,13.429892578125,17.160758984375Q13.429892578125,17.045958984374998,13.460862578124999,16.935458984375Q13.491831578125,16.824858984375,13.551473578125,16.726858984375Q13.611115578125,16.628758984375,13.695005578125,16.550458984375Q13.778896578125,16.472058984375,13.880811578125,16.419258984375Q15.525652578125,15.423558984375,16.492012578125,13.758158984375Q17.499932578125,12.021168984375,17.499932578125,10.000018984375Q17.499932578125,8.010658984374999,16.521692578125,6.293508984375Q15.584492578125,4.648418984375,13.982075578125,3.643182984375Q13.882499578125,3.589574984375,13.800770578125,3.511412984375Q13.719041578125,3.433249984375,13.661047578125,3.336162984375Q13.603053578125,3.239076984375,13.572972578125,3.130062984375Q13.542891578125,3.021047984375,13.542891578125,2.907958984375Q13.542891578125,2.825718684375,13.558936578125,2.745058984375Q13.574980578125,2.664398984375,13.606452578125,2.588417984375Q13.637924578125,2.512437984375,13.683614578125,2.444057984375Q13.729305578125,2.3756779843749998,13.787457578125,2.317524984375Q13.845610578125,2.259371984375,13.913990578125,2.213681984375Q13.982370578125,2.167991984375,14.058351578125,2.136519984375Q14.134331578125,2.105047984375,14.214991478125,2.089002984375Q14.295651478125,2.072958984375,14.377891578125,2.072958984375Q14.508378578125,2.072958984375,14.632644578125,2.112769984375Q14.756910578125,2.152579984375,14.863105578125,2.228405984375Z" fill-rule="evenodd" fill="#FFFFFF" fill-opacity="1" style="mix-blend-mode:passthrough;"></path></g></g></g>',
            2
          ),
        ])),
    ])
  )
}
const mie = si(hie, [['render', pie]]),
  gie = {},
  yie = {
    t: '1744352112173',
    class: 'icon',
    viewBox: '0 0 1024 1024',
    version: '1.1',
    xmlns: 'http://www.w3.org/2000/svg',
    'p-id': '16533',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    width: '200',
    height: '200',
  }
function vie(n, e) {
  return (
    mt(),
    Ct('svg', yie, [
      ...(e[0] ||
        (e[0] = [
          kt(
            'path',
            {
              d: 'M824 466.56V213.12q0-13.6512-5.2928-26.1632-5.104-12.064-14.3904-21.3536-9.2864-9.2864-21.3504-14.3872-12.5152-5.2928-26.1664-5.2928H246.4q-13.6512 0-26.1664 5.2928-12.064 5.1008-21.3504 14.3872-9.2864 9.2864-14.3904 21.3536Q179.2 199.4688 179.2 213.12v607.296q0 12.8448 5.0592 24.608 4.8576 11.2896 13.6704 19.9552 8.7616 8.6176 20.1184 13.344Q229.7792 883.2 242.56 883.2h217.6a28.8 28.8 0 0 0 0-57.6h-217.6q-2.528 0-4.2432-1.6864-1.5168-1.4912-1.5168-3.4976V213.12q0-3.9744 2.8128-6.784 2.8096-2.816 6.7872-2.816h510.4q3.9776 0 6.7872 2.816 2.8128 2.8096 2.8128 6.784v253.44a28.8 28.8 0 0 0 28.8 28.8 28.8 28.8 0 0 0 28.8-28.8zM466.0064 338.08l-130.2016 278.784A32 32 0 0 0 364.8 662.4h0.176a31.9904 31.9904 0 0 0 28.8192-18.4576L418.048 592h165.4976l15.2896 32.736q3.1008-3.4144 6.3904-6.704 20.3584-20.3616 45.4816-33.472l-115.1168-246.4832q-4.9408-10.5792-14.8704-16.5952-9.168-5.5552-19.9232-5.5552-10.7552 0-19.9232 5.5552-9.9296 6.016-14.8704 16.5952z m34.7936 76.7456L553.6576 528h-105.7152l52.8576-113.1776zM896 750.4c0 87.4816-70.9184 158.4-158.4 158.4S579.2 837.8816 579.2 750.4s70.9184-158.4 158.4-158.4 158.4 70.9184 158.4 158.4z m-116.3648-82.7648a28.9152 28.9152 0 0 1 7.1648-5.232q-5.8048-3.232-12.096-5.7248Q756.8256 649.6 737.6 649.6q-19.2256 0-37.104 7.0784-19.4112 7.6832-34.1728 22.448-14.7616 14.7616-22.4448 34.1696Q636.8 731.1744 636.8 750.4q0 19.232 7.0784 37.104 2.4896 6.2944 5.7248 12.096a28.7552 28.7552 0 0 1 5.232-7.1648l124.8-124.8zM838.4 750.4q0-19.2256-7.0784-37.104-2.4896-6.2912-5.7248-12.096a28.6944 28.6944 0 0 1-5.232 7.168l-124.8 124.8a28.7552 28.7552 0 0 1-7.1648 5.2288q5.8048 3.2352 12.096 5.728Q718.3744 851.2 737.6 851.2q19.2256 0 37.104-7.072 19.4112-7.6896 34.1728-22.4512 14.7616-14.7616 22.4448-34.1728Q838.4 769.632 838.4 750.4z',
              'p-id': '16534',
            },
            null,
            -1
          ),
        ])),
    ])
  )
}
const _ie = si(gie, [['render', vie]]),
  xie = {},
  Sie = {
    t: '1744352097285',
    class: 'icon',
    viewBox: '0 0 1024 1024',
    version: '1.1',
    xmlns: 'http://www.w3.org/2000/svg',
    'p-id': '16380',
    'data-spm-anchor-id': 'a313x.manage_type_myprojects.0.i0.60b03a81nz0mun',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    width: '200',
    height: '200',
  }
function Aie(n, e) {
  return (
    mt(),
    Ct('svg', Sie, [
      ...(e[0] ||
        (e[0] = [
          kt(
            'path',
            {
              d: 'M833.6 213.12v253.44a28.8 28.8 0 0 1-28.8 28.8 28.8 28.8 0 0 1-28.8-28.8V213.12q0-3.9744-2.8128-6.784-2.8096-2.816-6.7872-2.816H256q-3.9776 0-6.7872 2.816Q246.4 209.1424 246.4 213.12v607.296q0 2.0064 1.5168 3.4976 1.7152 1.6864 4.2432 1.6864h217.6a28.8 28.8 0 0 1 0 57.6h-217.6q-12.7808 0-24.512-4.8768-11.3568-4.7232-20.1184-13.3408-8.8128-8.6656-13.6704-19.9584Q188.8 833.264 188.8 820.416V213.12q0-13.6512 5.2928-26.1632 5.104-12.064 14.3904-21.3536 9.2864-9.2864 21.3504-14.3872Q242.3456 145.92 256 145.92h510.4q13.6512 0 26.1664 5.2928 12.064 5.1008 21.3504 14.3872 9.2864 9.2864 14.3904 21.3536 5.2928 12.512 5.2928 26.1664zM345.408 613.664l130.1984-278.784q4.9408-10.5824 14.8704-16.5984 9.168-5.5552 19.9232-5.5552 10.7552 0 19.9232 5.5552 9.9296 6.016 14.8704 16.5952l130.2016 278.784a32 32 0 0 1-28.672 45.5392l-0.3232 0.0032c-12.4288 0-23.7344-7.2-28.9952-18.4608L593.1488 588.8h-165.4976l-24.256 51.9424a32.0064 32.0064 0 0 1-28.8192 18.4576l-0.176 0.0032a32 32 0 0 1-28.992-45.5424z m164.992-202.0416L457.5424 524.8h105.7152L510.4 411.6224z m120.2784 329.44l61.3216 61.5872 162.1248-162.8256a31.9936 31.9936 0 0 1 22.608-9.424H876.8a32 32 0 0 1 32 31.936v0.064a32 32 0 0 1-9.3216 22.5792l-184.8 185.6-0.0992 0.0992a31.9936 31.9936 0 0 1-45.2544-0.096l-83.984-84.352-0.016-0.016a31.9904 31.9904 0 0 1-9.2896-21.1104l30.496-33.4336c0.4896-0.0224 0.9792-0.032 1.4688-0.032h0.0704a32 32 0 0 1 22.608 9.4208z',
              'p-id': '16381',
              'data-spm-anchor-id': 'a313x.manage_type_myprojects.0.i1.60b03a81nz0mun',
              class: 'selected',
            },
            null,
            -1
          ),
        ])),
    ])
  )
}
const bie = si(xie, [['render', Aie]]),
  Tie = { class: 'action-group' },
  wie = ['onClick'],
  Cie = { key: 0, class: 'active-icon' },
  Eie = ['onClick'],
  Mie = { key: 0, class: 'active-icon' },
  Rie = qt({
    __name: 'ActionGroup',
    setup(n) {
      const e = k0(),
        t = ba(),
        {
          hasCamera: i,
          hasMic: r,
          cameraOff: s,
          micMuted: o,
          volumeMuted: a,
          showChatRecords: l,
          streamState: c,
          selectedAudioDevice: u,
          selectedVideoDevice: d,
          availableAudioDevices: h,
          availableVideoDevices: f,
        } = dm(e),
        {
          handleCameraOff: p,
          handleMicMuted: g,
          handleVolumeMute: y,
          handleDeviceChange: m,
          handleSubtitleToggle: v,
        } = e,
        { wrapperRect: x, isLandscape: _ } = dm(t),
        S = Dn(!1),
        C = Dn(!1)
      return (A, R) => {
        const w = E8('click-outside')
        return (
          mt(),
          Ct('div', Tie, [
            Ke(i)
              ? Pc(
                  (mt(),
                  Ct(
                    'div',
                    {
                      key: 0,
                      class: 'action',
                      onClick: R[1] || (R[1] = (...M) => Ke(p) && Ke(p)(...M)),
                    },
                    [
                      Te(Ke(Ed), { icon: Ke(s) ? Ke(Hne) : Ke(Qne) }, null, 8, ['icon']),
                      Ke(c) === 'closed'
                        ? (mt(),
                          Ct(
                            'div',
                            {
                              key: 0,
                              class: 'corner',
                              onClick:
                                R[0] ||
                                (R[0] = vf(() => (C.value = !C.value), ['stop', 'prevent'])),
                            },
                            [...(R[6] || (R[6] = [kt('div', { class: 'corner-inner' }, null, -1)]))]
                          ))
                        : qr('', !0),
                      Pc(
                        kt(
                          'div',
                          { class: Wo(['selectors', { left: Ke(_) }]) },
                          [
                            (mt(!0),
                            Ct(
                              Hn,
                              null,
                              th(
                                Ke(f),
                                (M) => (
                                  mt(),
                                  Ct(
                                    'div',
                                    {
                                      key: M.deviceId,
                                      class: 'selector',
                                      onClick: vf(() => {
                                        ;(Ke(m)(M.deviceId), (C.value = !1))
                                      }, ['stop']),
                                    },
                                    [
                                      om(su(M.label) + ' ', 1),
                                      Ke(d) && M.deviceId === Ke(d).deviceId
                                        ? (mt(), Ct('div', Cie, [Te(Ke(DT))]))
                                        : qr('', !0),
                                    ],
                                    8,
                                    wie
                                  )
                                )
                              ),
                              128
                            )),
                          ],
                          2
                        ),
                        [[cm, C.value && Ke(c) === 'closed']]
                      ),
                    ]
                  )),
                  [[w, () => (C.value = !1)]]
                )
              : qr('', !0),
            Ke(r)
              ? Pc(
                  (mt(),
                  Ct(
                    'div',
                    {
                      key: 1,
                      class: 'action',
                      onClick: R[3] || (R[3] = (...M) => Ke(g) && Ke(g)(...M)),
                    },
                    [
                      Te(Ke(Ed), { icon: Ke(o) ? Ke(Jne) : Ke(iie) }, null, 8, ['icon']),
                      Ke(c) === 'closed'
                        ? (mt(),
                          Ct(
                            'div',
                            {
                              key: 0,
                              class: 'corner',
                              onClick:
                                R[2] ||
                                (R[2] = vf(() => (S.value = !S.value), ['stop', 'prevent'])),
                            },
                            [...(R[7] || (R[7] = [kt('div', { class: 'corner-inner' }, null, -1)]))]
                          ))
                        : qr('', !0),
                      Pc(
                        kt(
                          'div',
                          { class: Wo(['selectors', { left: Ke(_) }]) },
                          [
                            (mt(!0),
                            Ct(
                              Hn,
                              null,
                              th(
                                Ke(h),
                                (M) => (
                                  mt(),
                                  Ct(
                                    'div',
                                    {
                                      key: M.deviceId,
                                      class: 'selector',
                                      onClick: vf(
                                        (I) => {
                                          ;(Ke(m)(M.deviceId), (S.value = !1))
                                        },
                                        ['stop']
                                      ),
                                    },
                                    [
                                      om(su(M.label) + ' ', 1),
                                      Ke(u) && M.deviceId === Ke(u).deviceId
                                        ? (mt(), Ct('div', Mie, [Te(Ke(DT))]))
                                        : qr('', !0),
                                    ],
                                    8,
                                    Eie
                                  )
                                )
                              ),
                              128
                            )),
                          ],
                          2
                        ),
                        [[cm, S.value && Ke(c) === 'closed']]
                      ),
                    ]
                  )),
                  [[w, () => (S.value = !1)]]
                )
              : qr('', !0),
            kt(
              'div',
              { class: 'action', onClick: R[4] || (R[4] = (...M) => Ke(y) && Ke(y)(...M)) },
              [Te(Ke(Ed), { icon: Ke(a) ? Ke(die) : Ke(mie) }, null, 8, ['icon'])]
            ),
            Ke(x).width > 300
              ? (mt(),
                Ct(
                  'div',
                  {
                    key: 2,
                    class: 'action',
                    onClick: R[5] || (R[5] = (...M) => Ke(v) && Ke(v)(...M)),
                  },
                  [Te(Ke(Ed), { icon: Ke(l) ? Ke(bie) : Ke(_ie) }, null, 8, ['icon'])]
                ))
              : qr('', !0),
          ])
        )
      }
    },
  }),
  Iie = si(Rie, [['__scopeId', 'data-v-f5429897']]),
  Nie = { class: 'gradio-webrtc-waveContainer' },
  Pie = qt({
    __name: 'AudioWave',
    props: {
      streamState: { default: qi.closed },
      audioSourceCallback: {},
      numBars: { default: 16 },
      icon: {},
      iconButtonColor: { default: 'var(--color-accent)' },
      pulseColor: { default: 'var(--color-accent)' },
      waveColor: { default: 'var(--color-accent)' },
      pulseScale: { default: 1 },
    },
    emits: [],
    setup(n, { emit: e }) {
      const t = n
      let i, r, s, o
      const a = Ge(() =>
        t.icon ? '128px' : 'calc((var(--boxSize) + var(--gutter)) * '.concat(t.numBars, ' + 80px)')
      )
      ;(Jn(
        () => t.streamState,
        () => {
          ;(console.log(111111), t.streamState === 'open' && l())
        },
        { immediate: !0 }
      ),
        Fh(() => {
          ;(o && cancelAnimationFrame(o), i && i.close())
        }))
      function l() {
        ;((i = new (window.AudioContext || window.webkitAudioContext)()), (r = i.createAnalyser()))
        const d = t.audioSourceCallback()
        if (!d) return
        ;(i.createMediaStreamSource(d).connect(r),
          (r.fftSize = 64),
          (r.smoothingTimeConstant = 0.8),
          (s = new Uint8Array(r.frequencyBinCount)),
          c())
      }
      function c() {
        r.getByteFrequencyData(s)
        const d = document.querySelectorAll('.gradio-webrtc-waveContainer .gradio-webrtc-box')
        for (let h = 0; h < d.length; h++) {
          const f = s[u(h)] / 255,
            p = d[h]
          ;((p.style.transform = 'scaleY('.concat(Math.max(0.1, f), ')')),
            (p.style.background = t.waveColor),
            (p.style.opacity = '0.5'))
        }
        o = requestAnimationFrame(c)
      }
      function u(d) {
        const h = [0, 2, 4, 6, 8, 10, 12, 14, 15, 13, 11, 9, 7, 5, 3, 1]
        if (d < 0 || d >= h.length) throw new Error('Index must be between 0 and 15')
        return h[d]
      }
      return (d, h) => (
        mt(),
        Ct('div', Nie, [
          kt(
            'div',
            { class: 'gradio-webrtc-boxContainer', style: Go({ width: a.value }) },
            [
              (mt(!0),
              Ct(
                Hn,
                null,
                th(
                  Array(d.numBars / 2),
                  (f, p) => (mt(), Ct('div', { key: p, class: 'gradio-webrtc-box' }))
                ),
                128
              )),
              h[0] || (h[0] = kt('div', { class: 'split-container' }, null, -1)),
              (mt(!0),
              Ct(
                Hn,
                null,
                th(
                  Array(d.numBars / 2),
                  (f, p) => (mt(), Ct('div', { key: p, class: 'gradio-webrtc-box' }))
                ),
                128
              )),
            ],
            4
          ),
        ])
      )
    },
  }),
  Lie = si(Pie, [['__scopeId', 'data-v-d7e47480']]),
  Die = { class: 'player-controls' },
  Fie = { key: 0 },
  Oie = { key: 1, class: 'waiting-icon-text' },
  Bie = { class: 'icon', title: 'spinner' },
  Uie = { key: 2, class: 'stop-chat-inner' },
  kie = { key: 0, class: 'input-audio-wave' },
  zie = qt({
    __name: 'ChatBtn',
    props: {
      streamState: { type: String, default: qi.closed },
      onStartChat: { type: Function, required: !0 },
      audioSourceCallback: { type: Function, required: !0 },
      waveColor: { type: String, required: !0 },
    },
    emits: [],
    setup(n, { emit: e }) {
      return (t, i) => (
        mt(),
        Ct('div', Die, [
          kt(
            'div',
            {
              class: Wo([
                'chat-btn',
                n.streamState === Ke(qi).closed && 'start-chat',
                n.streamState === Ke(qi).open && 'stop-chat',
              ]),
              onClick: i[0] || (i[0] = (...r) => n.onStartChat && n.onStartChat(...r)),
            },
            [
              n.streamState === Ke(qi).closed
                ? (mt(), Ct('span', Fie, '点击开始对话'))
                : n.streamState === Ke(qi).waiting
                  ? (mt(),
                    Ct('div', Oie, [
                      kt('div', Bie, [Te(Ke(qd), { 'wrapper-class-name': 'spin-icon' })]),
                      i[1] || (i[1] = kt('span', null, '等待中', -1)),
                    ]))
                  : (mt(), Ct('div', Uie)),
            ],
            2
          ),
          n.streamState === Ke(qi).open
            ? (mt(),
              Ct('div', kie, [
                Te(
                  Lie,
                  {
                    'audio-source-callback': n.audioSourceCallback,
                    'stream-state': n.streamState,
                    'wave-color': n.waveColor,
                  },
                  null,
                  8,
                  ['audio-source-callback', 'stream-state', 'wave-color']
                ),
              ]))
            : qr('', !0),
        ])
      )
    },
  }),
  Vie = si(zie, [['__scopeId', 'data-v-1ac3c442']])
function Hie(n, e, t) {
  return t < 0 || t > n.length
    ? (console.error('索引超出范围'), n)
    : n.substring(0, t) + e + n.substring(t)
}
const $ie = { class: 'chat-input-container' },
  Gie = { class: 'chat-input-main' },
  Wie = { class: 'chat-input-inner' },
  Qie = { class: 'chat-input-wrapper' },
  jie = qt({
    __name: 'ChatInput',
    props: { replying: { type: Boolean } },
    emits: ['send', 'stop', 'interrupt'],
    setup(n, { emit: e }) {
      const t = e
      let i = 24,
        r = nm('rowsDivRef'),
        s = nm('chatInputRef'),
        o = ''
      function a(h) {
        h.key === 'Enter' &&
          (h.altKey
            ? s.value &&
              ((s.value.value = Hie(s.value.value, '\n', s.value.selectionStart || 0)),
              s.value.dispatchEvent(new InputEvent('input')))
            : (h.preventDefault(), l()))
      }
      async function l() {
        s.value && (t('send', s.value.value), (s.value.value = ''))
      }
      function c(h) {
        r.value &&
          ((r.value.textContent = h.target.value.replace(/\n$/, '\n\n')),
          (i = r.value.offsetHeight))
      }
      function u() {
        t('stop')
      }
      function d() {
        t('interrupt')
      }
      return (h, f) => (
        mt(),
        Ct('div', $ie, [
          kt('div', Gie, [
            kt('div', { class: 'stop-chat-btn', onClick: u }),
            kt('div', Wie, [
              kt('div', Qie, [
                kt(
                  'textarea',
                  {
                    class: 'chat-input',
                    ref_key: 'chatInputRef',
                    ref: s,
                    onKeydown: a,
                    onInput: c,
                    style: Go('height:'.concat(Ke(i), 'px')),
                  },
                  null,
                  36
                ),
                kt('div', { class: 'rowsDiv', ref_key: 'rowsDivRef', ref: r }, su(Ke(o)), 513),
              ]),
              h.replying
                ? (mt(), Ct('button', { key: 0, class: 'interrupt-btn', onClick: d }))
                : (mt(),
                  Ct('button', { key: 1, class: 'send-btn', onClick: l }, [
                    Te(Ke(Ed), { icon: Ke(aie), color: '#fff' }, null, 8, ['icon']),
                  ])),
            ]),
          ]),
          f[0] || (f[0] = kt('div', { class: 'ai-generate-hint' }, '内容由 AI 生成', -1)),
        ])
      )
    },
  }),
  qie = si(jie, [['__scopeId', 'data-v-329533fc']]),
  Xie = { class: 'answer-message-text' },
  Kie = qt({
    __name: 'ChatMessage',
    props: { message: {}, role: {}, style: {} },
    setup(n) {
      return (e, t) => (
        mt(),
        Ct(
          'div',
          { class: Wo(['answer-message-container', e.role]), style: Go(e.style) },
          [kt('div', Xie, su(e.message), 1)],
          6
        )
      )
    },
  }),
  Yie = si(Kie, [['__scopeId', 'data-v-57261938']]),
  Zie = { class: 'chat-records-inner' },
  Jie = qt({
    __name: 'ChatRecords',
    props: { chatRecords: {} },
    setup(n, { expose: e }) {
      const t = n
      let i = nm('containerRef')
      Jn(
        () => t.chatRecords,
        (s) => {
          t.chatRecords &&
            Dh().then(() => {
              r()
            })
        }
      )
      function r() {
        i.value && (i.value.scrollTop = i.value.scrollHeight)
      }
      return (
        e({ scrollToBottom: r }),
        (s, o) => (
          mt(),
          Ct(
            'div',
            { class: 'chat-records', ref_key: 'containerRef', ref: i },
            [
              kt('div', Zie, [
                (mt(!0),
                Ct(
                  Hn,
                  null,
                  th(
                    s.chatRecords,
                    (a, l) => (
                      mt(),
                      Ct(
                        'div',
                        { key: a.id, class: Wo('chat-message '.concat(a.role)) },
                        [
                          Te(Yie, { message: a.message, role: a.role }, null, 8, [
                            'message',
                            'role',
                          ]),
                        ],
                        2
                      )
                    )
                  ),
                  128
                )),
              ]),
            ],
            512
          )
        )
      )
    },
  }),
  ere = { class: 'content-container' },
  tre = { class: 'top-actions' },
  nre = ['muted'],
  ire = { key: 0, class: 'chat-records-container' },
  rre = qt({
    __name: 'index',
    setup(n) {
      const e = ba(),
        t = k0(),
        i = Dn(),
        r = Dn(),
        s = Dn(),
        o = Dn(),
        a = Dn(),
        l = Dn('9 / 16'),
        c = () => {
          a.value && (l.value = ''.concat(a.value.videoWidth, ' / ').concat(a.value.videoHeight))
        },
        u = () => t.localStream
      Va(() => {
        const T = i.value
        ;((e.wrapperRef = T),
          T.getBoundingClientRect(),
          (C.value.width = T.clientWidth),
          (C.value.height = T.clientHeight),
          (e.isLandscape = C.value.width > C.value.height),
          console.log(C),
          (e.remoteVideoContainerRef = s.value),
          (e.localVideoContainerRef = r.value),
          (e.localVideoRef = o.value),
          (e.remoteVideoRef = a.value),
          (e.wrapperRef = i.value))
      })
      const {
          hasCamera: d,
          hasMic: h,
          micMuted: f,
          cameraOff: p,
          webcamAccessed: g,
          streamState: y,
          avatarType: m,
          volumeMuted: v,
          replying: x,
          showChatRecords: _,
          chatRecords: S,
        } = dm(t),
        { wrapperRect: C, isLandscape: A } = dm(e),
        R = Ge(() => !!((S.value && S.value.length > 0) || y.value === 'open'))
      function w() {
        t.startWebRTC().then(() => {
          M()
        })
      }
      function M() {
        t.chatDataChannel &&
          t.chatDataChannel.addEventListener('message', (T) => {
            const F = JSON.parse(T.data)
            if (F.type === 'chat') {
              const V = t.chatRecords.findIndex((W) => W.id === F.id)
              if (V !== -1) {
                const W = t.chatRecords[V]
                ;((W.message += F.message),
                  t.chatRecords.splice(V, 1, W),
                  (t.chatRecords = [...t.chatRecords]))
              } else
                t.chatRecords = [
                  ...t.chatRecords,
                  { id: F.id, role: F.role || 'human', message: F.message },
                ]
            } else F.type === 'avatar_end' && (t.replying = !1)
          })
      }
      function I() {
        t.chatDataChannel && t.chatDataChannel.send(JSON.stringify({ type: 'stop_chat' }))
      }
      const L = nm('chatRecordsInstanceRef')
      function U(T) {
        var F
        T &&
          t.chatDataChannel &&
          (t.chatDataChannel.send(JSON.stringify({ type: 'chat', data: T })),
          (t.replying = !0),
          (F = L.value) == null || F.scrollToBottom())
      }
      return (T, F) => (
        mt(),
        Ct(
          'div',
          { class: 'page-container', ref_key: 'wrapRef', ref: i },
          [
            kt('div', ere, [
              kt(
                'div',
                { class: 'video-container', style: Go({ aspectRatio: l.value }) },
                [
                  kt('div', tre, [Te(Iie)]),
                  Pc(
                    kt(
                      'div',
                      {
                        class: Wo(
                          'local-video-container '.concat(Ke(y) === 'open' ? 'scaled' : '')
                        ),
                        ref_key: 'localVideoContainerRef',
                        ref: r,
                      },
                      [
                        kt(
                          'video',
                          {
                            class: 'local-video',
                            ref_key: 'localVideoRef',
                            ref: o,
                            autoplay: '',
                            muted: '',
                            playsinline: '',
                            style: Go({
                              visibility: Ke(p) ? 'hidden' : 'visible',
                              display: !Ke(d) || Ke(p) ? 'none' : 'block',
                            }),
                          },
                          null,
                          4
                        ),
                      ],
                      2
                    ),
                    [[cm, Ke(d) && !Ke(p)]]
                  ),
                  kt(
                    'div',
                    { class: 'remote-video-container', ref_key: 'remoteVideoContainerRef', ref: s },
                    [
                      Ke(m)
                        ? qr('', !0)
                        : Pc(
                            (mt(),
                            Ct(
                              'video',
                              {
                                key: 0,
                                class: 'remote-video',
                                onPlaying: c,
                                ref_key: 'remoteVideoRef',
                                ref: a,
                                autoplay: '',
                                playsinline: '',
                                muted: Ke(v),
                              },
                              null,
                              40,
                              nre
                            )),
                            [[cm, Ke(y) === 'open']]
                          ),
                    ],
                    512
                  ),
                  R.value
                    ? (mt(),
                      Ct('div', ire, [
                        Te(
                          Jie,
                          { ref_key: 'chatRecordsInstanceRef', ref: L, chatRecords: Ke(S) },
                          null,
                          8,
                          ['chatRecords']
                        ),
                      ]))
                    : qr('', !0),
                ],
                4
              ),
              (!Ke(h) || Ke(f)) && Ke(y) === 'open'
                ? (mt(),
                  ou(
                    qie,
                    {
                      key: 0,
                      replying: Ke(x),
                      onInterrupt: I,
                      onSend: U,
                      onStop: Ke(t).startWebRTC,
                    },
                    null,
                    8,
                    ['replying', 'onStop']
                  ))
                : Ke(g)
                  ? (mt(),
                    ou(
                      Vie,
                      {
                        key: 1,
                        onStartChat: w,
                        'audio-source-callback': u,
                        streamState: Ke(y),
                        'wave-color': '#7873F6',
                      },
                      null,
                      8,
                      ['streamState']
                    ))
                  : qr('', !0),
            ]),
          ],
          512
        )
      )
    },
  }),
  sre = si(rre, [['__scopeId', 'data-v-b39fd6e8']]),
  ore = { class: 'wrap' },
  are = qt({
    __name: 'App',
    setup(n) {
      const e = k0()
      return (
        e.init(),
        (t, i) => (
          mt(),
          ou(
            Ke(Jc),
            { locale: Ke(Fne)[Ke(uI)] },
            {
              default: gw(() => [
                kt('div', ore, [
                  Ke(e).webcamAccessed ? qr('', !0) : (mt(), ou(Iee, { key: 0 })),
                  Te(sre),
                ]),
              ]),
              _: 1,
            },
            8,
            ['locale']
          )
        )
      )
    },
  }),
  lre = si(are, [['__scopeId', 'data-v-ab895659']])
var Kp = { exports: {} },
  cre = Kp.exports,
  FT
function ure() {
  return (
    FT ||
      ((FT = 1),
      (function (n, e) {
        ;(function (t, i) {
          n.exports = i()
        })(cre, function () {
          var t = '__v-click-outside',
            i = typeof window < 'u',
            r = typeof navigator < 'u',
            s =
              i && ('ontouchstart' in window || (r && navigator.msMaxTouchPoints > 0))
                ? ['touchstart']
                : ['click'],
            o = function (u) {
              var d = u.event,
                h = u.handler
              ;(0, u.middleware)(d) && h(d)
            },
            a = function (u, d) {
              var h = (function (v) {
                  var x = typeof v == 'function'
                  if (!x && typeof v != 'object')
                    throw new Error(
                      'v-click-outside: Binding value must be a function or an object'
                    )
                  return {
                    handler: x ? v : v.handler,
                    middleware:
                      v.middleware ||
                      function (_) {
                        return _
                      },
                    events: v.events || s,
                    isActive: v.isActive !== !1,
                    detectIframe: v.detectIframe !== !1,
                    capture: !!v.capture,
                  }
                })(d.value),
                f = h.handler,
                p = h.middleware,
                g = h.detectIframe,
                y = h.capture
              if (h.isActive) {
                if (
                  ((u[t] = h.events.map(function (v) {
                    return {
                      event: v,
                      srcTarget: document.documentElement,
                      handler: function (x) {
                        return (function (_) {
                          var S = _.el,
                            C = _.event,
                            A = _.handler,
                            R = _.middleware,
                            w = C.path || (C.composedPath && C.composedPath())
                          ;(w ? w.indexOf(S) < 0 : !S.contains(C.target)) &&
                            o({ event: C, handler: A, middleware: R })
                        })({ el: u, event: x, handler: f, middleware: p })
                      },
                      capture: y,
                    }
                  })),
                  g)
                ) {
                  var m = {
                    event: 'blur',
                    srcTarget: window,
                    handler: function (v) {
                      return (function (x) {
                        var _ = x.el,
                          S = x.event,
                          C = x.handler,
                          A = x.middleware
                        setTimeout(function () {
                          var R = document.activeElement
                          R &&
                            R.tagName === 'IFRAME' &&
                            !_.contains(R) &&
                            o({ event: S, handler: C, middleware: A })
                        }, 0)
                      })({ el: u, event: v, handler: f, middleware: p })
                    },
                    capture: y,
                  }
                  u[t] = [].concat(u[t], [m])
                }
                u[t].forEach(function (v) {
                  var x = v.event,
                    _ = v.srcTarget,
                    S = v.handler
                  return setTimeout(function () {
                    u[t] && _.addEventListener(x, S, y)
                  }, 0)
                })
              }
            },
            l = function (u) {
              ;((u[t] || []).forEach(function (d) {
                return d.srcTarget.removeEventListener(d.event, d.handler, d.capture)
              }),
                delete u[t])
            },
            c = i
              ? {
                  beforeMount: a,
                  updated: function (u, d) {
                    var h = d.value,
                      f = d.oldValue
                    JSON.stringify(h) !== JSON.stringify(f) && (l(u), a(u, { value: h }))
                  },
                  unmounted: l,
                }
              : {}
          return {
            install: function (u) {
              u.directive('click-outside', c)
            },
            directive: c,
          }
        })
      })(Kp)),
    Kp.exports
  )
}
var dre = ure()
const hre = u_(dre),
  $0 = X9(lre),
  fre = Z9()
$0.use(fre)
$0.use(Bne)
$0.use(hre)
$0.mount('#app')
export { mre as __vite_legacy_guard }
